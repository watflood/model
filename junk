      SUBROUTINE aet(time,t,mon,ju)

!***********************************************************************
!    Copyright (C) 1996 by Nicholas Kouwen and Todd Neff 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
       
!***********************************************************************
! PROGRAM BY: Todd A.M. Neff,  MARCH 1996
!
! Subprogram aet.for for the Watflood program runof6.for
! Calculates actual evapotranspiration (AET) indexed to
! potential evapotranspiration (PET)
! Index is a function of degree days (tto(n)) and the
!  value of soil moisture (uzsi - upper zone storage
!  indicator)
!
!
!
!     This s/r was modified by ts and then nk added his changes back in
!     April 07

!     REV. 8.89  - Nov.  30/98  -  simplified uzs parameters
!     REV. 9.00  - Mar.   2000  -  TS: CONVERTED TO FORTRAN 90
!     REV. 9.03    Nov.   2000  - TS: ADDED WATFLOOD WETLAND ROUTING
!     rev. 9.1.26  Sep.  11/02  - fixed wetland evaporation re: uzsi
!     rev. 9.4.03  Apr.  18/07  - NK: For water ev(n,ii)=pet(n,ii)*fpet(ii)
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance
!     rev. 10.1.56 Nov.  30/16  - NK: Fixed evt in AET.f to account for sca
!
!     changes made to include c&g model stuff  nk  April. 26/07
!
!  fpet2 - reduction in PET for low soil temperatures
!  full  - saturation capacity = retn(ii)/fcap (mm)
!  pwp   - permanent wilting point = fraction of the field capacity
!  sat   - soil moisture at saturation 
!  intev - interception evaporation
!  ftall - reduction in PET for tall vegetation
!          fpetmo(month,ii)=ftall(ii)*h(month,ii)/hmax     set in rdpar.for
!  ev    - is the AET
!  evt   - total AET so far - used for plotting only
!  fcap  - field capacity (% / 100)
!  ffcap - permanent wilting point (% / 100)
!  spore - saturation capacity (% / 100)
!
!***********************************************************************

	USE areacg
      use area_watflood
      implicit none
      save
      integer  :: n,ii,nnaa,mon,i,j,ios,ju
      real*4   :: uzsi,t,time,eratio,chk
      character*1 :: firstpass

! start nk addition apr. 19/07
      data firstpass/'y'/
      if(firstpass.eq.'y')then
!       write the header for evap.txt
	  if(iopt99)write(74,7403)nnprint
	  if(iopt99)write(74,7400)
!       this used to be in soilinit but needed here when read_soilinit is used
!     rev. 9.8.34  Oct.  23/12  - NK: Added sums to the resume.txt file
        if(resumflg.eq.'n')then
          do n=1,naa
	      do ii=1,classcount
              evt(n,ii)=0.0
              sum_pet(n,ii)=0.0    ! added May 14/13  nk
              sum_et(n,ii)=0.0     ! added May 14/13  nk
            end do
	    end do
	  endif
        if(frcflg.eq.'y')then
          do n=1,naa
	      do ii=1,classcount
	        icgflg(n,ii)=0
            end do
	    end do
        endif
	endif
! end nk addition apr. 19/07

!d      if(iopt.eq.2)print*,' checkpoint 10 in aet'

! ARRAY ALLOCATIONS FIRST TIME THROUGH:
      !       TS: RESET EACH TIME WE RETURN TO A GRID (for craig_gordon.for)
      if(frcflg.eq.'y'.and.isocg.eq.0)then
        allocate(dele(na,classcount),isoEconc(na,classcount),dela(na),&
       estar(na),dell(na),alphastar(na),ekin(na,classcount),&
       delstar(na,classcount),estar2H(na),alphastar2H(na),dela2H(na),&
       dell2H(na),ekin2H(na,classcount),delstar2H(na,classcount),&
       dele2H(na,classcount),iso2HEconc(na,classcount),stat=iall)
	  if(iall.ne.0) STOP 'Error allocating C&G arrays'

!       INITIALIZATION:
        do n=1,na
	    do ii=1,classcount
            ekin(n,ii)=0.0
	    end do
	  end do
	  isocg=1    ! Craig & Gordon allocation flag
	endif

      do n=nastart,naend
        i=yyy(n)
        j=xxx(n)
        if(p(i,j).le.0.0.or.firstpass.eq.'y')then
          do ii=1,classcount
!* * * * *  IMPERVIOUS * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! TS: ADDED IMPERVIOUS EVAP CALCULATION: MAR 27/06
            if(ii.eq.classcount)then
! ** USE DS(n,ii) INSTEAD OF D2 TO INDICATE SURFACE STORAGE
! ** ON IMPERVIOUS AREA
              if(d2(n).gt.0.0)then
!               H2O TO EVAPORATE ON SURFACE
                ev(n,ii)=pet(n,ii)
                chk=d2(n)-ev(n,ii)
                if(chk.ge.0.0)then
!                 THERE WAS ENOUGH H2O, SUBTRACT OFF SURFACE STORAGE
                  d2(n)=d2(n)-ev(n,ii)
                else
!                 NOT ENOUGH H2O, TAKE ALL SURFACE STORAGE
                  ev(n,ii)=d2(n)
                  d2(n)=0.0
                endif
	        else
!               NO SURFACE STORAGE
                ev(n,ii)=0.0
	        endif
	        sum_et(n,ii)=sum_et(n,ii)+ev(n,ii)
	        sum_pet(n,ii)=sum_pet(n,ii)+pet(n,ii)

!c            elseif(nclass(ii).eq.'water     ')then    !elseif(ii.eq.classcount.or.nclass(ii).eq.'water     ')then
            elseif(ii.eq.ii_water)then    
            
!  * * * * *  WATER  * * * * * * * * * *  WATER  * * * * * * * * * *  WATER  * * * * * 
!             OPEN WATER EVAP IS EQUAL TO POTENTIAL RATE

!              DO NOTHING - STUFF MOVED TO LAKE_EVAP
!              DO NOTHING - STUFF MOVED TO LAKE_EVAP
!              DO NOTHING - STUFF MOVED TO LAKE_EVAP

!* * * * *  WETLAND  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! TS: MOVED FROM BELOW SO EV(N,WETLAND) IS CALCULATED AS SPECIAL CASE
! ALL OTHER CLASSES GET EV(N,II) CALC (27/03/06)
!            elseif(ii.eq.classcount-2.or.nclass(ii).eq.'wetland   '.and.
!c            elseif(ii.eq.classcount-2.and.
!c     *                 wetflg.eq.'y'.and.theta(n).gt.0.0)then
!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance
            elseif(ii.eq.classcount-2.and.wetland_flag(n))then
!                this assumes that the wetland class is before the water class
!                added theta to conditional Dec. 23/02 nk
!     rev. 10.1.48 Nov.  08/16  - NK: addet fpet(ii_water) to the wetland evaporation
! TH: trying to reduce wetland evap with water factor
                 ev(n,ii)=pet(n,ii)*fpet2(n)*fpetmo(mon,ii)*fpet(ii_water)

!     rev. 9.1.26  Sep.  11/02  - fixed wetland evaporation re: uzsi
!                DO THE WATER BALANCE FOR WETLANDS:

                 if(hwet2(n)*1000.0*theta(n).gt.ev(n,ii))then
!                   WSTORE2 IS REDUCED BY EVAPORATION - NO CONSTRAINT
!                   ftall has already been taken into account
	              qswevp(n)=ev(n,ii)*wetwid(n)*rl(n)/1000./t
!cc                    evt(n,ii)=evt(n,ii)+ev(n,ii)                  
!     rev. 10.1.56 Nov.  30/16  - NK: Fixed evt in AET.f to account for sca
                    evt(n,ii)=evt(n,ii)+ev(n,ii)*(1-sca(n,ii))

                 else
!                   half(?) AVAILABLE FREE WATER IS REMOVED
                    ev(n,ii)=hwet2(n)*1000.0*theta(n)/2.0
	              qswevp(n)=ev(n,ii)*wetwid(n)*rl(n)/1000./t
!cc                   evt(n,ii)=evt(n,ii)+ev(n,ii)
!     rev. 10.1.56 Nov.  30/16  - NK: Fixed evt in AET.f to account for sca
                    evt(n,ii)=evt(n,ii)+ev(n,ii)*(1-sca(n,ii))

                 endif

!* * * * *  ALL OTHER CLASSES  * * * * * * * * * * * * * * * * * * * * * * * * * *
! SO LONG AS THAT CLASS EXISTS IN THIS GRID	      
            else
              if(aclass(n,ii).gt.0.0)then
!               no UZS for wetlands 
                if(uzs(n,ii).ge.retn(ii))then
                   uzsi=1.
                elseif(uzs(n,ii).le.ffcap(ii))then
                   uzsi=0.
                else
                   uzsi=sqrt((uzs(n,ii)-ffcap(ii))/(retn(ii)-ffcap(ii)))
                endif

!               CALCULATE THE MAX EVAPORATION FOR THIS TIME STEP
!               BASED ON PET, UZS AND TEMPERATURE INFLUENCE
!!!!! SOME PEOPLE ARGUE THAT CANOPU EVAP IS IN ADDITION TO SOIL EVAP
!               CALC EVAP (NOT WATER, WETLAND OR IMPERVIOUS)
                ev(n,ii)=pet(n,ii)*fpet2(n)*uzsi*fpetmo(mon,ii)

                if(uzs(n,ii)-ffcap(ii).ge.ev(n,ii))then
!                  UZS IS REDUCED BY EVAPORATION - NO CONSTRAINT
                   uzs(n,ii)=uzs(n,ii)-ev(n,ii)
!cc                   evt(n,ii)=evt(n,ii)+ev(n,ii)
!     rev. 10.1.56 Nov.  30/16  - NK: Fixed evt in AET.f to account for sca
                    evt(n,ii)=evt(n,ii)+ev(n,ii)*(1-sca(n,ii))
                elseif(uzs(n,ii).le.ffcap(ii))then
!                  UZS LT WILTING POINT SO NO EVAPORATION
                   ev(n,ii)=0.0
                else
!                  ALL FREE WATER IS REMOVED
                   ev(n,ii)=uzs(n,ii)-ffcap(ii)
                   uzs(n,ii)=ffcap(ii)
!cc                   evt(n,ii)=evt(n,ii)+ev(n,ii)
!     rev. 10.1.56 Nov.  30/16  - NK: Fixed evt in AET.f to account for sca
                    evt(n,ii)=evt(n,ii)+ev(n,ii)*(1-sca(n,ii))
                endif
! 
              else      
!              ACLASS(n,ii) IS 0.0 (no area)
!              BY-PASS EVAP-SEPARATION CODE TO SAVE TIME
               if(frcflg.eq.'y')icgflg(n,ii)=0
               GOTO 100

	        endif   ! ACLASS.GT.0.0

            endif     ! CALCULATING EV(n,ii) BASED ON CLASS

!           for the glake model, if lake evaporation file is read, 
!           this sum is done in sub
!           added Mar. 12/08 -nk-
            if(.not.rd_evp_flg)then
	        sum_et(n,ii)=sum_et(n,ii)+ev(n,ii)
	        sum_pet(n,ii)=sum_pet(n,ii)+pet(n,ii)
	      endif

!     Frac model     Frac model     Frac model     Frac model     Frac model     Frac model

!     rev. 10.1.47 Nov.  08/16  - NK: Major changes in the ISO part of AET.f
            if(frcflg.eq.'y')then
! TH: modded this section for use in isoWATFLOOD
! *******************************************************************************
! PUT E-ET SEPARATION HERE.
! NEED TO IDENTIFY FRACTION THAT WILL BE APPLYING C&G TO, EVCG(n,ii)
! LEAVE AS A FUNCTION OF LANDCLASS STILL.

! NEED TO CONSIDER THAT LAND COVER TYPES CHANGE W/ H2O-SHED
! WATER       = 100% E
! IMPERMEABLE = 100% E
! BARREN      = 100% E
! INTERCEPT   = 100% E -- negligable cause storages so small
! OTHERS...   = X% E + Y% T

!              TS: RESET EACH TIME WE RETURN TO A GRID (for craig_gordon.for)
               ekin(n,ii)=0.0
	         devcg(n,ii)=0.0

               if(fpet2(n).lt.1.0)then
!                GROUND NOT WARM ENOUGH, VEG NOT DEVELOPED ENOUGH TO TRANSPIRE
!                THEREFORE ALL ET=E
	           icgflg(n,ii)=0  !0 this way it is always =1
                 evcg(n,ii)=ev(n,ii)

	         else   !  fpet2.ge.1.0
	           icgflg(n,ii)=1
!                THERE IS A MIX OF E AND T, BUT MOSTLY T
!                T IS ASSUMED 100% UNLESS THERE'S SOIL MOISTURE
!                HOW WE TREAT THE PARTITIONING DEPENDS ON LANDCOVER
                 if(ii.ge.classcount-1)then
!                WATER OR IMPERMEABLE EVAP SEPARATION
!                DOESN'T LOOP THROUGH FOR classcount, SO CALC WHEN ii=classcount
                   evcg(n,ii)=ev(n,ii)

	           !     WETLAND EVAP SEPARATION
!                WSAT=wetland degree of saturation (from 0 to 1)
                   elseif(ii.eq.classcount-2.and.wetland_flag(n))then  !  TS: fen, not bog
                      wsat(n)=hwet2(n)/(wcap(n)/wetarea(n)/theta(n))

                    if(wsat(n).ge.1.0)then
!                     WETLAND IS FLOODED, OPEN WATER: AET=PET so eratio=1
                      evcg(n,ii)=ev(n,ii)

	              else
!                     WETLAND IS NOT FLOODED: AET<PET
!                      acg(ii)=1.
!	                bcg(ii)=2.0
                      eratio=acg(ii)*wsat(n)**bcg(ii)
!                      evcg(n,ii)=intev(n,ii)+eratio*ev(n,ii)  ! TS: affect on MB?
                      evcg(n,ii)=eratio*ev(n,ii)

	              endif 
                   

	           else 
	             eratio=acg(ii)*uzsi**bcg(ii)
                   evcg(n,ii)=eratio*ev(n,ii)

                 endif   ! LANDCLASS TYPE
            
               endif     ! fpet2.ge.1.0

!              TS - called from ISOinter now - Apr 3/07
!              ISOTOPE FRACTIONATION:  
!               nnaa=s(ipr,jpr)
!               call craig_gordon(n,ii,time)

            endif        ! FRACTIONATION: frcflg.eq.'y'
! *******************************************************************************
100   CONTINUE            ! if(aclass.eq.0.0)

          end do   ! ii=1,classcount

! start nk addition apr. 19/07
! trish check:  is this needed? should there be more?
        else       ! precip this hour - no et
	    do ii=1,classcount
            ev(n,ii)=0.0
          end do
! end nk addition apr. 19/07

        endif      ! p(i,j).le.0.0
      end do       ! n=nastart,naend


!d 	if(iopt.eq.2)print*,' checkpoint 20 in aet'

!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance
      do n=nastart,naend
         do ii=1,classcount-2   
            if(wetland_flag(n).and.ii.ne.classcount-2&
              .or.wetland_flag(n)==.false.)&
              eloss(n)=eloss(n)+ev(n,ii)*aclass(n,ii)*(1.0-sca(n,ii))
         end do
!        water not added in here - done in lake_evap
         eloss(n)=eloss(n)+ev(n,classcount)*aclass(n,classcount)*(1.0-sca(n,classcount))
      end do

      if(frcflg.eq.'y')then
!        SKIP WETLANDS, BUT ADD OPEN WATER EVAPORATION:
        do n=nastart,naend
          do ii=1,classcount
	      if(wetland_flag(n).and.ii.ne.classcount-2&
              .or.wetland_flag(n)==.false.)& 
               devcg(n,ii)=ev(n,ii)*aclass(n,ii)*(1-sca(n,ii))   !TS was evcg(n,ii)
          end do
!            devcg(n,classcount)=evcg(n,classcount)*aclass(n,classcount)
!     *                               *(1-sca(n,classcount))
        end do
      endif 
!        FRACTIONATION WEIGHTED DEPTH OF EVAPORATION PER GRID
! trish check:  should this be inside ii loop?

!d	if(iopt.eq.2)print*,' checkpoint 30 in aet'

      if(iopt.ge.1)then
        if(aclass(nnprint,iiprint).lt.0.0)then
          nnaa=s(ipr,jpr)
!         write(74,7401)time,fpet2(nnaa),uzsi,tto(nnaa),intev(nnaa,1),
!     *         ev(nnaa,1),pet(nnaa,1),uzs(nnaa,1),p(yyy(nnaa),xxx(nnaa))
          if(iopt99)write(74,7401,iostat=ios)time,fpet2(nnprint),uzsi,&
              tto(nnprint),intev(nnprint,iiprint),ev(nnprint,iiprint),&
              pet(nnprint,iiprint),&
              uzs(nnprint,iiprint),p(yyy(nnprint),xxx(nnprint))
          if(ios.ne.0)then
            print*,'output conversion error in aet @ 394'
          endif
         
          if(frcflg.eq.'y')write(95,7402)time,(ev(nnprint,ii),(evcg(nnprint,ii)-intev(nnprint,ii)),ii=1,classcount)
         else
           if(firstpass.eq.'y')then   ! write this once only
             if(iopt99)write(74,*)'No area for land cover',iiprint
             if(iopt99)write(95,*)'No area for land cover',iiprint
           endif
         endif
      endif

      firstpass='n'

!d 	if(iopt.eq.2)print*,' checkpoint 40 in aet'

! FORMATS:

 7400 format('    time  fpet2(n)  uzsi   tto(n)  intev ev(n.ii) pet(n.ii) uzs(n.ii) p(n,ii)')

 7401 format(f8.0,6f8.2,f12.2,f8.2)
 7402 format(f8.0,2(<classcount>f8.2))
 7403 format('OutputForGrid# ',i8,' class # ',i8)
 7500 format(f8.0,i5,<classcount+2>(f12.4))


      RETURN

      END SUBROUTINE aet


      subroutine baseflow(n,dlz,sdlz,tdum)

!     s/r created May 5/03 NK
      
!***********************************************************************
!    Copyright (C) 2003 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list

!     called in RUNOF6 and ROUTE

      USE area_watflood
	implicit none

      integer    :: n
      real*4     :: dlz,sdlz,tdum

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
!       GROUNDWATER OUTFLOW:
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

!       DLZ = LOWER ZONE OUTFLOW IN MM

        dlz=flz2(n)*lzs(n)**pwr(n)
        if(dlz.gt.lzs(n))then
          dlz=lzs(n)
          lzs(n)=0.0
        else
          lzs(n)=lzs(n)-dlz
        endif

c	if(iopt.eq.2)print*,' checkpoint 5a in baseflow'

!       section to create runoff file for watroute with no 
!       groundwater component  nk  06/07/00
	  if(flz(1).ge.0.1E-12)then
          qlz(n)=dlz*tdum*frac(n)
        else
	    qlz(n)=0.0
	  endif

c	if(iopt.eq.2)print*,' checkpoint 5b in baseflow'

	  leakage=leakage+qlz(n)
!        qdrng=qdrng+rechrg(n)*tdum*frac(n)

        if(n.eq.nnprint)then
!       CALC LZ OUTFLOW
          sdlz=sdlz+dlz
        endif

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

      return

      end subroutine baseflow
        PROGRAM CHARM   ! Canadian Hydrological And Routing Model

!***********************************************************************
!    Copyright (C) 1987-2018 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.


!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty ofdir runreport
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!    This program is the Canadian Hydrological And Routing Model (CHARM (R) )
!    It's purpose is to ingest precipitation and temperature time series data
!    and compute hydrographs at selected locations.
!***********************************************************************

        

!           the use of the main program is only to dimension the
!           variables and to decide a few options.
!
!           note that the dimensions of a variable must be the
!           same in all parts of the programs. eg: if qsyn is
!           dimensioned to (1,8,123) in the main calling program,
!           then is it is dimensioned qsyn(ls,js,ih), ls must be
!           set =1, js=8, & ih=123
!
!           the variables qi1 and qi2 have to be dimensioned to
!           the value of na while all the other variables can be
!           dimensioned to naa.  this is to allow the water to
!           run into something at the outlet.

    USE area_watflood
    use areacg
    use area_debug
!///////////////////////// 
!// Added by Dave
    USE EF_module
!// End Dave addition
!/////////////////////////

!     rev. 9.5.44  Oct.  27/08  - NK: removed code & obj modules for hasp & rainbow

      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

! TW  MAR. 5/98  - DATA STATEMENT MOVED FROM INPEVT.FOR

      CHARACTER*14    :: date
    character(3)    :: beepflg
      CHARACTER(1)    :: recflg
    character(4096)  :: line

      integer     :: n,ii,i,j,mon
      integer    ::  iallocate,attCount,ios,nhr,nhf,iendarg,ix
      real*4     ::  conv,scale,smc5(16),e1,recmax
      character(20) :: junk
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday
      INTEGER(2) status1
      CHARACTER(1) buf,stopflg,ensimopenflg
      logical       :: exists
      logical       :: foundEndHeader

!      logical, parameter :: debug_output = .false. 
!!DIR$         IF DEFINED (DEBUG)
!                 debug_output = .true.
!!DIR$         ENDIF
 
                
!     rev. 7.2      sept. 19/94 - added ireach(n) for dwoper input 
!     rev. 7.3      dec.  20/94 - added uz & lz drainage in runof4
!     rev. 7.31     jan.  08/95 - set record length for 40 flow sta 
!     rev. 7.31.1   jan.  08/95 - set met data source for lapse rate
!     rev. 7.32     feb.  07/95 - added nopt to select opt flow sta 
!     rev. 7.33     feb.  20/95 - fixed flow initialization
!     rev. 7.4      feb.  24/95 - added 4 classes - max = 10
!     rev. not completed
!     rev. 7.41     apr.  15/95 - calc strmfl output /w inp fmt
!     rev. 7.42     may.  15/95 - check for div. by 0 in runof4
!     rev. 7.5      seperate snow covered and bare ground
!                   modified for separation of snowcovered ground and 
!                   bare ground by Frank Seglenieks  Feb/1995  new 
!                   runof5 debugged and intergrated by NK July/1995
!     rev. 7.51     oct.  08/95 - revise init channel flow in SUB
!     rev. 7.52     oct.  23/95 - check for opt constraints in main1
!     rev. 7.6      nov.  13/95 - added andrea's sediment routines
!     rev. 7.7      dec.  25/95 - added Allyson's Columbia routing
!     rev. 7.71     jan.  15/95 - fixed bug in uzs calculation 
!                                 uzs-retn =freely draining water
!     rev. 7.72     feb.  04/96 - took flowinit.for from sub.for
!     rev. 7.73     feb.  21/96 - fixed sca-continuity / runof5
!     rev. 7.74     may.  23/96 - include lapse rate & elv ref 
!                                 as part of .tmp file
!     rev. 7.75     may.  27/96 - added ak2fs in param & runof5
!     rev. 7.76     jun.  11/96 - # classes increased to 16 + urban
!     rev. 7.77     Jul.  02/96 - fixed snow redistribution
!     Rev. 7.78     Sept. 29/96 - fileio: modified for error checking 

!     rev. 7.80     Oct.  29/96 - CHARM7 added yymmdd.rin for res inflows
!                               - unit = 39   fln = 09
!     rev. 7.81     Nov.  07/96 - rdevt: added flags for stuff
!     rev. 7.83     Nov.  30/96 - fix div. by 0 - check - in lst.for
!     rev. 7.84     Dec.  16/96 - changed pmelt so that snowmelt only
!                                 occurs on snow covered area

!     rev. 8.0     Dec   18/96  - Added Todd Neff's evaporation
!     rev. 8.1     Feb.  15/97  - TBC & RSM (to be continued & resume) 
!     rev. 8.2     Feb.  15/97  - parameter selection for opt in main1
!     rev. 8.21    Mar.  15/97  - rain/snow choice tied to base temp  
!     rev. 8.22    Mar.  15/97  - glacier MF 2X when new snow=gone
!     rev. 8.23    Mar.  25/97  - fixed bug in route - keep qo2 for res
!     rev. 8.24    Apr.  07/97  - added glacier melt multiplier gladjust
!                               - used uzs-retn to determine freely 
!                                 draining water
!     rev. 8.25    May.  22/97  - fixed allocating the basin # in 
!                                 flowinit
!     rev. 8.3     May.  22/97  - added the simout/outfiles capability
!     rev. 8.31    June   3/97  - added initial uzs values in evap.par
!     rev. 8.32    June  13/97  - bypassed non-flagged parameters in OPT
!     rev. 8.4     July  16/97  - fixed melt routine and added init def
!     rev. 8.41    July  21/97  - added tipm to the optimization table
!     rev. 8.5     Oct.  09/97  - deleted the old interception stuff
!     rev. 8.51    Oct.  09/97  - fixed -ve qr() problem in runof5
!     rev. 8.52    Nov.  14/97  - replaced x4()= in runof
!     rev. 8.60    Nov.  14/97  - added sl2 to the interflow calculation
!     rev. 8.61    Dec.  12/97  - added contflg for statistics cont'n
!     rev. 8.62    Dec.  30/97  - fixed param s/r comb'd et & par flgs
!     rev. 8.70    Jan.  23/98  - added precip adjustment in rain.for
!     rev. 8.71    Feb.  24/98  - added evpflg2 to rdevt.for
!     rev. 8.72    Mar.   5/98  -tw: moved flgevp2 data statement to 
!                                CHARM.for
!     rev. 8.73    Mar.   1/98  - changed mhrd to mhtot in flowinit
!     rev. 8.74    Mar.  31/98  - reinvented fs stuff in opt
!     rev. 8.75    Apr.  27/98  - took da out of the resume file
!     rev. 8.76    May   26/98  - added precadj diagnostic to rain.for
!     rev. 8.77    June   1/98  - added sub-basin error calculation
!     rev. 8.78    July   7/98  - added scalesnw and scaletem to rdevt
!     rev. 8.79    July   7/98  - added 24 water survey format in strfw
!     rev. 8.80    July   9/98  - fixed precip shutdown after smearing
!     rev. 8.81    July  17/98  - precip adjust for T > 0 C only
!     rev. 8.82    July  10/98  - added runoff output option: routeflg
!     rev. 8.83    Sep.  23/98  - moved step args to area2.for
!     rev. 8.84    Sep.  28/98  - added runoff and evap fields to 
!                                 CHARM.txt
!     rev. 8.85    Oct.  12/98  - fixed rain & snow on water class
!     rev. 8.86    Nov.  02/98  - fixed opt problem found by ted.
!                               - fixed tto(n)=0 problem in etin
!     rev. 8.87    Nov.  17/98  - added watbal.for for water balance
!     rev. 8.88    Nov.  23/98  - fmadjust function of degree days
!     rev. 8.89    Nov.  30/98  - simplified uzs parameters
!     rev. 8.90    Dec.  04/98  - input to memory for opt runs
!     rev. 8.91    Dec.  07/98  - read rdevt in sub as well as CHARM!
!     rev. 8.92    Dec.  24/89  - check for 100% aclass coverage
!     rev. 8.93    Jan.  17/99  - sub modified for CHARM & watroute
!     rev. 8.94    Feb.  01/99  - crseflg to read resume & snow course
!     rev. 8.94a   Feb.  02/99  - reset heat deficit to 0.0 on Sept.01
!     rev. 8.94b   Feb.  06/99  - temperature correction and stop cmd
!     rev. 8.94c&d Feb.  20/99  - made paf.txt/error.txt default order
!     rev. 8.94e   Feb.  24/99  - added surfer output for error in lst
!     rev. 8.95    Mar.  15/99  - computed mean flows for time increment
!                               - involved getting rid of /kt throughout
!     rev. 8.96    Apr.  26/99  - lower zone function related to nbsn
!     rev. 8.96.1  May   12/99  - added ireport for reporting interval
!     rev. 8.97    July  12/99  - demonstration copy addition
!     rev. 8.98    July  15/99  - met grid shifting for weather models 
!     rev. 8.99    Aug.  18/99  - replaced err= with iostat= for f90
!     rev. 8.99a   Jul.     99  - lat-long watershed data
!     rev. 8.99b   Sept. 27/99  - divvy up interflow & drainae
!     rev. 8.99c   Oct.   5/99  - irough -> sl2 input in shed
!     rec. 8.99e   Nov.  29/99  - heat deficit initatialization
!     rev. 8.99f   Jan.   7/00  - changed uzs calcs re: shari's data
!     rev. 8.99g   Feb.   7/00  - added ttoinit to init evaporation
!     rev. 8.99k  feb. 15/2001  - fixex deficit calc in melt.for see9.06k
!     rev. 8.99l  Oct.    2001  - fixed reservoir release timing in CHARM8
!     rev. 8.99mm Dec. 13/2001-     added check for <= 0 init res flow
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!     rev. 9.0     Mar.  21/00  - ts: converted to Fortran 90 
!                               - added dynamic memory allocation
!                               - added wfo file for ensim
!                  Fall   2000  - added wetland routing model         
!     rev. 9.01    Aug.   1/00  - added look up for minimum temperature
!                                 and function to calculate RH
!     rev. 9.02    Oct.   5/00  - added option to debug on one grid
!     rev. 9.03    Jan.   7/01  - set min precip rate for smearing
!     rev. 9.04    Jan    16/01 - fixed grid diagnosis in flowinit
!     rev. 9.05    Feb.   6/01  - chngd unit 61 to snw1.csv for surfer
!     rev. 9.06k   Feb.  15/01  - fixed deficit calc in melt (rem. qlz.txt) =8.99k
!     rev. 9.07    Mar.  14/01  - fixed use of opt par's  for numa=0  
!     rev. 9.08    Mar.  26/01  - checked limits on heat def.
!     rev. 9.08.01 Apr.   3/01  - check wetland designation in param
!     rev. 9.1     May    7/01  - updated Luis's sed & nutrient stuff
!     rev  9.1.02  July  12/01  - put in dacheck in flowinit for wetland flag
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 9.1.04  Oct.   4/01  - added A7 for weighting old/new sca in melt
!                               - fixed Jan. 17/02 - didn't work before
!     rev. 8.99n   Dec.31/2001  -     fixed nat. res initial flow (JW)
!     rev. 9.1.05  Oct.   4/01  - new format parameter file
!     rev. 9.1.06  Oct.  16/01  - nrvr added to area3 to set # river types
!     rev. 9.1.07  Jan.   3/02  - check that outlet is in a lake
!     rev. 9.1.08  Jan.  17/02  - fixed rev. 9.1.04
!     rev. 9.1.09  Jan.  21/02  - fixed reservoir release timing in CHARM9 see8.99l
!     rev. 9.1.10  Jan.  29/02  - flow nudging added for nopt(l)=2
!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 
!     rev. 9.1.12  Mar.  15/02  - added xdelta and ydelta for ensim
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
!     rev. 9.1.14  Mar.  24/02  - fixed wetland min time step & outflow
!     rev. 9.1.15  Apr.  02/02  - Luis' sediment stuff runs. Not checked with old version.
!     rev. 9.1.16  Apr.  03/02  - Added wetland conditional to select river w/wo wetland
!     rev. 9.1.17  May   05/02  - Some tidying up
!     rev. 9.1.18  Jun.  03/02  - Added sub-watershed modelling capability
!     rev. 9.1.19  Jun.  22/02  - Added A9 as the max heat deficit/swe ratio
!     rev  9.1.20  Jun.  25/02  - Added A10 as the power on the UZ discharge function
!     rev. 9.1.21  Jun.  28/02  - Added wetland storage & outflow to the wfo file
!     rev. 9.1.22  Jul.  22/02  - Added simout\error.r2s file for ENSIM_Hydrologic
!     rev. 9.1.23  Jul.  23/02  - Added control for nudging in event #1
!     rev  9.1.24  Sep.  11/02  - Added scaleallsnw to set snw scale in event 1
!     rev  9.1.25  Sep.  11/02  - Added A11 as bare ground equiv. vegn height  
!     rev. 9.1.26  Sep.  11/02  - fixed wetland evaporation re: uzsi
!     rev. 9.1.27  Sept. 19/02  - Added isbaflg
!     rev. 9.1.28  Sept. 19/02  - Added shedlfg to replace the bsnm.shd file
!     rev. 9.1.29  Nov.  07/02  - Changed the threshold flow values for error calculations
!     rev. 9.1.30  Nov.  08/02  - added q1, qint, drng & qlz to the wfo file
!     rev. 9.1.31  Nov.  13/02  - Fixed the wetland Q to account for wetland area
!     rev. 9.1.32  Nov.  20/02  - Fixed fpetmon() wrt. h()
!     rev. 9.1.33  Dec.  05/02  - Fixed instability in wetland flow    
!     rev. 9.1.34  Dec.  23/02  - Added ensim1flg - if ensimflg='a' for 1st id then 'y' for all events
!     rev. 9.1.35  Dec.  26/02  - Added wetland & channel heights to the wfo file
!     rev. 9.1.36  Jan.  28/03  - Fixed wetland init condition in flowinit
!     rev. 9.1.37  Mar.  22/03  - Option to turn off leakage by setting LZF < 0.0
!     rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
!     rev. 9.1.39  Apr.  06/03  - Fixed wetland routing when channel is dry
!     rev. 9.1.40  Apr.  24/03  - Min time step A6 read in strfw over rides the A6 from the par file
!     rev. 9.1.41  May   15/03  - Event average flows output to unit=75
!     rev. 9.1.42  May   31/03  - Tracer module added - first try
!     rev. 9.1.43  Jun.  01/03  - Fixed the qdwpr.txt function - re: last grid in lake
!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!     rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added 
!     rev. 9.1.46  Jul.  17/03  - WATFLOOD LITE incorporated 
!     rev. 9.1.47  July  24/03  - TS: Tracer s/r deallocations added 
!     rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     rev. 9.1.50  Jan.  14/04  - NK: version number added to the wfo_spec.txt file
!     rev. 9.1.51  Jan.  28/04  - NK: added iz.ne.jz conditional to ENSIM output  
!     rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!     rev. 9.1.53  Mar.  14/04  - NK: hasp key configured
!     rev. 9.1.54  Apr.  12/04  - NK: SEDFLG set for multiple events at event No. 1
!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.57  Jul.  06/04  - NK: Fixed major bug in shed.for max instead of min
!     rev. 9.1.58  Jul.  12/04  - NK: New header for the .shd file
!     rev. 9.1.59  Jul.  15/04  - NK: CHARMit rerout into two parts: rdresv & rerout
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
!     rev. 9.1.61  Aug.  25/04  - NK: Check for repeated met data in RAIN
!     rev. 9.1.62  Sep.  08/04  - NK: Fixed the conversion factor in SNW.FOR  (cnv)
!     rev. 9.1.63  Sep.  29/04  - NK: Added iopt_start as an arg for quick filecheck
!     rev. 9.1.64  Oct.  03/04  - NK: Coded up new header in ragmet.for
!     rev. 9.1.65  Oct.  03/04  - NK: Coded up new header for snow course file
!     rev. 9.1.66  Oct.  17/04  - NK; pet*ftall for loss from water instead of pet
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_flow
!     rev. 9.1.68  Dec.  19/04  - NK: rewrote rdflow c/w memory allocation 
!     rev. 9.1.69  Dec.  19/04  - NK: rewrote rdresv c/w memory allocation 
!     rev. 9.1.70  Dec.  21/04  - NK: rewrote rdrain c/w memory allocation 
!     rev. 9.1.71  Dec.  28/04  - NK: rewrote rdtemp c/w memory allocation 
!     rev. 9.1.72  Dec.  28/04  - NK: fix bug in rdresv setting reach # 
!     rev. 9.1.73  Jan.  25/05  - NK: rewrote rdcrse c/w memory allocation 
!     rev. 9.1.74  Feb.  08/05  - NK: trashed rscrse replaced with rdswe
!     rev. 9.1.75  Feb.  08/05  - NK: added rdgsm (gridded soil moisture)
!     rev. 9.1.76  Mar.  09/05  - NK: separated glacier parameters in par file
!     rev. 9.1.77  Mar.  07/05  - NK: added .psm .gsm & .glz  files
!     rev. 9.1.78  Mar.  15/05  - NK: added WQD file to event file
!     rev. 9.1.79  Mar.  30/05  - NK: ktri to area2 for reservoir inflow dt
!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
!     rev. 9.1.81  Apr.  04/05  - NK: added sublimation,et and etfs to wfo file
!     rev. 9.2     Jun.  02/05  - NK: Numerous changes to program organization 
!     rev. 9.2.01  Jun.  29/05  - NK: Added write_r2s 
!     rev. 9.2.02  Jun.  29/05  - NK: Added read_r2s 
!     rev. 9.2.03  Jul.  11/05  - NK: Added s/r precip_adjust 
!     rev. 9.2.04  Jul.  13/05  - NK: allocation check for resrl 
!     rev. 9.2.05  Jul.  15/05  - NK: reversed order of reading resume file 
!     rev. 9.2.05  Jul.  27/05  - NK: initialized delta in s/r compute_error
!     rev. 9.2.06  Jul.  28/05  - NK: normalized error with da for optimization
!     rev. 9.2.07  Jul.  29/05  - NK: soilinit moved from runoff to sub 
!     rev. 9.2.08  Jul.  29/05  - NK: opt work-around in options 
!     rev. 9.2.09  Sep.  11/05  - NK: removed write_par.for from rdpar.for
!     rev. 9.2.10  Sep.  11/05  - NK: unlimited comments on .shd & .map files
!     rev. 9.2.11  Sep.  15/05  - NK: added Manning's n  r1n & r2n
!     rev. 9.2.12  Sep.  15/05  - NK: added EXCEL eqn to flowinit
!     rev. 9.2.13  Sep.  28/05  - NK: added freeze and break up to route
!     rev. 9.2.14  Sep.  29/05  - NK: Added control for opt in event #1
!     rev. 9.2.15  Sep.  30/05  - NK: Fixed bug for opt in flowinit
!     rev. 9.2.16  Oct.  10/05  - NK: Fixed bug for widep in rdpar
!     rev. 9.2.17  Oct.  11/05  - NK: Fixed bug for .str bounds in route
!     rev. 9.2.18  Oct.  27/05  - NK: Fixed bug in flowinit (init spike)
!     rev. 9.2.19  Oct.  28/05  - NK: Compute daily & monthly flows
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 
!     rev. 9.2.21  Nov.  11/05  - NK: Set nopt in first event .str file 
!     rev. 9.2.22  Nov.  15/05  - NK: Fixed hmax bug in rdpar 
!     rev. 9.2.23  Nov.  22/05  - NK: Fixed res(n)=0 bug in route 
!     rev. 9.2.24  Dec.  07/05  - BT: DDS optimization 
!     rev. 9.2.25  Dec.  13/05  - NK: ENSIM r2c gridded soil moisture 
!     rev. 9.2.26  Dec.  23/05  - NK: Fixed reservoir outlet location bug 
!     rev. 9.2.27  Jan.  20/06  - NK: Separated header read in rdtemp
!     rev. 9.2.28  Jan.  30/06  - NK: Added low slope a4 for grids with water
!     rev. 9.2.29  Feb.  07/06  - NK: Read resv coeff first event only
!     rev. 9.2.30  Feb.  07/06  - NK: Added class_distribution.txt to output
!     rev. 9.2.31  Feb.  09/06  - NK: Added area chaeck to rdresume
!     rev. 9.2.32  Feb.  10/06  - NK: Added area_check.csv to output
!     rev. 9.2.33  Feb.  14/06  - NK: str stations from first event ONLY!!
!     rev. 9.2.34  Mar.  21/06  - NK: Activated glacier tracer1
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.36  Mar.  30/06  - NK: Scaleallsnow changed to scale precip snow
!     rev. 9.2.37  Mar.  31/06  - NK: Removed impervious area as special class
!     rev. 9.2.38  Apr.  28/06  - NK: Lower bound set on a12 for smearing
!     rev. 9.2.39  May.  09/06  - NK: t added to route & rerout arg list
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
!     rev. 9.2.41  Jun.  15/06  - NK: changed the resin.txt file to resin.csv
!     rev. 9.2.42  Jun.  20/06  - NK: water class included in the water balance
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.3.02  Jul.  18/06  - NK: converted runof, rchrg & lkage to r2c
!     rev. 9.3.03  Sep.  09/06  - NK: read s(i,j) from table instead of grid
!     rev. 9.3.04  Oct.  24/06  - NK: routing parameters dim to na in rte
!     rev. 9.3.05  Nov.  13/06  - NK: adder write_flowinit.for to flowinit.for
!     rev. 9.3.06  Dec.  17/06  - NK: added precip adjustment for bias
!     rev. 9.3.07  Dec.  29/06  - NK: added sum_precip for whole domain
!     rev. 9.3.08  Jan.  15/07  - NK: added lzs_init_new.r2c output to sub.for
!     rev. 9.3.09  Jan.  17/07  - NK: all file name lenghts = 60 in area12
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!     rev. 9.3.11  Feb.  28/07  - NK: ch_par added / event file ver = 9.5
!     rev. 9.4.01  Apr.  17/07  - NK: added deltat_report for gridflow.r2c
!     rev. 9.4.02  Apr.  18/07  - NK: moved rf, rffs from areawq to area1
!     rev. 9.4.03  Apr.  18/07  - NK: For water ev(n,ii)=pet(n,ii)*fpet(ii)
!     rev. 9.4.04  Apr.  23/07  - NK: moved allocate for melt from melt > CHARM
!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 9.4.06  May.  09/07  - NK: replaced por with spore(n,ii) in runof6
!     rev. 9.4.07  May.  15/07  - NK: converted opt to gridded routing parameters
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!     rev. 9.4.09  Jun.  19/07  - NK: added lake_area as a variable for iso
!     rev. 9.4.10  Jun.  19/07  - NK: adjusted frac for channel water area
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
!     rev. 9.4.12  Jul.  06/07  - NK: put qr + qstream - strloss back in runof6 
!     rev. 9.4.13  Jul.  09/07  - NK: modified lzs to account for lake area (flowinit) 
!     rev. 9.4.14  Jul.  09/07  - NK: added lake loss file 
!     rev. 9.4.15  Jul.  31/07  - NK: moved stuff from resume -> soil & flow init 
!     rev. 9.5     Sep.  07/07  - NK: changed wetland/channel routing 
!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
!     rev. 9.5.02  Oct.  21/07  - NK: set init qdwpr=0.0 in route
!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
!     rev. 9.5.04  Dec.  27/07  - NK: fixed bug in wetland routing
!     rev. 9.5.05  Jan.  13/08  - NK: added check for rec() in CHARM
!     rev. 9.5.06  Feb.  05/08  - NK: added pool and pool_o in rdpar & route
!     rev. 9.5.07  Feb.  05/08  - NK: fixed double counting of strloss & qstream
!     rev. 9.5.08  Feb.  08/08  - NK: new event parser
!     rev. 9.5.09  Feb.  12/08  - NK: added evap.r2c to the output files
!     rev. 9.5.10  Feb.  12/08  - NK: added water_area in lake_evap
!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
!     rev. 9.5.14  Feb.  26/08  - NK: padded rel file for missing data
!     rev. 9.5.15  Feb.  28/08  - NK: fixed tdum & xdum for proper grid area in lat-long
!     rev. 9.5.16  Feb.  28/08  - NK: moved precip_adjust to sub
!     rev. 9.5.17  Feb.  28/08  - NK: moved scale snow from sub to process rain
!     rev. 9.5.18  Mar.  03/08  - NK: added conv to options & sub argument list
!     rev. 9.5.19  Mar.  05/08  - NK: prevented use of tracer * iso models with nudging
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso model
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
!     rev. 9.5.23  Mar.  12/08  - NK: fixed allocation error in read_resv_ef
!     rev. 9.5.24  Mar.  18/08  - NK: fixed missing data in read_resl_ef.f
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
!     rev. 9.5.26  Apr.  04/08  - NK: added Julian day calc. to read_evt
!     rev. 9.5.27  Apr.  15/08  - NK: fixed allocation for chnl in rdpar
!     rev. 9.5.28  Apr.  15/08  - NK: fixed allocation for inbsnflg in flowinit
!     rev. 9.5.29  May.  26/08  - NK: fixed initialization in read_resv_ef
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!     rev. 9.5.31  May.  27/08  - NK: moved totsnw(n) computation in sub
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.33  Sep.  12/08  - NK: added column labels for grapher in flow_station_location.xyz
!     rev. 9.5.34  Sep.  17/08  - NK: fixed lake area in flowinit
!     rev. 9.5.35  Sep.  22/08  - NK: moved flow_sta_location to flowinit
!     rev. 9.5.36  Oct.  01/08  - NK: fixed ires bug for unevent dx & dy in read_resv
!     rev. 9.5.37  Oct.  14/08  - NK: added deltat_report to lake_sd.csv file write
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
!     rev. 9.5.39  Oct.  15/08  - NK: fixed bug in reservoit routing
!     rev. 9.5.40  Oct.  21/08  - NK: added diversions to rerout
!     rev. 9.5.41  Oct.  22/08  - NK: read in reservoir coefficients each event
!     rev. 9.5.42  Oct.  22/08  - NK: added b7() as the initial lake surface elevation
!     rev. 9.5.43  Oct.  27/08  - NK: changed bottom part of par file to be free format
!     rev. 9.5.44  Oct.  27/08  - NK: removed code & obj modules for hasp & rainbow
!     rev. 9.5.45  Dec.  16/08  - NK: added various error calculations - user's choice with errflg
!     rev. 9.5.46  Dec.  23/08  - NK: trying to fix problem with -ve storage. Changed conditional to .lt.
!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!     rev. 9.5.48  Dec.  26/08  - NK: added event_fln() to allow unlimited events
!     rev. 9.5.49  Dec.  31/08  - NK: changed conditional to read releases in rerout
!     rev. 9.5.50  Jan.  05/09  - NK: read evap data for reaches only
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 for all lakes
!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.53  Jan.  20/09  - NK: undid rev. 9.5.40
!     rev. 9.5.54  Feb.  11/09  - NK: undid rev. 9.2.28
!     rev. 9.5.55  Feb.  11/09  - NK: Correct R2n for instream lakes
!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
!     rev. 9.5.57  Apr.  13/09  - NK: added ntrlflg for natural lake flows
!     rev. 9.5.58  Apr.  16/09  - NK: added nudgeflg for forcing gauge flows
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!     rev. 9.5.60  Sep.  01/09  - NK: added deltat_report for lake_sd.csv file
!     rev. 9.5.61  Sep.  03/09  - NK: bug/eloss - added water class for wfo weighted et
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.63  Sep.  04/09  - NK: moved lapse rate from melt.f to process_temp.f
!     rev. 9.5.64  Sep.  16/09  - NK: corrected nudging wrt first event
!     rev. 9.5.65  Sep.  26/09  - NK: lapse rate changed from dC per 100 m to dC per m
!     rev. 9.5.66  Oct.  06/09  - NK: fixed bug in flowinit for init flows < 1.0
!     rev. 9.5.67  Oct.  06/09  - NK: fixed bug in rerout
!     rev. 9.5.68  Oct.  07/09  - NK: debugged read_resvin_ef.f
!     rev. 9.5.69  Oct.  10/09  - NK: added xcount & ycount to error & paf files
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!     rev. 9.5.71  Oct.  12/09  - NK: fixed bug in lst for setting value for nhyd(,)
!     rev. 9.5.72  Oct.  12/09  - NK: fixed bug in rdpar setting init values for fpet & ftal
!     rev. 9.5.73  Oct.  12/09  - NK: bypass using lake levels when optimizing
!     rev. 9.5.74  Oct.  21/09  - NK: in opt - made optim abs(optim)
!     rev. 9.5.75  Oct.  26/09  - NK: commented "deallocate in sub for watroute reads
!     rev. 9.5.76  Oct.  26/09  - NK: fixed basin exclusion for opt if resin present
!     rev. 9.5.77  Oct.  26/09  - NK: fixed some inits for out of basin gauges
!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
!     rev. 9.5.79  Nov.  04/09  - NK: added resumflg='s' for read_soilinit ONLY
!     rev. 9.5.80  Dec.  20/09  - NK: added swe_locations.txt file for swe input
!     rev. 9.5.81  Jan.  16/10  - NK: allow reservoirs outside watershed in resv file
!     rev. 9.5.82  Jan.  26/10  - NK: replaced error check for inflow locations
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
!     rev. 9.6.01  Mar.  01/10  - NK: DDS capability added
!     rev. 9.6.01  Mar.  01/10  - NK: rlake parameter added for Manning n correction
!     rev. 9.6.02  Mar.  15/10  - NK: add sublimation to optimization
!     rev. 9.6.02  Mar.  23/10  - NK: add cumm_domain_precip
!     rev. 9.6.03  Mar.  31/10  - NK: replaced leakage.dat by nbs.tb0 fln(79)
!     rev. 9.6.04  Apr.  05/10  - NK: fixed filename carry over in read_evt
!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
!     rev. 9.6.06  Apr.  18/10  - NK: added glacier adjust for optimization
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.01  Jun.  09/10  - NK: fixed error.xyz & error.r2s
!     rev. 9.7.02  Jun.  24/10  - NK: fixed bug in rdpar for classcount for imp area
!     rev. 9.7.03  Jun.  24/10  - NK: normalized SSE with station Qmean**2
!     rev. 9.7.04  Aug.  30/10  - NK: added to error message in read_rain & read_temp
!     rev. 9.7.04  Aug.  31/10  - NK: changed # decimal points for r2c files header
!     rev. 9.7.05  Aug.  31/10  - NK: changed error.r2s to error.r2c
!     rev. 9.7.06  Sep.  01/10  - NK: fixed subscript out of range errors in flowinit
!     rev. 9.7.07  Sep.  05/10  - NK: increased allowed # flow stations from 128 to 512
!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
!     rev. 9.7.09  Sep.  29/10  - NK: corrected error.r2c file for sub-basin errors
!     rev. 9.7.09  Oct.  02/10  - NK: ensure fpet_lake is not assigned unintended values
!     rev. 9.7.10  Oct.  11/10  - NK: update flowflag in lst.f for subsequent events
!     rev. 9.7.11  Nov.  22/10  - NK: added monthly_climate_deltas.txt file
!     rev. 9.7.12  Nov.  10/10  - NK: fix array bugs for reservoir inflows
!     rev. 9.7.13  Nov.  22/10  - NK: Changed the outfiles.txt for more 30 rff classes
!     rev. 9.7.14  Nov.  22/10  - NK: Allow 30 land cover classes
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
!     rev. 9.7.17  Jan.  05/11  - NK: Fixed diversions outside sub-basin
!     rev. 9.7.18  Jan.  17/11  - NK: Changed tolerance on the grid check in read_rain & read_temp
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 9.7.20  Jan.  31/11  - NK: Moved open statement for rdpar to rdpar/f
!     rev. 9.7.21. Mar.  07/11  - NK: Fixed delta_reort for longer periods in lst
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.7.23  Mar.  18/11  - NK: Revamped auto hydrograph fitting with precip icase=-2
!     rev. 9.7.24  Apr.  20/11  - NK: Added diverflg to indicate if a diversion is in grid
!     rev. 9.7.25  Apr.  28/11  - NK: Fixed daily flows
!     rev. 9.7.27  May.  26/11  - NK: Add lake_ice_factor
!     rev. 9.7.28  Jun.  14/11  - NK: Add degree_day for lake_ice_factor  dd_ice
!     rev. 9.7.29  Jul.  07/11  - NK: Add sublim_rate to set sublimation rate/day to par file
!     rev. 9.7.30  Jul.  13/11  - NK: imax > ycount & jmax > xcount also imin > 1 jnim > 1
!     rev. 9.8.00  Jul.  14/11  - NK: ntype+1 replaced by classcount (plus all derivatives)
!     rev. 9.8.01  Jul.  21/11  - NK: added ragmet optimization to dds setup
!     rev. 9.8.02  Jul.  26/11  - NK: reactivated meander length
!     rev. 9.8.02  Aug.  02/11  - NK: added lake level tb0 file
!     rev. 9.8.03  Aug.  08/11  - NK: check no of mean observed flows in file are ok
!     rev. 9.8.04  Sep.  02/11  - NK: Fix bug in write)par_10 when reading old par file
!     rev. 9.8.05  Oct.  18/11  - NK: New read_par_parser subroutine
!     rev. 9.8.06  Nov.  08/11  - NK: Added check for `water` class name
!     rev. 9.8.07  Oct.  10/11  - NK: area_check - removed unused stations
!     rev. 9.8.08  Nov.  18/11  - NK: added fratio for interception hight optimization
!     rev. 9.8.09  Nov.  22/11  - NK: nopt(l)=0 for area_error(l) > 10%
!     rev. 9.8.10  Dec.  06/11  - NK: Added message for FP overflow in route
!     rev. 9.8.11  Dec.  06/11  - NK: removed 30 char limit on find filetype 
!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
!     rev. 9.8.12  Dec.  08/11  - NK: recognize kenueflg in the event file 
!     rev. 9.8.13  Jan.  17/12  - NK: modifications to read_r2c for single frame data
!     rev. 9.8.14  Jan.  27/12  - NK: dds_penalty added for swe not to zero in summer
!     rev. 9.8.15  Mar.  12/12  - NK: write error.txt for every dds evaluation
!     rev. 9.8.16  Mar.  21/12  - NK: reinstate reservoir inflow error for dds
!     rev. 9.8.17  Apr.  24/12  - NK: Moved dds flags to top of par file
!     rev. 9.8.18  Apr.  26/12  - NK: Added in-basin check in tracer4
!     rev. 9.8.19  May.  10/12  - NK: Added check on mising init flow for lakes
!     rev. 9.8.20  MAy.  15/12  - NK: fixed lake area in flowinit9.5.34
!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
!     rev. 9.8.24  Aug.  07/12  - NK: Added reading yyyymmdd_lvl.tb0 for lake levels
!     rev. 9.8.25  Sep.  26/12  - NK: Added warning for resumflg=y and ID > 1
!     rev. 9.8.26  Sep.  26/12  - NK: Added error check on # chained files for id>1'
!     rev. 9.8.27  Sep.  27/12  - NK: changed action on resumflg='s' - keep tbcflg='y'
!     rev. 9.8.28  Oct.  12/12  - NK: fixed heat deficit reset for resume
!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     rev. 9.8.30  Oct.  16/12  - NK: remove p(i,j)=0.0 from precip_adjust
!     rev. 9.8.31  Oct.  16/12  - NK: continue rff files for contflg = y
!     rev. 9.8.32  Oct.  19/12  - NK: Fixed format for resin.csv in lst.f
!     rev. 9.8.33  Oct.  23/12  - NK: Deleted header for rff files with resumflg = y
!     rev. 9.8.34  Oct.  23/12  - NK: Added sums to the resume.txt file
!     rev. 9.8.35  Oct.  23/12  - NK: Fixed bug in read_soilinit_ef
!     rev. 9.8.36  Oct.  23/12  - NK: added fields to rff files
!     rev. 9.8.37  Oct.  27/12  - NK: added section to read_flow_ef to check # columns = no
!     rev. 9.8.38  Nov.  13/12  - NK: changed name level_plotting.xyz > level_station_location.xyz
!     rev. 9.8.39  Nov.  26/12  - NK: added check for flow stations in lakes
!     rev. 9.8.40  Jan.  14/13  - NK: convert interception cap: h(,)*fratio()
!     rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
!     rev. 9.8.42  Jan.  31/13  - NK: fixed bug in read_resvin: nopti int conversion
!     rev. 9.8.43  Jan.  31/13  - NK: fixed bug in lst.f : undefined output for iopt=99
!     rev. 9.8.44  Jan.  31/13  - NK: fixed bug in sub.f : uninitialized course_calc(n,j)
!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99
!     rev. 9.8.46  Feb.  04/13  - NK: Fixed some write formats in lst,stats,watbal
!     rev. 9.8.47  Feb.  04/13  - NK: Headers added for CHARM & resin csv files
!     rev. 9.8.48  Feb.  12/13  - NK: Replaced CHARM.plt with CHARM.tb0 file
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
!     rev. 9.8.50  Feb.  27/13  - NK: Initialize store1&2() for zero lake outflow
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiphours in s/r stats to value1 in the str file
!     rev. 9.8.52  Mar.  20/13  - NK: deleted a pause for dds runs in route
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!     rev. 9.8.54  Apr.  02/13  - NK: deltat conversion seconds to hours
!     rev. 9.8.55  Apr.  10/13  - NK: fixed pause for dds runs in route
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!     rev. 9.8.59  May   14/13  - NK: REmoved psmear & punused from the program
!     rev. 9.8.60  May   14/13  - NK: fixed ice factor for whole x-section
!     rev. 9.8.61  May   22/13  - NK: Introduced flag1 to speed up runof6
!     rev. 9.8.62  May   22/13  - NK: Fixed bug in runof6: (classcount-3) to (classcount-2) 
!     rev. 9.8.63  May   22/13  - NK: Fixed bug in s/r SUB.f argument list: "jan" missing 
!     rev. 9.8.64  May   28/13  - NK: Undocumented debug file 
!     rev. 9.8.65  May   28/13  - NK: Dimensioned firstpass_local()in REROUT
!     rev. 9.8.66  Jun   03/13  - NK: Added error_Dv.txt output in stats.f
!     rev. 9.8.67  Jun   06/13  - NK: Added allocation for flag1
!     rev. 9.8.68  Jun   17/13  - NK: Added dds_override file
!     rev. 9.8.69  Jun   17/13  - NK: Fixed bug in allocating clumnunits in SUB.f
!     rev. 9.8.70  Jun   17/13  - NK: for PAF: change error & PAF files to use GK formats
!     rev. 9.8.77  Jul   08/13  - NK: Made universal the use of wetland_flag(n)
!     rev. 9.8.78  Jul   16/13  - NK: Fixed divertflg to have the first event file value
!     rev. 9.8.79  Jul   19/13  - NK: Fixed wetland conditional screwed up with rev 9.8.77 in runof6
!     rev. 9.8.80  Aug   09/13  - NK: Added withdraw.r2c output file in route.f
!     rev. 9.8.81  Sep.  03/13  - NK: Add pafflg and update precip adjustment factors PAF!***********************************************************************
!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
!     rev. 9.8.83  Sep.  10/13  - NK: Set classcount=0 for fli.exe program only
!     rev. 9.8.84  Sep.  15/13  - NK: Added fratio to list of equal values for bog & fen
!     rev. 9.8.85  Sep.  30/13  - NK: Fixed the water balance for Lake St. Jo so diversion is taken care of
!     rev. 9.8.86  Oct.  16/13  - NK: Added version no to stats.txt output
!     rev. 9.8.87  Oct.  25/13  - NK: Added error message for mismatched resume file
!     rev. 9.8.88  Oct.  26/13  - NK: Fixed header writing sequence for CHARM.tb0 
!     rev. 9.8.89  Oct.  27/13  - NK: Fixed undefined (NAN) problem in flowint
!     rev. 9.8.90  Oct.  30/13  - NK: Added fetch to the shd file 
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!     rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
!     rev. 9.8.93  Nov.  12/13  - NK: Added the routing initialization with yyyymmdd_fli.r2c
!     rev. 9.8.94  Nov.  20/13  - NK: Added check on interception capacity for water
!     rev. 9.8.95  Nov.  20/13  - NK: Changed unit 58 to 955 for CHARM.tb0
!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
!     rev. 9.9.01  Dec.  12/13  - NK: Added `pintwarning' in route added
!     rev. 9.9.02  Dec.  12/13  - NK: Changed format for origin in wfo code
!     rev. 9.9.03  Dec.  15/13  - NK: Change to gridded latitude for etharg
!     rev. 9.9.04  Dec.  17/13  - NK: Change over to gridded climate normals to diff
!     rev. 9.9.05  Jan.  02/14  - NK: Add check if in-basin in flowinit
!     rev. 9.9.06  Jan.  08/14  - NK: Add daily differences to Harfreaves ETHarg.f
!     rev. 9.9.07  Jan.  10/14  - NK: Overhaul of the frame numbers to EnSim specs
!     rev. 9.9.08  Jan.  10/14  - NK: Add check on diversion locations in read_divert'
!     rev. 9.9.09  Feb.  24/14  - NK: Fixed reading the time stame in r2c frame headers
!     rev. 9.9.10  Mar.  20/14  - NK: Update swe anytime a file is found
!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!     rev. 9.9.12  Apr.  04/14  - NK: Added min & max lake_level output file
!     rev. 9.9.13  Apr.  04/14  - NK: Fix water balance
!     rev. 9.9.14  Jun.  02/14  - NK: Fix water balance for water class
!     rev. 9.9.15  Jun.  02/14  - NK: Add lz to the water balance - it was missing
!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
!     rev. 9.9.17  Jun.  07/14  - NK: Added check for allocation of outarray in Sub.f
!     rev. 9.9.18  Jun.  08/14  - NK: Fixed glacier_class check for wetlands
!     rev. 9.9.19  Jun.  11/14  - NK: Added a file for lat-long diversion locations for L. St. Jo
!     rev. 9.9.20  Jul.  15/14  - NK: Fix -ve lake storage when release data used
!     rev. 9.9.20  Jul.  24/14  - NK: Added dead storage for lakes "store_dead"
!     rev. 9.9.21  Jul.  27/14  - NK: Added allocation for outarray in sub
!     rev. 9.9.22  Jul.  29/14  - NK: Fixed basin no assignment in flowinit.f
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!     rev. 9.9.24  Aug.  20/14  - NK: Added monthly mean flow csv file CHARM_mly_nn.csv
!     rev. 9.9.25  Sep.  02/14  - NK: Finally fixed the error when nbasin=0
!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!     rev. 9.9.27  Sep.  18/14  - NK: Added zero class bypass in intcept.f
!     rev. 9.9.28  Sep.  18/14  - NK: Added 'a' as option for ntrlflg & smrflg
!     rev. 9.9.29  Sep.  30/14  - NK: Remove unnecessary writes for watroute
!     rev. 9.9.30  Sep.  30/14  - NK: fixed allocation for qhyd_mly & qsyn_mly
!     rev. 9.9.31  Oct.  13/14  - NK: Changed flow initialization RE: zero init flows
!     rev. 9.9.33  Oct.  16/14  - NK: Added checks for files existing for a resume'
!     rev. 9.9.34  Oct.  17/14  - NK: Added re-compute of lake storage re: new lake levels
!     rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
!     rev. 9.9.36  Nov.  03/14  - NK: Revised error message for daily diff choices
!     rev. 9.9.37  Nov.  05/14  - NK: Added `newDataFlag` check to WATROUTE 
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
!     rev. 9.9.39  Nov.  14/14  - NK: Modifications for watroute
!     rev. 9.9.40  Nov.  19/14  - NK: Modified the 'a' option for ntrlflg
!     rev. 9.9.41  Nov.  20/14  - NK: Added check if diversion = in-basin 
!     rev. 9.9.42  Nov.  26/14  - NK: Added errer check if diversion does not exist 
!     rev. 9.9.43  Nov.  26/14  - NK: Allocation for divertflg = 'g' 
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
!     rev. 9.9.45  Dec.  03/14  - NK: Revamped read_pt2 for general use
!     rev. 9.9.46  Dec.  10/14  - NK: Added check on initial lake outflow
!     rev. 9.9.47  Dec.  24/14  - NK: Added lakeflg for lake evaporation option
!     rev. 9.9.48  Jan.  06/15  - NK: Added wetland cond. function for o/b flow
!     rev. 9.9.49  Jan.  06/15  - NK: Added courantflg
!     rev. 9.9.50  Jan.  07/15  - NK: Added zero - initial flow warning
!     rev. 9.9.51  Jan.  13/15  - NK: Added min channel area in flowinit
!     rev. 9.9.52  Jan.  14/15  - NK: Fixed bug for channel store < 0 for withdrawals
!     rev. 9.9.53  Jan.  18/15  - NK: Prevent mode switch during iteration in wetland routing
!     rev. 9.9.54  Jan.  19/15  - NK: Put par & shd file names for 1st event in the headers
!     rev. 9.9.55  Jan.  22/15  - NK: Added diversion upstream drainage area in div file
!     rev. 9.9.56  Feb.  04/15  - NK: Fixed missing initial rel data in read_resv
!     rev. 9.9.57  Feb.  08/15  - NK: Fixed resv inflow output resin & lake_sd
!     rev. 9.9.58  Feb.  13/15  - NK: Added time column to levels.txt
!     rev. 9.9.59  Mar.  06/15  - NK: In route: strloss option frcflg y/n
!     rev. 9.9.60  Mar.  06/15  - NK: In sub: fixed call write_r2c for close condition 
!     rev. 9.9.61  Mar.  06/15  - NK: In route: restored hcha2(n)=store2(n)/chaarea(n)
!     rev. 9.9.62  Mar.  21/15  - NK: Change zone from character to integer
!     rev. 9.9.63  Apr.  06/15  - NK: Changed reas_resv to carry on with lask known release(s)
!     rev. 9.9.64  Apr.  08/15  - NK: DDS bypass in sub for single runs
!     rev. 9.9.65  Apr.  03/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 9.9.66  Apr.  03/15  - NK: Added options to write_tb0 str files
!     rev. 9.9.67  Apr.  29/15  - NK: Deleted mid_file headers in with tbcflg=y
!     rev. 9.9.68  Apr.  29/15  - NK: Fixed tto reset with resume
!     rev. 9.9.69  Jun.  10/15  - NK: prevent write ro rff if there is no class area
!     rev. 9.9.70  Jun.  12/15  - NK: Add del_rain, and dSTRconc2  to the wfo file
!     rev. 9.9.71  Jun.  13/15  - NK: DDS obf function taken out of sub > s/r obj_fn
!     rev. 9.9.72  Jul.  21/15  - NK: Dave Newson additions to sub & process_rain
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!     rev. 9.9.74  Sep.  11/15  - NK: Added output to unit 53 in flowinit
!     rev. 9.9.75  Sep.  11/15  - NK: Added basin_no.r2c output to flowinit.f
!     rev. 9.9.76  Sep.  11/15  - NK: Added recorded isotope concentrations
!     rev. 9.9.77  Sep.  11/15  - NK: S/r read_ts5 created
!     rev. 9.9.78  Sep.  16/15  - NK: Fixed wcl in melt.f
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
!     rev. 10.1.02 Oct.  09/15  - NK: Fixed allocation for qhyd_mly & qsyn_mly
!     rev. 10.1.03 Oct.  09/15  - NK: Added units 81-83 for isotope output
!     rev. 10.1.04 Oct.  10/15  - NK: Added year_last variable for use in reading isotope data
!     rev. 10.1.05 Oct.  11/15  - NK: Iso RMS error 
!     rev. 10.1.06 Nov.  19/15  - NK: Added area_check with can_discharge_sites.xyz 
!     rev. 10.1.07 Dec.  02/15  - NK: Added ice_fctr(n) to route 
!     rev. 10.1.08 Dec.  04/15  - NK: Added msg re: replacing "mean_observed_flows.txt"' 
!     rev. 10.1.09 Dec.  07/15  - NK: Add blank line for missing data in the precip.txt file in lst.f 
!     rev. 10.1.10 Dec.  09/15  - NK: Add blank line for missing data in the precip.txt file in lst.f 
!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!     rev. 10.1.12 Dec.  12/15  - NK: Added Nash Efficiency nasheff.r2c file unit-66
!     REV. 10.1.13 Dec.  28/15  - NK: Rearranged the par file blocks & contents
!     REV. 10.1.14 Jan.  05/16  - NK: Added ice rules for Lakes Athabaska & Great Slave.
!     REV. 10.1.15 Jan.  08/16  - NK: Custom coding for Mackenzie River Basin Hydraulic Model
!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f
!     REV. 10.1.17 Jan.  11/16  - NK: Added fpetLakeOverride factor
!     REV. 10.1.18 Jan.  15/16  - NK: Made opening of the master_inflow file optional with routeflg=q
!     REV. 10.1.19 Jan.  15/16  - NK: Fixed initialization of ice_factr - moved from lake_ice > runof6
!     REV. 10.1.20 Jan.  15/16  - NK: Fixed initialization of ice_factr - moved from lake_ice > runof6
!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
!     REV. 10.1.21 Jan.  23/16  - NK: Fixed lake init flow bug in flowinit
!     REV. 10.1.22 Jan.  25/16  - NK: Fixed flowinit for partial basins
!     REV. 10.1.23 Jan.  28/16  - NK: Added abort when water class not specified
!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
!     REV. 10.1.25 Feb.  21/16  - NK: Added nudge_flags.txt 
!     REV. 10.1.26 Mar.  23/16  - NK: Fixed comment for spinup period 
!     REV. 10.1.27 Apr.  19/16  - NK: Moved outfiles code in CHARM9 (below) 
!     REV. 10.1.28 Apr.  26/16  - NK: Fixed first day of output for master_inflows file 
!     REV. 10.1.29 May   04/16  - NK: Added parfile comments
!     REV. 10.1.30 May   08/16  - NK: Added smoothdist warning in read_par_parser
!     REV. 10.1.31 May   15/16  - NK: Revised output to precip.txt : include all str stations
!     REV. 10.1.32 May   18/16  - NK: Separate radinfl for precip & temperature
!     REV. 10.1.33 Jun   20/16  - NK: Change the time stamp in the watflood.wfo file
!     REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
!     REV. 10.1.35 Jul   07/16  - NK: Added simulation start time to the wfo file
!     REV. 10.1.36 Jul   12/16  - NK: Added results\LakeName.tb0
!     REV. 10.1.37 Jul   28/16  - NK: Added "Ellipsoid to the WFO header
!     REV. 10.1.38 Jul   28/16  - NK: Added noDataValue to WFO & tb0 files
!     REV. 10.1.39 Sep   16/16  - NK: Fixed stations outside the watershed for tb0
!     REV. 10.1.40 Oct   11/16  - NK: Fixed bug in read_divert for missing u/s DA
!     REV. 10.1.41 Oct   11/16  - NK: Added tb0flg to write lake_*.tb0 files
!     REV. 10.1.42 Oct   20/16  - NK: Reinstated read_ice_factor.f as default if present
!     REV. 10.1.43 Oct   21/16  - NK: lake_ice_facter changed from : to :,:  
!     rev. 10.1.44 Oct.  22/16  - NK: Reworked icerivflg & icelakeflg
!     rev. 10.1.45 Oct.  26/16  - NK: Added allocation check for qdivert in rerout
!     rev. 10.1.46 Nov.  08/16  - TH: Changed B1 - 5 to real*8
!     rev. 10.1.47 Nov.  08/16  - TH: Major changes in the ISO part of AET.f
!     rev. 10.1.48 Nov.  08/16  - TH: addet fpet(ii_water) to the wetland evaporation
!     rev. 10.1.49 Nov.  08/16  - TH: Overhauled lake evaporation
!     rev. 10.1.50 Nov.  08/16  - TH: Overhauled lst for new isotope output
!     rev. 10.1.51 Nov.  08/16  - TH: removed unused isotope related calculations, merged two 
!     rev. 10.1.51                TH: isotope related calc sections to reduce if statements
!     rev. 10.1.52 Nov.  08/16  - NK:
!     rev. 10.1.53 Nov.  09/16  - NK: Changed levels.txt to levels.csv
!     rev. 10.1.54 Nov.  25/16  - NK: Moved tdum under call timer in sub
!     rev. 10.1.55 Nov.  30/16  - NK: Fixed sumf & sumffs in runof6
!     rev. 10.1.56 Dec.  05/16  - NK: Fixed evt in AET.f to account for sca
!     rev. 10.1.57 Dec.  06/16  - NK: Added snwNN.txt files for iopt > 0
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!     rev. 10.1.59 Dec.  18/16  - NK: Fixed missing # channel correction chnl(1-5)
!     rev. 10.1.60 Jan.  03/17  - NK: Fixed conditional in route
!     rev. 10.1.61 Jan.  03/17  - NK: Changed results\peaks.txt to write peak flows
!     rev. 10.1.62 Jan.  08/17  - NK: Checkup on strloss effect on low flows
!     rev. 10.1.63 Jan.  25/17  - NK: Intel Parallel Studio XE 2017 Update 1 
!     rev. 10.1.64 Jan.  26/17  - NK: Added XML output file 
!     rev. 10.1.65 Jan.  28/17  - NK: Fixed allocate lake_elv from read_flow 
!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!     rev. 10.1.67 Feb.  18/17  - NK: Ignore start year in subsequent event files 
!     rev. 10.1.68 Mar.  03/17  - NK: Made midnight 00 instead of 24 
!     rev. 10.1.69 Mar.  03/17  - NK: Changed allocation for lvl_reach in read_lvl.f 
!     rev. 10.1.70 Mar.  03/17  - NK: Added year_now2 etc. for converting Grib2 files 
!     rev. 10.1.71 Mar.  14/17  - NK: Revised reading mean_observed_flows in sub 
!     rev. 10.1.72 Mar.  20/17  - NK: Fixed bug in sub for error_flag = 4 
!     rev. 10.1.73 Mar.  27/17  - NK: Advisory message set in precip.txt for iopt=0 
!     rev. 10.1.74 Apr.  01/17  - NK: Changed timer to fix 1 day-off problem 
!     rev. 10.1.75 Apr.  03/17  - NK: Fixed time & thr in runof6 arg list
!     rev. 10.1.76 Apr.  05/17  - NK: Reorganized the outfiles.* file
!     rev. 10.1.77 Apr.  17/17  - NK: Moved DDS err calcs to new dds_code s/r's
!     rev. 10.1.78 Apr.  17/17  - NK: New s/r dds_UZS to calculate low flow penalty
!     rev. 10.1.79 Apr.  18/17  - NK: Set trcflg=0 for all dds except errflg=10
!     rev. 10.1.80 Apr.  26/17  - NK: Fixed tracer turnoff for -ve resv. storage
!     rev. 10.1.81 May   05/17  - NK: Added snowg\yyyymmdd_swe.tb0 obs. swe
!     rev. 10.1.82 May   09/17  - NK: Added reservoir_fudge_factors.csv
!     rev. 10.1.83 May   09/17  - NK: Fixed lake evap bug - moved it outside lake-only loop
!     rev. 10.1.84 May   09/17  - NK: Put drng(n,ii)=drng(n,ii)*fraction back into runof6
!     rev. 10.1.85 May   17/17  - NK: Level_station_location.xyx for iopt > 0 only
!     rev. 10.1.86 May   17/17  - NK: Diversion_location.xyx for iopt > 0 only
!     rev. 10.1.87 May   18/17  - NK: Added DA to reservoir_location.xyz
!     rev. 10.1.88 May   23/17  - NK: Fixed Juliean_day problems for iso R/W
!     rev. 10.1.89 May   25/17  - NK: Added errflg = 11 for isotope DDS
!     rev. 10.1.90 Jul.  27/17  - NK: Added date_now for i/o files
!     rev. 10.1.91 May   25/17  - NK: Added errflg = 12 for isotope DDS
!     rev. 10.1.92 May   25/17  - NK: Changed to max 200 dds variables
!     rev. 10.1.92 Aug   12/17  - NK: delete store_dead in iso s/r's
!     rev. 10.1.93 Aug   17/17  - NK: allow year1 etc. to be passed for each event
!     rev. 10.1.94 Aug   29/17  - NK: Fixed col check bug in read_lvl
!     rev. 10.1.95 Sep   11/17  - NK: Fixed LKdepth bug in sub
!     rev. 10.1.96 Sep   11/17  - NK: Added variable lake depth calculation lake_elv()-LKinvert()
!     rev. 10.1.97 Sep   11/17  - NK: Moved hdrflg action in runof6.f
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
!     rev. 10.1.99 Oct   08/17  - NK: Added error check for # sdc classes in Melt.f
!     rev. 10.2.01 Oct   08/17  - NK: Moved ruleflg from sub.f to CHARM.f
!     rev. 10.2.02 Oct   24/17  - NK: Fixed xml output file
!     rev. 10.2.03 Oct   28/17  - NK: Revert to old G format for lakeSD.csv
!     rev. 10.2.04 Oct   28/17  - NK: Change to one xml output file for computed flow
!     rev. 10.2.05 Oct   28/17  - NK: Killed off stats_info.txt for iopt.ge.1
!     rev. 10.2.06 Oct   28/17  - NK: wfo_spec.txt in working OR basin directory
!     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
!     rev. 10.2.09 Nov.  04/17  - NK: Reinstated old Manning's n correction for legacy files      
!     rev. 10.2.10 Nov.  04/17  - NK: Fixed XML file    
!     rev. 10.2.11 Dec.  18/17  - NK: 4 files added for BLEND.exe    
!     rev. 10.2.12 Dec.  30/17  - NK: Added frame headers to static r2c files incl. shd file   
!     rev. 10.2.13 Jan.  31/18  - NK: Re-wrote rules.f to mimic stop log operations    -> rules_sl.f
!     rev. 10.2.14 Jan.  31/18  - NK: Renamed rules.f to rules_tl.f - for use with target levels
!     rev. 10.2.15 Feb.  05/18  - NK: Added 'results\monthly_peaks'
!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
!     rev. 10.2.17 Feb.  26/18  - NK: Added WFruntime to read_flow_ef
!     rev. 10.2.18 Mar.  12/18  - NK: Fixed array fault in read_resv_ef and sub
!     rev. 10.2.19 Mar.  13/18  - NK: Fixed array fault read_divert.f
!     rev. 10.2.20 Apr.  06/18  - NK: Added res_next for NBS
!     rev. 10.2.21 Apr.  14/18  - NK: Added Lake Level update 
!     rev. 10.2.22 May   10/18  - NK: Set wetland classes uncoupled and coupled to same parameters
!     rev. 10.2.23 May   18/18  - NK: Revamped target level lake rules
!     rev. 10.2.24 May   21/18  - NK: Added error message in Read_rain & read_tmp
!     rev. 10.2.25 May   27/18  - NK: Fixed nash e calculation for value1=nopt=0
!     rev. 10.2.26 Jul.  03/18  - NK: Fixed nash e calculation for denominator = 0
!     rev. 10.2.27 Jul.  08/18  - NK: replaced lake_inflow_sum with temp_flow_sum
!     rev. 10.2.28 Jul.  08/18  - NK: Revised for TSW = NBS without lake precip/evap'n
!     rev. 10.2.29 Aug.  21/18  - NK: Added warning for lake depths less than 1 m
!     rev. 10.2.30 Aug.  22/18  - NK: Added error for ftall(water) 
!     rev. 10.2.31 Aug.  23/18  - NK: Echo recorded levels for iopt>=99 only 
!     rev. 10.2.32 Aug.  23/18  - NK: Changed non-convergence value for qo2 
!     rev. 10.2.33 Sep.  14/18  - NK: Changed unit=42  fln(12) from clutter to model\*.r2c file 
!     rev. 10.2.34 Sep.  22/18  - NK: Initialize modelLastHour in rear_rain_ef
!     rev. 10.2.35 Oct.  08/18  - NK: Moved logical def. to area_watflood
!     rev. 10.2.36 Oct.  17/18  - NK: Initialized evap_rate(n) in lake_evap.f 
!     rev. 10.2.37 Oct.  18/18  - NK: Changed target levels to real*8 
!     rev. 10.2.38 Oct.  24/18  - NK: Added runReport.txt for forecast mode 
!     rev. 10.2.39 Nov.  15/18  - NK: changed snowc(n,ii) to snowc(n,ii)*sca(n,ii) in runof6
!     rev. 10.2.40 Nov.  22/18  - NK: GNU Lesser General Public License
!     rev. 10.2.41 Dec.  10/18  - NK: Added winter monthly peaks
!     rev. 10.2.42 Jan.  16/19  - NK: Added resume\yyyy-mm-dd folder with resume files
!     rev. 10.2.43 Jan.  17/19  - NK: Fixed bug in leapyear extra day in rules_echo.txt
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
!     rev. 10.2.45 Jan.  21/19  - NK: Fixed bug in reservoir initialization in sub - n was undefined
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!     rev. 10.2.47 Feb.  10/19  - NK: Revised write_resume
!     rev. 10.2.48 Feb.  25/19  - NK: Moved temp correction to read_temp from process_temp
!     rev. 10.2.49 Jan.  21/19  - NK: Cleaned up write_2d_nc (netCDF)
!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*
!     rev. 10.2.51 Apr.  03/19  - NK: New section to read ts5 format file for swe
!     rev. 10.2.52 Apr.  15/19  - NK: Added total UZS for reporting in FEWS
!     rev. 10.2.53 May.  09/19  - AJ: Added ensemble to read_2D for FEWS
!     rev. 10.2.54 June  07/19  - NK Fixed time stamp values for the wfo file when running FEWS
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
!     rev. 10.2.56 June  13/19  - NK Added .nc output for grid_runoff & cumm ET
!     rev. 10.2.57 Jul.  07/19  - NK Tweaked coefficients in rules_tl
!     rev. 10.2.58 Jul.  17/19  - NK Remap nopt for changed flow stationlocations in FEWS
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef,read_lvl & read_divert to F90
!     rev. 10.2.60 Aug.  27/19  - NK Renamed read_lvl.f90 to read_level.f90 to get it added to the Repo
!     rev. 10.2.61 Aug.  28/19  - NK removed inbsnflg from read_resume
!     rev. 10.2.62 Sep.  09/19  - NK Added read_sm_update.f90 for read in sm adjustment factors
!     rev. 10.2.63 Sep.  09/19  - NK Fixed check for file exists for fln(54) - swe time series
!     rev. 10.2.64 Sep.  09/19  - NK added min_flow_cutoff for error calculations
!     rev. 10.2.65 Sep.  30/19  - NK Changed format of net_basin_supply outputs
!     rev. 10.2.66 Sep.  30/19  - NK Changed gage_temp from 7 to 8 char variable and used as flag ID
!     rev. 10.2.67 Nov.  03/19  - NK Fixed flow averaging in lst
!     rev. 10.2.68 Nov.  11/19  - NK New strfw\flowstation.xyz to set locations of the flow gages
!     rev. 10.2.69 Nov.  11/19  - NK New level\levelstation.xyz to set locations of the level gages
!     rev. 10.2.70 Nov.  11/19  - NK Lowered acceptable rvalue for Manning n correction 1.0 > 0.1
!     rev. 10.2.71 Nov.  18/19  - NK Bug fixes in wetland & reservoir routing
!     rev. 10.2.72 Nov.  21/19  - NK flow_sta_name: changed from 12 to 8 char  to accomodate US sta names
!     rev. 10.2.73 Dec.  14/19  - NK Convert rules_tl.f90 to Fortran 90 & fix drawdown comps.
!     rev. 10.3.00 Dec.  **/19  = NK Conversion f77 to f90      
!     rev. 10.3.01 Jan.  05/20  = Use nudge_flaf.xyz file for station area check      
!     rev. 10.3.02 Jan.  17/20  = changed event\*.evt to event\*.cfg      
!     rev. 10.3.03 Jan.  21/20  = NK added dd_ice & dd_thaw to the resume.txt file      
!     rev. 10.3.04 Jan.  29/20  = NK added smrflg = "t" for FEWS only      
!     rev. 10.3.05 Feb.  06/20  = NK added climate data
!     rev. 10.3.06 Feb.  27/20  = NK Fixed temperature scaling factors for single events
!     rev. 10.3.07 Mar.  04/20  = NK Fixed weighted swe in wfo file for grids with water
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating
!     rev. 10.3.09 Mar.  07/20  = NK Revise swe updating to maintain relative swe in classes
!           
      program_name='CHARM     '
      program_version=' 10.3.09  '
      program_date='2020/03/08'

      
!     rev. 9.5.44  Oct.  27/08  - NK: removed code & obj modules for hasp & rainbow
!      NOT VALID IN UNIX
!      include 'watfile.fi'
 
!      DATA uzsinit/16*0.0/
!      DATA flgevp2/-1.0/
      
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
      do i=1,100
          warning(i)=.false.
      end do
      
!     rev. 10.2.38 Oct.  24/18  - NK: Added runReport.txt for forecast mode 
      inquire(file='runReport.txt',EXIST=exists)
      if(exists)then
        open(unit=99,file='runReport.txt',status='unknown') 
        If(exists)then
          do while(.not.eof(99))
              read(99,*,iostat=ios)line
          end do
        endif
        write(99,*)'CHARM.exe - started'
        close(unit=99,status='keep')
      endif
      
      
!     stopflg is to keep the dos window open in WATFLOOD (VB)      
!     stopflg is to keep the dos window open in WATFLOOD (VB)      
!     If the program is run as:  CHARM 1  then the user has to hit return
!     when CHARM is finished.

      CALL GETARG(1, buf, status1)
      if(status1.ne.1)buf=' '
      if(buf.eq.'1')then
        stopflg='y'
      elseif(buf.eq.'9')then
!       rev. 9.1.63  Sep.  29/04  - NK: Added iopt_start as an arg for quick filecheck
      iopt_start=99
      elseif(buf.eq.'2')then
!       rev. 9.1.63  Sep.  29/04  - NK: Added iopt_start as an arg for quick filecheck
      iopt=2
      else
        stopflg='n'
      endif

!     increase stack size
!      editbin /stack:4000000 foo.exe

!     THIS SECTION GETS THE COMPUTER'S DATE AND TIME
!     THIS INFO USED TO COME FROM HEADER.FI, HOWEVER F90 INTRINSICS
!     AND CALLS ARE DIFFERENT AND THEREFORE IT NEEDED TO BE MODFIED

      call date_time(cday,time)

!     other unit numbers in use:
!     unit 29 - for domain_precip.txt in sub

!     INPUT FILES ARE UNITS 30-50  and  251- .....
!     THESE ARE OPENED MOSTLY IN SUB.F BECAUSE INPUT FILES
!     HAVE TO BE OPENED AND CLOSED FOR EACH MONTH IN THE ID LOOP

! unit=31  fln(1) - basin file (                    bsnm_shd.r2c)
! unit=32  fln(2) - parameter file (                bsnm.par)
! unit=33  fln(3) - point data location file (      bsnm.pdl)
! unit=34  fln(4) - not used in CHARM
! unit=35  fln(5) - point precipitation file        yyyymmdd_rag.tb0
! unit=36  fln(6) - streamflow data                 yyyymmdd_str.tb0  FEWS strfw\flow.nc
! unit=37  fln(7) - reservoir release data (        yyyymmdd_rel.tb0
! unit=38  fln(8) - reservoir inflow data           yyyymmdd_rin.tb0
! unit=39  fln(9) - unadjusted radar file           yyyymmdd_rad.r2c
! unit=39  fln(9) - reduced temperature grid        yyyymmdd_tem.r2c
! unit=40  fln(10)- precipitation data (            yyyymmdd_met.r2c  FEWS radcl\precip.nc
! unit=41  fln(11)- radar scan (cappi) file
!     rev. 10.2.33 Sep.  14/18  - NK: Changed unit=42  fln(12) from clutter to model\*.r2c file 
! unit=42  fln(12)- model r2c file                  yyyymmdd_capa.r2c
!                   note:  can be capa, regl_apcp or glb_apcp      
! unit=42  fln(12)- reduced precip grid             yyyymmdd_met.r2c
! unit=43  fln(13)- snow cover depletion curve      bsnm.sdc
! unit=44  fln(14)- point temperatures              yyyymmdd_tag.tb0
! unit=45  fln(15)- gridded temperatures            yyyymmdd_tem.r2c  FEWS tempr\tempt.nc
! unit=46  fln(16)- max temperatures                yyyymmdd.tmx
! unit=47  fln(17)- min temperatures                yyyymmdd.tmn
! unit=48  fln(18)- point daily snow files          yyyymmdd_dsn.tb0
! unit=49  fln(19)- radiation data gridded          yyyymmdd_flx.r2c
! unit=50  fln(20)- radiation data point            yyyymmdd_prn.tb0
! unit=251  fln(21)- humidity                       yyyymmdd_grh.r2c
! unit=252  fln(22)- wind speed                     yyyymmdd_gws.r2c
! unit=253  fln(23)- longwave radiation             yyyymmdd_glw.r2c
! unit=254  fln(24)- shortwave radiatin             yyyymmdd_gsw.r2c
! unit=255  fln(25)- atmospheric pressure           yyyymmdd_gpr.r2c
! unit=256  fln(26)- point relative humidity        yyyymmdd_prh.tb0       OR
! unit=256  fln(26)- point specific humidity        yyyymmdd_psh.tb0
! unit=257  fln(27)- point wind speed               yyyymmdd_pws.tb0
! unit=258  fln(28)- point longwave radiation       yyyymmdd_plw.tb0
! unit=259  fln(29)- point shortwave radiation      yyyymmdd_psw.tb0
! unit=260  fln(30)- point atmospheric pressure     yyyymmdd_ppr.tb0
! unit=261  fln(31)- gridded runoff files     runof\yyyymmdd_rff.r2c
! unit=262  fln(32)- gridded recharge         rchrg\yyyymmdd_rch.r2c
! unit=263  fln(33)- gridded leakage          lkage\yyyymmdd_lkg.r2c
! unit=264  fln(34)-  gridded lakeloss        eloss\yyyymmdd_lss.r2c
! unit=265  fln(35)- snow course data file          yyyymmdd_crs.pt2 
! unit=266  fln(36)- gridded snow water equivalant  yyyymmdd_swe.r2c
! unit=267  fln(37)- gridded soil moisture          yyyymmdd_gsm.r2c
! unit=268  fln(38)- gridded lower zone storage     yyyymmdd_lzs.r2c
! unit=269  fln(39)- point soil moisture            yyyymmdd_psm.pt2 
! unit=270  fln(40)- water quality data file  .wqd
! unit=271  fln(41)- routing parameter file         bsnm_ch_par.r2c
! unit=272  fln(42)- gridded wetland surface flux    - r2c file
! unit=273  fln(43)- gridded water surface flux file - 2rc file
! unit=274  fln(44)- point snow precip              yyyymmdd_snw.tbO
! unit=275  fln(45)- point drain (O18)              yyyymmdd_drn.tbO
! unit=276  fln(46)- point dsnow (O18)              yyyymmdd_dsn.tbO
! unit=277  fln(47)- gridded snow precip            yyyymmdd_snw.r2c
! unit=278  fln(48)- gridded drain (O18)            yyyymmdd_drn.r2c
! unit=279  fln(49)- gridded dsnow (O18)            yyyymmdd_dsn.r2c
! unit=280  fln(50)- point initial lake conditions  yyyymmdd_ill.pt2
! unit=281  fln(51)- gridded evaporation            yyyymmdd_evp.r2c
! unit=282  fln(52)- point diversion flow file      yyyymmdd_div.tb0
! unit=283  fln(53)- recorded lake level file       yyyymmdd_lvl.tb0  FEWS level\level.nc
! unit=284  fln(54)- swe time series pillows & crs  yyyymmdd_swe.ts5
! unit=285  fln(55)- init routing state variables   yyyymmdd_fli.r2c
! unit=286  fln(56)- point wind speed               yyyymmdd_spd.tb0
! unit=287  fln(57)- point wind direction           yyyymmdd_dir.tb0
! unit=288  fln(58)- gridded wind speed             yyyymmdd_spd.r2c
! unit=289  fln(59)- gridded wind direction         yyyymmdd_dir.r2c
! unit=290  fln(60)- mean daily temp diff    basin\mean_dly_diff.r2c
!           fln(61)- in usefor swe
! unit=292  fln(62)- daily temp differences         yyyymmdd_dif.r2c
!     rev. 10.2.11 Dec.  18/17  - NK: 4 files added for BLEND.exe    
! unit=293  fln(63)- Point Hourly Precip           yyyymmdd_pcp.tb0
! unit=294  fln(64)- Point Daily Precip            yyyymmdd_pcp.tb0
! unit=295  fln(65)- Gridded Hourly Precip         yyyymmdd_pcp.r2c
!           fln(66)- in used for results\nash_eff.r2c
!           fln(67)- in used for results\error.r2c
! unit=298  fln(68)- Gridded Daily precip          yyyymmdd_pcp.r2c

! unit=282  fln(52)- radar _1hr file    gzip1hr\yyyymm\yyyymmddhhmm_1hr
! unit=???  fln(201)-Gridded output for FEWS       CHARM_output.nc

! units 51-99 reserved for output files
! filenames 100-199 reserved for event file names

!     THE RESERVOIR INPUT FILE WAS ORIGINALLY 49 BUT THIS
!     WAS CHANGED WHEN TODD NEFF's EVAPORATION WAS ADDED

!!!!!!!!!!!!!!!!!!!!!!!!!!
!     ALSO USED IN SHED: UNIT 9 FOR FLN(6)

    translateflg='n'  ! used on translate.for if 'y'
      ittoflg=0
      ssmc_firstpass='y'
      flgevp2=-1.0
      ensimopenflg='n'

!     TS - ALLOCATION FOR AREA12A ARRAYS
      allocate(fln(3000),filename(3000),outfln(3000),stat=iAllocate)
      if (iAllocate.ne.0)then
          write(*,*)'Error: error with allocation of fln arrays in CHARM'
          write(98,*)'Error: error with allocation of fln arrays in CHARM'
          STOP  
      endif

! SET DEFALUT FILENAMES FOR OUTPUT FILES:
!     these names may be replaced with the outfiles.txt file in the working
!     directory to send the files to a designated place for output.
!     A default outfiles.new file is created in the working directory each 
!     time this program is run.

!     unit number = file number

    filename(21)='results\monthly_peaks_winter.txt'          
    filename(22)='results\monthly_peaks.txt'          
      filename(23)='results\withdraw.r2c'
           fln(23)=filename(23)
    filename(25)='basin\new_par.csv'      
    filename(26)='results\parfile.csv'      
    filename(27)='results\precip.txt'             !dv vs classes
    filename(28)='results\stats.txt'              !statistics list
    filename(29)='results\domain_precip.txt'      !for BCHydro/CRA
    filename(30)='dds\dds_log.txt'                !for DDS pre-emption
!     units 31-50 reserved for input files
      filename(51)='debug\charm_info.txt'  !program information
      filename(52)='results\opt.txt'      !optimization dataF
      filename(53)='debug\res.txt'      !reservoir data
      filename(54)='debug\lake_error.txt'      
      filename(55)='debug\rte.txt'      !routing data
      filename(56)='56-notinuse'      !animation data for mapper
      filename(57)='results\snw.txt'      !snow pack info
      filename(58)='not_in_use'      
      filename(59)='results\stg.plt'      !output for stage plots
      filename(60)='results\spl.csv'      !paired observed/computed = default
!     for WATROUTE this file is named results\wrt.csv      
           fln(60)='basin\mean_dly_diff.r2c'
      filename(61)='results\swe.r2c'      !now in ensim format
           fln(61)=filename(61)             !used in write_r2c
      filename(62)='results\snw.csv'      !for snow plots
      filename(63)='debug\debug.txt'           
      filename(64)='debug\snwdebug.txt' !snow info
      filename(65)='results\watflood.wfo' !opened in wfocode
      filename(66)='results\nash_eff.r2c' !gridded nash efficiency
           fln(66)=filename(66)           !used in write_r2s
      filename(67)='results\error.r2c'    !gridded flow errors
           fln(67)=filename(67)           !used in write_r2s
      filename(68)='results\wetland.csv'  !wetland info
      filename(69)='results\sed.csv'      !sediment conc. obs/computed
      filename(70)='mrbhm\mrb_master_inflows.new'  !inflows for MRBHM
           fln(70)=filename(70)             !used in write_tb0
      filename(71)='results\CHARM_dly.csv'  !daily streamflow obs & comptd
      filename(72)='results\gridflow.r2c' !grid outflow fn(time) 
           fln(72)=filename(72)             !used in write_r2c
      filename(73)='results\resin.csv'    !lake inflow obs/computed
      filename(74)='results\evap.txt'     !evaporation debug data
      filename(75)='results\evt_means.csv'   ! used to be 'runoff.txt'
      filename(76)='results\peaks.txt'    !obs/computed Qp / event
      filename(77)='results\volumes.txt'  !obs/computed vol. / event
      filename(78)='results\CHARM_mly.csv'  !monthly streamflow          
      filename(79)='not_in_use'    ! for sum of all lzoutflow
      filename(80)='results\lake_sd.csv'  !  reservoir storage output
!     rev. 9.9.76  Sep.  11/15  - NK: Added recorded isotope concentrations


!     these 3 files are not included in the outfiles.txt file (for now)
      filename(81)='results\iso_info.txt'   !isotope messages, data echo, etc
      filename(82)='results\iso_18O_conc.csv'    ! 18O concentrations
      filename(83)='results\iso_2H_conc.csv'     ! 2H concentration
!     84-89 reserved for isotope output


      filename(90)='results\tracer.csv'     !tracer data
      filename(91)='results\tracerMB.csv'   ! added Oct.30/03 TS
      filename(92)='results\tracer_debug.csv'                       
      filename(93)='results\tracerWET.csv'    ! added Dec.01/03 TS
      filename(94)='results\tracerWETMB.csv'  ! added Dec.01/03 TS
      filename(95)='results\evapsep.txt'  ! added Apr.05/06 TS
      filename(96)='results\watbal1.csv'
      filename(97)='results\watbal2.csv'  ! runof6
      filename(98)='debug\warnings.txt'
      filename(99)='scratch5'             ! reserved as scratch file
      filename(100)='results\evap.r2c'    !weighted evaporation
           fln(100)=filename(100)             !used in write_r2c
      filename(201)='results\CHARM_flow_2D.nc'             !results\CHARM_output.nc
           fln(201)=filename(201)             !used in write_r2c
      filename(202)='results\CHARM_swe_2D.nc'             !results\CHARM_output.nc
           fln(202)=filename(202)             !used in write_r2c
      filename(203)='results\CHARM_uzs_2D.nc'             !results\CHARM_output.nc
           fln(203)=filename(203)             !used in write_r2c
      filename(204)='results\CHARM_grid_runoff_2D.nc'     !results\CHARM_output.nc
           fln(204)=filename(204)             !used in write_r2c
      filename(205)='results\CHARM_cumm_ET_2D.nc'         !results\CHARM_output.nc
           fln(205)=filename(205)             !used in write_r2c


!     reserve filename(2001-2999) for tb0 files with lake data: inflow/outflow/level

      
      
!     rev. 10.1.57 Dec.  06/16  - NK: Added snwNN.txt files for iopt > 0
      filename(801)='results\snw01.txt'     !snow plots class 1
      filename(802)='results\snw02.txt'     !snow plots class 2
      filename(803)='results\snw03.txt'     !snow plots class 3
      filename(804)='results\snw04.txt'     !snow plots class 4
      filename(805)='results\snw05.txt'     !snow plots class 5
      filename(806)='results\snw06.txt'     !snow plots class 6
      filename(807)='results\snw07.txt'     !snow plots class 7
      filename(808)='results\snw08.txt'     !snow plots class 8
      filename(809)='results\snw09.txt'     !snow plots class 9
      filename(810)='results\snw10.txt'     !snow plots class 10
      filename(811)='results\snw11.txt'     !snow plots class 11
      filename(812)='results\snw12.txt'     !snow plots class 12
      filename(813)='results\snw13.txt'     !snow plots class 13
      filename(814)='results\snw14.txt'     !snow plots class 14
      filename(815)='results\snw15.txt'     !snow plots class 15
      filename(816)='results\snw16.txt'     !snow plots class 16
      filename(817)='results\snw17.txt'     !snow plots class 17
      filename(818)='results\snw18.txt'     !snow plots class 18
      filename(819)='results\snw19.txt'     !snow plots class 19
      filename(820)='results\snw20.txt'     !snow plots class 20
      filename(821)='results\snw21.txt'     !snow plots class 21
      filename(822)='results\snw22.txt'     !snow plots class 22
      filename(823)='results\snw23.txt'     !snow plots class 23
      filename(824)='results\snw24.txt'     !snow plots class 24
      filename(825)='results\snw25.txt'     !snow plots class 25
      filename(826)='results\snw26.txt'     !snow plots class 26
      filename(827)='results\snw27.txt'     !snow plots class 27
      filename(828)='results\snw28.txt'     !snow plots class 28
      filename(829)='results\snw29.txt'     !snow plots class 29
      filename(830)='results\snw30.txt'     !snow plots class 30
      filename(831)='results\snw31.txt'     !snow plots class 30
      filename(832)='results\snw32.txt'     !snow plots class 30
      filename(833)='results\snw33.txt'     !snow plots class 30
      filename(834)='results\snw34.txt'     !snow plots class 30
      filename(835)='results\snw35.txt'     !snow plots class 30
      filename(836)='results\snw36.txt'     !snow plots class 30
      filename(837)='results\snw37.txt'     !snow plots class 30
      filename(838)='results\snw38.txt'     !snow plots class 30
      filename(839)='results\snw39.txt'     !snow plots class 30
      filename(840)='results\snw40.txt'     !snow plots class 30
      filename(841)='results\snw41.txt'     !snow plots class 30
      filename(842)='results\snw42.txt'     !snow plots class 30
      filename(843)='results\snw43.txt'     !snow plots class 30
      filename(844)='results\snw44.txt'     !snow plots class 30
      filename(845)='results\snw45.txt'     !snow plots class 30
      filename(846)='results\snw46.txt'     !snow plots class 30
      filename(847)='results\snw47.txt'     !snow plots class 30
      filename(848)='results\snw48.txt'     !snow plots class 30
      filename(849)='results\snw49.txt'     !snow plots class 30
      filename(850)='results\snw50.txt'     !snow plots class 30

!     rev. 9.7.13  Nov.  22/10  - NK: Changed the outfiles.txt for more 30 rff classes
      filename(901)='results\rff01.txt'     !runoff plots class 1
      filename(902)='results\rff02.txt'     !runoff plots class 2
      filename(903)='results\rff03.txt'     !runoff plots class 3
      filename(904)='results\rff04.txt'     !runoff plots class 4
      filename(905)='results\rff05.txt'     !runoff plots class 5
      filename(906)='results\rff06.txt'     !runoff plots class 6
      filename(907)='results\rff07.txt'     !runoff plots class 7
      filename(908)='results\rff08.txt'     !runoff plots class 8
      filename(909)='results\rff09.txt'     !runoff plots class 9
      filename(910)='results\rff10.txt'     !runoff plots class 10
      filename(911)='results\rff11.txt'     !runoff plots class 11
      filename(912)='results\rff12.txt'     !runoff plots class 12
      filename(913)='results\rff13.txt'     !runoff plots class 13
      filename(914)='results\rff14.txt'     !runoff plots class 14
      filename(915)='results\rff15.txt'     !runoff plots class 15
      filename(916)='results\rff16.txt'     !runoff plots class 16
      filename(917)='results\rff17.txt'     !runoff plots class 17
      filename(918)='results\rff18.txt'     !runoff plots class 18
      filename(919)='results\rff19.txt'     !runoff plots class 19
      filename(920)='results\rff20.txt'     !runoff plots class 20
      filename(921)='results\rff21.txt'     !runoff plots class 21
      filename(922)='results\rff22.txt'     !runoff plots class 22
      filename(923)='results\rff23.txt'     !runoff plots class 23
      filename(924)='results\rff24.txt'     !runoff plots class 24
      filename(925)='results\rff25.txt'     !runoff plots class 25
      filename(926)='results\rff26.txt'     !runoff plots class 26
      filename(927)='results\rff27.txt'     !runoff plots class 27
      filename(928)='results\rff28.txt'     !runoff plots class 28
      filename(929)='results\rff29.txt'     !runoff plots class 29
      filename(930)='results\rff30.txt'     !runoff plots class 30
      filename(931)='results\rff31.txt'     !runoff plots class 30
      filename(932)='results\rff32.txt'     !runoff plots class 30
      filename(933)='results\rff33.txt'     !runoff plots class 30
      filename(934)='results\rff34.txt'     !runoff plots class 30
      filename(935)='results\rff35.txt'     !runoff plots class 30
      filename(936)='results\rff36.txt'     !runoff plots class 30
      filename(937)='results\rff37.txt'     !runoff plots class 30
      filename(938)='results\rff38.txt'     !runoff plots class 30
      filename(939)='results\rff39.txt'     !runoff plots class 30
      filename(940)='results\rff40.txt'     !runoff plots class 30
      filename(941)='results\rff41.txt'     !runoff plots class 30
      filename(942)='results\rff42.txt'     !runoff plots class 30
      filename(943)='results\rff43.txt'     !runoff plots class 30
      filename(944)='results\rff44.txt'     !runoff plots class 30
      filename(945)='results\rff45.txt'     !runoff plots class 30
      filename(946)='results\rff46.txt'     !runoff plots class 30
      filename(947)='results\rff47.txt'     !runoff plots class 30
      filename(948)='results\rff48.txt'     !runoff plots class 30
      filename(949)='results\rff49.txt'     !runoff plots class 30
      filename(950)='results\rff50.txt'     !runoff plots class 30
!     rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
      filename(951)='results\swe.csv'       !snow course comparison
      filename(953)='results\levels.csv'    !lake level comparison
      filename(954)='results\diversion.txt' !lake St. Jo. debug file
      filename(955)='results\CHARM.tb0'       !tb0 format output for CHARM
           fln(955)=filename(955)           !used in write_tb0
      filename(956)='results\lake_evap.txt' !lake evaporationdebug file
           fln(956)=filename(956)           !used in write_tb0
!     rev. 10.2.28 Jul.  08/18  - NK: Revised for TSW = NBS without lake precip/evap'n
      filename(957)='results\NetBasinSupply.txt'   !NBS
!     rev. 9.9.24  Aug.  20/14  - NK: Added monthly mean flow csv file CHARM_mly_nn.csv
      filename(960)='results\CHARM_mly_dlt.csv'      !daily comp-obs Q
      filename(961)='results\CHARM_mly_01.csv'       !monthly mean flow
      filename(962)='results\CHARM_mly_02.csv'       !monthly mean flow
      filename(963)='results\CHARM_mly_03.csv'       !monthly mean flow
      filename(964)='results\CHARM_mly_04.csv'       !monthly mean flow
      filename(965)='results\CHARM_mly_05.csv'       !monthly mean flow
      filename(966)='results\CHARM_mly_06.csv'       !monthly mean flow
      filename(967)='results\CHARM_mly_07.csv'       !monthly mean flow
      filename(968)='results\CHARM_mly_08.csv'       !monthly mean flow
      filename(969)='results\CHARM_mly_09.csv'       !monthly mean flow
      filename(970)='results\CHARM_mly_10.csv'       !monthly mean flow
      filename(971)='results\CHARM_mly_11.csv'       !monthly mean flow
      filename(972)='results\CHARM_mly_12.csv'       !monthly mean flow

      open(unit=51,file=filename(51),status='unknown',iostat=ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ios.ne.0)call io_warning(51,filename(51),ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      open(unit=63,file=filename(63),status='unknown',iostat=ios)
        if(ios.ne.0)call io_warning(63,filename(63),ios)
      iendarg=0
!     id is used as a flag. when id=0 openfiles:
      id=1              !not used like this now  nk Apr. 8/03
      ni=1

! NOTE: UNIT 99 IS A SCRATCH FILE ONLY
!       CLOSE MUST FOLLOW OPEN IN SAME SEQUENCE
!           FILENAMES USING 99:
!             new.par
!             resume.par
!             tot.par
!             stop.txtc
!             outfiles.txt
!             losCHARMot.txt
!             newerror.txt
!             basin/evap.txt
!             event/event.evt
!             status='scratch'
!             fln(99)
!             basin/correct.tmp'
!             tempname.txt
!

! DURING EXECUTION, THE 'STOP' COMMAND CAN BE MADE FROM ANOTHER DOS
! WINDOW.  IT WILL CHECK AT THE END OF EACH EVENT.  THIS WILL CLOSE
! ALL FILES PROPERLY AS OPPOSED TO THE PROBLEMS WITH A CTRL/BRK CRASH
      open(unit=99,file='stop.txt',form='formatted',status='unknown',iostat=ios)
    if(ios.eq.0)then
        write(99,99001)
        close(unit=99,status='keep')
    else
      write(98,*)'Info: error opening stop.txt - new file not written'
    endif
      
! ioflg IS THE NUMBER OF OUTPUT FILES LISTED IN OUTFILES.TXT
! so it's value will be changed then

! OPEN CHARM_info.txt    MUST OPEN FIRST
! OPEN FILE FOR ALL CHARM ERROR MESSAGES:
      if(ioflg.gt.1)then
        filename(98)=outfln(98)
      endif
     
!     open warnings.txt     
      open(unit=98,file=filename(98),status='unknown',iostat=ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(ios.ne.0)call io_warning(98,filename(98),ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call date_and_time(cday,time)
      write(98,6016)'Info: ',time(1:2),time(3:4),time(5:6)
      write(98,6017)'Info: ',cday(1:4),cday(5:6),cday(7:8)

!     rev. 10.3.02 Jan.  17/20  = changed event\*.evt to event\*.cfg      
      fln(99)='event/event.cfg'
      INQUIRE(FILE=fln(99),EXIST=exists)
      if(exists)then
          fln(99)='event/event.cfg'
      else
          fln(99)='event/event.evt'
      endif
      write(98,*)'Warning: If program dies here, possibly there are forward '
      write(98,*)'Warning: slashes in the event file'
      write(98,*)'Warning: please convert / to \ in event files'
      write(*,*)'Warning: If program dies here, possibly there are forward '
      write(*,*)'Warning: slashes in the event file'
      write(*,*)'Warning: please convert / to \ in event files'
      
      iopt=1  
!     not read until par file is read which happens after
!     reading the event file to get the par file name
     
!**********************************************************************
!      call rdevt(date,conv,scale,smc5,nhr,nhf)
      call read_evt(date,conv,scale,smc5,nhr,nhf)
!**********************************************************************
      year_now=year1

       if(debug_output)write(63,*) ' In CHARM - before call rdpar'
  
! ORIGINAL FILEIO.FI SECTION - STARTS HERE: 

!   LEAVE FILEIO HERE BECAUSE rdevtA READS FILE NAMES THAT HAVE TO BE 
!                            OPENED

!   Rev. 7.78 modified for error checking - Sept.29/96  AC flight 
!   Rev  7.9  modified to open files for evaporation output
!   Rev. 8.3  - May.  22/97 -     added the simout/outfiles capability

       if(debug_output)write(63,*) ' In CHARM - 1190'

!     SHED READS IN ALL THE WATERSHED DATA, FROM SEPERATE PROGRAM:
 
       if(debug_output)write(63,*) ' In CHARM - before call shed'
      
!C//////////////////////////////////////////////
!C///////////////////////// 
!C// Added by Dave

!     rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
        if(IsFileTypeR2C(fln(1)))then
            call read_shed_ef(31,1)	
        else
!cc			call rdshed()
                 print*,'Old format shd files not accepted'
                 print*,'Please create EF ????_shd.r2c files & rerun'
                 write(98,*)'Error: Old format shd files not accepted-Program aborted in CHARM @ 994'
               stop 'Program aborted in CHARM9 @ 994'
        endif

!// End Dave addition
!C/////////////////////////
!C//////////////////////////////////////////////
       if(debug_output)write(63,*) ' In CHARM - before allocate'

!       TS - ALLOCATIONS OF AREA16A ARRAYS
        allocate(qrgrid(ycount+10,xcount+10),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: with allocation of area16a arrays in CHARM9'
            STOP  'Error with allocation of area16a arrays in CHARM9'
        endif
!       Initialize these values because many are outside grid
!       and would otherwise be undifined.  nk June 11/03
        do i=1,ycount+10
          do j=1,xcount+10
            qrgrid(i,j)=0.0
          end do
        end do

!       TS - ALLOCATIONS OF AREA6A ARRAYS
!       NK - nxtbasin is done in flowinit
        allocate(sn1(ycount,xcount),nhyd(ycount,xcount),&
       nbasin(ycount,xcount),basinerr(ycount,xcount),&
       nasheff(ycount,xcount),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*) 'Error: with allocation of area6a arrays in CHARM9'
            STOP 'Error with allocation of area6a arrays in CHARM9'
        endif
!       TS - ALLOCATION OF ARRAY RAD FROM AREAETA (REMAINDER)
        allocate(rad(ycount,xcount),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: with allocation of rad array in CHARM9'
            STOP 'Error with allocation of rad array in CHARM9'
        endif
!       TS - ALLOCATION OF AREAMELTA ARRAYS (REMAINDER)
!       ALLOCATION FOR SDCD,SDCSCA OCCUR IN RDSDCA.FOR
        allocate(snw(ycount,xcount),dsn(it,xcount-1),&
            tmx(it,xcount-1),tmn(it,xcount-1),el(it,xcount-1),&
            stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: with allocation of areamelta arrays in CHARM9 @ 1138'
            STOP 'Error with allocation of areamelta arrays in CHARM9 @ 1138'
        endif
        
    if(IsFileTypeR2C(fln(1))) then
!       TS - ALLOCATIONS OF AREAMELTA ARRAYS (PARTIAL)
!       SNW,DSN,TTEMP,TMX,TMN,EL ALLOCATED IN SHEDA.FOR
!       SDCD,SDCSCA ALLOCATED IN RDSDCA.FOR

!       done in rdshed for the old file types
!       now here so read_shed_ef can be the same for rte & CHARM
        allocate(snowc(na,classcount),dsnow(na),tmax(na),tmin(na),&
        tmin1(na),tmin2(na),sca(na,classcount),oldsca(na,classcount),&
        fexcess(na,classcount),snowcmin(na,classcount),&
        wcl(na,classcount),nsdc(classcount),snocap(classcount),&
        ati(na,classcount),def(na,classcount),&
        qtot(classcount),robg(classcount),rosn(classcount),qnet(classcount),&
        smelt(classcount),excess(classcount),extra(classcount),idump(classcount),&
        qrain(classcount),qsnow(classcount),qrn(na),qsn(na),glmelt(na),&
        qe(classcount),qh(classcount),qn(classcount),qp(classcount),&
        refrz(classcount),fmadj(na),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: Error with allocation of areamelta arrays in CHARM9 @1160'
        endif
!       TS - ALLOCATIONS OF AREAETA ARRAYS (PARTIAL)
!       RAD ALLOCATED IN SHEDA.FOR
!       TS - ADDED ALLOCATIONS FOR EVAP-SEPARATION PARAMS (22/03/06)
!       TS: CHANGED ALLOCATIONS OF alb,pet, evap TO classcount (27/03/06)
!       rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
!       parameter allocation moved to rdpar  27/07/06 nk

!       but oh my god. Not needed in rte so not in read_shed_ef
!       So moved here from rdshed. 

!       but strloss taken out!!!!!!

        allocate(vo(na,classcount),intev(na,classcount),&
        sublim(na,classcount),sum_sublim(na,classcount),&
        sum_et(na,classcount),sum_pet(na,classcount),pint(na,classcount),&
        ev(na,classcount),pet(na,classcount),fpet2(na),&
        x2(na,classcount),x3(na,classcount),intevt(na,classcount),&
        evt(na,classcount),ssumr(na,classcount),totint(na),eloss(na),&
        uzsinit(classcount),deficit(classcount),v1(na,classcount),&
        radv(na),sinlat(na),coslat(na),tanlat(na),&
        flgtemp(na),tto(na),ttomin(na),ttomax(na),&
        dd_ice(na),dd_thaw(na),stat=iAllocate)
 !      *rh(na),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: Error with allocation of evt arrrays in CHARM9 @ 1185'
            STOP'Error with allocation of evt arrrays in CHARM9 @ 1185'
        endif

!     rev. 9.4.04  Apr.  23/07  - NK: moved allocate for melt from melt > CHARM
        if(snwflg.eq.'y')then
! TS - ADDED ARRAY ALLOCATIONS FOR MODULE MELTAONLY.FOR
            allocate(excess1(naa,classcount),raint(naa,classcount),&
            snowf(naa,classcount),snowt(naa,classcount),ta(naa,classcount),&
            deld(naa,classcount),dsno(naa,classcount),top(naa,classcount),&
            bot(naa,classcount),water(naa,classcount),wlmax(naa,classcount),&
            stat=iAllocate)
            if(iAllocate.ne.0)then
                write(98,*)'Error: Error allocating in CHARM @ 1195'
                STOP 'Error allocating in CHARM @ 1195'
            endif
        endif

        if(frcflg.eq.'y')then        
            allocate(evcg(na,classcount),acg(classcount),bcg(classcount),&
            relh(na),spech(na),delr(na),devcg(na,classcount),&
            icgflg(na,classcount),delsrf(na),delsm(na),&
            storeSW1(na,classcount),storeSW2(na,classcount),dels(na),&
            storeIF2(na,classcount),storeGW2(na),isodef(na,classcount),&
            isowcl(na,classcount),isowater(na,classcount),stat=iAllocate)
            if(iAllocate.ne.0)then
                write(98,*)'Error: Error with allocation of iso arrays in CHARM9 @ 1208'
                STOP 'Error with allocation of iso arrays in CHARM9 @ 1208'
            endif
        endif

!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
        if(frcflg.eq.'y')then        
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
          allocate(dlt2H_snow(na),dlt2H_rain(na),dlt_rain(na),dlt_snow(na),stat=iAllocate)
          if(iAllocate.ne.0)then
            write(98,*)'Error: error with allocation of dlt_???? in CHARM9'
            STOP 'Error with allocation of dlt_???? in CHARM9'
          endif
        endif

!       AB Added to make sure that intevt(n,ii)=intevt(n,ii)+intev(n,ii) in intcept works May 10, 2002
        do i=1,ycount+10
          do j=1,xcount+10
            qrgrid(i,j)=0.0
          end do
        end do

      endif     ! if(IsFileTypeR2C(fln(1))) the
       if(debug_output)write(63,*) ' In CHARM - before call rdpar'

!     rev. 9.7.20  Jan.  31/11  - NK: Moved open statement for rdpar to rdpar/f
      call find_filetype(2)
      if(filetype.eq.'par'.or.filetype.eq.'PAR')then
      newparflg=.false.

!       **********************************************************************
        call rdpar(1,ix,e1)
!       **********************************************************************

!       rev. 9.5.05  Jan.  13/08  - NK: added check for rec() in CHARM
!       Check that rec is not too high in any grid & any class
!       Got rid of x(ii) in runof6
        recflg='n'
      recmax=1.0E+32
        do n=1,naa
        do ii=1,classcount-2
          if(sl1(n)*rec(ii).gt.1.0)then
            recflg='y'
            recmax=amin1(recmax,1.0/sl1(n))
            write(98,*)'Warning: Value of rec for class',ii,'is too high. ',sl1(n)*rec(ii)
          endif
        end do
      end do
      if(recflg.eq.'y')then
        write(98,*)'Warning: Max value for rec recommended for this watershed =',recmax
        write(98,*)'Warning: See charm.txt for infoon which grids'
        write(98,*)'Warning:You may try it at your own risk'
      endif

         if(debug_output)write(63,*) ' In CHARM: 3 - before call rdsdc'

!       **********************************************************************
        if(snwflg.eq.'y') call rdsdc()
!       **********************************************************************

!       temporary defaults
        radinfl=300
        smoothdist=35
        rainsnowtemp=0.0
!       replace the old per file format with a new format file
        if(iopt99)then
!       **********************************************************************
        call write_par_10(99,25)
!       **********************************************************************
        call write_par_10(99,26)
!       **********************************************************************
        call write_par_10(51,0)
!       **********************************************************************
        endif

        if(flgevp2.ne.4.0)then
!         not needed if daily differences are used        
          inquire(FILE='basin\monthly_climate_normals.txt',EXIST=exists)
          if(.not.exists)then
!           write a new monthly climate data file
!           previously part of the par file
          open(unit=99,file='basin\monthly_climate_normals.txt',status='unknown',iostat=ios)
          if(ios.ne.0)then
            write(98,*)'Error: Problem opening "basin\monthly_climate_normals.txt"'
            write(98,*)'Error: program aborted in CHARM @ 1509'
            print*,'program aborted in CHARM @ 1509'
          endif
          write(99,99011)
99011       format('month  jan  feb  mar  apr  may  jun  jul  aug  sep  oct  nov  dec')
            write(99,99012,iostat=ios)(diff(i),i=1,12)
99012       format('mxmn ',12f5.1)          
            write(99,99013,iostat=ios)(hu(i),i=1,12)
99013       format('humid',12f5.1)          
            write(99,99014,iostat=ios)(pres(i),i=1,12)
99014       format('pres ',12f5.1)          
          write(98,*)'Info: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
          write(98,*)'Info: !the files:                          !'
          write(98,*)'Info: !basin\new_par.csv    &              !'
          write(98,*)'Info: !basin\monthly_climate_normals.txt   !'
          write(98,*)'Info: !have been written                   !'
          write(98,*)'Info: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
          endif
        endif
   
      else

      newparflg=.true.

      debugflg=.true.  ! iopt from the par file will not be changed

!     rev. 9.8.05  Oct.  18/11  - NK: New read_par_parser subroutine
!       **********************************************************************
      call read_par_parser(32,2)
!	  call read_par(32,2)
!       **********************************************************************
!       write the par file in results\CHARM.txt
        if(iopt99)then
!         **********************************************************************
        call write_par_10(51,0)
!         **********************************************************************
!         write results\parfile.csv
!         **********************************************************************
          call write_par_10(99,26)
!         **********************************************************************
        endif

!       dds is a logical variable and can be used to suppress output
        if(dds_flag.eq.1)dds=.true.

!       open monthly peaks        
        if(iopt99)then
          open(unit=21,file=filename(21),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(21,filename(21),ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          open(unit=22,file=filename(22),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(22,filename(22),ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        endif
        
        

        if(flgevp2.ne.4.0)then
!         this file should be changed to an GK format file
!         and should get an entry in the event file
          inquire(FILE='basin\monthly_climate_normals.txt',EXIST=exists)
          if(exists)then
           write(98,*)'Info: found basin\monthly_climate_normals.txt file'
        else
             write(98,*)'Error: Could not find:"basin\monthly_climate_normals.txt"'
             write(98,*)'Error: This file not needed if daily differences were'
             write(98,*)'Error: calculated tempr\yyyymmdd_dif.r2c and flgevp = 4'
             write(98,*)'Error: in the par file to use the updated'
             write(98,*)'Error: Hargreaves ET solution'
             write(98,*)'Error: Program aborted in CHARM9 @ 1336'
           stop 'Program aborted in CHARM9 @ 1336'
        endif   
        
!         read the old monthly_climate_normals.txt file:      
        open(unit=99,file='basin\monthly_climate_normals.txt',status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            write(98,*)'Error: Unable to open   basin\montly_climate_normals.txt'
            write(98,*)'Error: Possible cause(s):'
            write(98,*)'Error: file in use by another application'
            write(98,*)'Error: or target directory does not exist'
            write(98,*)'Error: Program aborted in CHARM.f @ 1587'
            stop 'Program aborted in CHARM.f @ 1587'
          endif
        write(51,*)  
        write(51,*)'Climate normals:'
        write(51,99011)
        read(99,*)line
          if(ios.ne.0)write(98,*)'Error: problems reading title line'
          read(99,*,iostat=ios)junk,(diff(i),i=1,12)
          write(51,99012)(diff(i),i=1,12)
!          mean_dly_diff(n,ii) is not used - replaced by dly_diff(n)
          if(ios.ne.0)write(98,*)'Error: problems reading diff'
          read(99,*,iostat=ios)junk,(hu(i),i=1,12)
          write(51,99013)(hu(i),i=1,12)
          if(ios.ne.0)write(98,*)'Error: problems reading humid'
          read(99,*,iostat=ios)junk,(pres(i),i=1,12)
          write(51,99014)(pres(i),i=1,12)
          if(ios.ne.0)write(98,*)'Error: problems reading pres'
          if(ios.ne.0)write(98,*)'Program aborted in CHARM9 @ 1355'
        close(unit=99,status='keep')
        if(ios.ne.0)then
            
            stop 'Program aborted in CHARM9 @ 1355'
        endif
          write(51,*)
        
!         write the par file in results\CHARM.txt
!         **********************************************************************
        call write_par_10(51,0)
!         **********************************************************************
!         write results\parfile.csv
!         **********************************************************************
          call write_par_10(99,26)
!         **********************************************************************
        endif
      endif
!   THIS IS TO OPEN AND READ THE OPTIONAL OUTFILES.TXT FILE THAT SETS
!   THE LOCATIONS OF THE OUTPUT FILES.  IF FILE DOES NOT EXIST, DEFAULT
!   NAMES WILL BE USED.

      do i=1,999
          writeflg(i)=.true.
      end do
      
      if(iopt.eq.0.and.netCDFflg)then       
!           suppress output for netCDF production runs when iopt = 0          
            writeflg(1)=.false.      ! used as a generic flag that can be used anywhere
            writeflg(27)=.false.     ! precip.txt
            writeflg(51)=.false.  
            writeflg(59)=.false.     ! stage.plt
            writeflg(60)=.false.
            writeflg(63)=.false.
            writeflg(64)=.false.
            writeflg(65)=.false.     ! watflood.wfo
            writeflg(68)=.false.     ! used in rt_wetland
            writeflg(71)=.false.
            writeflg(78)=.false.
            writeflg(80)=.false.
            writeflg(953)=.false.    ! levels.csv
            writeflg(955)=.false.    ! CHARM.tb0
            ensimflg='n'
            nbsflg='n'
            write(98,*)'INFO: SUPRESSING OUTPUT for FEWS'
      else            
            write(98,*)'INFO: NOT SUPRESSING OUTPUT for FEWS'
      endif
      

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     Moved all thhis from above so we have iopt99
      if(iopt99)then
          open(unit=52,file=filename(52),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(52,filename(52),ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)52,filename(52)
!         for dds we want to append - see errfg =9 in sub
        do while((.NOT.EOF(52)))
              read(52,*)line
          end do
      endif

      do i=53,55,2   ! don't open 54
      if(.not.i.eq.61)then
          if(ioflg.gt.1)then
            filename(i)=outfln(i)
          endif
          open(unit=i,file=filename(i),status='unknown',iostat=ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
        endif
      end do
!     files 56 - 59 for wind and not checked here  
      
      do i=60,64
      if(.not.i.eq.61)then
          if(ioflg.gt.1)then
            filename(i)=outfln(i)
          endif

      
          if(writeFlg(i))open(unit=i,file=filename(i),status='unknown',iostat=ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
        endif
      end do

       if(debug_output)write(63,*) 'passed 682 in CHARM'
      
!     File 61 (i=61) 'swe.r2c' is opened in write_r2c
!     File 65 (i=65) 'watflood.wfo' is opened in wfocode.for
!     File 66 (i=65) 'error.xyz' is opened in lst.for at end of run
!     File 67 (i=65) 'error.r2s' is opened in lst.for at end of run
      if(ioflg.gt.1)then
        do i=65,67
          filename(i)=outfln(i)
        end do
      endif

!     TS: CHANGED MAX LIMIT TO INCLUDE TRACER FILES + EVAPSEP FILE (APR 5/06)
      do i=68,80
        if(ioflg.gt.1)then
          filename(i)=outfln(i)
        endif
      if(i.ne.72.and.i.ne.70)then         ! 72 opened in write_r2c
!                                           ! 70 opened below if needed	  
          if(writeFlg(i))open(unit=i,file=filename(i),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
      endif
!     REV. 10.1.18 Jan.  15/16  - NK: Made opening of the master_inflow file optional with routeflg=q
      if(i.eq.70.and.routeflg.eq.'q')then         ! open the MRB_master_inflow.tb0
          open(unit=i,file=filename(i),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
          write(*,5003)i,filename(i)
      endif
      end do
      do i=90,95
        if(ioflg.gt.1)then
          filename(i)=outfln(i)
        endif
      if(i.ne.72)then         ! 72 opened in write_r2c
          open(unit=i,file=filename(i),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
      endif
      end do
      
!     This add the new run to the previous for CHARM.csv & lake_sd.csv
!     Added Feb. 23/19  NK      
      if(contflg.eq.'y')then
          do while(.not.eof(60))
              read(60,*)junk
          end do
          do while(.not.eof(80))
              read(80,*)junk
          end do
      endif
      
!     rev. 9.9.24  Aug.  20/14  - NK: Added monthly mean flow csv file CHARM_mly_nn.csv
      if(iopt99)then
          do i=960,972
              open(unit=i,file=filename(i),status='unknown',iostat=ios)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              if(ios.ne.0)call io_warning(i,filename(i),ios)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              write(98,*)'Info: opened CHARM_mly files'
              write(51,5003)i,filename(i)
          end do
      endif

       if(debug_output)write(63,*) ' In CHARM -1001'

!     rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!     wqual/yymmdd.wqd
      if(sedflg.eq.'y')then
        open(unit=256,file=fln(40),status='unknown',iostat=ios)
        if(ios.ne.0)then
          write(*,99119)fln(40)
          write(98,99119)fln(40)
99119     format(' Warning: Error opening or reading fln:',a30)
            write(98,*)'Error: Probable cause: read only yymmdd.wqd - wat qual file'
            write(98,*)'Error: This file is optional - used to enter nutrient loading'
            write(98,*)'Error: needed if sedflg=y in yymmdd.evt'
            write(98,*)'Error: OR: in config.sys have you set files=100 & buffers=50?'
            write(98,*)'Error: iostat code =',ios
            write(98,*)'Error: program aborted in CHARM.for @ 883'
          stop 'program aborted in CHARM.for @ 883'
        endif
      endif

      write(51,6015)time(1:2),time(3:4),time(5:6),cday(1:4),cday(5:6),cday(7:8)

!      write(51,6015) hrs,mins,secs,day,month,year

99905 write(51,1000)fln(10),fln(1)

       if(debug_output)write(63,*) ' In CHARM - 1183'

!     don't know what this is used for <<<<<<nl  18/04/02
!      type=float(itype)

      if(iopt.ge.1)then
        write(51,6001) iopt,itype
      endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     REV. 10.1.27 Apr.  19/16  - NK: Moved outfiles code in CHARM9 (below) 
!     rev. 10.1.76 Apr.  05/17  - NK: Reorganized the outfiles.* file
! WRITE A NEW OUTFILES.TXT FILE THAT CAN BE MODIFIED BY THE USER:
      if(writeFlg(1))then
        open(unit=99,file='outfiles.new',form='formatted',status='unknown',iostat=ios)
        if(ios.eq.0)then
          write(99,*)'unit#  Filename'
          write(99,99002)(i,filename(i),i=26,30)
          write(99,99002)(i,filename(i),i=51,80)
          write(99,99002)(i,filename(i),i=90,100)
          write(99,99002)(i,filename(i),i=901,900+classcount)
          close(unit=99,status='keep')
        else
          write(98,*)'Error: Unable to open file  outfiles.new'
          write(98,*)'Error: Possible cause(s):'
          write(98,*)'Error: file in use by another application'
          write(98,*)'Error: Program aborted in CHARM.f @ 865'
          stop 'Program aborted in CHARM.f @ 865'
        endif
      endif
      
!     rev. 10.1.76 Apr.  05/17  - NK: Reorganized the outfiles.* file
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call read_outfiles
!      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! THIS INCLUDE OPENS THE SIMOUT FILES AND WILL BE DIFFERENT FOR UNIX 
! OR DOS\WINDOWS
     
      call date_and_time(cday,time)
      if(numa.eq.0.and.dds_flag.eq.0)then
        write(51,6011)program_version,program_date
        write(51,6016)time(1:2),time(3:4),time(5:6)
        write(51,6017)cday(1:4),cday(5:6),cday(7:8)
        write(51,*)
        write(51,5003)i,filename(i)

        write(51,5002)
        write(51,1030)(i,i,filename(i),i=51,80)
        write(51,1030)(i,i,filename(i),i=901,930)
        write(51,1030)(i,i,filename(i),i=90,100)
    endif

      allocate (dly_diff(na),stat=iAllocate)
 
!     rev. 9.8.77  Jul   08/13  - NK: Made universal the use of wetland_flag(n)
!     added mar 28/06  nk
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
      if(glacier_class_number.ne.0)then
!       glacier_class_number is assigned in the rdpar file
        do n=1,naa
          if(aclass(n,glacier_class_number).gt.0.0)then
!         there is a glacier in this grid
          glacier_flag(n)='y'
          else
!         there is no glacier in this grid
          glacier_flag(n)='n'
          endif
        end do
      else  
!     rev. 9.9.18  Jun.  08/14  - NK: Fixed glacier_class check for wetlands
!       there are no glaciers at all      
        do n=1,naa
          glacier_flag(n)='n'
        end do
      endif

!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     wetland_flag(n) replaced multiple logical checks by just 1 in each
!     time & grid loop - so will save a lot of time
      allocate(wetland_flag(naa),stat=iAllocate)
      if(iAllocate.ne.0)then
          write(98,*)'Error:Error with allocation of wetland_flag in CHARM9 @ 1496'
          STOP 'Error with allocation of wetland_flag in CHARM9 @ 1496'
      endif

      write(51,*)'Wetland flag settings:'
      do n=1,naa
        if(wetflg.eq.'y'&
                .and.grid_area(n).gt.10.0&   
                .and.aclass(n,classcount-2).gt.0.0&         
                .and.theta(n).gt.0.00001&        
                .and.glacier_flag(n).ne.'y')then     
          wetland_flag(n)=.true.
        else
          wetland_flag(n)=.false.
        endif
        write(51,*)n,grid_area(n),aclass(n,classcount-2),ibn(n),theta(n),glacier_flag(n),wetland_flag(n)
    end do  
       
!     rev. 9.8.02  Jul.  26/11  - NK: reactivated meander length
!     this can only be placed here after reqding both the shd & par files
!     as with the PS it could be recalculated with each iteration      
      do n=1,naa
        rl(n)=rl(n)*mndr(n)
      end do
      
!     rev. 10.1.57 Dec.  06/16  - NK: Added snwNN.txt files for iopt > 0
!     open the snw files      
      if(iopt.ge.2)then
        do i=801,800+classcount
          open(unit=i,file=filename(i),status='unknown',iostat=ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(ios.ne.0)call io_warning(i,filename(i),ios)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(51,5003)i,filename(i)
        end do
      endif

!     open the rff files      
      if(iopt.ge.1)then
          write(98,*)'Info: results\rff**.txt files - if any:'
          write(98,*)'Info:      class #         file name              class fraction'
        do ii=1,classcount
          if(ioflg.gt.1)then
            filename(ii)=outfln(ii)
          endif
!         Alwasy open a rff file for the water class as some area is given 
!         in flowinit          
          if(aclass(nnprint,ii).gt.0.00)then
              write(98,*)'Info: ',ii,filename(900+ii)(1:30),aclass(nnprint,ii)
            open(unit=900+ii,file=filename(900+ii),status='unknown',iostat=ios)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(ios.ne.0)call io_warning(ii,filename(900+ii),ios)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
        end do
        
!     rev. 9.8.31  Oct.  16/12  - NK: continue rff files for contflg = y
        if(contflg.eq.'y')then
!         want rff files to continue from the spinup run
!         so read to end of files        
          do ii=1,classcount
            if(aclass(nnprint,ii).gt.0.00)then
              do while(.not.eof(900+ii))
                  read(900+ii,*)
              end do      
            endif
          end do      
        endif  
      else
!       delete existing files      
        if(.not.contflg.eq.'y')then
        do ii=1,classcount
          INQUIRE(FILE=filename(900+ii),EXIST=exists)
          if(exists)then
            open(unit=99,file=filename(900+ii),status='unknown',iostat=ios)
            close(unit=99,status='delete')
            write(98,*)'Info: rff??.txt file ',filename(900+ii)(1:25),' deleted'
          endif
        end do  
        endif
      endif

!     rev. 10.2.01 Oct   08/17  - NK: Moved ruleflg from sub.f to CHARM.f
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
      INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)
      if(exists)then
!         this means there are rules for some or all of the lakes & reservoirs
!         Note:  not necessarily all        
          ruleflg=.true.
          ruletype='aaaaaaaaaaaa'
          open(unit=99,file='resrl\rules.ts5',status='old')
          foundEndHeader=.false.
          do while(.not.foundEndHeader)
            read(99,99000)line
99000       format(a4096)       
            if(line(1:10).eq.':endHeader')foundEndHeader=.true.   
            if(line(1:10).eq.':EndHeader')foundEndHeader=.true.   
            if(line(1:8).eq.':StopLog')     ruletype='StopLog     '  
            if(line(1:12).eq.':TargetLevel')ruletype='TargetLevel '  
          end do
          write(98,*)'Info: ruletype = ',ruletype
      else
!         this means there are no rules at all.        
          ruleflg=.false.
      endif      


       if(debug_output)write(63,*) ' In CHARM: 3 - before call options'

!     **********************************************************************
    call options(ix,e1,conv,scale,smc5,nhr,nhf)
!     **********************************************************************

       if(debug_output)write(63,*)'in CHARM9 @1'



!     rev. 10.2.28 Jul.  08/18  - NK: Revised for TSW = NBS without lake precip/evap'n
      if(nbsflg.eq.'y')then    ! for the NBS file
    write(957,*)
      write(957,*)'DISCLAIMER'
    write(957,*)'The WATFLOOD software and other material supplied' 
    write(957,*)'in connection herewith is furnished by N. Kouwen and the' 
    write(957,*)'University of Waterloo and is accepted by the' 
    write(957,*)'user upon the express understanding that N. Kouwen' 
    write(957,*)'or the University of Waterloo make no warranties, either' 
    write(957,*)'express or implied, ' 
    write(957,*)'concerning the accuracy, completeness,' 
    write(957,*)'reliability, usability, performance, or fitness for any' 
    write(957,*)'particular purpose.' 
    write(957,*)
    write(957,*)'The material is provided "as is". The entire risk as to' 
    write(957,*)'its quality and performance is with the user.'
      write(957,*)
    write(957,*)'The forecasts produced by the WATFLOOD software are for' 
    write(957,*)'information and discussion purposes only and are not to' 
    write(957,*)'be relied upon in any particular situation without the' 
    write(957,*)'express written consent of N. Kouwen or the' 
    write(957,*)'University of Waterloo.'
      write(957,*)
      endif
              
      

      do i=901,930
        close(unit=i,status='keep',iostat=ios)
        if(ios.ne.0)then
          write(98,*)'Warning:  Problems on unit ',i,filename(i)
          write(98,*)'Warning:  error in closing file name',filename(i)
          write(98,*)'Warning:  iostat code =',ios
        endif
      end do

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      CALL ERRSNS(io_err,SYS_ERR,STAT,UNIT,cond)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      call errormsg(io_err,SYS_ERR,STAT,UNIT,cond)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      beepflg='on'
      INQUIRE(FILE='beep.txt',EXIST=exists)
      IF(exists)THEN
      open(unit=99,file='beep.txt',status='unknown')
      read(99,99005)beepflg
    endif

      if(beepflg.ne.'off')then
!       take out for unix - non standard
!       CALL BEEPQQ (frequency, duration)
!       CALL SLEEPQQ(delay)
        call BEEPQQ(2000,100)
        call SLEEPQQ(100) 
        call BEEPQQ(2000,100)
!       take out for unix - non standard
      endif

      if(fratioflg.and.dds_flag.eq.0.and.iopt99)then
        write(98,*)'fratio(s) <> 1.0 so maybe you would like to correct'
        write(98,*)'the interception capacity values h(month,class)'
        write(98,*)'in the par if you are happy with the values'
        write(98,*)'Find the corrected h(,) values and fratio=1.0'
        write(98,*)'in results\parfile.csv  Copy this as you par file'
      endif
      
!     rev. 9.9.39  Nov.  14/14  - NK: Modifications for watroute
      if(.not.dlyflg.and.flgevp2.eq.4.and.modelflg.eq.'n')then
        write(98,*)'Warning: Samani & Hargreaves (1985) eqn. used without use'
        write(98,*)'Warning: of daily temeprature differences as intended'
        write(98,*)'Warning: If this is not intended, please run TMP to create'
        write(98,*)'Warning: the yyyymmdd_dif.r2c files.'
      endif  

      if(.not.courantflg)then
        write(98,*)'Warning: Courant criterion violated'
        write(98,*)'Warning: Likely problems with instability & FP overflows'
        write(98,*)'Warning: Please reduce the min time step A6 in the par file'
      endif

      if(iopt.ge.1)close (unit=51,status='keep')
      
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
      !TH: stuffing the output framework stuff here for 2H isotopes, since I only want output at the end, move if you know a better spot
      if(frcflg.eq.'y'.and.flg2H.eq.2)then
      
       do n=1,nisoframe
        do i=1,int(totaltime)
         sumRO(n)=sumRO(n)+bsnRO(i,n)*bsnR(i,n)
         sumR2H(n)=sumR2H(n)+bsnR2H(i,n)*bsnR(i,n)
         sumRP(n)=sumRP(n)+bsnR(i,n)
        enddo
        do i=1,int(totaltime)
         sumRNum(n)=sumRNum(n)+(bsnRO(i,n)-sumRO(n)/sumRP(n))*(bsnR2H(i,n)-sumR2H(n)/sumRP(n))*bsnR(i,n)
         sumRDen(n)=sumRDen(n)+(bsnRO(i,n)-sumRO(n)/sumRP(n))**2*bsnR(i,n)
        enddo
       enddo
       
       !mX=sumRO(n)/sumRP(n)
       !mY=sumR2H(n)/sumRP(n)
       !Bx=dA-5= (1000*dAtotal(n)/Etotal(n)-5)
       !Ex=d*+1= (dStotal(n)/Etotal(n)+2)
            
        open(2228,file='results\frame.csv',status='unknown',iostat=ios)
          write(98,*)'Error: Error opening frame.csv output file'
          if(ios.ne.0) STOP 'Error opening frame output file'
          write(2228,1997)
          write(2228,1998)((1000*dAtotal(n)/Etotal(n)-5),&
                8*(1000*dAtotal(n)/Etotal(n)-5)+10,&
                (1000*dAtotal(n)/Etotal(n)-5),&
                sumRNum(n)/sumRDen(n)*(1000*dAtotal(n)/Etotal(n)-5)&
                +sumR2H(n)/sumRP(n)-sumRNum(n)/sumRDen(n)*sumRO(n)/sumRP(n),&
                (1000*dAtotal(n)/Etotal(n)-5),&
                ((d2HEtotal(n)-d2HStotal(n))/(dEtotal(n)-dStotal(n)))&
                *(1000*dAtotal(n)/Etotal(n)-5)+d2HStotal(n)/Etotal(n)&
                -(((d2HEtotal(n)-d2HStotal(n))/(dEtotal(n)-dStotal(n)))&
                *dStotal(n)/Etotal(n)),&
                1000*dAtotal(n)/Etotal(n),1000*d2HAtotal(n)/Etotal(n),&
                dStotal(n)/Etotal(n),d2HStotal(n)/Etotal(n),&
                  n=1,nisoframe)
          write(2228,1999)((dStotal(n)/Etotal(n)+1),&
                8*(dStotal(n)/Etotal(n)+1)+10,&
                (dStotal(n)/Etotal(n)+1),&
                sumRNum(n)/sumRDen(n)*(dStotal(n)/Etotal(n)+1)+sumR2H(n)/sumRP(n)&
                -sumRNum(n)/sumRDen(n)*sumRO(n)/sumRP(n),&
                (dStotal(n)/Etotal(n)+1),((d2HEtotal(n)-d2HStotal(n))/&
                (dEtotal(n)-dStotal(n)))*(dStotal(n)/Etotal(n)+1)&
                +d2HStotal(n)/Etotal(n)-(((d2HEtotal(n)-d2HStotal(n))/&
                (dEtotal(n)-dStotal(n)))*dStotal(n))/Etotal(n),&
                n=1,nisoframe)
 1997 FORMAT(<nisoframe>('GMWL',',',',','LMWL',',',',','LEL',',',',','del a',',',',','del *',',',','))
 1998 FORMAT(<nisoframe>(10(f20.6,',')))
 1999 FORMAT(<nisoframe>(6(f20.6,','),',',',',',',','))
      end if



    print*,'DISCLAIMER'
    print*,'The WATFLOOD software and other material supplied' 
    print*,'in connection herewith is furnished by N. Kouwen and the' 
    print*,'University of Waterloo and is accepted by the' 
    print*,'user upon the express understanding that N. Kouwen' 
    print*,'or the University of Waterloo make no warranties, either' 
    print*,'express or implied, concerning the accuracy, completeness,' 
    print*,'reliability, usability, performance, or fitness for any' 
    print*,'particular purpose.' 
    print*
    print*,'The material is provided "as is". The entire risk as to' 
    print*,'its quality and performance is with the user.'
    print*
    print*,'The forecasts produced by the WATFLOOD software are for' 
    print*,'information and discussion purposes only and are not to' 
    print*,'be relied upon in any particular situation without the' 
    print*,'express written consent of N. Kouwen or the' 
    print*,'University of Waterloo.'
    print*

      
      if(error_msg.eq.1)then
        write(98,*)'Warning:'
        write(98,*)'Warning: # of events to follow is > 0 for 1 or more '
        write(98,*)'Warning: chained events other than the first event file.'  
        write(98,*)'Warning: Only the first event file is used to set the'
        write(98,*)'Warning: sequence of events - othere are ignored'
      endif
      
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
      if(warning(1).and.iopt99)then
          write(98,*)'Warning:'
          write(98,*)'Warning: -ve flows encountered in some grids'
          write(98,*)'Warning: Please see warnings.txt for grid #(s) and time'
          write(98,*)'Warning: Lowest value encountered = ',qlow
          write(98,*)'Warning: id ',lowid,' time ',lowtime,' grid# ',lowgrid
          write(98,*)'Warning: row ',yyy(lowgrid),' col ',xxx(lowgrid)
          write(98,*)'Warning: Probably cause: evaporation from streams & rivers'
          write(98,*)'Warning: too large after prolonged dry periods'
          write(98,*)'Warning: Please see qlow.xyz for locations with -ve flows'
      endif
      if(warning(2))then
            write(98,*)'Warning: Very low flows encountered in some grids'
            write(98,*)'Warning: and evaporation from streams set = 0 This may not be a problem. '
            write(98,*)'Warning: Set iopt=1 to see grid #(s) and time'
      endif

      write(98,*)
      write(98,*)'DISCLAIMER'
    write(98,*)'Info: The WATFLOOD software and other material supplied' 
    write(98,*)'Info: in connection herewith is furnished by N. Kouwen and the' 
    write(98,*)'Info: University of Waterloo and is accepted by the' 
    write(98,*)'Info: user upon the express understanding that N. Kouwen' 
    write(98,*)'Info: or the University of Waterloo make no warranties, either' 
    write(98,*)'Info: express or implied, ' 
    write(98,*)'Info: concerning the accuracy, completeness,' 
    write(98,*)'Info: reliability, usability, performance, or fitness for any' 
    write(98,*)'Info: particular purpose.' 
    write(98,*)
    write(98,*)'Info: The material is provided "as is". The entire risk as to' 
    write(98,*)'Info: its quality and performance is with the user.'
      write(98,*)
    write(98,*)'Info: The forecasts produced by the WATFLOOD software are for' 
    write(98,*)'Info: information and discussion purposes only and are not to' 
    write(98,*)'Info: be relied upon in any particular situation without the' 
    write(98,*)'Info: express written consent of N. Kouwen or the' 
    write(98,*)'Info: University of Waterloo.'
      write(98,*)
          
!     rev. 10.2.38 Oct.  24/18  - NK: Added runReport.txt for forecast mode 
      if(.not.netCDFflg)then
        inquire(file='runReport.txt',EXIST=exists)
        if(exists)Then
         open(unit=99,file='runReport.txt',status='unknown') 
           If(exists)then
             do while(.not.eof(99))
               read(99,*,iostat=ios)line
             end do
           endif
           write(99,*)'CHARM.exe - normal ending'
           close(unit=99,status='keep')
         endif
      endif
      
!     save the CHARM.csv file for forecast statistical analysis 
      if(ni.gt.1)then
!       event_fln not allocated for one event run          
        if(event_fln(ni)(1:13).eq.'event\glb.evt')then
          call date_and_time(cday,time)
          write(line,99006)cday(1:4),cday(5:6),cday(7:8)
99006     format('copy results\CHARM.csv results\',a4,a2,a2,'_CHARM.csv') 
          print*
          print*,line(1:45)
          CALL execute_command_line(line(1:45))
          print*
        endif
      endif
      
!     stopflg is to keep the dos window open in WATFLOOD (VB)      
      if(stopflg.eq.'y')then
        print*,' normal ending'
        PAUSE ' Hit enter to exit window'
        print*
        stop 
      else
        print*,'Please see debug\warnings.txt for messages'
        print*
        stop ' normal ending'
      endif



! FORMATS

 1000 format(' ',2(' ',a30))
 1001 format(39x,32a1)
 1002 format(' ','key = ',i10)
 1003 format(' ',33a1)
 1030 format(' ','Unit no. =',i3,' file no',i3,' = ',a30)
 1050 format(26x,a30)
 3000 format(a5,7i5,25x,f10.0)
 3001 format(a20,i12)
 3010 format(a1,a79)
 5001 format(a30)
 5002 format(/' output files')
 5003 format(' opened unit',i5,' file name ',a30)
 5004 format(i10,a30)
 5006 format(/' Output file names ')
 5007 format(' runtime & date ',2a20)
 5008 format(' closed unit',i5,' file name ',a30)
 6001 format(' CHARM7: iopt=',i5,' itype=',i5)
 6040 format(' .met file not found. run radmet or ragmet again')
 6010 format(12i5)
 6011 format(1x,'*      ver=',2a10,'          *',2x,a30)
 6015 format(' runtime  ',a2,':',a2,':',a2,2x,a4,'-',a2,'-',a2)
! 6015 format(' runtime ',2(i2,':'),i2,2x,2(i2,'/'),i4)
 6016 format(a10,'  runtime    ',2(a2,':'),a2)
 6017 format(a10,'  rundate  ',a4,'-',a2,'-',a2)
 9021 format(f10.0,f5.0,3i5)
 9804 format(a5,f10.0,a60)
 9805 format(a5,i10,a60)
99001 format('  0.0')
99002 format(i5,1x,a256)
99003 format(i1,5x,a50)
99004 format(i5)
99005 format(a3)

      END PROGRAM CHARM     
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      subroutine io_warning(unit_number,file_name,ios)


      use area_watflood
      implicit none

      integer  :: unit_number,ios
      character*256  :: file_name

      write(98,*)'Error: Problems on unit',unit_number
      write(98,*)'Error:  error in opening file name  '
      write(98,*)'Error: ',file_name(1:60)
      write(98,*)'Error: possible cause: existing file is read-only'
      write(98,*)'Error:     which happens if it is open by say excel'
      write(98,*)'Error:     or some other program'
      write(98,*)'Error: or folder does not exist    <<<'
      write(98,*)'Error: or file does not exist      <<<'
      write(98,*)'Error: or DISK does not exist      <<<'
      write(98,*)'Error: iostat code =',ios
      write(98,*)'Error: program aborted in io-warning.for (CHARM)  @1054'
      
      print*,'Problems on unit',unit_number
      print*,'Warning:'
      print*,' error in opening file name  '
      print*,file_name(1:60)
      print*,'possible cause: existing file is read-only'
      print*,'    which happens if it is open by say excel'
      print*,'    or some other program'
      print*,'or folder does not exist    <<<'
      print*,'or file does not exist      <<<'
      print*,'or DISK does not exist      <<<'
      Print*
      print*,'iostat code =',ios
      print*
 
      STOP 'program aborted in io-warning.for (CHARM)  @1054'


      end subroutine io_warning

      subroutine dds_options(dds_error)
      
!***********************************************************************
!    Copyright (C) 2003 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      

!     rev. 10.1.77 Apr.  17/17  - NK: Moved DDS err calcs to new dds_code s/r's
      
!     DDS only <<<
!     DDS only <<<
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     error calculation for dds with pre-emption for each event
      
      use area_watflood
      use areacg
      USE EF_module
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE
      
      integer    ::  i,j,k,l,n,ii,ios
!     DDS error functions
     	real*4    ::   log_qhyd,log_qinfl,log_mean_obs           
      real*4    ::   sum_swe
      real*4    ::   score
      real*4    ::   dds_penalty
      real*4    ::   temp_value,sum_sq_error,
     *               temp_value_sum,dds_error,
     *               error_2H,error_18O 
      CHARACTER(10) :: ctime
      CHARACTER(8)  :: cday

      data dds_penalty/1.0/
      
!       use abs(dds_flag) so it works for DDS & sensitivity runs
!     DDS only <<<
!     DDS only <<<
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     error calculation for dds with pre-emption for each event
!       use abs(dds_flag) so it works for DDS & sensitivity runs
      
c        if(dds_flag.eq.1.and.id.gt.idskip)then
      if(errflg.eq.1)then     ! weighted MSE          
!           calculate the mean squared error for each chosen station
            do l=1,no
              if(nopt(l).eq.1)then
	          sum_sq_error=0.0
                i=0
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
!                 note: qsyn -1 when not in watershed
!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
                    temp_value=(qhyd(l,k)-qsyn(l,k))
                    sum_sq_error=sum_sq_error+temp_value*temp_value
	              i=i+1
                  endif
                end do
	          if(i.gt.0)mse(l)=sum_sq_error*sta_weight(l)
	          dds_error=dds_error+mse(l)
              endif
            end do
            
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
		  ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
c              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1)then
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      temp_value=(qinfl(l,k)-qdwpr(l,k))
                      sum_sq_error=sum_sq_error+temp_value*temp_value
                      i=i+1
                    endif
                  end do
	          if(i.gt.0)mse(l)=sum_sq_error*sta_weight(l+no)
	          dds_error=dds_error+mse(l)
                endif
c              endif
            end do
            
      elseif(errflg.eq.2)then  ! unweighted SSE
            i=0
            do l=1,no
              if(nopt(l).eq.1)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
                    temp_value=(qhyd(l,k)-qsyn(l,k))
                    dds_error=dds_error+temp_value*temp_value
                    i=i+1
                  endif
                 end do
              endif
            end do
            
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
c              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1)then
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      temp_value=(qinfl(l,k)-qdwpr(l,k))
                      dds_error=dds_error+temp_value*temp_value
                      i=i+1
                    endif
                  end do
                endif
c              endif
            end do
            
      elseif(errflg.eq.3.or.errflg.eq.11)then  ! sse weighted with mean flow
!     rev. 10.1.89 May   25/17  - NK: Added errflg = 11 for isotope DDS
        
            do l=1,no
              if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
!     rev. 9.7.03  Jun.  24/10  - NK: normalized SSE with station Qmean**2
c                  sum_sq_error=sum_sq_error+(qhyd(l,k)-qsyn(l,k))**2/
c     *          			  mean_observed(l)/mean_observed(l)
                    temp_value=(qhyd(l,k)-qsyn(l,k))/mean_observed(l)
                    dds_error=dds_error+temp_value*temp_value
                  endif
                 end do
              endif
            end do
       
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            if(noresvi.gt.0)then
            do l=1,noresvi
c              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1.and.mean_observed(no+l).gt.0.0)then
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      temp_value=(qinfl(l,k)-qdwpr(l,k))
     *                 					/mean_observed(no+l)
                      dds_error=dds_error+temp_value*temp_value
                      i=i+1
                    endif
                  end do
                endif
c              endif
            end do
            endif
            
            
c!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
c            if(courseflg.and.id.eq.ni)then
c!             this is a big penalty!!            
c              write(949,*)'penalty',
c     *                   dds_error,swe_penalty,dds_error*swe_penalty
c              dds_error=dds_error*swe_penalty
c            endif
            
      elseif(errflg.eq.4)then  ! optimize on volume only

              do l=1,no
              if(nopt(l).eq.1)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
                    qhyd_sum(l)=qhyd_sum(l)+qhyd(l,k)
                    qsyn_sum(l)=qsyn_sum(l)+qsyn(l,k)
                    num_obs(l)=num_obs(l)+1
                  endif
                end do
              else
                qhyd_sum(l)=0.0
                qsyn_sum(l)=0.0
              endif
              end do

!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(nopti(l).eq.1)then
                do k=ktri,mhtot,ktri
                  if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                    qhyd_sum(no+l)=qhyd_sum(no+l)+qinfl(l,k)
                    qsyn_sum(no+l)=qsyn_sum(no+l)+qdwpr(l,k)
                    num_obs(no+l)=num_obs(no+l)+1
                  endif
                end do
              else
                qhyd_sum(no+l)=0.0
                qsyn_sum(no+l)=0.0
              endif
            end do

            if(id.eq.ni)then
              i=0
              do l=1,no+noresvi
!                last event              
                if(num_obs(l).gt.0)then
c	            dds_error=dds_error+
c     *	                ((qhyd_sum(l)-qsyn_sum(l))/float(num_obs(l)))**2
	            dds_error=dds_error+
     *	                (qhyd_sum(l)-qsyn_sum(l))**2
                  i=i+1
                endif
              end do

!     rev. 10.1.72 Mar.  20/17  - NK: Fixed bug in sub for error_flag = 4 
              if(i.gt.0)then 
                dds_error=sqrt(dds_error)/float(i)
              else
                  print*,'Error: no data to calculate an error'
                  print*,'Program paused in sub @ 4460'
                  pause 'hit enter to continue'
              endif
            endif

      elseif(errflg.eq.5)then  ! optimize on weighted volume Dv
            do l=1,no
              if(nopt(l).eq.1)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
                    qhyd_sum(l)=qhyd_sum(l)+qhyd(l,k)
                    qsyn_sum(l)=qsyn_sum(l)+qsyn(l,k)
                    num_obs(l)=num_obs(l)+1
                  endif
                end do
              else
                qhyd_sum(l)=0.0
                qsyn_sum(l)=0.0
              endif
            end do

!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(nopti(l).eq.1)then
                do k=ktri,mhtot,ktri
                  if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                    qhyd_sum(no+l)=(qhyd_sum(no+l)+qinfl(l,k))
                    qsyn_sum(no+l)=(qsyn_sum(no+l)+qdwpr(l,k))
                    num_obs(no+l)=num_obs(no+l)+1
                    i=i+1
                  endif
                end do
              else
                qhyd_sum(no+l)=0.0
                qsyn_sum(no+l)=0.0
              endif
            end do

            if(id.eq.ni)then
!             if in the last event:
              do l=1,no+noresvi
                if(num_obs(l).gt.0)then
                  qhyd_mean(l)=qhyd_sum(l)/num_obs(l)
                  qsyn_mean(l)=qsyn_sum(l)/num_obs(l)
                  temp_value=
     *               abs((qhyd_mean(l)-qsyn_mean(l)))/qhyd_mean(l)*100.0
	            dds_error=dds_error+temp_value
                endif
              end do
              dds_error=dds_error/float(no+noresvi)
            endif

      elseif(errflg.eq.6)then  ! Differences weighted with mean flow
            do l=1,no
              if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
!     rev. 9.7.03  Jun.  24/10  
                    dds_error=dds_error
     *                     +abs(qhyd(l,k)-qsyn(l,k))/mean_observed(l)
                  endif
                end do
              endif
            end do

!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(nopti(l).eq.1)then
                do k=ktri,mhtot,ktri
                  if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                    dds_error=dds_error
     *                   +abs(qhyd(l,k)-qdwpr(l,k))/mean_observed(no+l)
                  endif
                end do
              endif
            end do

      elseif(errflg.eq.7.or.errflg.eq.10.or.errflg.eq.12)then  ! Nash efficiency
            ii=0
            do l=1,no
	        if(inbsnflg(l).eq.1)then
                if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                  ii=ii+1
                  do k=kt,nl,kt
                    if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
                      sum_num(l)=sum_num(l)
     *        				  +(qhyd(l,k)-qsyn(l,k))**2
                      sum_den(l)=sum_den(l)
     *        				  +(qhyd(l,k)-mean_observed(l))**2
                      num_obs(l)=num_obs(l)+1
                    endif
                  end do
                endif
	        endif
            end do
           
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1.and.mean_observed(l+no).gt.0.0)then
                  ii=ii+1
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      sum_num(l+no)=sum_num(l+no)
     *         				  +(qinfl(l,k)-qdwpr(l,k))**2
                      sum_den(l+no)=sum_den(l+no)
     *        				  +(qinfl(l,k)-mean_observed(l+no))**2
                      num_obs(l+no)=num_obs(l+no)+1
                    endif
                  end do
                endif
              endif
            end do
            
            if(id.eq.ni)then
              ii=0
!             sum the errors            
              do l=1,no+noresvi
                if(num_obs(l).gt.nl/kt/2)then     ! need at least 1/2 of the record
	            ii=ii+1
	            dds_error=dds_error+sum_num(l)/sum_den(l)
                else
                  if(inbsnflg(l))then     ! need at least 1/2 of the record
                    print*,'WARNING'
                    print*,'Number of observed flows for location ',l
                    print*,'fewer than half the record length so no'
                    print*,'error is calculated for this station'
                    print*,'Check value1 flag in the str file is 1'
                  endif
                endif
              end do
              if(ii.gt.0)then
                  dds_error=dds_error/float(ii)
              endif
            endif
            
      elseif(errflg.eq.8)then  ! Nash for log(q)
            ii=0
            do l=1,no
              if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                ii=ii+1
	          log_mean_obs=log(mean_observed(l))
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.001.and.qsyn(l,k).gt.0.001)then
	              log_qhyd=log(qhyd(l,k))
                    sum_num(l)=sum_num(l)
     *        				  +(log_qhyd-log(qsyn(l,k)))**2
                    sum_den(l)=sum_den(l)
     *        				  +(log_qhyd-log_mean_obs)**2
                    num_obs(l)=num_obs(l)+1
                  endif
                end do
              endif
              if(num_obs(l).gt.nl/kt/2)then
	          dds_error=dds_error+sum_num(l)/sum_den(l)
              endif
            end do
           
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1.and.mean_observed(l+no).gt.0.0)then
                  ii=ii+1
	          log_mean_obs=log(mean_observed(l))
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      log_qinfl=log(qinfl(l,k))
                      sum_num(l+no)=sum_num(l+no)
     *         				  +(log_qinfl-log(qdwpr(l,k)))**2
                      sum_den(l+no)=sum_den(l+no)
     *        				  +(log_qinfl-mean_observed(l+no))**2
                      num_obs(l+no)=num_obs(l+no)+1
                    endif
                  end do
                endif
              endif
            end do
                            
            if(id.eq.ni)then
              ii=0
!             sum the errors            
              do l=1,no+noresvi
                if(num_obs(l).gt.nl/kt/2)then     ! need at least 1/2 of the record
	            ii=ii+1
	            dds_error=dds_error+sum_num(l)/sum_den(l)
                endif
              end do
              dds_error=dds_error/float(ii)
            endif
            
      elseif(errflg.eq.9)then  ! optimize on rms of event errors
!           first calculate event sums  
            do l=1,no+noresvi
              qhyd_sum(l)=0.0
              qsyn_sum(l)=0.0
              num_obs(l)=0
            end do
            do l=1,no
              if(nopt(l).eq.1)then
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.001.and.qsyn(l,k).gt.0.001)then
                    qhyd_sum(l)=qhyd_sum(l)+qhyd(l,k)
                    qsyn_sum(l)=qsyn_sum(l)+qsyn(l,k)
                    num_obs(l)=num_obs(l)+1
                  endif
                end do
              endif
!              store the values of each event mean 
              if(num_obs(l).gt.0)then           
                qhyd_mean_evt(l,id)=qhyd_sum(l)/num_obs(l)
                qsyn_mean_evt(l,id)=qsyn_sum(l)/num_obs(l)
              endif 
c      write(777,77777)id,l,nopt(l),num_obs(l),
c     *               qhyd_mean_evt(l,id),qsyn_mean_evt(l,id)
c77777 format(4i5,2f12.3)      
            end do
	      write(52,52001)id,(l,num_obs(l),
     *               qhyd_mean_evt(l,id),qsyn_mean_evt(l,id),l=1,no)
52001       format(i5,<l>(2i10,2f10.3))
            write(52,*)'~~~~~~~~~~~~~~~~~~~~~~~~~~'  
            if(id.eq.ni)then
!             we're done & calculate rms of event errors  
	        temp_value_sum=0.0
              do i=1,ni 
                temp_value=0.0         
                do l=1,no
                  if(nopt(l).eq.1)then
                    temp_value=
     *                 (qhyd_mean_evt(l,i)-qsyn_mean_evt(l,i))**2
     *                        /(mean_observed(l)*mean_observed(l))   
	              if(temp_value.gt.10)then
                      print*,'for event=',i,'sta=',l,
     *                   'probable bad data ignored!!!'
	              else
                      temp_value_sum=temp_value_sum+temp_value
	              endif
	              write(52,*)
	              write(52,*)
                    write(52,*)i,l,'temp_value=',
     *                               temp_value,temp_value_sum
                  endif
                end do
                dds_error=dds_error+temp_value_sum
              end do
            endif
            write(52,*)dds_error
            dds_error=sqrt(dds_error/float(no))/float(ni)
            write(52,*)'sqrt',dds_error
            write(52,*)'______________________________________________'

	    
!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
      elseif(errflg.eq.100)then  ! TH: Trying isotopes + Nash efficiency
            ii=0
            do l=1,no
	        if(inbsnflg(l).eq.1)then
                if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                  ii=ii+1
                  do k=kt,nl,kt
                    if(qhyd(l,k).gt.0.0000.and.qsyn(l,k).gt.0.0000)then
                      sum_num(l)=sum_num(l)
     *        				  +(qhyd(l,k)-qsyn(l,k))**2
                      sum_den(l)=sum_den(l)
     *        				  +(qhyd(l,k)-mean_observed(l))**2
                      num_obs(l)=num_obs(l)+1
                    endif
                  end do
                endif
	        endif
            end do
           
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
            do l=1,noresvi
              if(inbsnflg(l+no).eq.1)then
                if(nopti(l).eq.1.and.mean_observed(l+no).gt.0.0)then
                  ii=ii+1
                  do k=ktri,mhtot,ktri
                    if(qinfl(l,k).gt.0.0.and.qdwpr(l,k).gt.0.0)then
                      sum_num(l+no)=sum_num(l+no)
     *         				  +(qinfl(l,k)-qdwpr(l,k))**2
                      sum_den(l+no)=sum_den(l+no)
     *        				  +(qinfl(l,k)-mean_observed(l+no))**2
                      num_obs(l+no)=num_obs(l+no)+1
                    endif
                  end do
                endif
              endif
            end do

            if(id.eq.ni)then
              ii=0
!             sum the errors            
              do l=1,no+noresvi
                if(num_obs(l).gt.nl/kt/2)then     ! need at least 1/2 of the record
	            ii=ii+1
	            dds_error=dds_error+sum_num(l)/sum_den(l)
                endif
              end do
              dds_error=dds_error/float(ii)/5.
              ii=0
              do l=1,n18O
                if(iso_n_18O(l).gt.0)then
                  ii=ii+1
                  temp_value=temp_value+iso_rms_18O(l)/
     *                     (abs(iso_sumO_18O(l))/iso_n_18O(l))
                  if(flg2H.eq.2)temp_value=temp_value+iso_rms_2H(l)/
     *                     (abs(iso_sumO_2H(l))/iso_n_2H(l)) 
                endif
              end do
              if(flg2H.eq.2)then
                dds_error=dds_error+temp_value/2./float(ii)
              else
                dds_error=dds_error+temp_value/float(ii)
              endif
            endif

      else
            print*
            print*,'No error function specified'
            pause 'hit return & then "ctrl C"'
            stop 'Program aborted in sub @ 2824'
      endif
          
          
!     rev. 10.1.89 May   25/17  - NK: Added errflg = 11  for isotope DDS
!     rev. 10.1.91 May   25/17  - NK: Added errflg = 12 for isotope DDS
      if(errflg.eq.11.or.errflg.eq.12.and.id.eq.ni)then
!         add 2nd part of the objective function of isotope error
!         this is in conjunction with errflg = 3 & 7          
          temp_value_sum=0.0
          if(n18O.gt.0)then
              do j=1,n18O
                  temp_value_sum=temp_value_sum+iso_rms_18O(j)
              end do
              error_18O=temp_value_sum/float(n18O)
          endif  
              
          temp_value_sum=0.0
          if(n2H.gt.0)then
              do j=1,n2H
                  temp_value_sum=temp_value_sum+iso_rms_2H(j)
              end do
              error_2H=temp_value_sum/float(n2H)
          endif
          if(errflg.eq.11)then
              dds_error=dds_error*error_18O*error_2H
          elseif(errflg.eq.12)then
!             This puts a little more weight on Nash's e:
!             otherwise, not enough.              
              dds_error=dds_error*dds_error*error_18O*error_2H
          endif
      endif
          
!     rev. 9.8.14  Jan.  27/11  - NK: dds_penalty added for swe not to zero in summer
!         a penalty is assigned when swe does not go to zero each summer.
          dds_error=dds_error*dds_penalty

!         write progress to dds_log.txt
      if(dds_flag.eq.1)then
            call date_and_time(cday,ctime)
            write(30,30011)id,cday(1:4),cday(5:6),cday(7:8),
     *                 ctime(1:2),ctime(3:4),ctime(5:6),
     *                 dds_error,pre_emption_value
            write(*,30011)id,cday(1:4),cday(5:6),cday(7:8),
     *                 ctime(1:2),ctime(3:4),ctime(5:6),
     *                 dds_error,pre_emption_value
30011       format(i5,5x,a4,'-',a2,'-',a2,2x,2(a2,':'),a2,2e15.6)
      endif

!         check to see if program can be aborted it error > pre-emption value
!         no pre-emption for using Nash as the objective function
!         CAN ONLY BE USED FOR MONATOMICALLY INCREASING ERROR FUCTION!!!
      if(dds_flag.eq.1)then
          if(dds_error.gt.pre_emption_value.and.errflg.le.3)then
!           kill the run - write a large value to dds\function_out.txt
            open(unit=99,file='dds\function_out.txt',
     *          status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file  dds\function_out.txt'
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              print*,'or target directory does not exist'
              pause 'Program will abort with enter'
              stop 'Program aborted in sub.f @ 4216'
            endif
	      if(id.lt.ni)then
!             write a large error so it can't be confused by DDS for a low value
              write(99,*)dds_error*100.0
	      else
              write(99,*)dds_error
	      endif
            close(unit=99,status='keep')
!           if we get to the end of the event list, there is no pre-emption
            if(id.lt.ni)then
              print*,'Program snuffed due to pre-emption for DDS',id
            endif
            write(30,*)  !blank line between trials in dds_log.txt
!           stop here for DDS run when pre_empted
!           For sensitivity, keep going
            if(dds_flag.eq.1)stop 
          endif
      endif
        
      RETURN
          
      end subroutine dds_options

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      
          
      subroutine dds_uzs(score)
      
!     rev. 10.1.77 Apr.  17/17  - NK: Moved DDS err calcs to new dds_code s/r's
!     rev. 10.1.78 Apr.  17/17  - NK: New s/r dds_UZS to calculate low flow penalty
      
!     Subroutine to calculate the UZS index for dds penalty
!     to ensure flow = close to Qlz only for very low river flows
!     Written by NK  April 16/2017      
      
      use area_watflood
      USE EF_module
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer    ::  i,j,k,l,n,ii,count,count_total
      integer    ::  kk(99)
      real*4     ::  sum_sq_error,temp_value,score
      Real*4     ::  UZS_retn(9999),UZSindex(99)
      logical    ::  firstpass
      
      data firstpass/.true./
      
      if(firstpass)then
          do l=1,no
!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
              if(inbsnflg(l).eq.1)then    ! added nk Jan. 05/11
!             STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
                  nn(l)=s(iy(l),jx(l))
              else
!     rev. 9.8.18  Apr.  26/11  - NK: Added in-basin check in tracer4
                  nn(l)=-1
              endif
          end do
          count=0
          count_total=1
      endif
      
!     Calculate UZS/retn for each grid   
!     assume the grid areas small & large will average out to frac = 1
!     UZS_retn is a ratio of the average ratio UZS/retn       
      do n=1,naa
          UZS_retn(n)=0.0
          do ii=1,classcount-3
              UZS_retn(n)=UZS_retn(n)+
     *                    (uzs(n,ii)/retn(ii)*(1.0-sca(n,ii))+
     *                    uzsfs(n,ii)/retn(ii)*sca(n,ii))*
     *                    aclass(n,ii)
          end do
      end do
      
      do l=1,no
          kk(l)=0
          UZSindex(l)=0.0
      end do
      
      do n=1,naa
          j=xxx(n)
          i=yyy(n)
          l=nbasin(i,j)
          UZSindex(l)=UZSindex(l)+UZS_retn(n)
          kk(l)=kk(l)+1
      end do
      
      do l=1,no
          UZSindex(l)=UZSindex(l)/float(kk(l))
      end do
      
!     calculate the average GW concentration during the low flows      
      do l=1,no
          count_total=count_total+1
          if(nopt(l).eq.1.and.UZSindex(l).le.0.4)then   ! depleted UZS
c          if(UZSindex(l).le.0.3)then   ! depleted UZS
c              if(isoconcGW(nn(l),l).lt.0.80)count=count+1
              if(isoconcGW(nn(l),l).lt.0.70)count=count+1
          endif
      end do

      score=float(count)/float(count_total)*10.0
      
C     WRITE(799,*)score
C      write(799,79900)count,count_total,
C     *       (UZSindex(l),l=1,no),score,(isoconcGW(nn(l),l),l=1,no)
C79900 format(2i10,999f8.3)      
     
      firstpass=.false.
      
      return
      
      end subroutine dds_uzs
      
  subroutine disaggregate(jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
    
!    First coded March 2019 NK
!    This s/r is used for FEWS only
    
  use area_watflood
  implicit none
  save

  real,    dimension(:,:), allocatable :: unused,pLocal
  integer, dimension(:,:), allocatable :: no_hrs_precip

  integer :: nhdt,nh,n,i,j,jz,iAllocate
  logical :: firstpass
  
  data firstpass/.true./

  if(firstpass)then
      allocate(pLocal(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0) STOP'Error with allocation of pLocal in `disaggregate`'
      allocate(no_hrs_precip(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0) STOP'Error with allocation of no_hrs_precip in `disaggregate`'
      allocate(unused(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0) STOP'Error with allocation of unused in `disaggregate`'
  endif
  
! p(i,j) is the precip read from the input file but it is modified here
! for subsequent time steps  
  
    
!  if(mod((jz-1)/deltaT2,deltaT2).eq.0)then
  if(mod(jz+23,deltaT2).eq.0)then
    do i=1,ycount                                                                                              
        do j=1,xcount                                                                                             
            no_hrs_precip(i,j)=min(int(p(i,j)+1),24)  
            ! assumes 1 mm/hr and 24 hour data time step 
            ! time step to be obtained in read_pcp_nc from the precip file header
            pLocal(i,j)=p(i,j)                                                                                   
            unused(i,j)=p(i,j)  
            nhdt=0
        end do                                                                                                 
    end do  
!    write(777,*)'xx',pLocal(ycount/2,xcount/2)
  endif
  
  deltat=24
  
    nhdt=nhdt+1
    do i=1,ycount                                                                                             
      do j=1,xcount                                                                                          
        if(pLocal(i,j).le.0.0)then                                                                              
          p(i,j)=0.0                   
        elseif(pLocal(i,j).le.smearfactor)then                                                                  
          if(unused(i,j).ge.0.0)then                                                                       
           p(i,j)=unused(i,j)                                                                       
           unused(i,j)=0.0                                                                                 
          endif                                                                                            
        elseif(pLocal(i,j).le.deltaT2)then                                                                       
          if(unused(i,j).gt.0.000001)then                                                                  
            p(i,j)=amin1(smearfactor,unused(i,j))                                                   
            unused(i,j)=unused(i,j)-p(i,j)                                                          
          else                                                                                             
            p(i,j)=0.0                                                                              
          endif                                                                                            
        elseif(pLocal(i,j).gt.deltaT2)then                                                                       
          p(i,j)=pLocal(i,j)/deltaT2                                                                      
        else                                                                                               
          print*,'nhdt,i,j,pLocal(i,j)/',nhdt,i,j,pLocal(i,j)                                                        
          print*,'This should never happen!!!'                                                             
          stop                                                                                             
        endif                                                                                              
      end do                                                                                               
    end do         
    
 !   write(777,*)jz,mod(jz+23,deltaT2),unused(ycount/2,xcount/2),p(ycount/2,xcount/2)

  firstpass=.false.
    
  end subroutine disaggregate      subroutine errormsg(io_err,SYS_ERR,STAT,UNIT,cond)
      
!***********************************************************************
!    Copyright (C) 1987-2018 by Nicholas Kouwen  
         
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      

      integer         io_err,sys_err,stat,unit,cond


      write(98,98001)io_err,sys_err,cond,unit,stat

98001 format(' io_err = ',i2,' sys_err = ',i2,' cond =',i2,

     *            ' unit = ',i2,' stat =',i2)


      end subroutine errormsg
      SUBROUTINE etharg(mon,ju)
      
!***********************************************************************
!    Copyright (C) 1996 by Todd Neff  
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!***********************************************************************
! PROGRAM BY: Todd A.M. Neff,  MARCH 1996

! THIS SUBROUTINE CALCULATES HARGREAVES PET FOR EACH ELEMENT
! HARGREAVES EQUATION FROM A HANDBOOK OF HYDROLOGY
! - NOTE THAT THERE ARE SOME CHANGES - SEE ORIGINAL PAPER
!   REFERENCED IN MASc THESIS T.Neff 1996

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

! akt - reduction due to excessive humidity (>54%)

!***********************************************************************

      USE area_watflood
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      real*4 :: akt1,petn,dlta,dr,sindlta,cosdlta,tandlta,ws0,so0
      integer  :: mon,ju,n,ii

      if(hu(mon).lt.54)then
         akt = .125
      else
         akt = 0.035*(100.-hu(mon))**(1./3.)
      endif

c      n=1   
      call solar(ju,so0,naa/2)
!     since for the old etharg the solar angle was constant
!     in read_par_parser.f all solar sinlat,coslat & tanlat are set equal
!     for flgevp2=2.0
!     
      do n=1,naa
        if(tempv(n).ge.-5.)then
!         rh(n)=amin1(100.00,rh(n))
!         akt = 0.035*(100.00-rh(n))**.333
          petn=0.0075*so0*sqrt((diff(mon)*1.8))*(tempv(n)*1.8+32.)
     *                                     *akt/24.
        else
          petn=0.
        endif
        do ii=1,classcount
          pet(n,ii)=petn
        end do
      end do

c      write(590,59000)pet(nnprint,3),so0,diff(mon),tempv(nnprint),akt
c59000 format(99f12.3)      

      RETURN

      END SUBROUTINE etharg

!***********************************************************************
      SUBROUTINE solar(ju,so0,n)
!***********************************************************************

! THIS SUBROUTINE CALCULATES THE EXTRATERRESTRIAL SOLAR RADIATION
! TAKEN FROM THE HANDBOOK OF HYDROLOGY - CHAPTER 4

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

! ju is the Julian day
! phi is the latitude (+ve in the N. hemisphere)  << not used?
! ws is the sunset hour angle (radians)
! dr is the relative distance between the earth and the sun
! so is the solar radiation in equivalent water evaporation (mm/d)
!    so used to be in area_watflood but was renamed to so0
! dlta is the solar declination (radians)
! pi = re: circles

!***********************************************************************

      USE area_watflood
      implicit none

      real*4 :: akt1,petn,dlta,dr,sindlta,cosdlta,tandlta,ws0,so0
      integer  :: mon,ju,n,ii

      dlta=0.4093*sin(0.0172142*float(ju)-1.405)
      dr=1.0+0.033*cos(0.0172142*float(ju))
      sindlta=sin(dlta)
      cosdlta=cos(dlta)
      tandlta=sindlta/cosdlta
      ws0=acos(-tanlat(n)*tandlta)
      so0=15.392*dr*(ws0*sinlat(n)*sindlta+coslat(n)*cosdlta*sin(ws0))
!     The functions were subsripted and renamed to accomodata variable solar angles      

c	  write(811,9091)n,dlta,dr,sindlta,cosdlta,tandlta,
c     *             sinlat(n),coslat(n),tanlat(n),ws0,so0
c	  write(811,9091)n,tandlta,tanlat(n),-tandlta*tanlat(n),ws0
c9091    format(i6,12f12.4)

      RETURN

      END SUBROUTINE solar




      SUBROUTINE etharg_beta(mon,ju)
      
!***********************************************************************
!    Copyright (C) 2004 by Todd Neff and Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!***********************************************************************
! PROGRAM BY: Todd A.M. Neff,  MARCH 1996

! THIS SUBROUTINE CALCULATES HARGREAVES PET FOR EACH ELEMENT
! HARGREAVES EQUATION FROM A HANDBOOK OF HYDROLOGY
! - NOTE THAT THERE ARE SOME CHANGES - SEE ORIGINAL PAPER
!   REFERENCED IN MASc THESIS T.Neff 1996

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90
!     rev. 9.9.03  Dec.  15/13  - NK: Change to gridded latitude for etharg
!     rev. 9.9.04  Dec.  17/13  - NK: Change over to gridded clamate normals to diff

! akt - reduction due to excessive humidity (>54%)

!***********************************************************************

      USE area_watflood
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      real*4   :: akt1,petn,dlta,sindlta,cosdlta,tandlta,dr
      integer  :: mon,ju,n,ii,ju_last,iAllocateStatus
      logical  :: firstpass
      
      real*4, dimension(:), allocatable :: so,ws
      
      
      data ju_last/-999/
      data firstpass/.true./

c      if(firstpass)THEN
c        write(811,81100)'    n        dlta          dr     sindlta  
c     *     cosdlta     tandlta    sinlat(n)    coslat(n)    tanlat(n)   
c     *ws(n)       so(n)'
c      ENDIF
c81100 FORMAT(A126)

      if(.not.allocated(so))then
        allocate(so(na),ws(na),stat=iAllocateStatus)
        if (iAllocateStatus .ne. 0) STOP 
     *    '**Allocation failed for dr in etharg @ 32'
      endif

      if(hu(mon).lt.54)then
         akt = .125
      else
         akt = 0.035*(100.-hu(mon))**(1./3.)
      endif

c      call solar(ju)
! ju is the Julian day
! phi is the latitude (+ve in the N. hemisphere)  << not used?
! dlta is the solar declination (radians)
! dr is the relative distance between the earth and the sun
! ws is the sunset hour angle (radians)
! so is the solar radiation in equivalent water evaporation (mm/d)
! pi = re: circles
!     only need to do this once a day (NK)
      if(ju.ne.ju_last)then
        dlta=0.4093*sin(0.0172142*float(ju)-1.405)
        dr=1.0+0.033*cos(0.0172142*float(ju))
        sindlta=sin(dlta)
        cosdlta=cos(dlta)
        tandlta=sindlta/cosdlta
 
 !      Fix tanlat(n),coslat(n),sinlat(n)
 !      to get a value for each row in the map file
 !      can be done in the first pass
        
        do n=1,naa
          ws(n)=acos(-tanlat(n)*tandlta)
          so(n)=15.392*dr*
     *           (ws(n)*sinlat(n)*sindlta+coslat(n)*cosdlta*sin(ws(n)))
        end do
c        print*,ju
      endif
      
      
c      n=nnprint
c	  write(811,9091)n,dlta,dr,sindlta,cosdlta,tandlta,
c     *             sinlat(n),coslat(n),tanlat(n),ws(n),so(n)
c9091    format(i6,12f12.4)


      do n=1,naa
        if(tempv(n).ge.-5.)then
!         SB e-mail Jan. 03/14
!         Hargreaves & Samani 1985
!         ET0 = 0.0023(Tmax - Tmin)1/2(Tavg + 17.8)Ra 
!         Where ET is in mm/d, temps are in Celsius and radiation in mm/d. 

          if(dlyflg)then
            petn=0.0023*so(n)*sqrt(dly_diff(n))*(tempv(n)+17.8)/24.
          else
            petn=0.0023*so(n)*sqrt(diff(mon)*1.8)*(tempv(n)+17.8)/24.
          endif

c         if(n.eq.nnprint)print*,'h&S 1985',day_now,dly_diff(n)
c        if(n.eq.nnprint)print*,ju,mon,diff(mon),mean_dly_diff(n,mon),petn
        else
          petn=0.
        endif
c        if(n.eq.nnprint)print*,ju,ws(n),so(n),petn,tempv(n)
        do ii=1,classcount
          pet(n,ii)=petn
        end do
      end do
      
      ju_last=ju
      firstpass=.false.
     
      RETURN

      END SUBROUTINE etharg_beta

!***********************************************************************
c      SUBROUTINE solar(ju)
!***********************************************************************

! THIS SUBROUTINE CALCULATES THE EXTRATERRESTRIAL SOLAR RADIATION
! TAKEN FROM THE HANDBOOK OF HYDROLOGY - CHAPTER 4

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

! ju is the Julian day
! phi is the latitude (+ve in the N. hemisphere)  << not used?
! ws is the sunset hour angle (radians)
! dr is the relative distance between the earth and the sun
! so is the solar radiation in equivalent water evaporation (mm/d)
! dlta is the solar declination (radians)
! pi = re: circles

!***********************************************************************

c      USE area_watflood
c      implicit none

c      real*4 :: akt1,petn,dlta,dr,sindlta,cosdlta,tandlta,ws
c      integer  :: mon,ju,n,ii

c      dlta=0.4093*sin(0.0172142*float(ju)-1.405)
c      dr=1.0+0.033*cos(0.0172142*float(ju))
c      sindlta=sin(dlta)
c      cosdlta=cos(dlta)
c      tandlta=sindlta/cosdlta
c      ws=acos(-tanlat(n)*tandlta)
c      so=15.392*dr*(ws*sinlat*sindlta+coslat*cosdlta*sin(ws))

!	write(91,9091)dlta,dr,sindlta,cosdlta,tandlta,
!     *             sinlat,coslat,tanlat,ws,so
!9091  format(12f12.4)

c      RETURN

c      END SUBROUTINE solar




      SUBROUTINE etin(mon,jan,ju)
      
!***********************************************************************
!    Copyright (C) 1996 by Todd Neff  
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!***********************************************************************
! PROGRAM BY: Todd A.M. Neff,  MARCH 1996

! Organizes the calculation of PET and calculates the value of the 
! temperature constraint (fpet2) on PET 

!     REV. 8.25  - May.   22/97  -  changed calc for pet in etin 
!     REV. 8.99g - Feb.   7/2000 -  added ttoinit to init evaporation
!     REV. 9.00  - Mar.     2000 -  TS: CONVERTED TO FORTRAN 90 
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
!     rev. 9.9.68  Apr.  29/15  - NK: Fixed tto reset with resume

!***********************************************************************

      USE area_watflood
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer  :: ju,jan,n,ii,mon
      real*4   :: ddh
      character*1 :: firstpass   ! intermediate variable

      data firstpass/'y'/

!        DATA ittoflg/0/    moved to spl9

!     LOOP INITIALIZES THE DEGREE DAYS TTO(N)
!     see also soilinit
c      if(firstpass.eq.'y')then
      if(jan.eq.1)then   
        do n=1,naa   
          if(resumflg.ne.'y')then
            tto(n)=tton            ! tton set in the par file
	      if(ju.ge.90.and.ju.le.270.and.tton.lt.1.0
     *                   .and.n.eq.1)then
	        print*,'Run is started during the growing season and'
	        print*,'tton (in the par file) should be given some value'
              print*,'See manual sect. 2.4.2'
              print*
	        pause 'Hit enter to continue (in etin.for @ 43)'
            endif 
            ttomin(n)=1.0e+32
            ttomax(n)=-1.0e+32
!           SET DEFAULT VALUE FOR FPET2
!           WARNING WILL BE USED IF NOT ALTERED LATER  
            fpet2(n)=1.0
          endif
        end do
      endif

      if(ju.eq.1)then
!       reset the values on Jan.1 each year
        do n=1,naa   
!     rev. 9.9.68  Apr.  29/15  - NK: Fixed tto reset with resume
c          if(resumflg.ne.'y')then   ! take it out!!!! it still needs to ber reset
            tto(n)=0.0
            ttomin(n)=1.0e+32
            ttomax(n)=-1.0e+32

!           SET DEFAULT VALUE FOR FPET2
!           WARNING WILL BE USED IF NOT ALTERED LATER  
            fpet2(n)=1.0
c          endif
        end do
      endif
      
!     rev. 9.7.28  Jun.  14/11  - NK: Add degree_day for lake_ice_factor  dd_ice
      if(ju.eq.274)then
        do n=1,naa
          dd_ice(n)=0.0
        end do
      end if
      if(ju.eq.90)then
        do n=1,naa
          dd_thaw(n)=0.0
        end do
      end if


!     SETS THE FLAG TO RESTART THE ACCUMULATION OF DEGREE-DAYS
!     FROM THE START OF MARCH (MON=3)

!     MAXIMUM VALUE OF FPET2(n)=1.0

!     FLGTMP1 SHUTS OFF THE ACCUMULATION OF DEGREE-DAYS ONCE
!     THE CONSTRAINT REACHES A VALUE OF 1.  FPET2(n)=1

!     ACCUMULATES DEGREE DAYS (TTO(n)).  CALCULATES THE CONSTRAINT
!     FPET2(n) ON THE PET IN EACH ELEMENT

      do n=1,naa
         ddh=tempv(n)/24.
         tto(n)=tto(n)+ddh     !! ACUMMULATION OF DEGREE-DAYS
         dd_ice(n)=dd_ice(n)-ddh
         dd_thaw(n)=dd_thaw(n)+ddh
!           assumes it gets here hourly

         ttomin(n)=amin1(ttomin(n),tto(n))
         ttomax(n)=amax1(ttomin(n),tto(n))

!        CHECK FOR DIV BY 0      

!      fix fix   ttomin thing needs to be checked out
!                problems with a summer start -evap ramps up 
!                with degree day from start of run
!                degree days have accumulated before the start.

!         if(abs(tempa3-ttomin(n)).gt.0.1e-20)then
!          fpet2(n)=(tto(n)-ttomin(n))/(tempa3-ttomin(n))
!         endif

         fpet2(n)=(tto(n)-ttomin(n))/tempa3
!           seems ok. checked out nk  Jul.6/06
         fpet2(n)=amax1(0.02,fpet2(n))
         fpet2(n)=amin1(1.00,fpet2(n))
!        ITTOFLG WILL BE 0 IF TTOMIN NEVER FALLS BELOW TEMPA3
!        TEMPA3 SHOULD BE GIVEN A HIGHER VALUE (IN THE PAR FILE)
!        THIS LINE WAS COMMENTED OUT, I THINK IT SHOULD BE THERE FRANK S DEC/2000
         if(tempa3.gt.ttomin(n)) ittoflg=1
      end do

!     IF FLGEVP2=1 USE TABLE PET
!     IF FLGEVP2=2 USE HARGREAVES PET
!     IF FLGEVP2=3 USE PREISTLEY-TAYLOR PET
!     NOTE: PET = 0 IF TEMP < -5 DEG. C

      if(flgevp2.eq.1.)then

!        print*,' in etin calculating pan evap'
!        USE PAN EVAPORATION AS THE POT EVAP
         do ii=1,classcount
            do n=1,naa
               if(tempv(n).ge.-5.0)then
!                 non-water class
                  pet(n,ii)=evap(ii,mon)
                  fpet2(n)=1.0
               else
                  pet(n,ii)=0.
               endif
            end do
         end do
      elseif (flgevp2.eq.2.) then
!	   print*,' in etin calling etharg'
         call etharg(mon,ju)
!          water class use table for cold temperatures
      elseif (flgevp2.eq.4.) then
!	   print*,' in etin calling etharg'
         call etharg_beta(mon,ju)
!          water class use table for cold temperatures
      elseif (flgevp2.eq.3.) then
         call etpriest(mon)
         do n=1,naa
            do ii=1,classcount
!              TN: APRIL, 1997 
!              REV. 8.25 - May.  22/97 - CHANGED CALC FOR PET IN ETIN 
               pet(n,ii)=alb(ii)/albe*pet(n,ii)
            end do
         end do
      endif

      firstpass='n'

      RETURN

      END SUBROUTINE etin

      SUBROUTINE etpriest(mon)

      
!***********************************************************************
!    Copyright (C) 1996 by Todd Neff 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!***********************************************************************
! Program by: Todd A.M. Neff,  August 1996

! THIS SUBROUTINE CALCULATES PRIESTLY-TAYLOR PET FOR EACH ELEMENT &
! CALCULATES EVAPOTRANSPIRATION FROM PRIESTLY-TAYLOR EQUATION  
! ASCE MANUAL NO. 70 - REV. APRIL 1982 - PAGE 145

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

!  alamb      - lambda (eqn 7.1) - latent heat of vapourization
!  delt       - delta (slope of saturation vap press curve - eqn 7.12)
!  gam        - psychrometric constant (eqn 7.15)
!  petn       - Priestley-Taylor PET 
!  press(mon) - mean monthly pressure (kPa)
!  radv       - vectored mean hourly net radiation (W/sq.m.)

! NOTE: petn is adjusted based on the time increment
!  i.e. for 1 hour it is multiplied by 3.6 since there are 3600 seconds
!       per hour and is divided by 1000 to conserve units

!***********************************************************************

      USE area_watflood
      implicit none

      real*4   :: gam,delt,ddg,petn
      integer*4 :: n,ii,mon

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

! adjust alpha throughout the year, just for mackrpn
! Jan, Feb, March =0.0, April=0.6, May=1.2,
! June,July,August=1.35, Sept=1.2, Oct=0.6, Nov,Dec=0.0

      alpha=0.942857+0.00285714*real(mon)**4-0.08*real(mon)**3+
     +0.682857*real(mon)**2-1.72*real(mon)
      alpha=max(0.0,alpha)
      alpha=min(1.35,alpha)
      gam=.001013/0.622*pres(mon)/alamb

      do n=1,naa

         if(tempv(n).ge.-5)then
            delt=25083./(tempv(n)+237.3)**2*exp
     *          (17.3*tempv(n)/(tempv(n)+237.3))
            ddg=delt/(delt+gam)
            petn=alpha*ddg*radv(n)/alamb/den*3.6
         else
            petn=0
         endif

c      if(n.eq.1152) print *, ddg,den

         if(petn.lt.0) petn=0

         do ii=1,classcount
            pet(n,ii)=petn
         end do

      end do

      RETURN

      END SUBROUTINE etpriest
      SUBROUTINE header()
      
!***********************************************************************
!    Copyright (C) 1987-2018 by Nicholas Kouwen 
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    This WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      

!********************************************************************

!       THIS SUBROUTINE PRINTS THE BANNER FOR PROGRAM CHARM

!********************************************************************
!     rev. 9.9.54  Jan.  19/15  - NK: Put par & shd file names for 1st event in the headers

      USE area_watflood
      implicit none

      CHARACTER(10) :: time
      CHARACTER(8)  :: cday
      integer  :: n,i,j,iset,istep2,l,ktt,k,ktemp,iasdf,ios,noread
     *             ,nnx
      real*4   :: datemp,qdagrd,qinit

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      if(abs(dds_flag).ne.1)then
      
!  THIS SECTION GETS THE COMPUTER'S DATE AND TIME
!  THIS INFO USED TO COME FROM HEADER.FI, HOWEVER F90 INTRINSICS
!  AND CALLS ARE DIFFERENT AND THEREFORE IT NEEDED TO BE MODFIED.
       call date_and_time(cday,time)
       
        write(6,6001)
        write(6,6002)
        write(6,6003)
        write(6,6004) 
        write(6,6005) 
        write(6,6006) 
        write(6,6007) 
        write(6,6008) 
        write(6,6009) 
        write(6,6002)
        write(6,6001)

      if(modelflg.eq.'r'.or.modelflg.eq.'l'.or.modelflg.eq.'i')then
        write(6,7001)
        write(6,7002)
        write(6,7003)
        write(6,7004) shd_fln    ! writes the name from event #1
        write(6,7005) par_fln    ! writes the name from event #1
        write(6,7006) fln(3)
        write(6,7007) fln(4)
        write(6,7008) fln(6)
        write(6,7009) fln(7)
        write(6,6010)program_version,program_date,fln(8)
        write(51,6017)
        write(51,6010) ! write version number to the simout/spl.txt file
        write(51,6017)
! NOTE: FORMATS 6011/6012 NEEDED TO BE MODIFIED TO CHARACTER TYPES FROM
!       INTEGERS FOR NEW INTRINSIC.  IF THIS DOESN'T WORK, USE VALUES
!       ARRAY FROM INTRINSIC.
        write(6,7011) time(1:2),time(3:4),time(5:6)   !,fln(10)
        write(6,7012) cday(1:4),cday(5:6),cday(7:8)   !,fln(13)
        write(6,7019) ! fln(15)
        write(6,7013) iopt,snwflg,sedflg,vapflg,smrflg,resinflg,
     *              tbcflg,resumflg,contflg,routeflg,crseflg,
     *              ensimflg,picflg,wetflg,modelflg,shdflg,trcflg,
     *              fln(19)
        write(6,7018) itype,fln(20)
        write(6,7020) fln(21)     
        write(6,7014) 
        write(6,7015) 
        write(6,7016) 
        write(6,7020) 
        write(6,7001) 
        write(6,7017)
      else

        write(6,6051)
        write(6,6052)
        write(6,6053)
        write(6,6054) 
        write(6,6055) 
        write(6,6056) 
        write(6,6057) 
        write(6,6058) 
        write(6,6059) 
        write(6,6052)
        write(6,6051)
        write(6,6060)
        write(6,*)
        write(6,6021)
        write(6,6020)

c
c        write(6,6020)fln(20)
c	  write(6,6022)



! NOTE: FORMATS 6011/6012 NEEDED TO BE MODIFIED TO CHARACTER TYPES FROM
!       INTEGERS FOR NEW INTRINSIC.  IF THIS DOESN'T WORK, USE VALUES
!       ARRAY FROM INTRINSIC.
        write(6,6010)program_version,program_date,shd_fln
        write(6,6011) time(1:2),time(3:4),time(5:6),par_fln
        write(6,6012) cday(1:4),cday(5:6),cday(7:8),fln(3)
        write(6,6019) fln(13)
        write(6,6013) iopt,snwflg,sedflg,vapflg,smrflg,resinflg,
     *              tbcflg,resumflg,contflg,routeflg,crseflg,
     *              ensimflg,picflg,wetflg,modelflg,shdflg,trcflg,
     *              frcflg,initflg,
     *              fln(6)  
        write(6,6018) itype,fln(7)
        
        write(6,6020)fln(36)     
        write(6,6014)fln(8) 
        write(6,6020)fln(10) 
        write(6,6015)fln(15) 
        write(6,6016)fln(62) 
        write(6,6020)fln(20)
        write(6,6025)
        write(6,6022)fln(21)
        write(6,6023)
        write(6,6024)
        write(6,6020)
        write(6,6021)
        write(6,6017)
        
      endif

!     TS - ADDED WATFLOOD WETLAND HEADER MESSAGE:
      if(wetflg.eq.'y'.or.ensimflg.eq.'y'.or.trcflg.eq.'y'.
     *     or.sedflg.eq.'y'.or.frcflg.eq.'y')then
!        print*
	  print*,'******************************************'
      endif

d     print*,'*      >>>>>>DEBUG MODE<<<<<<            *'

      if(ensimflg.eq.'y')then
        if(int(totaltime).gt.ireport_start
     *            .and.int(totaltime).le.ireport_end)then
           print*,'*    Writing a WATFLOOD.WFO file         *'
        endif
	  if(id.eq.1)then  !totaltime not yet defined
           print*,'*    Writing a WATFLOOD.WFO file         *'
        endif
      endif
      
      if(modelflg.eq.'n')then
        if(wetflg.eq.'y')then
          print*,'*      RUNNING WATFLOOD WETLAND          *'
        endif
        if(ruleflg)then
          print*,'*      USING LAKE TARGET LEVELS          *'
        endif
c        if(dlyflg)then
        if(flgevp2.eq.4)then
          print*,'*   RUNNING w/daily temp. differences    *'
        endif
        if(lakeflg.eq.'y')then
          print*,'*    RUNNING WATFLOOD Lake Evapn.        *'
        endif
        if(sedflg.eq.'y')then
          print*,'*      RUNNING WATFLOOD QUALITY          *'
        endif
        if(trcflg.eq.'y')then
          print*,'*    RUNNING WATFLOOD VIRTUAL TRACER      *'
          print*,'*    Tracer ',itrace, '                *'
        endif
        if(frcflg.eq.'y')then
          print*,'*    RUNNING ISOTOPE FRACTIONATION       *'
        endif
        if(ntrlflg.eq.'y')then
          print*,'*      RUNNING WITH NATURAL FLOWS        *'
        endif
!     rev. 10.1.44 Dec.  02/15  - NK: Reworked icerivflg & icelakeflg
        if(iceflg.eq.'y')then
          print*,'*  river ice effects enabled  (iceflg=y) *'
        endif
!     rev. 10.1.44 Dec.  02/15  - NK: Reworked icerivflg & icelakeflg
        if(icerivflg.eq.'y')then
          print*,'* river ice effects enabled (icerivflg=y)*'
        endif
        if(icelakeflg.eq.'y')then
          print*,'* lake ice effects enabled (icerivflg=y) *'
        endif
	endif
      if(wetflg.eq.'y'.or.ensimflg.eq.'y'.or.trcflg.eq.'y'.
     *     or.sedflg.eq.'y'.or.frcflg.eq.'y')then
        print*,'******************************************'
!	  print*
      endif
! FORMATSsplx
      
      elseif(id.eq.1)then
          
        write(6,6051)
        write(6,6010)program_version,program_date,shd_fln
        write(6,6051)
          
      endif

 6051 format(1x,'*************^^**********************************')
 6052 format(1x,'*                                               *')
 6053 format(1x,'*    cccc  hh   hh     a     rrrrr  mmm   mmm(R)*')
 6054 format(1x,'*   cc  cc hh   hh    aaa    rr  rr mmmm mmmm   *')  
 6055 format(1x,'*   cc     hh   hh   aa aa   rr  rr mm mmm mm   *')
 6056 format(1x,'*   cc     hhhhhhh  aa   aa  rrrrr  mm  m  mm   *')
 6057 format(1x,'*   cc     hh   hh  aaaaaaa  rrrrr  mm     mm   *')
 6058 format(1x,'*   cc  cc hh   hh aa     aa rr  rr mm     mm   *')
 6059 format(1x,'*    cccc  hh   hh aa     aa rr  rr mm     mm   *')
 6060 format(1x,'     Canadian Hydrological And Routing Model')




 1000 format(' ',3(2a30/))
 6001 format(1x,'*******************************************************
     ***********************')
 6002 format(1x,'*                                                      
     *                     *')
 6003 format(1x,'*  ww  ww         ww  a    tttttttt ffffff ll       ooo
     *      ooo    ddddd   *')
 6004 format(1x,'*   ww  ww       ww  aaa   tttttttt ffffff ll      oooo
     *o    ooooo   dddddd  *')
 6005 format(1x,'*    ww  ww     ww  aa aa     tt    ff     ll     oo   
     *oo  oo   oo  dd   dd *')
 6006 format(1x,'*     ww  ww   ww  aaa aaa    tt    ffff   ll     oo   
     *oo  oo   oo  dd   dd *')
 6007 format(1x,'*      ww  ww ww  aaaaaaaaa   tt    ffff   ll     oo   
     *oo  oo   oo  dd   dd *')
 6008 format(1x,'*       ww  www  aa       aa  tt    ff     llllll  oooo
     *o    ooooo   dddddd  *')
 6009 format(1x,'*        ww  w  aa         aa tt    ff     llllll   ooo
     *      ooo    ddddd   *')
 6010 format(1x,'*      ver=',2a10,'          *',2x,a30)
 6011 format(1x,'*      runtime    ',2(a2,':'),a2,15x,'*',2x,a31)
 6012 format(1x,'*      rundate  ',a4,'-',a2,'-',a2,15x,'*',2x,a30)
 6019 format(1x,'*                                        *',2x,a30)
 6013 format(1x,'*   debug level  ',i2,1x,18a1,    2x' *',2x,a30)
 6018 format(1x,'*   channel type ',i2,' 123456789012345678   *',2x,a30)
 6014 format(1x,'*             WATFLOOD(R)                *',2x,a30)
 6015 format(1x,'*    copyright (c) by n kouwen 1985-2018 *',2x,a30)
 6016 format(1x,'*    university of waterloo,  canada     *',2x,a30)
 6017 format(' ')
 6025 format(1x,'*              Written for               *',2x,a30)
 6022 format(1x,'*   E N V I R O N M E N T  C A N A D A   *',2x,a30)
 6023 format(1x,'*       Open source code under the       *')
 6024 format(1x,'*    GNU Lesser General Public License   *')
 6020 format(1x,'*                                        *',2x,a30)
 6021 format(1x,'******************************************',2x,a30)


 7001 format(1x,'******************************************',2x,a30)
 7002 format(1x,'*                                        * files used')
 7003 format(1x,'*   RRRRRR   TTTTTTTT EEEEEE    999999   *')
 7004 format(1x,'*   RR    R     TT    EE       99    99  *',2x,a30)
 7005 format(1x,'*   RR    R     TT    EE       99    99  *',2x,a30)
 7006 format(1x,'*   RRRRRR      TT    EEEE      9999999  *',2x,a30)
 7007 format(1x,'*   RR  RR      TT    EE             99  *',2x,a30)
 7008 format(1x,'*   RR   RR     TT    EE             99  *',2x,a30)
 7009 format(1x,'*   RR    R     TT    EEEEEEE   999999   *',2x,a30)
!7010 format(1x,'*      ver=x.x.xx   xxx. xx/xx           *',2x,a30)
 7011 format(1x,'*      runtime    ',2(a2,':'),a2,15x,'*',2x,a31)
 7012 format(1x,'*      rundate  ',a4,'-',a2,'-',a2,15x,'*',2x,a30)
 7019 format(1x,'*                                        *',2x,a30)
 7013 format(1x,'*     debug level  ',i2,1x,16a1,    2x' *',2x,a30)
 7018 format(1x,'*     channel type ',i2,' 1234567890123456   *',1x,a30)
 7014 format(1x,'*    copyright (c) by n kouwen 1985-2016 *',2x,a30)
 7015 format(1x,'*    department of civil engineering     *',2x,a30)
 7016 format(1x,'*    university of waterloo,  canada     *',2x,a30)
 7017 format(' ')
 7020 format(1x,'*                                        *',2x,a30)

      RETURN

      END SUBROUTINE header
      SUBROUTINE ice_factor

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f

      use area_watflood
      implicit none

      integer     :: i,j,l,n,jz
      logical     :: firstpass

      data firstpass/.true./

!     ice_factor is called if icerivflg and/or icelakeflg = y

!     rev. 10.1.07 Dec.  02/15  - NK: Added ice_fctr(n) to route 
!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!     the equations were taken from the Lake Winnipeg model
      if(firstpass.eq.'y')then
!     rev. 10.3.03 Jan.  21/20  = NK added dd_ice & dd_thaw to the resume.txt file      
          if(resumflg.ne.'y')then
!             initialize the  ice factor
              do n=1,naa
                  dd_ice(n)=1000
                  dd_thaw(n)=0.0
              end do
          endif
!     REV. 10.1.19 Jan.  15/16  - NK: Fixed initialization of ice_factr - moved from lake_ice > runof6
c!       default ice_fctr        
c        do n=1,naa
c          ice_fctr(n)=1.0
c        end do
        open(unit=549,file='ice_factor.txt',status='unknown')
        firstpass=.false.
      endif
      
!       Calculate the ice factors for eacg grid
!       needed only once a day      
        if(jul_day_now.gt.275.or.jul_day_now.lt.91)then     
!         fall freeze up & winter           
          do n=1,naa
              if(dd_ice(n).gt.0.0)then
!               dd_ice (freezing degree days) must be +ve   
!               equation for Waterhen:       
!               lif=3.0981177*dd_ice(n)**-0.3324723
                ice_fctr(n)=3.7222496*dd_ice(n)**-0.4
!               in the winter is should not be less than 0.25
                ice_fctr(n)=amax1(0.25,ice_fctr(n))
!               and should never be larger than 1.0
                ice_fctr(n)=amin1(1.0,ice_fctr(n))
              endif
          end do
        else  !spring thaw & summer
          do n=1,naa
              if(dd_thaw(n).gt.0.0)then
!               taken from Lake Winnipeg              
c               ice_fctr(n)=1.0/(3.7222496*dd_thaw(n)**-0.2747330)
                ice_fctr(n)=1.0/(3.7222496*dd_thaw(n)**-.3)
!               in the winter is should not be less than 0.25
                ice_fctr(n)=amax1(0.25,ice_fctr(n))
!               in the summer it should not be more than 1.0
                ice_fctr(n)=amin1(1.0,ice_fctr(n))
c              else
c                ice_fctr(n)=1.0
              endif
c            endif
          end do  ! NOTE: ice_fctr written in rte.txt fln(55)
       endif
      
!     rev. 10.1.44 Dec.  02/15  - NK: Reworked icerivflg & icelakeflg
      if(.not.icefactorfile)then
        if(icelakeflg.eq.'y')then
!         ice factors for lakes if the resrl\ice_factor.tb0 
!         file does NOT exists 
          do l=1,noresv
            i=ires(l)
            j=jres(l)
            n=s(i,j)
!           lake ice factor should probably not be less than 0.50
            lake_ice_factor(l,month_now)=amax1(0.90,ice_fctr(n))
          end do
c          print*,'lake ice factors are computed'
        endif
      endif

      
      end subroutine ice_factor
        SUBROUTINE intcept(mon)

!***********************************************************************
!    Copyright (C) 1996 Todd Neff and Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
      
!***********************************************************************
! PROGRAM BY: Todd A.M. Neff,  MARCH 1996

! Subprogram intcept.f for the Watflood program runof5.f
! calculates ineterception v(n,ii);interception evaporation intev(n,ii);
! throughfall r(n,ii).  Based on Linsley's equation

!     REV. 8.6   - Oct.  28/97  -  replaced todd's incept routine 
!     REV. 9.00  - Mar.   2000  -  TS: CONVERTED TO FORTRAN 90
!     rev. 9.2.37  Mar.  31/06  - NK: Removed impervious area as special class
!     rev. 9.9.26  Sep.  18/14  - NK: Added zero class bypass in intcept.f


!  vo           - interception storage during the last time step
!  ssumr        - sum of rain so far - used for plotting only
!  pint(n,ii)   -  the sum of intercepted rain
!  v(n,ii)      -  water in interception storage
!  intev(n,ii)  -  interception evaporation this time step
!  intevt(n,ii) -  the sum of intev
!  flint(ii)    -  an interception flag om the param file

!***********************************************************************

      USE area_watflood

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      implicit none
      SAVE

c      REAL*4 :: pint(17500,99),deficit(99)
!      moved to area_watflood & allocated

      integer  :: n,i,j,ii,mon


d     if(iopt.eq.2)print*,'in intcept @ 35'

      do n=1,naa
        i=yyy(n)
        j=xxx(n)
        do ii=1,classcount
!     rev. 9.9.26  Sep.  18/14  - NK: Added zero class bypass in intcept.f
        if(aclass(n,ii).gt.0.0)then   ! skip if class area = 0.0

!       NOTE: classcount IS THE WATER CLASS AND IS DONE BELOW

!!!!!!! FIX THIS BOTH IF'S DO THE SAME THING !!!!!!!

         if(flint(ii).gt.0.9999)then
!           FLINT IS SET IN THE PARAM FILE
            if(h(mon,ii).gt.0.0)then
!              INT EVAP IS INCREASED BY FPET FOR ALL VEGETATION   
!              BECAUSE OF THE INCREASED ROUGHNESS AND ADVECTION
!              FIRST CHECK THAT PRECIP OCCURS
               if(p(i,j).gt.0.0)then
!                 DURING PRECIP EVENT THERE IS NO EVAPORATION FROM 
!                 THE LEAVES; WATER IS ADDED TO INTERCEPTION STORAGE 
!                 TO THE MAX INTERCEPTION STORAGE AND THE REMAINDER 
!                 REACHES THE GROUND...WE CAN DO AN EITHER-OR

!				This is different from what Todd has inhis thesis 
!                 which states that during precip the int. evaporation 
!                 occurs at the pet rate. But nk figures that pet=0.0
!                 during rain.

                  deficit(ii)=h(mon,ii)-v(n,ii)
                  if(p(i,j).ge.deficit(ii))then
!                    PRECIP IS GREATER THAN REMAINING INTERCEPTION 
!                    DEFICIT AND INTERCEPTION IS MAXED OUT
!                    THRUFALL IS PRECIP - INTERCEPTED WATER 
                     pint(n,ii)=pint(n,ii)+deficit(ii)
!                    CALCULATE THRUFALL   
                     r(n,ii)=p(i,j)-deficit(ii)
                     v(n,ii)=v(n,ii)+deficit(ii)
                     intev(n,ii)=0.0
                  else
!                    PRECIP IS LESS THAN INTERCEPTION DEFICIT 
!                    AND ALL PRECIP IS ADDED TO INTERCEPTION STORAGE
                     pint(n,ii)=pint(n,ii)+p(i,j)
                     r(n,ii)=0.0
                     v(n,ii)=v(n,ii)+p(i,j)
                     intev(n,ii)=0.0
                  endif

               else

!                 ELSE, NO RAIN OCCURS - NO WATER REACHES THE GROUND
!                 THIS IS THE SAME FOR BARE & SNOW COVERED AREAS
                  r(n,ii)=0.0

!                 IF THERE IS WATER IN INTERCEPTION STORAGE THEN 
!                 EVAPORATE IT AT FPET TIMES THE POTENTIAL RATE UNTIL
!                 THERE IS NONE.  RECALCULATE LINSLEY CONSTANT BASED ON
!                 CURRENT AMOUNT OF STORAGE.

                  if(v(n,ii).gt.0.0)then
!                    THERE IS WATER TO EVAP AT FPET TIMES THE POT RATE
                     if(fpet(ii)*pet(n,ii).gt.v(n,ii))then
!                       ALL WATER IN INT STORAGE WILL BE EVAPORATED 
                        intev(n,ii)=v(n,ii)
                        v(n,ii)=0.0
!                       PET IS REDUCED BY THIS AMOUNT FOR NEXT CALC
!                       FOR CALCULATING EVAP FROM SOIL IN AET.FOR
                     else
!                       NOT ALL WATER IN INT STORAGE WILL BE EVAPORATED
                        intev(n,ii)=fpet(ii)*pet(n,ii)
!                       AND INTERCEPTION STORAGE IS REDUCED BY
                        v(n,ii)=v(n,ii)-intev(n,ii)
                     endif
                  else
!                    THERE IS NO WATER IN INTERCEPTION STORAGE
                     intev(n,ii)=0.
                  endif
               endif

               intevt(n,ii)=intevt(n,ii)+intev(n,ii)

               sum_et(n,ii)=sum_et(n,ii)+intev(n,ii)

!              LOSS IS FROM BARE & SNOW COVERED AREA ALIKE
               eloss(n)=eloss(n)+intev(n,ii)*aclass(n,ii)
               if(pint(n,ii).lt.0.)     pint(n,ii)=0.
               if(v(n,ii).lt.0.)        v(n,ii)=0.
               if(v(n,ii).gt.h(mon,ii)) v(n,ii)=h(mon,ii)
               if(intev(n,ii).lt.0.)    intev(n,ii)=0.
               vo(n,ii)=v(n,ii)
               ssumr(n,ii)=ssumr(n,ii)+r(n,ii)
           endif

          else
!           IF FLINT EQ 0:
!           NO INTERCEPTION IS CALCULATED (eg. WATER, GLACIERS)
            intev(n,ii)=0.
            intevt(n,ii)=intevt(n,ii)+intev(n,ii)
            r(n,ii)=p(i,j)

!           REV. I ADDED THIS HERE - NK: JAN 29/97
            ssumr(n,ii)=ssumr(n,ii)+r(n,ii)
          endif

c          if(iopt.ge.1)then
c	      if(n.eq.nnprint.and.ii.eq.iiprint)then
c	       write(64,6401)n,ii,p(i,j),v(n,ii),deficit(ii),pint(n,ii),
c     *         r(n,ii),intev(n,ii),intevt(n,ii)
c6401         format(2i5,7e12.4)
c	      endif
c          endif

        endif  !  aclass()>0
        end do

!     rev. 9.2.37  Mar.  31/06  - NK: Removed impervious area as special class
        r(n,classcount)=p(i,j)   !impervious area
        intev(n,classcount)=0.0
        v(n,classcount)=0.0

      end do
d     if(iopt.eq.2)print*,'in intcept @ 155'

      RETURN

      END SUBROUTINE intcept


       SUBROUTINE lake_evap
!***********************************************************************
!    Copyright (C) 1987 by Tegan Holmes and Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  Written by: Tegan Holmes 
!  With initial work by: Phil Slota, March 2013
!       internal revisions:
!          1.0 running
!          2.0 unit conversions, heat flux, net rad v2
!          2.1 solar rad, evap shut down in rain, water T alpha, ice cover
!          2.2 lake depth read-in created
!          3.0 Cleaned out fossil code
!     	   4.0 Removed wind and Granger
!
!  alamb - lambda - latent heat of vapourization
!  delt - delta (slope of saturation vap press curve)
!  gam - psychrometric constant
!  strloss(n) - Evaporation for lakes in cms
!  tempv(n) vectorized air temperature (deg C) for grid n
!  tempw(n) vectorized water temperature (deg C) for grid n
!  alpha - prieslty-taylor alpha coefficient
!  heatflux - heat storage flux in grid
!  net_solar_radv - net solar radiation flux in grid
!  ket_hr - extra-terrestrial solar radiation at middle of hour
!  ice_cover - positive is ice-on, based on water temperature
!
! NOTE: petn is adjusted based on the time increment
! i.e. for 1 hour it is multiplied by 3.6 since there are 3600 seconds
! per hour and is divided by 1000 to conserve units
!**********************************************************************

!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model to WATFLOOD
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
!     rev. 10.1.49 Nov.  08/16  - NK: Overhauled lake evaporation
!     rev. 10.2.36 Oct.  17/18  - NK: Initialized evap_rate(n) in lake_evap.f 

      USE area_watflood
      implicit none
      save

      real*8      :: gam,delt,ddg,declin,eccent,ths,
     *               heatflux,short_wave,long_wave,
     *               net_solar_radv,lkalpha,tau,Ket,Kso,evapE
      integer*4   :: n,ii,l,hour_count,ios,rbin
      real*4      :: dlta,sindlta,cosdlta,tandlta,dr,ws
      logical     :: exists,firstpass,warningflag
      REAL*4, DIMENSION(:), ALLOCATABLE :: ftempold,tempw,ilat
     *        ,radlat,Temp_max,Temp_min,Temp_tot,Temp_avg,evap_rate
     *        ,heatstore,tau_so,tdum,logD
      REAL*4, DIMENSION(12,10) :: albedo(12,10)= RESHAPE((/ 100.,100.,
     * 30.1,29.3,17.1,14.8,16.0,24.6,34.2,100.,100.,100.,100.,30.1,31.9,
     * 22.5,16.0,13.1,14.5,20.6,29.4,30.5,100.,100.,30.1,33.8,22.9,14.8,
     * 11.6,11.2,11.4,13.4,20.2,31.3,30.1,100.,33.9,24.0,15.5,10.5,8.8,
     * 8.4,8.6,9.8,13.6,21.6,32.1,35.5,22.0,16.1,10.8,8.4,7.5,7.3,7.4,
     * 8.0,9.9,14.4,21.0,24.1,14.5,11.1,8.5,7.3,6.8,6.7,6.8,7.1,8.0,
     * 10.3,13.8,16.1,10.3,8.6,7.3,6.7,6.5,6.4,6.4,6.6,7.1,8.2,10.0,
     * 11.1,8.3,7.4,6.7,6.4,6.3,6.3,6.3,6.4,6.6,7.2,8.1,8.7,7.2,6.7,6.4,
     * 6.3,6.4,6.4,6.4,6.3,6.3,6.6,7.1,7.4,6.6,6.4,6.3,6.4,6.6,6.8,6.7,
     * 6.4,6.3,6.4,6.6,6.8/),(/12,10/))
      logical, DIMENSION(:), ALLOCATABLE ::  choice

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE
      
!     SET FIXED PARAMETERS, INITIAL TEMPERATURE IN FIRST PASS
      data firstpass/.true./
      data warningflag/.true./
!      data eff_bare_area/1.0/

      if(firstpass)then
        allocate(ftempold(na),tempw(na),radlat(na),ilat(na)
     *          ,Temp_tot(na),Temp_avg(na),Temp_max(na),Temp_min(na),
     *          evap_rate(na),heatstore(na),tau_so(na),choice(na),
     *          tdum(na),logD(noresv),stat=iAll)
	  if(iAll.ne.0) STOP 'Error allocating arrays in evap_lake.for'  

!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
!       NOTE:                   NK   Feb. 25/16      
!       for the Mackenzie River Basin Hydraulic Model LKdepth is used as a flag
!       for evaporation from large lakes. 
!       for small lakes and river reaches the depth is set to 1 m
!       so to use the lake evaporation model the lake depth has to be > 1 m
  
           alpha=1.28 !PTC alphaPT for lakes (could vary)
           hour_count=0
           do n=1,naa
              ! calculate latitude of grid in radians ->fine but this only works for basins in LATLONG (which works for Hydro)
      if(lakeflg.eq.'y')then
               ilat(n)=(iymin+yyy(n)*grdn)/60.
              radlat(n)=ilat(n)/180.*3.14159
             ! patch so lake evap will run (not very well..) when not in latlong
              if(radlat(n)<0)radlat(n)=0.
              if(radlat(n)>1.16)radlat(n)=1.16
              
              tau_so(n)=0.75+0.00002*elev(n)

              ftempold(n)=tempv(n)
              Temp_tot(n)=0
              Temp_max(n)=-999
              Temp_min(n)=999
              heatstore(n)=0
      endif         
      
              rbin=ireach(n)
             choice(n)=.false.
              if(rbin.gt.0)then
                if(LKdepth(rbin).gt.1.0.and.lakeflg.eq.'y')then
                  choice(n)=.true.
                  logD(rbin)=log(LKdepth(rbin))
                  if(logD(rbin)<1.)logD(rbin)=1.
                elseif(lakeflg.eq.'y')then
!     rev. 10.2.29 Aug.  21/18  - NK: Added warning for lake depths less than 1 m
                    if(warningflag)then
                    print*
                    print*,'WARNING'
                    print*,'lakeflg = y but lake depth < or = to 1 m'
                    print*,'Lake evaporation model will not work for '
                    print*,'lake depths less than 1 m and is turned off'
                    print*,'for lake #' ,rbin
                    print*
                    print*,'To turn on lake evaporation, set the'
                    print*,'lake depth > 1 m in the ill file'
                    print*,'Depth found =',LKdepth(rbin)
                    print*
                    print*,'This message given just once'
                    print*,'but be sure to fix all lake depths > 1 m'
                    print*,'to apply lake evaporation model to any lake'
                    print*
                    call BEEPQQ(500,500)
!       take out for unix - non standard
                    pause 'Hit enter to continue  - in lake_evap @ 115'
                    warningflag=.false.
                    endif
                endif  
              endif
             
!     rev. 10.2.36 Oct.  17/18  - NK: Initialized evap_rate(n) in lake_evap.f 
              evap_rate(n)=0.0  ! must be initialized because it's not calculated until time=24
              tdum(n)= !grid_area(n)/3600000.0*frac(n)*aclass(n,ii_water)
     *        1000.*step2/3600.*frac(n)*aclass(n,ii_water)

            end do    
      end if !first pass
      
!	ju=jul_day_now           ! added NK

      ! This is just an internal hour counter, REPLACE (0=midnight)   
      hour_count=hour_count+1
      if(hour_count>23)hour_count=0

!     qstream(n) = net precip in mm converted to cms
         
      do n=1,naa
!       add precip to all water areas        
        qstream(n)=r(n,ii_water)*tdum(n)*(1.0-sca(n,ii_water))
       if(snwflg.eq.'y') qstream(n)=qstream(n)
     *        +fexcess(n,ii_water)*tdum(n)*sca(n,ii_water)
        
       if(choice(n))then
       
!         lake_evap is called in sub for ALL grids
!         so river evaporation is calculated using the pet method 
!         when choice is false - i.e. whn not on a lake OR
!               when lake evap is not used - lakeflf=n   
  
!         choice is true when we're in a coded lake where :
!                           ireach(n)>0
!                      .and.LKdepth(rbin)>1.0
!                      .and.lakeflg.eq.'y'
c         if(hour_count.ne.0)then
        if(mod(int(totaltime),24).ne.0)then             
           Temp_tot(n)=Temp_tot(n)+tempv(n)
           if(tempv(n)>Temp_max(n))Temp_max(n)=tempv(n)
           if(tempv(n)<Temp_min(n))Temp_min(n)=tempv(n)
            
         else ! day end, new lake evap calc:
           Temp_avg(n)=Temp_tot(n)/24.
           
           dlta=0.4093*sin(0.0172142*float(jul_day_now)-1.405)
           dr=1.0+0.033*cos(0.0172142*float(jul_day_now))
           sindlta=sin(dlta)
           cosdlta=cos(dlta)
           tandlta=sindlta/cosdlta
           ws=acos(-tan(radlat(n))*tandlta)

           ! Shortwave Radation:
           declin=0.4093*sin(2*3.14159*(jul_day_now-81)/365)
           Ket=1367./3.14159*dr*
     *           (ws*sinlat(n)*sindlta+coslat(n)*cosdlta*sin(ws))
           Kso=tau_so(n)*Ket
           if(dlyflg)then
            tau=0.16*(1+0.000027*elev(n))*dly_diff(n)**0.5
           else
            tau=0.16*(1+0.000027*elev(n))*(Temp_max(n)-Temp_min(n))**0.5
           endif
        
           ! Water temperature:
           lkalpha=1./(6.7-0.829*logD(ireach(n)))
           ftempold(n)=lkalpha*Temp_avg(n)+(1-lkalpha)*ftempold(n)
           tempw(n)=0.62*logD(ireach(n))+.979*ftempold(n)
     *          +(0.0126-0.0059*logD(ireach(n)))*Kso
           if(tempw(n)<-0.5)tempw(n)=-0.5
           
           ! Net radiation:
           if(tempw(n).eq.-0.5)then
             short_wave=tau*Ket*(1-0.8)
           else
             short_wave=tau*Ket*(1-(albedo(month_now,9-int(ilat(n)/10))
     *             *(ilat(n)/10-int(ilat(n)/10))+albedo(month_now,10-
     *            int(ilat(n)/10))*(1-ilat(n)/10+int(ilat(n)/10)))/100.)
           endif
           long_wave=(5.67*10**-8.)*((Temp_avg(n)+273.16)**4.
     *          *(1-0.261*exp(-0.00077*Temp_avg(n)**2.))
     *          -0.98*(tempw(n)+273.16)**4.)
           net_solar_radv=short_wave+long_wave
             
           ! Heat storage flux:
           heatflux=-23+0.232*Ket+28.2*(Temp_avg(n)-tempw(n))
     *          -2.1*Temp_avg(n) !*log(LKdepth(ireach(n)))-1.1*Temp_avg(n)
           if(heatstore(n)<-heatflux) heatflux=-heatstore(n)
           heatstore(n)=heatstore(n)+heatflux
      
           ! Evaporation rate (daily)
           evapE=-heatflux
           
           if(net_solar_radv>0)evapE=evapE+net_solar_radv
           if(evapE.lt.0.0)evapE=0.0

             gam=.001013/0.622*(100*((44331.514-elev(n))
     *              /11880.516)**(1/0.1902632)/1000)/alamb
             delt=2508.3/(tempw(n)+237.3)**2*exp
     *           (17.3*tempw(n)/(tempw(n)+237.3))
             ddg=delt/(delt+gam)
        
            ! calculate lake evaporation (in mm/hr)
             evap_rate(n)=alpha*ddg*(evapE)/alamb/den*86.4/24
             
          if(heatstore(n)<0) heatstore(n)=0.0   ! fixed mixed mode
         
         ! Start up the temperature tracking for the next day
         Temp_tot(n)=tempv(n)
         Temp_max(n)=tempv(n)
         Temp_min(n)=tempv(n)
         
        end if !end of day if
             
        strloss(n)=evap_rate(n)*tdum(n)*(1.0-sca(n,ii_water))
        
!       use ftall(water) for optimization     
        strloss(n)=strloss(n)*ftall(ii_water)  ! dds optimization  
        
        if(r(n,classcount-1).gt.0.0) strloss(n)=0.0   ! fixed mixed mode
        
        if(strloss(n).lt.0.0) strloss(n)=0.0  ! fixed mixed mode
       
        evt(n,classcount-1)=evt(n,classcount-1)+evap_rate(n) 
        eloss(n)=eloss(n)+evap_rate(n)*aclass(n,classcount-1)
      
       else              ! end lake if                   PET method:
!         SURFACE WATER:
!         RAIN FALLS ON WATER SURFACE AND IS DIRECTLY ADDED TO 
!         RIVER FLOW. 
!         REV 7.9 NEW CALCULATION BASED ON NEW EVAPORATION
!         REV. 8.85 - Oct. 12/98 - FIXED RAIN & SNOW ON WATER CLASS
!         qstream(n) is added to channel inflow in route
!         qstream(n) = net precip in mm converted to cms
!          qstream(n)=r(n,ii_water)*tdum(n)        
!         if the water evaporation is read in, skip this part

!         For this option:
!         EVAPORATION IN THE WATER CLASS IS EQUAL TO
!         POTENTIAL EVAPORATION AND HAS TO BE TAKEN FROM
!         RIVER STORAGE AS A FLOW
!     rev. 9.1.66  Oct.  17/04  - NK; pet*fpet for loss from water instead of pet
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!change  nov 25/09 nk
          if(r(n,ii_water).gt.0.0)then
            ev(n,ii_water)=0.0    
          else
            ev(n,ii_water)=pet(n,ii_water)*fpet(ii_water)   ! pet calculated 
          endif
                
c!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f
          if(ice_fctr(n).lt.0.0)then
            strloss(n)=0.0
            ev(n,ii_water)=0.0
          else !  ice_fctr(n)>.0.0

!     rev. 9.5.61  Sep.  03/09  - NK: bug/eloss - added water class for wfo weighted et
!           for the wfo file:

!            if(r(n,ii_water).le.0.001)then
              strloss(n)=ev(n,ii_water)*tdum(n)*(1.0-sca(n,ii_water))
!              strloss(n)=strloss(n)*fpet(ii_water)  ! dds optimization TH: fpet already in ev
!            else
!             no evaporation when it's raining            
!              strloss(n)=0.0
!            endif
            
!           strloss is taken from channel storage in route
c            if(ireach(n).eq.0)then
              if(store2(n).gt.strloss(n)*3600.0)then
                evt(n,ii_water)=evt(n,ii_water)+ev(n,ii_water)         ! for rffxx.txt
!               for ensim: prorated for sca 
!               100% snow cover - no et
!                0% snow cover - no reduction
                sum_et(n,ii_water)=sum_et(n,ii_water)+
     *                      ev(n,ii_water)*(1.0-sca(n,ii_water))   
     
!               for the watflood.wfo and watbal2.csv files:     
                eloss(n)=eloss(n)+ev(n,ii_water)*aclass(n,ii_water)         ! *(1-sca(n,ii_water))

!     REV. 10.1.17 Jan.  11/16  - NK: Added fpetLakeOverride factor
!               Temporary fix for dealing with rogue lakes - i.e. where fpet
!               just doesn't fit all the lakes
!               Maybve the lake evaporation model will fix this - maybe not.
!               It has to be done here so the tracer & isotope stuff 
!               is not affected
              else
                strloss(n)=0.0
              endif     !  store2(n).gt.............
c            endif     !  ireach(n).eq.0
          endif     !  ice_fctr(n).lt.0.0

   
!          snow covered ice - eventually.........................

c            else                    !IF(akfs(ii).gt.0.0)THEN
c!             FEXCESS FALLS ON WATER SURFACE AND IS DIRECTLY ADDED TO 
c!             RIVER FLOW. SET AK(ii) TO 0.0 OR LESS FOR THIS OPTION
c!             REV 7.9 UPDATED EVAPORATION    
c!                BUT THERE IS NO EVAP FOR MELTED SNOW
c!             REV. 8.85 - Oct. 12/98 - FIXED RAIN & SNOW ON WATER CLASS
c              d1fs(n,ii)=0.0
c              dffs(n,ii)=0.0
c              uzs(n,ii)=0.0
c              iiwater=ii
c!             qstream(n) is added to channel inflow in route
c!             qstream(n) = net melt+rain in mm converted to cms
c              qstream(n)=qstream(n)+fexcess(n,ii)*eff_sc_area*tdum
c              
c              strloss(n)=0.0
c              
c!             NO EVAPORATION WHEN WATER IS COVERED BY SNOW!
c!                 this is in the last version of SPL8

      end if !  ireach(n)>0.and.LKdepth(rbin)>1.0

      end do !end grid loop  

      firstpass=.false.
      RETURN
49900     format((i5,','),20(f10.5,','))     
 9992 format(7x,f9.2)
      END SUBROUTINE lake_evap
      SUBROUTINE lake_ice

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f

      use area_watflood
      implicit none

      integer     ::  n,jz
      logical     :: firstpass

      data firstpass/.true./


!     rev. 10.1.07 Dec.  02/15  - NK: Added ice_fctr(n) to route 
!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!     the equations were taken from the Lake Winnipeg model
      if(firstpass.eq.'y')then
!         initialize the  ice factor
        do n=1,naa
          dd_ice(n)=1000
          dd_thaw(n)=0.0
        end do
!     REV. 10.1.19 Jan.  15/16  - NK: Fixed initialization of ice_factr - moved from lake_ice > runof6
c!       default ice_fctr        
c        do n=1,naa
c          ice_fctr(n)=1.0
c        end do
        open(unit=549,file='ice_factor.txt',status='unknown')
        firstpass=.false.
      endif
      
c      if(iceflg.eq.'y'.and.mod(jz,24).eq.0)then
!       needed only once a day      
        if(jul_day_now.gt.275.or.jul_day_now.lt.91)then     
!         fall freeze up & winter           
          do n=1,naa
c            if(IBN(n).eq.5)then
              if(dd_ice(n).gt.0.0)then
!               dd_ice (freezing degree days) must be +ve          
c               lif=3.0981177*dd_ice(n)**-0.3324723
c                ice_fctr(n)=3.7222496*dd_ice(n)**-0.2747330
                ice_fctr(n)=3.7222496*dd_ice(n)**-0.4
c                ice_fctr(n)=amax1(1.0,ice_fctr(n))
!               in the winter is should not be less than 0.5
                ice_fctr(n)=amax1(0.25,ice_fctr(n))
                ice_fctr(n)=amin1(1.0,ice_fctr(n))
              endif
c              if(ice_fctr(n).lt.0.95)ice_fctr(n)=0.5
c            endif
          end do
        else  !spring thaw & summer
          do n=1,naa
c            if(IBN(n).eq.5)then
              if(dd_thaw(n).gt.0.0)then
c                ice_fctr(n)=1.0/(3.7222496*dd_thaw(n)**-0.2747330)
                ice_fctr(n)=1.0/(3.7222496*dd_thaw(n)**-0.2747330)
                ice_fctr(n)=1.0/(3.7222496*dd_thaw(n)**-.3)
c                ice_fctr(n)=amax1(1.0,ice_fctr(n))
!               in the summer it should not be more than 1.0
                ice_fctr(n)=amax1(0.25,ice_fctr(n))
                ice_fctr(n)=amin1(1.0,ice_fctr(n))
c              else
c                ice_fctr(n)=1.0
              endif
c            endif
          end do  ! NOTE: ice_fctr written in rte.txt fln(55)
        endif
c      endif  ! iceflg.eq.y
      
      end subroutine lake_ice
      SUBROUTINE lake_lvl_update(jz,date,time)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
        
      use area_watflood
	implicit none
      save
      integer(4)     :: i,j,n,l,jz,ios,iAllocate
      integer(4)     :: fileDD,fileMM,fileYY
      real(4)        :: div,thr,at,dtmin,time
      CHARACTER(14)  :: date
      character(256) :: line,junk
      logical        :: firstpass,exists
      
      data firstpass/.true./
      
      if(firstpass)then
                allocate(lake_release(noresv,366),stat=iAllocate)
                if(iAllocate.ne.0) STOP
     *			'Allocation Error: lake_release in lake_lvl_update @ 38'
                do l=1,noresv
                    do j=1,366
                        lake_release(l,j)=-999.0
                    end do
                end do
      endif
        
            if(mod(jz,24)+6.eq.6)then
!             update 1 am local time for Ont                
              if(month_now.lt.10.and.day_now.lt.10)then
                write(line,77771)year_now,month_now,day_now
77771           format('level\',i4,'0'i1,'0',i1,'_ull.txt')
              elseif(month_now.lt.10.and.day_now.ge.10)then
                write(line,77772)year_now,month_now,day_now
77772           format('level\',i4,'0',i1,i2,'_ull.txt')
              elseif(month.ge.10.and.day_now.lt.10)then
                write(line,77773)year_now,month_now,day_now
77773           format('level\',i4,i2,'0',i1,'_ull.txt')
              else
                write(line,77774)year_now,month_now,day_now
77774           format('level\',i4,i2,i2,'_ull.txt')
              endif
              fln(99)=line
c              print*,fln(99)(1:40)
c              pause 77788
              continue
              INQUIRE(FILE=fln(99),EXIST=exists)
              if(exists)then
                write(98,*)
     *          'Info: Updating the lake levels with fln',fln(99)(1:40)
                open(unit=99,file=fln(99),status='old',iostat=ios)
                do while(.not.eof(99))
                    read(99,*,iostat=ios)l,junk,lake_elv(l,jz)
                    if(ios.eq.0)then
                      i=ires(l)
                      j=jres(l)
                      n=s(i,j)
                      store2(n)=lake_area(l)*(lake_elv(l,jz)-b7(l))+
     *                                           store_dead(l)
                      store1(n)=store2(n)
                    endif
                end do
               write(98,*)'Info: lake level updated with file:',
     *                              fln(99)(1:72)
              endif

                
              do l=1,noresv
                  lake_release(l,day_now)=-999.0
              end do
!             Read a single day of pre-determined lake outflow                
              if(month_now.lt.10.and.day_now.lt.10)then
                write(line,87771)year_now,month_now,day_now
87771           format('resrl\',i4,'0'i1,'0',i1,'_ufl.txt')
              elseif(month_now.lt.10.and.day_now.ge.10)then
                write(line,87772)year_now,month_now,day_now
87772           format('resrl\',i4,'0',i1,i2,'_ufl.txt')
              elseif(month.ge.10.and.day_now.lt.10)then
                write(line,87773)year_now,month_now,day_now
87773           format('resrl\',i4,i2,'0',i1,'_ufl.txt')
              else
                write(line,87774)year_now,month_now,day_now
87774           format('resrl\',i4,i2,i2,'_ufl.txt')
              endif
              fln(99)=line
              INQUIRE(FILE=fln(99),EXIST=exists)
              if(exists)then
              print*,fln(99)(1:40)
                print*,'NEW <<<<<'
                write(98,*)'Info:
     *              Updating the lake levels with fln',fln(99)(1:40)
                open(unit=99,file=fln(99),status='old',iostat=ios)
                do while(.not.eof(99))
                    read(99,*,iostat=ios)l,junk,lake_release(l,day_now)
                end do
                write(98,*)'Info: lake discharge updated '
              endif
          endif
      firstpass=.false.  
      return      
        
      END SUBROUTINE lake_lvl_update

            SUBROUTINE lst(scale,igrdshft)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

!  THIS SUBROUTINE PRINTS THE FINAL RESULTS AND CALCULATES THE ERROR

!     REV. 7.80   Oct.  29/96 -  spl7 added yymmdd.rin for res inflows
!                             -  unit = 39   fln = 09
!     REV. 8.61 - Dec.  12/97 -  added contflg for statistics cont'n
!     REV. 8.77 - June   1/98 -  added sub-basin error calculation
!     REV. 8.83 - sep.  23/98 -  added step to the lst argument list
!     REV. 8.84 - Sep.  28/98 -  added runoff and evap fields to spl.txt
!     REV. 8.95 - Mar.  15/99 -  computed mean flows for time increment

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90
!     rev. 9.1.18  Jun.  03/02  - Added sub-watershed modelling capability
!     rev. 9.1.22  Jul.  22/02  - Added simout\error.r2s file for ENSIM_Hydrologic
!     rev. 9.1.29  Nov.  07/02  - Changed the threshold flow values for error calculations
!     rev. 9.1.41  May   15/03  - Event average flows output to unit=75
!     rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_outflow
!     rev. 9.1.79  Mar.  30/05  - NK: ktri to area2 for reservoir inflow dt
!     rev. 9.2.19  Oct.  28/05  - NK: Compute daily & monthly flows
!     rev. 9.2.41  Jun.  15/06  - NK: changed the resin.txt file to resin.csv
!     rev. 9.3.07  Dec.  29/06  - NK: added sum_precip for whole domain
!     rev. 9.5.37  Oct.  14/08  - NK: added deltat_report to lake_sd.csv file write
!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
!     rev. 9.5.60  Sep.  01/09  - NK: added deltat_report for lake_sd.csv file
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
!     rev. 9.7.09  Oct.  11/10  - NK: update flowflag in lst.f for subsequent events
!     rev. 9.7.25  Apr.  28/11  - NK: Fixed daily flows
!     rev. 9.8.27  Sep.  27/12  - NK: changed action on resumflg='s' - keep tbcflg='y'
!     rev. 9.8.43  Jan.  31/13  - NK: fixed bug in lst.f : undefined output for iopt=99
!     rev. 9.8.48  Feb.  12/13  - NK: Replaced spl.plt with spl.tb0 file
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiphours in s/r stats to value1 in the str file
!     rev. 9.8.88  Oct.  26/13  - NK: Fixed header writing sequence for spl.tb0 
!     rev. 10.1.50 Nov.  08/16  - NK: Overhauled lst for new isotope output
!     rev. 10.2.41 Dec.  10/18  - NK: Added winter monthly peaks

!  a - mm  runoff recorded
!  b - mm of runoff computed

!***********************************************************************
 
      use area_watflood
      use areacg
	implicit none


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(10) :: time
      character(60) :: col_name(999)
      CHARACTER(8)  :: cday,tempflg
      character(80) :: line
      character(1)   :: dsflg,firstpass,answer
      logical       :: exists,tmpflg,errflg1
      
!     the MRBflg is custom for revising the MRB_WILLISTON_INFLOWS>tb0 
!     file for the MRB model. The natural flows will be added to col 3 
!     CHARM will look for the file and if present, add the data is so directed    
      logical       :: MRBflg
      character(72) :: MRBheader(100)
      integer       :: MRBheaderlines,MRBdatalines
      integer       :: day_last,jd,jul_day1_id1
      real(4),  dimension(:,:), allocatable ::  MRBdata
 
      real(4) :: aaa,bbb,ccc,ab,scale,tttmmmpp,qmaxs,
     *            qsynmean,smc5(99),             !qdwprmd(60),
     *            diff2,qmaxh,aig,ajg,
     *            qhydevent(1000),qsynevent(1000),
     *            qdwrp_sum
      integer :: i,j,n,ii,ig,jg,ios,n1,kk,l,noo,k,nend,evt_hrs,
     *             nmissed,igrdshft,kfirst,mh,nqevent(1000),mon,
     *             mohours(24),nmonths,month_1,hour_no,hour_neg,
     *             time_sum,iDeallocate,iAllocate,level_count,
     *             strLength,un

      DATA mohours/744,672,744,720,744,720,744,744,720,744,720,744,
     *             744,672,744,720,744,720,744,744,720,744,720,744/
     
      real(4),  dimension(:),   allocatable :: lake_elv_max
      real(4),  dimension(:),   allocatable :: lake_elv_min
      real(4),  dimension(:),   allocatable :: lake_elv_max_av
      real(4),  dimension(:),   allocatable :: lake_elv_min_av
      real(4),  dimension(:),   allocatable :: sum_max
      real(4),  dimension(:),   allocatable :: sum_min
      real(4),  dimension(:),   allocatable :: mnl_diff
      real(4),  dimension(:,:), allocatable :: lake_elv_max_id
      real(4),  dimension(:,:), allocatable :: lake_elv_min_id
      real(4),  dimension(:),   allocatable :: qdwpr_sum

      data time_sum/0/
      data firstpass/'y'/

!       SET UP A FEW FILENAMES FOR BACKGROUND STREAMFLOW FILES
!       FIVE IS ALL WE NEED FOR BC HYDRO

!     THIS SECTION GETS THE COMPUTER'S DATE AND TIME
!     THIS INFO USED TO COME FROM HEADER.FI, HOWEVER F90 INTRINSICS
!     AND CALLS ARE DIFFERENT AND THEREFORE IT NEEDED TO BE MODFIED.
      call date_and_time(cday,time)

!       MAX FLOW CALCUL'D IN EACH SQUARE IS PRINTED WHEN IOPT.GT.0
!       GIVES QMAX=FN(DRAINAGE AREA) FOR IOPT.NEQ.0 ONLY

!!!!!!!!!!!!!!!!!!!!!!!      if(ni.le.1)then

!     CALUCLATE THE TOTAL PRECIP ON EACH SQUARE SUB-BASIN
!     THERE IS A PROBLEM IN THAT WE ARE CALCULATING ON EACH SUB-AREA, 
!     NOT THE TOTAL CONSTRIBUTING AREA

d	if(iopt.eq.2)print*,' checkpoint 10 in lst'

      if(firstpass.eq.'y')then
        allocate(mnl_diff(no),stat=iAllocate)
        if(iAllocate.ne.0)STOP
     *         'Error with allocation of mnl_diff @ 108'
        allocate(net_basin_supply(noresv,100),stat=iAllocate)  ! good for up to 100 days
        if(iAllocate.ne.0)STOP
     *         'Error with allocation of net_basin_supply @ 144'
         
        if(iopt99)then
          allocate(qp_month_syn(no,13),
     *             qp_month_hyd(no,13),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *         'Error with allocation of qp_month** @ 127'
      
      endif
        
        
      endif

!     MRB model custom code
      if(firstpass.eq.'y')then
        INQUIRE(FILE='MRB_WILLISTON_INFLOWS.tb0',EXIST=exists)
        if(exists)then
          MRBflg=.true.
        else
          MRBflg=.false. 
        endif  
        if(MRBflg)then
          print*
          print*,'Found the file: MRB_WILLISTON_INFLOWS.tb0'
          print*,'MRBflg =',MRBflg
          print*
          print*,'Would you like to replace col 3 with CHARM generated'
          print*,'natural flows at the Bennett dam?'
          print*,'To make this work, you will need to run'
          print*,'1960_natural.evt  as the event.evt file'
          print*,'and answer `y` next, else answer `n`'
          print*
          print*,'If you do not wish to see this option with each run'
          print*,'answer `s` to stop this run'
          print*,'Then move the MRB_WILLISTON_INFLOWS.tb0 file from'
          print*,'the working directory to somewhere safe.' 
          print*
          read*,answer
          if(answer.eq.'s')stop
          if(answer.eq.'n')MRBflg=.false.
c          if(answer.eq.'y')then
c            print*,'What is the rank for the Hudson Hope WSC'
c            print*,'Flow station?'
c            read*,HHrank
c          endif
        endif
        if(MRBflg)then
          open(unit=99,file='MRB_WILLISTON_INFLOWS.tb0',
     *                          status='old',iostat=ios)
          read(99,99501)line
99501     format(a80)  
          n=1        
          MRBheader(n)=line(1:72)
          do while(.not.line(1:10).eq.':EndHeader')
            n=n+1
            read(99,99501)line
            MRBheader(n)=line(1:72)
          end do
          MRBheaderlines=n
          do i=1,n
            print*,MRBheader(i)(1:72)
          end do
          n=0
          do while(.not.eof(99))
            n=n+1
            read(99,99501)line
          end do
          print*,'found ',n,' lines with data'
          MRBdatalines=n
          allocate(MRBdata(3,MRBdatalines),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *         'Error with allocation of gname lst & 522'
          rewind(unit=99)
          do n=1,MRBheaderlines
            read(99,*)line
          end do
          do n=1,MRBdatalines
            read(99,*,iostat=ios)(MRBdata(i,n),i=1,3)
            if(ios.ne.0)then
              print*,'Error in data line ',n
              stop 'Program aborted in lst @ 188'
            endif
            write(555,*)(MRBdata(i,n),i=1,3)
          end do
          close(unit=99)
c        endif     ! ** moved down
        
!         write the header for the file updated with CHARM computed natural flows        
          open(unit=99,file='MRB_WILLISTON_INFLOWS.new',
     *                       status='unknown',iostat=ios)
          if(ios.ne.0)then
            print*,'Problems opening MRB_WILLISTON_INFLOWS.new'
            stop 'CHARM aborted in lst @ 193'
          endif
          MRBheader(8)=':WrittenBy                WATFLOOD/CHARM'
          do n=1,MRBheaderlines
            if(n.eq.9)then
              write(99,3010)':CreationDate       ',
     *        cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
            else
               Write(99,99502)MRBheader(n)
99502         format(a72)
            endif
          end do
          close(unit=99,status='keep')
        endif    !  ** moved from above  Oct. 18/17 NK
        

!     REV. 10.1.36 Jul   12/16  - NK: Added results\LakeName.tb0
!       Write the headers for the yyyymmdd_lake.tb0 files
!       make up file names 
        if(noresv.gt.0.and.tb0flg.eq.'y')then
        do l=1,noresv 
          strLength = LEN_TRIM(resname(l))
          print*,'strLength=',strLength
                 
          if(l.le.9)then
             write(line,50001)
     *        'results\lake_00',l,'_',resname(l),'.tb0'
             write(*,50001)
     *        'results\lake_00',l,'_',resname(l),'.tb0'
50001        format(a15,i1,a1,a<strLength>,a4)
          elseif(l.le.99)then  
             write(line,50002)
     *        'results\lake_0',l,'_',resname(l),'.tb0'
             write(*,50002)
     *        'results\lake_0',l,'_',resname(l),'.tb0'
50002        format(a14,i2,a1,a<strLength>,a4)
          else
             write(line,50003)
     *        'results\lake_',l,'_',resname(l),'.tb0'
             write(*,50003)
     *        'results\lake_',l,'_',resname(l),'.tb0'
50003        format(a13,i3,a1,a<strLength>,a4)  
          endif
          read(line,50004)line
50004     format(a72)     
          print*,line(1:72)        
          un=2000+l
          open(unit=un,file=line,status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',line(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in write_tb0.f @ 52'
          endif
          PRINT*
	    if(iopt.ge.1)print*,'Opened unit=',un,' filename=',line(1:40)
          write(un,3005,iostat=ios)
     *              '##########################################'
          if(ios.ne.0)then
            print*,'Unable to write to ',line(1:40)
            print*,'Likely problem: duplicate names in the rel file'
            print*
            stop 'Program aborted in lst @ 252'
          endif
          write(un,3005)':FileType tb0  ASCII  EnSim 1.0           '
          write(un,3005)'#                                         '
	    write(un,3005)'# DataType              EnSim Table Data  '
          write(un,3005)'#                                         '
          write(un,3005)':Application            WATFLOOD          '
	    write(un,3005)':Version                2.1.23            '
	    write(un,3005)':WrittenBy              WATFLOOD/CHARM    '
          call date_and_time(cday,time)
	    write(un,3010)':CreationDate       ',
     *   cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
3010      format(a20,a4,'-',a2,'-',a2,2x,a2,':',a2)
          write(un,3005)'#                                         '
	    write(un,3005)'#-----------------------------------------'
          write(un,3005)':SourceFile             Various           '                                    '
          write(un,3005)'#                                         '
          write(un,3005)'#                                         '
!         fixed format for the date      
          if(mo_start.le.9.and.hour_start.le.9)then
            write(un,3024)':StartDate          ',
     *   year_start,mo_start,day_start,hour_start
3024        format(a20,i4,'/0',i1,'/0',i1,'  ',i2,':00:00')  
          elseif(mo_start.le.9.and.hour_start.gt.9)then
            write(un,3025)':StartDate          ',
     *     year_start,mo_start,day_start,hour_start
3025        format(a20,i4,'/0',i1,'/',i2,'  ',i2,':00:00')  
          elseif(mo_start.gt.9.and.hour_start.le.9)then
            write(un,3026)':StartDate          ',
     *     year_start,mo_start,day_start,hour_start
3026        format(a20,i4,'/',i2,'/0',i1,'  ',i2,':00:00')  
          else    
            write(un,3027)':StartDate          ',
     *         year_start,mo_start,day_start,hour_start
          endif
3027      format(a20,i4,'/',i2,'/',i2,'  ',i2,':00:00')      
          write(un,3005)':deltaT             24:00:00.000          '
!         This next line asked foe by AB @ NRC
!         but there should never be missing data in these computed 
!         lake elv. inflow & outflow          
!     REV. 10.1.38 Jul   28/16  - NK: Added noDataValue to WFO & tb0 files
          write(un,3005)':NoDataValue -999.0                       '
3028      format(a20,i10)   
          write(un,3005)'#                                         '
	    write(un,3005)':ColumnMetaData                           '
	    write(un,3006)
     *	    '   :ColumnName       level      inflow     outflow'
          write(un,3006)
     *      '   :ColumnUnits       masl         cms         cms'
	    write(un,3006)
     *	    '   :ColumnType       float       float       float'
          write(un,3005)':endHeader                                ' 
 3001     format(a20,i16)
 3005     format(a42)
 3006     format(a50)
 3020     format(a20,a40)
 3021     format(a20,999(a42))

        end do
        endif    ! noresv > 0
!     END    REV. 10.1.36 Jul   12/16  - NK: Added results\LakeName.tb0

!     rev. 10.2.28 Jul.  08/18  - NK: Revised for TSW = NBS without lake precip/evap'n
        if(nbsflg.eq.'0')then
!         Open the file and write header in the first event only
          open(unit=957,file=filename(957),status='unknown') 
          write(957,*)'Sub-basin supply (between numbered lakes)'
	    write(957,3010)'Run time            ',
     *        cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
	    write(957,3010)'Valid approx.       ',
     *        cday(1:4),cday(5:6),cday(7:8),00,00
          write(957,95701)(l,l=1,noresv)
95701     format(<noresv>i8)
          write(957,95702)(resname(l),l=1,noresv)
95702     format(<noresv>(1x,a7))
        endif
        
      endif   !first pass
      
c      stop 'in lst'
      
      do i=1,ij
         do j=1,ji
            p(i,j)=0.0
!           This used to be -9999. but it gave format errors in 
!           the newerror.txt file. This may have an effect
!            when the file is read.   nk  Apr. 10/03
            basinerr(i,j)=-999.
         end do
      end do
d	if(iopt.eq.2)print*,' checkpoint 11 in lst'

!     P(I,J) IS THE CUMMULATIVE RAINFALL NOW
      do n=1,naa
         i=yyy(n)
         j=xxx(n)
         p(i,j)=sump(n)
      end do
d	if(iopt.eq.2)print*,' checkpoint 12 in lst'

!     THIS NEEDS TO BE DONE EACH EVENT BECAUSE SUMP() AND P() ARE
!     ALREADY THE SUM OF THE PRECIP SINCE THE START      
      do l=1,no
        nnsum(l)=0
        ppsum(l)=0.0
        qhydevent(l)=0.0
        qsynevent(l)=0.0
        nqevent(l)=0
      end do
d	if(iopt.eq.2)print*,' checkpoint 13 in lst'
 
      do n=1,naa
         i=yyy(n)
         j=xxx(n)
         l=nhyd(i,j)
         if(l.gt.0)then
            ppsum(l)=ppsum(l)+p(i,j)
            nnsum(l)=nnsum(l)+1
         endif
      end do
d	if(iopt.eq.2)print*,' checkpoint 14 in lst'

      do l=1,no
         if(nnsum(l).gt.0)then
            ppsum(l)=ppsum(l)/float(nnsum(l))
         else
            ppsum(l)=-10.
         endif
      end do
d	if(iopt.eq.2)print*,' checkpoint 15 in lst'

      if(iopt.ge.1)then 	
         write(51,6080)
         write(51,6081)
         write(51,6666)(n,yyy(n),xxx(n),da(n),qmax(n),sump(n),n=1,naa)
      endif
d	if(iopt.eq.2)print*,' checkpoint 16 in lst'

!     P(I,J) IS USED HERE ONLY TO REPORT PRECIPITATION ON
!     A SQUARE GRID MATRIX, THIS P(I,J) IS NOT USED IN ANY
!     COMPUTATIONS, AND HAS DIFFERENT VALUE FROM THAT IN S/R,
!     RAIN,RUNOFF,ETC...
      write(51,6668)scale
	write(51,6667)scalesnw

!     rev. 9.9.28  Sep.  30/14  - NK: Remove unnecessary writes for watroute
      if(modelflg.eq.'n')then
!       WRITE THE PRECIP ON EACH GRID
        if(xcount.le.250) then
          do i=ycount,1,-1
            write(51,6090)(p(i,j),j=1,xcount)
          end do
	  else
	    do i=ycount,1,-1
            write(51,6092)(p(i,j),j=1,xcount)
          end do
	  endif

        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=sumrff(n)
        end do
        write(51,6672)
        if(xcount.le.250) then
          do i=ycount,1,-1
            write(51,6090)(p(i,j),j=1,xcount)
          end do
	  else
	    do i=ycount,1,-1
            write(51,6092)(p(i,j),j=1,xcount)
          end do
	  endif
!       P(I,J) IS THE CUMMULATIVE RUNOFF NOW

        do n=1,naa
          i=yyy(n)
          j=xxx(n)
!         TRY PRINTING OUT ACTUAL CUMMULATIVE EVAPORATION FRANK S FEB/99
          p(i,j)=eloss(n)
        end do
        write(51,6673)
        if(xcount.le.250) then
          do i=ycount,1,-1
            write(51,6090)(p(i,j),j=1,xcount)
          end do
	  else
	    do i=ycount,1,-1
            write(51,6092)(p(i,j),j=1,xcount)
          end do
	  endif
!       P(I,J) IS THE TOTAL EVAPORATION 
!            +/- CHANGE IN BASIN ELEMENT STORAGE

!       rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!       write the recharge totals:
!       Write THE TOTAL recharge to spl.txt
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=sumrechrg(n)/frac(n)
        end do
        write(51,6677)

        if(xcount.le.250) then
          do i=ycount,1,-1
c           write(51,6090)(p(i,j),j=1,xcount)
           write(51,*)(p(i,j),j=1,xcount)
          end do
	  else
	    do i=ycount,1,-1
c            write(51,6092)(p(i,j),j=1,xcount)
            write(51,*)(p(i,j),j=1,xcount)
         end do
	  endif
!	
!       Write the runoff coefficient to spl.txt 
        do n=1,naa
           i=yyy(n)
           j=xxx(n)
           if(sump(n).gt.0.01)then
              p(i,j)=sumrff(n)/sump(n)*100.
           else
              p(i,j)=-1.0
           endif
        end do
        write(51,6674)
        if(xcount.le.250) then
          do i=ycount,1,-1
            write(51,6090)(p(i,j),j=1,xcount)
          end do
	  else
	    do i=ycount,1,-1
            write(51,6092)(p(i,j),j=1,xcount)
          end do
	  endif

!       WRITE A FILE TO PLOT PRECIP, LOSS AND RUNOFF FIELDS
        if(iopt99)then
          open(unit=99,file='debug\lossplot.txt',
     *                   status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file lossplot.txt'
            print*,'Possible causes:'
            print*,'file in use by another application'
            stop 'Program aborted in lst.f @ 312'
          endif
          write(99,6675)
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            aig=yorigin+(i-1)*ydelta+ydelta/2.0
            ajg=xorigin+(j-1)*xdelta+xdelta/2.0
            if(sump(n).gt.0.001)then
              tttmmmpp=sumrff(n)/sump(n)*100.0
            else
              tttmmmpp=-1.0
            endif
            write(99,6094)nbasin(i,j),i,j,aig,ajg,sump(n),sumrff(n),
     *                 sump(n)-sumrff(n),tttmmmpp
          end do
          close(unit=99,status='keep')
        endif
      endif    ! modelflg='n'
!     end rev. 9.9.28  Sep.  30/14  - NK: Remove unnecessary writes for watroute


!     JUST TO MAKE SURE WE DON'T GET HUGE AMOUNTS REMAINING IN MEMORY
!     FOR THE NEXT MONTH:
      do i=1,ycount
         do j=1,xcount
            p(i,j)=0.0
         end do
      end do

!!!!!!!!!!!!!!!!!!!!!!         endif

!     THIS SECTION PRINTS A SUMMARY OF THE MEASURED AND COMPUTED
!     FLOWS FOR PLOTTING
d	if(iopt.eq.2)print*,' checkpoint 30 in lst'

      open(unit=27,file=filename(27),status='unknown',
     *     iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file',filename(27)(1:40)
        print*,'Possible causes:'
        print*,'file in use by another application'
        print*,'or target directory does not exist'
        stop 'Program aborted in lst.f @ 312'
      endif

      write(51,6015)
     *  time(1:2),time(3:4),time(5:6),cday(1:4),cday(5:6),cday(7:8)
      if(writeFlg(1))write(27,6015)
     *  time(1:2),time(3:4),time(5:6),cday(1:4),cday(5:6),cday(7:8)
c      write(*,6015)
c     *  time(1:2),time(3:4),time(5:6),cday(1:4),cday(5:6),cday(7:8)

!      write(51,6015)hrs,mins,secs,day,month,year
!      write(99,6015)hrs,mins,secs,day,month,year

      write(51,1013)
      if(writeFlg(1))write(27,1013)

d            if(iopt.eq.2)then
d              print*,' In lst before writing to unit 58'
d              print*
d            endif

d	if(iopt.eq.2)print*,' checkpoint 40 in lst'

!     * * * * * * * * * * * * * * * * 
!     Calculate the statistics
!     * * * * * * * * * * * * * * * * 

c      do n=1,no,9
c         n1=n+8
c         n1=min0(n1,no)
c         noo=n1-n+1

c         write(58,1000)fln(10)
c         write(58,1015)noo,nl,mhtot,kt
c         write(58,1014)

!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      do l =1,no

           if(inbsnflg(l).eq.1.and.area(l).gt.0.0)then  ! area added Feb. 11/11 nk

!           SEE S/R SUB FOR INTIALIZATION OF NQ,NQC,AA,BB,CC,ASHNUM,
!           ASHDEN,QPEAKH & QPEAKS
            if(id.eq.1)then
               qmaxh=0.1e-10
               qmaxs=0.0e-10
               qbarobs(l)=-1.0
            endif

!           RESET THE DAILY PEAKS FOR EACH EVENT FOR THE DAILY PEAK 
!           TABLE
c            dpeakh(l)=0.1e-10
c            dpeaks(l)=0.1e-10
            qpeakh(l)=0.1e-10
            qpeaks(l)=0.1e-10
            volhyd(l)=0.0
            volsyn(l)=0.0
	  
!   REV. 8.95 - Mar.  15/99 -  COMPUTED MEAN FLOWS FOR TIME INCREMENT
!           CALCULATE THE MEAN FLOWS FOR THE TIME INCREMENT:
!           QHYD(L,K) WILL BE MODIFIED TO BECOME THE MEAN DAILY FLOW
!           INSTEAD OF THE INSTANTANEOUS FLOW (BUT ONLY FOR DAILY'S)

            if(kt.eq.24)then
               do k=kt,mhtot,kt
                  qsynmean=0.0
                  do kk=1,kt
                     qsynmean=qsynmean+qsyn(l,k-kk+1)  
                  end do
                  qsyn(l,k)=qsynmean/float(kt)         ! mean daily <<
c                  dpeakh(l)=amax1(dpeakh(l),qhyd(l,k))
c                  dpeaks(l)=amax1(dpeaks(l),qsyn(l,k))
                  qpeakh(l)=amax1(qpeakh(l),qhyd(l,k))
                  qpeaks(l)=amax1(qpeaks(l),qsyn(l,k))
              end do
            else
               do k=kt,mhtot,kt
c                  dpeakh(l)=amax1(dpeakh(l),qhyd(l,k))
c                  dpeaks(l)=amax1(dpeaks(l),qsyn(l,k))
                  qpeakh(l)=amax1(qpeakh(l),qhyd(l,k))
                  qpeaks(l)=amax1(qpeaks(l),qsyn(l,k))
               end do
            endif

!     rev. 10.2.15 Feb.  05/18  - NK: Added 'results\monthly_peaks'
!           pick our the monthly peak flow pairs (Obs/Comp)
!           qp_month_sym(no,12),qp_month_hyd(no,12),   
!           in first day of the event set peaks to 0.001
!           (Needed for log plots)
            if(iopt99)then
              do j=1,13
                qp_month_hyd(l,j)=0.001
                qp_month_syn(l,j)=0.001
              end do
              do k=1,mhtot
                j=k/732+1
                if(qhyd(l,k).gt.qp_month_hyd(l,j))then
                  qp_month_hyd(l,j)=qhyd(l,k)
!                 pick the max flow in a 12 hour window
                  qp_month_syn(l,j)=qsyn(l,k)
                  if(k.gt.25.and.k.lt.mhtot-25)then
                      do i=k-24,k+24
                        qp_month_syn(l,j)=
     *                   amax1(qp_month_syn(l,j),qsyn(l,i))
                      end do
c                      qp_month_syn(l,j)=amax1(qp_month_syn(l,j),
c     *                qsyn(l,k-5),qsyn(l,k-4),qsyn(l,k-3),
c     *                qsyn(l,k-2),qsyn(l,k-1),                  
c     *                qsyn(l,k+5),qsyn(l,k+4),qsyn(l,k+3),
c     *                qsyn(l,k+2),qsyn(l,k+1))     
                  endif
                endif
c                write(450+l,45300)k,j,qhyd(l,k),qsyn(l,k),
c     *                  qp_month_hyd(l,j),qp_month_syn(l,j)
c45300           format(2i5,4f10.1)              
              end do
            endif

!     rev. 9.8.51  Mar.  11/13  - NK: Link skiphours in s/r stats to value1 in the str file
            if(.not.skipflg)then
              do k=kt,nl,kt
c               qhyd(l,k)=amax1(qhyd(l,k),0.100E-32)
!               no good for the stats program

!               CALCULATE HYDROGRAPH VOLUMES:
!     rev. 10.2.64 Sep.  09/26  - NK added min_flow_cutoff for error calculations
                if(qhyd(l,k).gt.min_flow_cutoff)then 
                  nq(l)=nq(l)+1
                  nqevent(l)=nqevent(l)+1
                  aa(l)=aa(l)+qhyd(l,k)
                  bb(l)=bb(l)+qsyn(l,k)
                  volhyd(l)=volhyd(l)+qhyd(l,k)
                  volsyn(l)=volsyn(l)+qsyn(l,k)
                  qhydevent(l)=qhydevent(l)+qhyd(l,k)
	            qsynevent(l)=qsynevent(l)+qsyn(l,k)
                endif
                cc(l)=cc(l)+qsyn(l,k)
                nqc(l)=nqc(l)+1
              end do

!	        pre-emption
!             calculated station errors:ashnum(l)
              if(nq(l).gt.0)then
                qbarobs(l)=aa(l)/nq(l)
                do k=kt,nl,kt
                  if(qhyd(l,k).gt.0.0000)then
                     ashnum(l)=ashnum(l)+(qhyd(l,k)-qsyn(l,k))**2
                     ashden(l)=ashden(l)+(qhyd(l,k)-qbarobs(l))**2
                  endif
                end do
                if(ashden(l).ne.0.0)then
                  rsquare(l)=1.0-ashnum(l)/ashden(l) ! actually Nash effeciency
                else
                  rsquare(l)=-99.
                endif
              else
                rsquare(l)=-99.
              endif
            endif    !skipflg

!   REV. 8.83 - Nov. 30/96 - FIX DIVISION BY 0 - CHECK
c            if(area(l).le.0.0)then
c               write(6,6020)id,l,area(l)
c               print*,'spl.csv not written'
c               STOP 'Probram aborted in lst @ 410'  
c            endif

!           calculate the mm runoff          
            aaa=amin1(99999.0,aa(l)*float(kt)*3.6/area(l))
            bbb=amin1(99999.0,bb(l)*float(kt)*3.6/area(l))
            ccc=amin1(99999.0,cc(l)*float(kt)*3.6/area(l))
            if(aaa.gt.99998.9)aaa=-999.
            if(bbb.gt.99998.9)bbb=-999.
            if(ccc.gt.99998.9)ccc=-999.
            volhyd(l)=volhyd(l)*float(kt)*3.6/area(l)
            volsyn(l)=volsyn(l)*float(kt)*3.6/area(l)
!           calculate Dv
c            if(aaa.gt.0.0)then
            if(aaa.gt.1.0)then
               ab=(bbb-aaa)/aaa*100.
               statnerr(l)=(bb(l)-aa(l))/aa(l)*100.0
            else
               ab=-1.0
               statnerr(l)=-999.9
            endif

!           reinitialize flowflag - in flowinit is is basin only on year 1
            flowflag(l)=.false.
            if(statnerr(l).gt.-999.0)flowflag(l)=.true.

!           CALCULATION & PRINTING OF RECORDED DATA & CALCULATED  
!           HYDROGRAPHS.
!           FLOWS ARE REPORTED AT KT INTERVALS.

!		  write precip.txt
!     rev. 9.8.43  Jan.  31/13  - NK: fixed bug in lst.f : undefined output for iopt=99
!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99

!     REV. 10.1.31 May   15/16  - NK: Revised output to precip.txt : include all str stations
!           section moved outside inbsnflg loop (below)

            qmaxh=amax1(qmaxh,qpeakh(l))
            qmaxs=amax1(qmaxs,qpeaks(l))

           endif   !  inbsnflg
           
           
!     REV. 10.1.31 May   15/16  - NK: Revised output to precip.txt : include all str stations
c            if(iopt.lt.99.and.iopt.gt.0)then
            if(writeFlg(1))then   ! always print precip.txt so results can be compared during dds
!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
!             write only where there is data
	        i=(ystr(l)-yorigin)/ydelta+1
	        j=(xstr(l)-xorigin)/xdelta+1
              if(aaa.gt.ppsum(l)*0.01.and.inbsnflg(l).eq.1)then
                if(iopt.ge.2.and.iopt.le.10)
     *                    print*,'i,j,aaa,ppsum',i,j,aaa,ppsum
	          if(sta_area(l).gt.1.0)then
                  write(27,1018,iostat=ios)
c                  write(27,*)
     *            l,gage(l),area(l),ppsum(l),aaa,bbb,ccc,statnerr(l),
     *            rsquare(l),qpeakh(l),qpeaks(l),sta_area(l),area(l),
     *            (area(l)-sta_area(l))/sta_area(l)*100.0,
     *          ((areaclass(s(i,j),ii)/areasum(s(i,j))),ii=1,classcount)
	          else
                  if(iopt.ge.2.and.iopt.le.10)
     *                         print*,'i,j',i,j,areasum(s(i,j))
                  if(iopt.ge.2.and.iopt.le.10)print*,'i,j',i,j,
     *                 (areaclass(s(i,j),ii),ii=1,classcount)
c                  write(27,*)
                  write(27,1018,iostat=ios)
     *            l,gage(l),area(l),ppsum(l),aaa,bbb,ccc,statnerr(l),
     *            rsquare(l),qpeakh(l),qpeaks(l),sta_area(l),area(l),
     *                 -9999.0,
     *                 ((areaclass(s(i,j),ii)/areasum(s(i,j))),
     *                 ii=1,classcount)
                  endif
              else
!     rev. 10.1.09 Dec.  07/15  - NK: Add blank line for missing data in the precip.txt file in lst.f 
!               write a blank line to not screw up the numbering
!     rev. 10.2.18 Mar.  12/18  - NK: Fixed array fault in read_resv_ef and sub
                if(i.gt.0.and.i.le.ycount.and.
     *                             j.gt.0.and.j.le.xcount)then  
c                  if(s(i,j).gt.0)then
c                    write(27,1019,iostat=ios)l,gage(l),area(l),
                    write(27,1018,iostat=ios)l,gage(l),-999.0,
     *              -999.0,-999.0,-999.0,-999.0,-999.0,-99.0,
     *              -999.0,-999.0,-999.0,-999.0,-999.0,
     *               (-1.0,ii=1,classcount)
c                  endif
                endif
!     rev. 10.1.73 Mar.  27/17  - NK: Advisory message set in precip.txt for iopt=0 
              endif
            else  
              if(writeFlg(1))write(27,*)
              if(writeFlg(1))write(27,*)'Set iopt > 0 to get this table'
              if(writeFlg(1))write(27,*)
            endif

      end do
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

d	   if(iopt.eq.2)print*,' checkpoint 50 in lst'

!!!!     id=1

c!        WRITE THE SPL.PLT FILES - FOR THE SPLPLT PROGRAM
cc         write(58,6011)id,(smc5(ii),ii=1,classcount)
c         write(58,6400)
c
c         if(qmaxh.lt.10.0.and.qmaxs.lt.10.0)then
c            do k=kt,nl,kt
c               write(58,6401)k,(qhyd(l,k),qsyn(l,k),l=n,n1)
c            end do
c         else   
c            do k=kt,nl,kt
c               write(58,6402)k,(qhyd(l,k),qsyn(l,k),l=n,n1)
c            end do
c         endif
c       end do

c      close(unit=99,status='keep')


c      SUBROUTINE write_tb0(un,fn,nfg,ng,no_signf)

c     write the spl.tb0 file
!     rev. 9.8.48  Feb.  12/13  - NK: Replaced spl.plt with spl.tb0 file
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!                               - had to add xsta1 & ysta1 to allocation here as well

c      if(id.eq.1)then
      if(allocated(gname))then
c        deallocate(gname,xsta,ysta,xsta1,ysta1,stat=iDeallocate)
        deallocate(gname,stat=iDeallocate)
        if(ideallocate.ne.0)print*,
     *          'problem deallocating gname in lst @ 506'

      endif
      if(allocated(xsta))then
        deallocate(xsta,ysta,stat=iDeallocate)
        if(ideallocate.ne.0)print*,
     *          'problem deallocating xsta in lst @ 507'

      endif
      if(allocated(xsta1))then
        deallocate(xsta1,ysta1,stat=iDeallocate)
        if(ideallocate.ne.0)print*,
     *          'problem deallocating xsta1 in lst @ 508'

      endif
      
      allocate(gname(no*2),xsta(no*2),ysta(no*2),
     *              xsta1(no*2),ysta1(no*2),stat=iAllocate)
      if(iAllocate.ne.0)STOP
     *         'Error with allocation of gname lst & 522'


!     rev. 9.8.88  Oct.  26/13  - NK: Fixed header writing sequence for spl.tb0 
      author='WATFLOOD/CHARM                          '
      name='WATFLOOD model output: recorded/computed'
      coordsys_temp=coordsys1
      !     GreenKenue uses LatLong - code below uses LATLONG
      if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
      if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
      zone_temp=zone1
      datum_temp=datum1
      xorigin_temp=xorigin
      yorigin_temp=yorigin
      xcount_temp=no*2
      ycount_temp=nl/kt
      startdate='unknown   '
      starttime='unknown   '
      unit_conversion=1.0
      deltat_temp=kt*3600
      source_file_name='last spl run'   
      do l=1,no
        gname(l*2-1)=gage(l)
        xsta(l*2-1)=xstr(l)
        ysta(l*2-1)=ystr(l)
        gname(l*2)=gage(l)
        xsta(l*2)=xstr(l)
        ysta(l*2)=ystr(l)
      end do
      do l=1,2*no
        column_units(l)='cms' 
        column_type(l)='float'
      end do
!     REV. 10.1.38 Jul   28/16  - NK: Added noDataValue to WFO & tb0 files
      noDataValue=-999.0   
      
!     rev. 9.8.95  Nov.  20/13  - NK: Changed unit 58 to 22 for spl.tb0
      if(id.eq.1)then
!       write the header only once
!       and then just add data for each event      
!       writing to spl.tb0
        if(writeFlg(1))call write_tb0(955,955,1,no*2,8)
      endif

      if(allocated(outarray))then
        deallocate(outarray,stat=iDeallocate)
        if(ideallocate.ne.0)print*,
     *          'problem deallocating outarray in lst @ 573'
      endif
        
      allocate(outarray(nl/kt,no*2),stat=iAllocate)
      if(iAllocate.ne.0)STOP
     *         'Error with allocation of outarray lst & 511'
          
      do k=kt,nl,kt
        do l=1,no
          outarray(k/kt,l*2-1)=qhyd(l,k)
          outarray(k/kt,l*2)=qsyn(l,k)
        end do
      end do

!     rev. 9.8.95  Nov.  20/13  - NK: Changed unit 58 to 22 for spl.tb0
!     write the data to spl.tb0
      noDataValue=-999.0
      if(writeFlg(1))call write_tb0(955,955,0,no*2,12)    
        
!     close file after last event.      
      if(id.eq.ni)then
c        close(unit=22,status='keep')
        if(writeFlg(1))then
          write(51,*)'Closed unit 955 Filename=  ',fln(955)(1:40)
          write(*,*)'Closed unit 955 Filename=  ',fln(955)(1:40)
        endif
      endif

      deallocate(outarray,stat=iDeallocate)
      if(ideallocate.ne.0)print*,
     *          'problem deallocating outarray in lst @ 579'
      allocate(outarray(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0)STOP
     *         'Error with allocation of outarray lst & 582'


       
!     write a new mean_observed_flows.txt file if .not.exists
      if(dds_flag.eq.0.and.id.eq.ni)then
        inquire(FILE='mean_observed_flows.txt',EXIST=exists)
        if(.not.exists)then
          do l=1,no+noresvi
            if(nq(l).le.0)qbarobs(l)=-1.0
          end do
          open(unit=99,file='mean_observed_flows.txt',
     *              status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file mean_observed_flows.txt'
            print*,'Possible causes:'
            print*,'file in use by another application'
            stop 'Program aborted in lst.f @ 657'
          endif
d         print*,'reading the mean flows in sub'
          write(99,*)'Station Averages - observed'
          do l=1,no+noresvi
            write(99,*)l,qbarobs(l)
d            write(*,*)i,mean_observed(l)
          end do
          close(unit=99,status='keep')
          print*
          print*,'mean_observed_flows.txt written'
          print*,'for ',no,' flow stations and'
          print*,'for ',noresvi,' reservoirs'
          print*
        endif
      endif

!     * * * * * * * * * * * * * * * * 

d	if(iopt.eq.2)print*,' checkpoint 60 in lst'

!     * * * * * * * * * * * * * * * * * * * * * * * * *
!     CALCULATE MONTHLY FLOWS:
!     * * * * * * * * * * * * * * * * * * * * * * * * *
      do l=1,no
	  if(nqevent(l).gt.1)then
          qhydevent(l)=qhydevent(l)/nqevent(l)
          qsynevent(l)=qsynevent(l)/nqevent(l)
        else
          qhydevent(l)=-999.0
          qsynevent(l)=-999.0
        endif
      end do


d	if(iopt.eq.2)print*,' checkpoint 70 in lst'

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     THIS SECTION PRINTS THE ERROR FIELD ON GAUGED WATERSHEDS ONLY
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

!     rev. 9.7.09  Oct.  11/10  - NK: update flowflag in lst.f for subsequent events
!     update the flow flag incase flows were found in later events

      do l=1,no
	  suberr(l)=statnerr(l)
	end do

c!     rev. 9.7.01  Jun.  09/10  - NK: fixed error.xyz & error.r2s

!     pause 103

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
c      if(id.eq.ni.and.abs(dds_flag).ne.1)then  ! this part only when all done after last event

      if(writeflg(1))then
      if(id.eq.ni.and.dds_flag.ne.-1)then  ! this part only when all done after last event
c        if(dsflg.eq.'n')then
c          write(98,*)'++++++++++ WARNING++++++++++'
c          write(98,*)'Subarea assumed= 1.0 where -ve areas calculated'
c          write(98,*)'Probable cause: '
c          write(98,*)' two or more stream gaugesin one grid'
c          write(98,*)'                 or'
c          write(98,*)' stations not ordered in the downstream direction'
c          write(98,*)'>>>>>>Fatal mess for PAF file<<<<<<<'
c          write(98,*)
c          write(98,*)
c          write(*,*)'++++++++++ WARNING++++++++++'
c          write(*,*)'Subarea assumed= 1.0 where -ve areas calculated'
c          write(*,*)'Probable cause: '
c          write(*,*)' two or more stream gaugesin one grid'
c          write(*,*)'                 or'
c          write(*,*)' stations not ordered in the downstream direction'
c          write(*,*)'>>>>>>Fatal mess for PAF file<<<<<<<'
c          write(*,*)
c          write(*,*)'See spl.err file for more details'
c          write(*,*)
c        endif

!       WRITE THE RUNOFF ERRORS IN A GRIDDED FORMAT FOR THE 
!       srfERROR.TXT FILE 
!           unit 66 = simout\error.xyz
!           changed to Nash efficiency Dec. 12/15 NK  nash_eff.r2c
c        open(unit=66,file=filename(66),status='unknown',iostat=ios)
c        if(ios.ne.0)then    ! added Nov. 10/14  nk
c          print*
c          print*,'Unable to open file',filename(66)(1:40)
c          print*,'Possible causes:'
c          print*,'file in use by another application'
c          print*,'or target directory does not exist'
c          stop 'Program aborted in lst.f @ 744'
c        endif
!         write(66,6676)hrs,mins,secs,day,month,year
c        do i=1,ycount
c          do j=1,xcount
c            if(basinerr(i,j).lt.999.0)then
c              if(llflg.ne.'y')then
cc               ig,jg = utm coordinates
c                aig=float(iymin+(i-1)*istep)+float(istep)/2.0
c                ajg=float(jxmin+(j-1)*istep)+float(istep)/2.0
c!                write(66,6093)nbasin(i,j),i,j,ig,jg,basinerr(i,j),
c!     *                        precadj(i,j)
c              else
cc               ig,jg = lat-long in degrees.00
c                aig=(float(iymin)+float(i-1)*grdn+grdn/2.0)/60.0
c                ajg=(float(jxmin)+float(j-1)*grde+grde/2.0)/60.0
c!                write(66,6094)nbasin(i,j),i,j,aig,ajg,basinerr(i,j),
c!     *                        precadj(i,j)
c              endif
c              write(66,6095)ajg,aig,basinerr(i,j)
c            endif
c          end do
c        end do
c        close(unit=66,status='keep')

!       rev. 9.7.01  Jun.  09/10  - NK: fixed error.xyz & error.r2s
!       rev. 9.7.09  Oct.  11/10  - NK: update flowflag in lst.f for subsequent events
!       update the flow flag incase flows were found in later events
!        check to see if all stations have and error value
!       added a bunch of checks Dec. 15/10 nk
        do i=1,no
          if(inbsnflg(i).eq.1)then
            do l=1,no
              if(inbsnflg(l).eq.1.and.ds_sta(l).gt.0)then
                if(.not.flowflag(l).and.flowflag(ds_sta(l)))then
                  statnerr(l)=statnerr(ds_sta(l))
                  flowflag(l)=.true.
                endif  
	        endif
  	      end do
  	    endif
	  end do
         
!       NOT CORRECTED FOR U/S ERRORS < < < < < < < < <   
!       to get error for each sub basin use nudging 
        do i=1,ycount
          do j=1,xcount
            basinerr(i,j)=-999.000
            nasheff(i,j)=-999.000
          end do
        end do
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          if(nbasin(i,j).ne.0)then
            l=nbasin(i,j)
!           WE ARE IN A GAUGED SUB-AREA
            basinerr(i,j)=statnerr(l)
!     rev. 10.1.12 Dec.  12/15  - NK: Added Nash Efficiency nasheff.r2c file unit-66
            nasheff(i,j)=rsquare(l)    ! Nash efficiency actually
          endif
        end do

!     rev. 9.3.07  Dec.  29/06  - NK: added error field for whole domain
        author='WATFLOOD/CHARM                          '
        name='Volume errors in %                      '
        coordsys_temp=coordsys1
        zone_temp=zone1
	  datum_temp=datum1
	  xorigin_temp=xorigin
	  yorigin_temp=yorigin
	  xcount_temp=xcount
	  ycount_temp=ycount
	  xdelta_temp=xdelta
	  ydelta_temp=ydelta
	  startdate='unknown   '
	  starttime='unknown   '
        unit_conversion=1.0
          attribute_count=1
	    attribute_name='error                                    '
	    attribute_units='percent                                 ' 
        source_file_name='last spl run'     
        do j=1,xcount
	    do i=1,ycount
            outarray(i,j)=amin1(basinerr(i,j),999.000)
            outarray(i,j)=amax1(basinerr(i,j),-999.000)
	    end do
	  end do
        
!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99
        if(dds_flag.ne.1.and.iopt.lt.99)then
!         write the header for error.r2c
!       written in sub for ddsflg=1
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(67,67,0,0,0,0,11)   
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         write the data
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(67,67,0,0,0,1,11)   
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  endif


!     rev. 10.1.12 Dec.  12/15  - NK: Added Nash Efficiency nasheff.r2c file unit-66
        author='WATFLOOD/CHARM                          '
        name='Nash_Efficiency                         '
        coordsys_temp=coordsys1
	    attribute_name='Nash Efficiency                          '
	    attribute_units='dimensionless                            ' 
        source_file_name='last CHARM run                          '
        do j=1,xcount
	    do i=1,ycount
            outarray(i,j)=nasheff(i,j)
	    end do
	  end do
        
!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99
        if(dds_flag.ne.1.and.iopt.lt.99)then
!         write the header for error.r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(66,66,0,0,0,0,11)   
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         write the data
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(66,66,0,0,0,1,11)   
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  endif

!     rev. 9.9.39  Nov.  14/14  - NK: Modifications for watroute
      if(modelflg.eq.'n')then     ! this section not needed for watroute
!     rev. 9.3.07  Dec.  29/06  - NK: added sum_precip for whole domain
        fln(99)='sum_precip.r2c'
        author='watflood                                '
        name='Model run summed precip                 '
        unit_conversion=1.0
	  attribute_name='sum precipitation                       '
	  attribute_units='mm                                      ' 
!        attribute_type='Runoff                                  '  
        source_file_name='last spl run'     
        do j=1,xcount
	    do i=1,ycount
c            outarray(i,j)=sum_precip(i,j)
	    end do
	  end do
        
!     rev. 9.9.22  Jul.  29/14  - NK: Fixed basin no assignment in flowinit.f
!       write the header
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(99,99,1,0,0,0,10)   
        call write_r2c(99,99,0,1,0,0,10)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       write the datawrite_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(99,99,1,1,1,1,10)   
        call write_r2c(99,99,0,1,0,1,10)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
        fln(99)='sum_runoff.r2c'
        author='watflood                                '
        name='Model run summed runoff                 '
        unit_conversion=1.0
	  attribute_name='sum runoff                              '
	  attribute_units='mm                                      ' 
!        attribute_type='Runoff                                  '  
        source_file_name='last spl run'     
        do j=1,xcount
	    do i=1,ycount
              outarray(i,j)=0.0
              n=s(i,j)
              if(n.gt.0)outarray(i,j)=QQsum(n)/da(n)
	    end do
	  end do
        
!     rev. 9.9.22  Jul.  29/14  - NK: Fixed basin no assignment in flowinit.f
!       write the header
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(99,99,1,0,0,0,10)   
        call write_r2c(99,99,0,1,0,0,10)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       write the datawrite_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(99,99,1,1,1,1,10)   
        call write_r2c(99,99,0,1,0,1,10)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
d         if(iopt.eq.2)then
d           print*,' In lst before writing to newerror.txt'
d           print*
d         endif

d	  if(iopt.eq.2)print*,' checkpoint 80 in lst'

         if(dds.eq.0)then
           do i=ycount,1,-1
              do j=1,xcount
	          basinerr(i,j)=amin1(999.0,basinerr(i,j))
	          basinerr(i,j)=amax1(-999.0,basinerr(i,j))
c	          basinerr(i,j)=amax1(0.0,basinerr(i,j))
                if(abs(basinerr(i,j)).ge.999.0)basinerr(i,j)=0.0
              end do
           end do
           if(pafflg.eq.'y')then
!            WRITE THE GRIDDED FLOW ERRORS FOR EACH WATERSHED
             INQUIRE(FILE='paf.r2s',EXIST=exists)
             if(.not.exists)then
               INQUIRE(FILE='newerror.txt',EXIST=exists)
!              write a newerror.txt file only when an error file already exists.   
               open(unit=99,file='newerror.txt',status='unknown',
     *                                               iostat=ios)
               if(ios.ne.0)then    ! added Nov. 10/14  nk
                 print*
                 print*,'Unable to open file newerror.txt'
                 print*,'Possible causes:'
                 print*,'file in use by another application'
                 stop 'Program aborted in lst.f @ 908'
               endif
               if(exists)then
                 do while(.not.eof(99))
                   read(99,*,iostat=ios)line
                 end do
                 backspace 99
                 backspace 99
                 read(99,*)nblock
                 backspace 99
               else 
                 nblock=0
               endif
	      
               print*
	         print*,'A newerror.txt file with',nblock
	         print*,'blocks of data has been found '
	         print*,'Do you want to continue with this old file'
	         print*,'and add to it ...`y`'
	         print*,'or delete this file ... `n`?'
	         print*,'Answer:'
	         read*,answer
	         print*,answer
	         if(answer.eq.'n')then
                 close(unit=99,status='delete')
                 print*,'old mewerror.txt file deleted'                        
    	           nblock=0   ! start a new newerror.txt file
               else
                 print*,'To continue the sequence of refining the PAF'
                 print*,'copy newerror.txt to error.txt and rerun the'
                 print*,'the program (SPLXnn)'
                 print*,'This will create a newpaf.r2s file'
                 print*,'which can be copied to paf.r2s and used as a '
                 print*,'permanent PAF'
                 print*,'If a paf.r2s file is found, it will take'
                 print*,'precedence over the error.txt file'
               endif	      

               nblock=abs(nblock)+1
               write(99,6670)nblock,time(1:2),time(3:4),time(5:6),
     *          cday(1:4),cday(5:6),cday(7:8)
!     rev. 9.5.69  Oct.  10/09  - NK: added xcount & ycount to error & paf files
               write(99,*)':xcount',xcount
	         write(99,*)':ycount',ycount
               do i=ycount,1,-1
                 write(99,6090)(basinerr(i,j),j=1,xcount)
               end do
               write(99,*)-1*nblock    ! no more data
               close(unit=99,status='keep')
               print*,'newerror.txt file has been written'
               print*
             endif
      
           endif
         endif

         endif    ! modelflg.eq.'n'


d	   if(iopt.eq.2)print*,' checkpoint 90 in lst'

!        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!        WRITE THE  FLOW ERRORS .xyz file FOR EACH WATERSHED:
!        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c         open(unit=66,file=filename(66),status='unknown',iostat=ios)
c         if(ios.ne.0)then    ! added Nov. 10/14  nk
c           print*
c           print*,'Unable to open file',filename(66)(1:40)
c           print*,'Possible causes:'
c           print*,'file in use by another application'
c           print*,'or target directory does not exist'
c           stop 'Program aborted in lst.f @ 974'
c         endif
c!        changed filename and unit number to fln list mar02/04  nk
c      
c!        WRITE ..\simout\error.xyz   
c         if(llflg.ne.'y')then
c           istep=int(astep)
c           do i=1,ycount
c             do j=1,xcount
c               if(nbasin(i,j).gt.0)then
c                 ig=iymin*1000+(i-1)*istep*1000
c                 jg=jxmin*1000+(j-1)*istep*1000
c                 write(66,207)float(jg),float(ig),basinerr(i,j)
c!                 write(*,207)float(jg),float(ig),basinerr(i,j)
c               endif
c             end do
c           end do
c         else
c           istep=int(astep)
c           do i=1,ycount
c             do j=1,xcount
c               if(nbasin(i,j).gt.0)then
c                 write(66,201)(float(jxmin)+float(j-1)*grde)/60.0,
c     *                 (float(iymin)+float(i-1)*grdn)/60.0,
c     *                 basinerr(i,j)
c               endif
c             end do
c           end do
c         endif
c         close(unit=66,status='keep')

        endif   !id=ni
        endif   ! if(writeflg(1))


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     NOW WRITE A COMMA SEPERATED FILE FOR A SPREADSHEET:  spl.csv
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

d      if(iopt.eq.2)then
d        print*,' In lst before reading to unit 60'
d        print*
d      endif

!     Append to existing files
!     FOR THE RESUME CASE, GO TO THE END OF THE output FILEs: 
!     rev. 9.8.27  Sep.  27/12  - NK: changed action on resumflg='s' - keep tbcflg='y'
      if(resumflg.ne.'n'.and.contflg.eq.'y'.and.id.eq.1)then
        ios=0
        do while (ios.eq.0)
          read(51,6040,iostat=ios)tempflg  ! simout\spl.txt
        end do
        ios=0
        do while(ios.eq.0)
          read(60,6040,iostat=ios)tempflg  ! simout\spl.csv
        end do
        ios=0
        do while(ios.eq.0)       
          read(68,6040,iostat=ios)tempflg  ! simout\wetland.csv
        end do
        ios=0
        do while(ios.eq.0)
          read(73,6040,iostat=ios)tempflg  ! simout\resin.csv
        end do
      endif

d      if(iopt.eq.2)then
d        print*,' In lst before writing to unit 60'
d        print*
d      endif

!      write(60,6400)
!     FOR SMALL RECORD LENGTH


!     for grid shifting, we need sequential k's for spaghetti plots
      if(igrdshft.ne.0.and.id.eq.1)then
         kfirst=0
      endif

!     in the future, this section can be used to print out flows only when computed.
!
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     PRINT spl.csv and EVENT MEANS
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

! martin 
!     rev. 9.8.47  Feb.  04/13  - NK: Headers added for spl & resin csv files
!     rev. 9.9.66  Apr.  29/15  - NK: Deleted mid_file headers in with tbcflg=y
      if(writeflg(60))then
          if(id.eq.1.and.hdrflg0.and.contflg.eq.'n')then 
!        write the headers for spl.csv
              write(60,60001)start_date,
     *            (gage(l),'_obs',gage(l),'_SIM',l=1,no)
60001         format(a12,<no>(',',a12,a4,',',a12,a4))     
          endif
 
!      if(kt.ge.irdt)then
!     NOTE:
!     qsyn & qhyd were turned into the mean flow for the time step above
!     For WATROUTE  output is wrt.csv and NIT spl.csv

        if(kt.ge.1)then
          do k=kt,nl,kt
            kfirst=kfirst+kt
c                  write(800,*)nl,kt,k,kfirst
            write(60,7401)kfirst,(qhyd(l,k),qsyn(l,k),l=1,no)
          end do
          write(75,7401)year_now,(qhydevent(l),qsynevent(l),l=1,no)
        else
          do k=irdt,nl,irdt
            kfirst=kfirst+irdt*kt
c              write(800,*)nl,kt,k,kfirst
            write(60,7401)kfirst,(qhyd(l,k),qsyn(l,k),l=1,no)
          end do
          write(75,7501)(qhydevent(l),qsynevent(l),l=1,no)
        endif
      endif
      
!     rev. 10.2.15 Feb.  05/18  - NK: Added 'results\monthly_peaks'
      if(iopt99)then
        do j=1,mhtot/732+1
!     rev. 10.2.41 Dec.  10/18  - NK: Added winter monthly peaks
          if(j.le.4.or.j.eq.12)then
            write(21,31000)j,(qp_month_hyd(l,j),
     *                             qp_month_syn(l,j),l=1,no)
          endif
          write(22,31000)j,(qp_month_hyd(l,j),qp_month_syn(l,j),l=1,no)
31000     format(i10,<2*no>f12.3)
        end do
      endif
      
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(xmlflg.eq.'y')then
        call write_xml
      endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      

!     Append this year's natural flow to the file:
      if(MRBflg)then
        open(unit=99,file='MRB_WILLISTON_INFLOWS.new',status='old')
!     First go to the end of the file
        n=-23    ! subtract # header lines
        do while(.not.eof(99))
          read(99,*)line
          n=n+1
        end do
!     Then add the nest year's worth of data
        do k=1,nl/24       ! assuming always 24 hour data
          write(99,65001)(MRBdata(i,k+n),i=1,2),qsyn(33,k*24)
65001     format(3f10.3)     
        end do      
        close(unit=99,status='keep')
      endif

!     rev. 9.2.19  Oct.  28/05  - NK: Compute daily & monthly flows
!     rev. 9.7.25  Apr.  28/11  - NK: Fixed daily flows

!     calculate and write the daily flows to ..\simout\spl_dly.csv
c      if(kt.lt.24)then    won't work for other dt's
      if(kt.eq.1.and.writeflg(71))then
        do l=1,no
          do j=1,nl/24*24,24
            qhyd_dly_sum(l)=0.0
            qsyn_dly_sum(l)=0.0
	      i=0
	      ii=0
	      tmpflg=.true.
            do k=j,j+23,kt
              if(qhyd(l,k).gt.0)then
                qhyd_dly_sum(l)=qhyd_dly_sum(l)+qhyd(l,k)
	          ii=ii+1
	        else
	          qhyd_dly_sum(l)=0.0
	          tmpflg=.false.
	        endif
              qsyn_dly_sum(l)=qsyn_dly_sum(l)+qsyn(l,k)
	        i=i+1
            end do
	      if(ii.gt.0)then
              qhyd_dly(l,(j+23)/24)=qhyd_dly_sum(l)/float(ii)
	      else
              qhyd_dly(l,(j+23)/24)=-1.0  ! set -1 if data = missing
	      endif
            qsyn_dly(l,(j+23)/24)=qsyn_dly_sum(l)/float(i)
          end do
        end do

        if(writeflg(71))then
          do j=1,nl/24,kt
            write(71,7404)j,(qhyd_dly(l,j),qsyn_dly(l,j),l=1,no)
          end do
        endif
	else
!       get rid of any hourly file
        inquire(FILE=filename(71),EXIST=exists)  
	  if(exists)close(unit=71,status='delete')      
      endif
      
      
!     rev. 9.9.76  Sep.  11/15  - NK: Added recorded isotope concentrations
      if(frcflg.eq.'y'.and.allocated(iso_18O))then
        if(.not.allocated(iso_sumO_18O))then    !changed by NK Jan 22/16
c        if(firstpass.eq.'y')then
          open(unit=82,file=filename(82),status='unknown')
          open(unit=83,file=filename(83),status='unknown')
          allocate(iso_sumO_18O(n18O),iso_sumO_2H(n18O),
     *             iso_sum_18O(n18O),iso_sum_2H(n18O),
     *             iso_msim2_18O(n18O),iso_msim2_2H(n18O),
     *             iso_obs2_18O(n18O),iso_obs2_2H(n18O),
     *             iso_mobs2_18O(n18O),iso_mobs2_2H(n18O),
     *             iso_obs_18O(n18O),iso_obs_2H(n18O),
     *             iso_csum_18O(n18O),iso_csum_2H(n18O),     
     *             iso_rms_18O(n18O),iso_rms_2H(n18O),
     *             iso_n_18O(n18O),iso_n_2H(n18O),
     *             iso_omobs2_18O(n18O),iso_omobs2_2H(n18O),
     *         stat=iAllocate)
          if (iAllocate.ne.0) STOP 
     *    'Warning: error with allocation of iso error arrays in lst'
          do j=1,n18O
            iso_sumO_18O(j)=0.0
            iso_sumO_2H(j)=0.0
            iso_sum_18O(j)=0.0
            iso_sum_2H(j)=0.0
            iso_msim2_18O(j)=0.0
            iso_msim2_2H(j)=0.0
            iso_obs2_18O(j)=0.0
            iso_obs2_2H(j)=0.0
            iso_mobs2_18O(j)=0.0
            iso_mobs2_2H(j)=0.0
            iso_obs_18O(j)=0.0
            iso_obs_2H(j)=0.0
            iso_csum_18O(j)=0.0
            iso_csum_2H(j)=0.0
            iso_n_18O(j)=0
            iso_n_2H(j)=0
            iso_omobs2_18O(j)=0.0
            iso_omobs2_2H(j)=0.0
          end do
        endif

!     rev. 10.1.88 May   23/17  - NK: Fixed Julian_day problems for iso R/W
c        if(id.eq.ni.or.jul_day_now.ge.365)then
        if(jul_day_now.eq.1.and.hour_now.eq.24)then
            
!         write the isotope data after the last event or on the last day of the year
!         as the recorded isotope file is always for a whole calendar year.        

          if(leapyear)then  
            jd=366
          else
            jd=365
          endif
              
          do i=1,jd
            write(82,82001)i,(iso_18O(i,j),dstr_18O(i,j),j=1,n18O)
82001       format(i10,<2*n18O>(',',f10.2))          
          end do  
          
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
          if(flg2H.eq.2)then
          do i=1,jd
            write(83,82001)i,(iso_2H(i,j),dstr_2h(i,j),j=1,n2H)
          end do 
          endif 
          
 !     rev. 10.1.05 Oct.  11/15  - NK: Iso RMS error 
          write(81,*)
          write(81,*)'Item      Jul_day     location        #',
     *               '   Observed       Computed'     
          do j=1,n18O
            do i=1,jd
 !             select only days with data for error calculation            
              if(iso_18O(i,j).gt.-90000.0)then
!               accumulate sums for average values                                    
                iso_sumO_18O(j)=iso_sumO_18O(j)+iso_18O(i,j)
                iso_sum_18O(j)=iso_sum_18O(j)+dstr_18O(i,j)  
                iso_obs2_18O(j)=iso_obs2_18O(j)+
     *                          (dstr_18O(i,j)-iso_18O(i,j))**2
                iso_obs_18O(j)=iso_obs_18O(j)+
     *                          (dstr_18O(i,j)-iso_18O(i,j))
                iso_n_18O(j)=iso_n_18O(j)+1
                write(81,*)'18O',i,j,
     *                   iso_n_18O(j),iso_18O(i,j),dstr_18O(i,j)
              endif
            end do
          end do
          write(81,*)
          if(flg2H.eq.2)then
          write(81,*)'Item     Jul_day     location        #',
     *               '   Observed       Computed'     
          do j=1,n2H
            do i=1,jd
!             select only days with data for error calculation            
              if(iso_2H(i,j).gt.-90000.0)then
!               accumulate sum of squares              
                iso_sumO_2H(j)=iso_sumO_2H(j)+iso_2H(i,j)
                iso_sum_2H(j)=iso_sum_2H(j)+dstr_2H(i,j)  
                iso_obs2_2H(j)=iso_obs2_2H(j)+
     *                          (dstr_2H(i,j)-iso_2H(i,j))**2
                iso_obs_2H(j)=iso_obs_2H(j)+
     *                          (dstr_2H(i,j)-iso_2H(i,j))  
                iso_n_2H(j)=iso_n_2H(j)+1
                write(81,*)'2H',i,j,
     *                  iso_n_2H(j),iso_2H(i,j),dstr_2H(i,j)
              endif
            end do
          end do
          endif  
!       calcualte the iso error up to this point        
          do j=1,n18O
            iso_rms_18O(j)=sqrt(iso_obs2_18O(j)/iso_n_18O(j))
            iso_rms_2H(j)=sqrt(iso_obs2_2H(j)/iso_n_2H(j))
          end do
          
          write(81,*)'Isotope RMS error 18O'
           write(81,*)'   Location   # readings   RMS error'
          do j=1,n18O
             write(81,*)j,iso_n_18O(j),iso_rms_18O(j)
          end do
          write(81,*)
           write(81,*)'Isotope RMS error 2H'
           write(81,*)'   Location   # readings   RMS error'
          do j=1,n2H
             write(81,*)j,iso_n_2H(j),iso_rms_2H(j)
          end do
           write(81,*),'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
           
c!     rev. 10.1.89 May   25/17  - NK: Added errflg = 11 for isotope DDS
c          if(id.eq.ni)then
c            write(*,*)
c            write(*,*)'Isotope RMS error 18O'
c            write(*,*)'   Location   # readings   RMS error'
c             do j=1,n18O
c             write(*,*)j,iso_n_18O(j),iso_rms_18O(j)
c            end do
c            write(*,*)
c            write(*,*)'Isotope RMS error 2H'
c            write(*,*)'   Location   # readings   RMS error'
c            do j=1,n2H
c              write(*,*)j,iso_n_2H(j),iso_rms_2H(j)
c            end do
c          endif
        endif
      endif   ! frcflg.eq.'y'
 !     END rev. 10.1.05 Oct.  11/15  - NK: Iso RMS error 

!     calculate and write the monthly flows to ..\simout\spl_mly.csv
!     We can do this only if the event is at least one month duration
!     Split the year in to 12 equal lenght events of 730 hour
      if(mhtot.gt.670.and.mhtot.lt.745)then
        nmonths=1
      else
        nmonths=min(mhtot/720,12)     ! approximately
!       so if there are fractions of months, the last month will be ignored        
      endif

!     write the monthly flows
      evt_hrs=mhtot
C      if(nmonths.eq.1)then    ! changed ge to eq   mar 15/06  nk
      if(nmonths.ge.1.and.iopt99)then    ! changed ge to eq   mar 15/06  nk
!       we have month-long events
        do l=1,no
          if(nmonths.eq.1)then
	      hour_no=0
            j=1
            qhyd_mly_sum(l)=0.0
            qsyn_mly_sum(l)=0.0
            do k=1,nl
	        hour_no=hour_no+1    ! count hours
              qhyd_mly_sum(l)=qhyd_mly_sum(l)+qhyd(l,k)
              qsyn_mly_sum(l)=qsyn_mly_sum(l)+qsyn(l,k)
            end do
            qhyd_mly(l,j)=amax1(0.0001,qhyd_mly_sum(l)/float(hour_no))
            qsyn_mly(l,j)=qsyn_mly_sum(l)/float(hour_no)
          else  
!          we have events > 1 month - yearly events assumed
!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
	      hour_no=0
            do j=1,nmonths
c            do j=1,12
              qhyd_mly_sum(l)=0.0
              qsyn_mly_sum(l)=0.0
              hour_neg=0
!             run through the months
              do k=1,mohours(j)
	          hour_no=hour_no+1    ! count hours
	          if(qhyd(l,hour_no).lt.0.0)then    !<<<<<<<<<<<<<<<<<<<<<<<
                  hour_neg=hour_neg+1 ! count hours with no data
!                 dont plot data for month with missing data
                endif
                qhyd_mly_sum(l)=amax1(0.0,qhyd_mly_sum(l))+
     *                  			              qhyd(l,hour_no)
                qsyn_mly_sum(l)=qsyn_mly_sum(l)+qsyn(l,hour_no)
              end do
              qhyd_mly(l,j)=qhyd_mly_sum(l)/float(mohours(j))
              qsyn_mly(l,j)=qsyn_mly_sum(l)/float(mohours(j))
c	pause
            end do
          endif
        end do
        do j=1,nmonths
c        do j=1,12
          write(78,7401)j,(qhyd_mly(l,j),qsyn_mly(l,j),l=1,no)
        end do
        do j=1,12
          do l=1,no
            if(qhyd_mly(l,j).gt.0.0)then
               mnl_diff(l)=qsyn_mly(l,j)-qhyd_mly(l,j)
            else
               mnl_diff(l)=-1.0e10
            endif
          end do
            write(960,7401)j,(mnl_diff(l),l=1,no)

!     rev. 9.9.24  Aug.  20/14  - NK: Added monthly mean flow csv file spl_mly_nn.csv
c         write(960+j,7401)id,(qhyd_mly(l,j)*kt,qsyn_mly(l,j),l=1,no)
        end do
          write(961,7401)id,(qhyd_mly(l,1)*kt,qsyn_mly(l,1),l=1,no)
          write(962,7401)id,(qhyd_mly(l,2)*kt,qsyn_mly(l,2),l=1,no)
          write(963,7401)id,(qhyd_mly(l,3)*kt,qsyn_mly(l,3),l=1,no)
          write(964,7401)id,(qhyd_mly(l,4)*kt,qsyn_mly(l,4),l=1,no)
          write(965,7401)id,(qhyd_mly(l,5)*kt,qsyn_mly(l,5),l=1,no)
          write(966,7401)id,(qhyd_mly(l,6)*kt,qsyn_mly(l,6),l=1,no)
          write(967,7401)id,(qhyd_mly(l,7)*kt,qsyn_mly(l,7),l=1,no)
          write(968,7401)id,(qhyd_mly(l,8)*kt,qsyn_mly(l,8),l=1,no)
          write(969,7401)id,(qhyd_mly(l,9)*kt,qsyn_mly(l,9),l=1,no)
          write(970,7401)id,(qhyd_mly(l,10)*kt,qsyn_mly(l,10),l=1,no)
          write(971,7401)id,(qhyd_mly(l,11)*kt,qsyn_mly(l,11),l=1,no)
          write(972,7401)id,(qhyd_mly(l,12)*kt,qsyn_mly(l,12),l=1,no)
      else
        if(iopt99)write(78,*)'Events shorter than one month. No data'
      endif

d	if(iopt.eq.2)print*,' checkpoint 100 in lst'

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     NEW - REV. 7.41 - OUTPUT TO INPUT FILES . . . . .
!     Write the background streamflow file        strout.1
!     This file can be used to compare future runs to previous runs
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

c********************************************************************
!     ver. 9.1 - sediment component
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
d      if(iopt.eq.2)then
d        print*,' In lst before writing to unit 69'
d        print*
d      endif

      if(sedflg.eq.'y')then
!       output the sediment output:

        if(id.eq.1)then
          col_name(1)=
     *'SC kg/m3,   SM ton,  NC kg/m3,    NM ton,  PC kg/m3,  PM ton'
          do l=1,no
            col_name(l)=col_name(1)
          end do
           WRITE(69,6678)(l,col_name(l),l=1,no)
6678       format('hour,',99(i3,a60,'  ,'))
       endif


        do 393 k = kt,nl,kt
           write(69,6404)K,(sedsyn(L,K),sedmss(L,K),
     *       nitsyn(L,K),nitmss(L,K),
     *       phssyn(L,K),phsmss(L,K),L=1,No)
  393   continue
      endif

d      if(iopt.eq.2)then
d        print*,' In lst before writing to unit 59'
d        print*
d      endif

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     CREATE THE STAGE HYDROGRAPHS FOR THE DAMAGE LOCATIONS:
!     THE QHYD VARIABLE IS NOW REUSED AS THE STAGE VARIABLE
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     output for stage plots      
      if(writeFlg(59))then
          open(unit=59,file=filename(59),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file',filename(59)(1:40)
              print*,'Possible causes:'
              print*,'file in use by another application'
              print*,'or target directory does not exist'
              stop 'Program aborted in lst.f @ 1285'
          endif
          write(59,1000)fln(10)
          write(59,1015)no,nl,mhtot,kt
          write(59,1004)ndam
          do l=1,ndam
               write(59,1100)iys(l),jxs(l),damage(l),(frcs(l,i),i=1,4),
     *                 datum(l)
          end do

!         WRITE THE NOTES:
          write(59,1098)(note(i),i=1,nnnote)
          write(59,6400)
          if(ndam.gt.0)then
              do k=kt,nl,kt
                  do l=1,ndam
                      i=iys(l)
                      j=jxs(l)
!       TS - SET QLOC TO MIN VALUE B/C OF ERRORS IN DEBUGGING (OCT.30/03)
	                if(qloc(l,k).lt.0.0)qloc(l,k)=0.0001
	                if(s(i,j).ne.0)then
c                         qhyd(l,k)=frcs(l,1)*qloc(l,k)**frcs(l,2)
                      else
	                    qloc(l,k)=0.0001
	                    qhyd(l,k)=0.0001
	                endif
                  end do
                  write(59,6403,iostat=ios)
     *                  k,(qloc(l,k),qhyd(l,k),l=1,ndam)
              end do
          endif
!      close(59,status='keep')
      endif   
      
	If(ios.ne.0)then
	  write(99,99001)
99001   format(' WARNING: problems writing to unit 59 stg.plt')
	endif

d      if(iopt.eq.2)then
d        print*,' In lst before writing to unit 70'
d        print*
d      endif


! fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix fix 
! this section needs to be done by write_flow1d
! populate the array etc.

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     WRITE THE FILE FOR external DW routing in tb0 format
!     WRITE THE FILE FOR external DW routing in tb0 format
!     WRITE THE FILE FOR external DW routing in tb0 format
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


!     REV. 7.2 Sept. 19/94 - ADDED IREACH(N) FOR DWOPER or Flow1D INPUT 
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     REV. 10.1.15 Jan.  08/16  - NK: Custom coding for Mackenzie River Basin Hydraulic Model
!     REV. 10.1.28 Apr.  26/16  - NK: Fixed first day of output for master_inflows file 
!     maxr = no of reservoirs - i.e. don't write if there are no reservoirs/reaches
      if(maxr.gt.0.and.routeflg.eq.'q'.and.dds_flag.eq.0)then
!       averaging the flows for the day      
        do mh=24,mhtot,24
  	    do i=1,maxr
	      q24(i)=0.0
            do j=mh-23,mh
              q24(i)=q24(i)+qdwpr(i,j)

c      if(i.eq.1)print*,j,q24(i),qdwpr(i,j)

	      end do
            q24(i)=q24(i)/24.0

c      if(i.eq.1)print*,j,q24(i)

c      if(i.eq.1)pause 'lst.f'


	    end do
!         Note:the last 22 lakes are not to be written to this file but 
!         passed through rerout for natural lake routing
!         Note: write_flow1d_tb0 is not called here as we need to write
!         the file continuously for the whole run
!         tHE HEADER IS WRITTEN IN sub.F
!         this should be changed to call write_flow1d_tb0 if possible
          write(70,5001)(q24(i),i=1,126)  ! just the # of MRBHM nodes
        end do
	endif

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     WRITE THE RESERVOIR INFLOW FILES 
!     DWOPER FLOWS IN COLUMN FORMAT FOR PLOTTING MAYBE 
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
d        if(iopt.eq.2)then
d          print*,' In lst before writing to unit 70'
d          print*
d        endif
      if(id.eq.1)then
        write(53,*)'In lst'
        write(53,*)'Reservoir inflows this event:'
	endif

      do mh=kt,mhtot,kt
 	  do i=1,maxr
	    q24(i)=0.0
          do j=mh-kt+1,mh
            q24(i)=q24(i)+qdwpr(i,j)
	    end do
          q24(i)=q24(i)/float(kt)
	  end do
        write(53,201)(q24(i),i=1,maxr)
      end do

!     rev. 9.6.03  Mar.  31/10  - NK: replaced leakage.dat by nbs.tb0
!     write the net basin supply for the great lakes
c      if(resname(1).eq.'Superior     ')then
c        do mh=kt,mhtot,kt
c          write(79,5001)qdwpr(1,mh),
c     *		qdwpr(2,mh)-qdwpr(1,mh),
c     *		qdwpr(3,mh)-qdwpr(2,mh),
c     *		qdwpr(4,mh)-qdwpr(3,mh),
c     *		qdwpr(5,mh)-qdwpr(4,mh)
c	  end do
c	endif


d	if(iopt.eq.2)print*,' checkpoint 110 in lst'
 
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     WRITE THE RESERVOIR FILE (RESIN.csv) FOR PLOTTING
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

!     MOVED FROM SUB  NOV.19/97
!     REV. 8.95 - Mar.  15/99 -  COMPUTED MEAN FLOWS FOR TIME INCREMENT
!     CHECKED BY SPREADSHEET APRIL 12/99 NK.

!     SET THE PEAKS EQUAL TO ZERO FOR EACH EVENT:
      do l=no+1,no+noresvi
c         dpeakh(l)=0.1e-10
c         dpeaks(l)=0.1e-10
         volhyd(l)=0.0
         volsyn(l)=0.0
      end do

!     rev. 9.1.79  Mar.  30/05  - NK: ktri to area2 for reservoir inflow dt
!       CALCULATE THE MEAN FLOW for the reservoir inflow timestep
	if(noresvi.gt.0)then    ! added Apr. 10/05 nk
!       only when there are reservoir inflows
!     rev. 9.8.47  Feb.  04/13  - NK: Headers added for spl & resin csv files
        if(id.eq.1.and.hdrflg0)then
          write(73,60002)start_date,
     *    (',obs_',resnamei(i),',SIM_',resnamei(i),i=1,noresvi)
60002     format(a12,<noresvi>(a5,a12,a5,a12))     
        endif
        if(id.eq.1)then
          allocate(qdwpr_sum(noresvi),stat=iAllocate)
          if (iAllocate.ne.0) STOP 
     *    'Error: error w/allocation of lake elv min/max in lst @ 1392' 
        endif

!     rev. 9.9.57  Feb.  08/15  - NK: Fixed resv inflow output resin & lake_sd
        ktri=min(ktri,mhtot)  !  ensure deltat .le. event length 
c        do k=ktri,mhtot,ktri
        do k=1,mhtot,ktri
          do i=1,noresvi
!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
            if(inbsnflg(no+i).eq.1)then
!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
	        l=resin_reach(i)   ! determined in read_resvin
!             calculate mean for time step
              qdwpr_sum(i)=0.0     ! qdwpr mean daoly
              do kk=k,k+ktri-1
                qdwpr_sum(i)=qdwpr_sum(i)+qdwpr(l,kk)
c      if(l.eq.1)write(835,*)kk,qdwpr(l,kk),qdwpr_sum(i)
              end do
              kk=kk-1
              
              qdwprmd(i)=qdwpr_sum(i)/float(ktri)
            endif
!           for pre-emption
            ashnum(no+i)=ashnum(no+i)+(qinfl(i,k)-qdwprmd(i))**2
          end do
!         write obs & comp inflow values to resin.csv
!     rev. 9.8.32  Oct.  19/12  - NK: Fixed format for resin.csv in lst.f
!     rev. 9.2.41  Jun.  15/06  - NK: changed the resin.txt file to resin.csv
c      write(835,*)kk,qdwprmd(1),qdwpr_sum(1)
c      write(835,*)
c          write(73,7405)kk,(qinfl(i,k+ktri-1),qdwprmd(i),i=1,noresvi)
          write(73,7405)int(totaltime)-mhtot+kk,
     *                   (qinfl(i,k+ktri-1),qdwprmd(i),i=1,noresvi)
        end do


!       add the diversion flow to the receiving grid for the continuity check
        do k=ktri,mhtot,ktri
          do i=1,noresvi
	      if(inbsnflg(no+i).eq.1)then
!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
	        l=resin_reach(i)   ! determined in read_resvin
              if(qinfl(l,k).gt.0.01)then
                volhyd(no+i)=volhyd(no+i)+qinfl(l,k)
                volsyn(no+i)=volsyn(no+i)+qdwpr(l,k)
              endif
	      endif
          end do
        end do
        do i=1,noresvi
          if(inbsnflg(no+i).eq.1)then
            volhyd(i)=volhyd(i)*float(ktri)*3.6e-03
            volsyn(i)=volsyn(i)*float(ktri)*3.6e-03
	    endif
	  end do
                                            
!     rev. 10.1.61 Jan.  03/17  - NK: Changed results\peaks.txt to write peak flows
c        write(76,7601)(dpeakh(l),dpeaks(l),l=1,no+noresvi)
        write(76,7601)id,(qpeakh(l),qpeaks(l),l=1,no+noresvi)
c        write(77,7602)(volhyd(l),volsyn(l),l=1,no+noresvi)
      endif

      if(id.eq.ni) write(51,6030)optim

d	if(iopt.eq.2)print*,' checkpoint 120 in lst'

!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_outflow

!     write the header for lake_sd.csv
      if(firstpass.eq.'y')then
          col_name(1)=
     *'  lake_elv,  lake_stor,     lake_inflow,        NBS    ,'
          col_name(2)=
     *'lake_outflow, net_lake_outflow, delta_stor,'
        do l=1,noresv*2,2
          col_name(l)=col_name(1)
	    col_name(l+1)=col_name(2)
        end do
c        if(.not.contflg.eq.'y'.and.iopt99)then
        if(.not.contflg.eq.'y'.and..not.netCDFflg.or.iopt99)then
          WRITE(80,6680)'     time,',((l+1)/2,
     *             col_name(l),col_name(l+1),l=1,noresv*2,2)
6680      format(a10,999(i5,a56,a44))
c        else
c            print*,'Set iopt>0 to get lake_sd.csv file'
        endif
!     rev. 9.9.12  Apr.  04/14  - NK: Added min & max lake_level output file
        allocate(lake_elv_min(noresv),lake_elv_max(noresv),
     *         lake_elv_min_av(noresv),lake_elv_max_av(noresv),   
     *         sum_min(noresv),sum_max(noresv),   
     *         lake_elv_min_id(noresv,ni),lake_elv_max_id(noresv,ni),
     *         stat=iAllocate)
        if (iAllocate.ne.0) STOP 
     *    'Error: error w/allocation of lake elv min/max in lst @ 1392' 
        do l=1,noresv
          lake_elv_min(l)=1.0e+31
          lake_elv_max(l)=-1.0E+31
          sum_min(l)=0.0
          sum_max(l)=0.0
          do i=1,ni   ! can not use id here as it would stop the run after 1 event
            lake_elv_min_id(l,i)=1.0e+31
            lake_elv_max_id(l,i)=-1.0E+31
          end do
        end do
!     rev. 9.9.58  Feb.  13/15  - NK: Added time column to levels.txt
!     rev. 10.1.53 Nov.  09/16  - NK: Changed levels.txt to levels.csv
       if(lvlflg.and.writeFlg(953))then
          write(953,95301)'total_time,  ',
     *               (gname_lvl(n),',',gname_lvl(n),',',n=1,nolvl)
95301     format(a13,<2*nolvl>(a13,a1)) 
        endif               
      endif

!     rev. 9.8.24  Aug.  07/12  - NK: Added reading yyyymmdd_lvl.tb0 for lake levels
!     rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99
c	if(dds_flag.ne.1.and.iopt.lt.99)then
c	if(iopt.lt.99)then  !Changed May 6/13 nk
	if(writeFlg(1))then  !Changed May 6/13 nk
        if(lvlflg)then
          do k=ktlvl,mhtot,ktlvl
            do l=1,nolvl
              i=lvl_reach(l)
              if(i.eq.0)then
!                give this value so file will be readable by grapher etc.              
c                lvl_calc(l,k)=lake_elv(i,k)
                lvl_calc(l,k)=-999.0
!               if the level station is not in a reach, the value of lvl_reach(l)
!               will be 0 and will not work as a subscript below. So we set a dummy 
!               reach number at noresv+1
                lvl_reach(l)=noresv+1
              endif
            end do
          end do

!     rev. 9.9.58  Feb.  13/15  - NK: Added time column to levels.txt
!     REV. 10.1.22 Jan.  25/16  - NK: Fixed flowinit for partial basins
!     rev. 10.1.53 Nov.  09/16  - NK: Changed levels.txt to levels.csv
!         don't write if any station is outside the sub-basin model  
          if(dds_flag.eq.0)then
            do k=ktlvl,mhtot,ktlvl
              write(953,95300)int(totaltime)-mhtot+k,',',
     *         (lvl_obs(l,k),',',lake_elv(lvl_reach(l),k),',',l=1,nolvl)
95300         format(i12,a1,<2*nolvl>(f13.3,a1))         
            end do   
          endif  
        endif
      endif   

!     rev. 9.9.12  Apr.  04/14  - NK: Added min & max lake_level output file
      if(ktlvl.eq.0)ktlvl=1
      if(ktlvl.gt.0)then
        do l=1,noresv
c          do k=ktlvl,mhtot,ktlvl
          do k=1,mhtot
!           find the overall min & max        
            lake_elv_min(l)=amin1(lake_elv(l,k),lake_elv_min(l))
            lake_elv_max(l)=amax1(lake_elv(l,k),lake_elv_max(l))
!           find the event min & max          
            lake_elv_min_id(l,id)=
     *              amin1(lake_elv(l,k),lake_elv_min_id(l,id))
            lake_elv_max_id(l,id)=
     *                amax1(lake_elv(l,k),lake_elv_max_id(l,id))
          end do
        end do
      endif

!     write the data for lake_sd.csv & NBS
      if(noresv.gt.0)then
        
c      if(dds_flag.ne.1.and.iopt99)then
      if(.not.netCDFflg.and.dds_flag.ne.1.or.iopt99)then           
c	    if(trcflg.eq.'y')then
	    if(trcflg.eq.' ')then
            do k=1,mhtot
              write(80,8001)(lake_elv(l,k),lake_stor(l,k),
     *          lake_inflow(l,k),net_lake_inflow(l,k),lake_outflow(l,k),
     *          net_lake_outflow(l,k),del_stor(l,k),l=1,noresv)
c     *         ,(isolakeGW(l,k),l=1,noresv)
8001          format(g14.6,9999(',',g14.6))
	      end do
          else   !   trcflg.eq.'n'

!     rev. 9.5.60  Sep.  01/09  - NK: added deltat_report for lake_sd.csv file
!     rev. 9.7.21. Mar.  07/11  - NK: Fixed delta_report for longer periods in lst
!     rev. 10.2.27 Jul.  08/18  - NK: replaced lake_inflow_sum with temp_flow_sum
            if(deltat_report.ne.1)then
!             calculate the average for the reporting period:            
              do l=1,noresv
                do k=1,mhtot,deltat_report
 	            temp_flow_sum(l)=0.0
                  i=0
                  if(k.le.mhtot)then
	              do j=k,k+deltat_report-1
	                if(j.le.mhtot)then
	                  i=i+1
                        temp_flow_sum(l)=
     *				       temp_flow_sum(l)+lake_inflow(l,j)
                      endif
                    end do
                    j=j-1     
                  endif
c                  lake_inflow(l,j)=temp_flow_sum(l)/deltat_report
		      end do
                lake_inflow(l,j)=temp_flow_sum(l)/float(i)
              end do

!             Get the average for the net-inflow:              
              do l=1,noresv
                do k=1,mhtot,deltat_report
 	            temp_flow_sum(l)=0.0
                  i=0
                  if(k.le.mhtot)then
	              do j=k,k+deltat_report-1
	                if(j.le.mhtot)then
	                  i=i+1
                        temp_flow_sum(l)=
     *				      temp_flow_sum(l)+net_lake_inflow(l,j)
c      if(l.eq.1)print*,k,j,net_lake_inflow(l,j),temp_flow_sum(l)                        
                      endif
                    end do     
                    j=j-1     
                    net_lake_inflow(l,j)=temp_flow_sum(l)/float(i)
c      if(l.eq.1)then
c          print*,k,j,net_lake_inflow(l,j),temp_flow_sum(l)/float(i) 
c          print*,float(i)
c      endif
                  endif
		      end do
              end do
              
!             calculate the outflow average for the reporting period:            
              do l=1,noresv
                do k=1,mhtot,deltat_report
 	            temp_flow_sum(l)=0.0
                  i=0
                  if(k.le.mhtot)then
	              do j=k,k+deltat_report-1
	                if(j.le.mhtot)then
	                  i=i+1
                        temp_flow_sum(l)=
     *				      temp_flow_sum(l)+lake_outflow(l,j)
c      if(l.eq.1)print*,k,j,i,lake_outflow(l,j),temp_flow_sum(l)                        
                      endif
                    end do 
                    j=j-1     
!     rev. 10.2.67 Nov.  03/19  - NK Fixed flow averaging in lst
                lake_outflow(l,j)=temp_flow_sum(l)/float(i)
c      if(l.eq.1)print*,k,j,i,lake_outflow(l,j)
c      if(l.eq.1)print*
                  endif    
 		      end do
              end do

!             calculate the net_outflow average for the reporting period:            
              do l=1,noresv
                do k=1,mhtot,deltat_report
  	            temp_flow_sum(l)=0.0
                  i=0
                  if(k.le.mhtot)then
	              do j=k,k+deltat_report-1
	                if(j.le.mhtot)then
	                  i=i+1
                        temp_flow_sum(l)=
     *				      temp_flow_sum(l)+net_lake_outflow(l,j)
                      endif
                    end do   
                    j=j-1     
!     rev. 10.2.67 Nov.  03/19  - NK Fixed flow averaging in lst
                net_lake_outflow(l,j)=temp_flow_sum(l)/float(i)
                  endif  
		      end do
              end do
	      endif     ! deltat_report.ne.1

c      print*,'deltat_report=',deltat_report
c      pause

!           write the data to lake_sd.csv
c            do k=1,mhtot,deltat_report
            do k=deltat_report,mhtot,deltat_report
	        time_sum=time_sum+deltat_report
!     rev. 10.2.03 Oct   28/17  - NK: Revert to old G format for lakeSD.csv
              write(80,8002)time_sum,(lake_elv(l,k),lake_stor(l,k),
     *          lake_inflow(l,k),net_lake_inflow(l,k),lake_outflow(l,k),
     *          net_lake_outflow(l,k),del_stor(l,k),l=1,noresv)
c8002          format(i10,<noresv>(',',g14.6))
8002          format(i10,999(',',g14.6))
c8002          format(i10,<noresv>(',',f14.3,',',f14.0,
c     *            ',',f14.3, ',',f14.3, ',',f14.3, ',',f14.3,',',f14.0))
c8002          format(i10,<noresv>(',',g14.3,',',g14.0,
c     *            ',',g14.3, ',',g14.3, ',',g14.3, ',',g14.3,',',g14.0))
            end do
            
!     REV. 10.1.36 Jul   12/16  - NK: Added results\LakeName.tb0
!     REV. 10.1.41 Oct   11/16  - NK: Added tb0flg to write lake_*.tb0 files

!           write the data to the lake_Resv_name.tb0 file
            if(noresv.gt.0.and.tb0flg.eq.'y')then
              do l=1,noresv            
                do k=deltat_report,mhtot,deltat_report
                  write(2000+l,3030)lake_elv(l,k),lake_inflow(l,k),
     *                              lake_outflow(l,k)
3030              format(14x,3f12.3)     
                end do
              end do
            endif
           
          endif   !trcflg

!     rev. 9.5.37  Oct.  14/08  - NK: added deltat_report to lake_sd.csv file write
!     rev. 9.5.37  UNDONE

        endif    !  dds_flag.ne.1
            
!     rev. 10.2.28 Jul.  08/18  - NK: Revised for TSW = NBS without lake precip/evap'n
c        if(writeFlg(957))then
!       Write NBS data      
        if(nbsflg.eq.'y')then
          do k=deltat_report,mhtot,deltat_report
              write(957,95703)(net_lake_inflow(l,k),l=1,noresv)
95703         format(<noresv>f8.1)                  
          end do
          
!     rev. 10.2.65 Sep.  30/26  - NK Changed format of net_basin_supply output
!     This is intended to work nly for regl & glb 2 & 8 day forecasts  
!     When iether of the last 2 evets is larger than 100 days = 2400 hours,
!     we're probably not in a forcast event. So don't write NBS          
          if(id.eq.ni-1.and.mhtot.le.2400)then   ! regl forecast
              i=0
              do k=deltat_report,mhtot,deltat_report
                  i=i+1
                  do l=1,noresv
                      net_basin_supply(l,i)=net_lake_inflow(l,k)
                  end do
              end do
          elseif(id.eq.ni.and.mhtot.le.2400)then  ! glb forecast
              i=2
              do k=deltat_report,mhtot,deltat_report
                  i=i+1
                  do l=1,noresv
                      net_basin_supply(l,i)=net_lake_inflow(l,k)
                  end do
              end do
              do l=1,noresv
                  write(957,95704)l,resname(l),
     *                            (net_basin_supply(l,j),j=1,i)
c                  write(957,*)
95704             format(i5,5x,a12,999f8.1)                  
              end do
          endif
        endif
        if(mhtot.gt.2400)then
            print*
            print*,'Warning:'
            print*,'NBS file not written as last 1 or 2 events appear'
            print*,'larger than the regl or glb events.'
            print*
        endif
      endif    ! if(noresv.gt.0)then

!     write data to nbs.tb0
c     do k=24,mhtot,24
c        write(70,5001)(net_lake_inflow(l,k),l=1,noresv)
c      end do

      close(unit=27,status='keep')

      firstpass='n'

!     rev. 9.9.12  Apr.  04/14  - NK: Added min & max lake_level output file
c      if(id.eq.ni)then
      if(modelflg.eq.'n'.and.writeFlg(1))then
        open(unit=99,file='results\min_max_lake_elevations.txt',
     *          status='unknown',iostat=ios)
        if(ios.ne.0)then
          print*,'Unable to open the file'
          print*,'results\min_max_lake_elevations.txt'
          print*,'so written in the working directory instead'
          open(unit=99,file='min_max_lake_elevations.txt',
     *          status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file min_max_lake_elevations.txt'
            print*,'Possible causes:'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in lst.f @ 1693'
          endif
        endif
!       write the column headers        
        write(99,*)
     *   'Lake#    Min       MinAv       MaxAv         Max     ',
     *                       'RangeAv    RangeAll'
        do l=1,noresv
          if(id.eq.ni)then ! last event
            do i=1,ni
              sum_min(l)=sum_min(l)+lake_elv_min_id(l,i)
              sum_max(l)=sum_max(l)+lake_elv_max_id(l,i)
            end do
            lake_elv_min_av(l)=sum_min(l)/float(ni)
            lake_elv_max_av(l)=sum_max(l)/float(ni)
          else
            lake_elv_min_av(l)=-1.0
            lake_elv_max_av(l)=-2.0
          endif
          write(99,99002)l,lake_elv_min(l),lake_elv_min_av(l),
c          write(99,*)l,lake_elv_min(l),lake_elv_min_av(l),
     *          lake_elv_max_av(l),lake_elv_max(l),
     *          lake_elv_max_av(l)-lake_elv_min_av(l),
     *          lake_elv_max(l)-lake_elv_min(l)  
99002     format(i5,6g12.3)          
        end do
        close(unit=99,status='keep',iostat=ios)
      endif

! FORMATS

  201 format(999g12.3)
  205 format(3i5,f10.2)
  206 format('    l    i    j      error ycount,xcount:',2i5)   
  207 format(3(' ',f12.3))
  503 format(30f8.2)
 1000 format(' ',a20)
 1004 format(' ',i5,' damage sites:')
 1011 format(a12,20x,999f8.0)
 1012 format(' ',a12,f8.0,4f7.0,f7.0,f7.1,2g12.0,3f8.0,99i5)
 1013 format('  no  location      area  precip  o/ro <->c/ro c/ro(t)',
     *'   Dv%   Nash_E    qp/m     qp/c      WS_A    spl_A   %Diff',
     *'  Class fractions')
 1014 format(' location',26x,'precip   o        c       qpm     qpc')
 1015 format(5i5)
 1017 format(5x,'peak flow measured =',f8.1,' cms, computed =',f8.1)
 1018 format(' ',i5,1x,a12,f8.0,4f7.0,2f8.2,5f9.0,99f6.2)
 1019 format(' ',i5,1x,a12,f8.0,11f7.0,99f5.2)
 1098 format(a80)
 1100 format(' ',2i5,1x,a12,7x,4e10.3,f8.3)
 2001 format(i8,' ',3(f8.2,' '),i8,a12,20x)
 2002 format(8f10.3)
 5000 format(' reach # ',2i5)
 5001 format(12x,999f12.3)
 5002 format(/' reach no ',i5,' of ',i5)
 6000 format(5x,'grid length =',f6.0,' meters')
 6002 format('0',10x,'* * * time=',f5.2,' hours * * *',/)
 6011 format(5x,'summary',i2,'   scm(1-5)=',999f5.2/)

 6013 format(' ',2f12.3,i5,1x,a12,99f5.2)
 6014 format(' ',2i5,99f5.2)

 6015 format(' runtime  ',a2,':',a2,':',a2,2x,a4,'-',a2,'-',a2)
 6016 format(/' soil moistutes are ',5f5.2/)
 6020 format(' ','id/l/area(l)/',2i5,f10.3,
     *'    area(l) can not be less than 0.0',
     *'    please check stream gauge location for gauge l'/)
 6030 format(5x,'total average error this run is',e15.6,' cms')
 6040 format(8a)
 6070 format(5x,'the initial unit flow for storm no. =',i5,' is',f10
     *.4,' m**3/sec/km**2')
 6080 format(5x,'lst: the maximum calculated flows are:',/)
 6081 format(9x,'n',5x, 'yyy(n)',5x,'xxx(n)',5x,'da(n)',3x,
     *'qmax(n)',3x,'sump(n)',3x,'sumrff(n)',3x,'eloss(n)',/)
 6089 format(999g7.1)
 6090 format(999f7.0)
 6091 format(999f5.2)
 6092 format(999f5.0)
 6093 format(5(i5,','),5(f10.1,','))
 6094 format(3(i5,','),2(f12.3,','),5(f10.1,','))
 6095 format(2(f10.3,','),g10.2)
 6400 format('  hour    then pairs of measured and computed flows')
 6409 format('  hour    then measured flows')
 6410 format('  hour    then computed flows')
 6401 format(i8,18g12.2)
 6402 format(i8,18g12.1)
 6404 format(i8,<no*2>(',',e10.3))
 7401 format(i8,<no*2>(',',g12.4))
c 7402 format(i8,512(',',f12.4))
c 7403 format(i8,512(',',f12.4))
 7404 format(i8,<no*2>(',',g12.4))
 7405 format(i11,<noresvi*2>(',',g16.4))
 7501 format(f9.4,<no*2>(',',g12.4))
c 7502 format(f9.3,512(',',f9.3))
c 7503 format(f9.2,512(',',f9.2))
c 7504 format(f9.1,512(',',f9.1))
c7402 format(i4,',',60(f6.1,','))
 6403 format(i4,60(f8.2,f8.3))
 6667 format('  snow on each element in mm, scaled by ',f5.2)
 6668 format('  precip. on each element in mm, scaled by ',f5.2)
 6666 format(3i10,3f10.1) 
 6669 format('  final soil moisture for each element is:')
 6670 format(i5,' Errors in %.Runtime ',
     *    a2,':',a2,':',a2,2x,a4,'-',a2,'-',a2)
c6671 format('  l,next,subarea(l),suberr(l)/',2i5,4f9.1)
 6671 format(' table for surfer: ',2(i2,':'),i2,2x,2(i2,'/'),i4,/
     *'nbasin   i    j      N            E     error    precip',
     *'    runoff      evap  runoff coeff.')
 6672 format('  runoff from each grid in mm')
 6673 format('  losses from each grid in mm')
 6674 format('  runoff coefficient ')
 6675 format('nbasin,   i,    j,         N,            E,    precip,'
     *,'    runoff,      evap,  runoff coeff.')
 6676 format(' table for surfer: ',2(i2,':'),i2,2x,2(i2,'/'),i4,/
     *'nbasin    i     j    N    E      error')
 6677 format('  recharge in each grid in mm')
 6679 format(a60)
 7601 format(i8,80f8.1)
 7602 format(80E11.3)
! 7777 format(10f10.1)

      RETURN

      END SUBROUTINE lst
      SUBROUTINE melt(time,jan,ju)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and John Donald
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***************************************************************************
! PROGRAM BY: John DOnald - SEPT. 1991
!
! THIS SUBROUTINE ESTIMATES SNBOW ACCUMULATION & CALCULATES THE SNOWMELT
!
!
!     REV. 7.84 - Dec.  16/96 -  changed pmelt so that snowmelt only
!                                occurs on snow covered area
!     REV. 7.9  - Dec   18/96 -  took out call to read temperatures
!     REV. 8.22 - Mar.  15/96 -  glacier MF 2X when new snow=gone
!     REV. 8.24 - Apr.  07/96 -  added glacier melt multiplier gladjust
!     REV. 8.94a- Feb.  02/99 -  reset heat deficit to 0.0 on Sept.01
!     rev. 9.06    Feb.  15/01  - fixed deficit calc in melt
!     rev. 9.08 - Mar.  26/01 -  checked limits on heat def.
!     rev. 9.1.04  Oct.   4/01  - added A7 for weighting old/new sca in melt
!     rev. 9.1.19  Jun.  22/02  - Added A9 as the max heat deficit/swe ratio
!     rev. 9.5.63  Sep.  04/09  - NK: moved lapse rate from melt.f to process_temp.f
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 9.7.29  Jul.  07/11  - NK: Add sublim_rate to set sublimation rate/day to par file
!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance
!     rev. 9.9.78  Sep.  16/15  - NK: Fixed wcl in melt.f
!
!	Latest edit Oct. 5/0
!
!     unit 31 = fln(11) - snowfall file
!     unit 32 = fln(12) - temperature file
!     unit 33 = fln(13) - wind file
!
!***************************************************************************

      use area_watflood
	implicit none

      CHARACTER(1) :: new,firstpass
      INTEGER      :: jan,ju,iallcnt2,iallocate,n,ii,j
	REAL*4       :: time,ttime,taold,temmmp                

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

!     ADDED TO MODULE MELTAONLY.FOR
!      REAL         :: excess1,snowf,snowt,raint    ! NK - added SEPT 20/2000

      DATA new/'f'/firstpass/'y'/
	DATA iallcnt2/0/

d      if(iopt.eq.2)print*,'in melt @ 0'

c      if(jan.eq.1.and.nnn.le.0)then
      if(firstpass.eq.'y')then
	  firstpass='n'

	  do n=1,naa     !  added March 15/07 nk
	    do ii=1,classcount
		    sum_sublim(n,ii)=0.0
		    sublim(n,ii)=-1.0    ! added May 12/13 nk
            fexcess(n,ii)=-1.0
	      ati(n,ii)=0.0
	      water(n,ii)=0.0
	    end do
	  end do

	  do ii=1,classcount
!         initialize qh   -  not used??  nk 29/12/04
          qh(ii)=-999.   ! fix - not used anywhere ?
	    qn(ii)=0.0     ! fix - not used anywhere ?
	    qe(ii)=0.0     ! fix - not used anywhere ?
	    qp(ii)=0.0     ! fix - not used anywhere ?
          refrz(ii)=0.0     ! fix - not used anywhere ?
	    qsnow(ii)=0.0     ! fix - not used anywhere ?
          qrain(ii)=0.0     ! fix - not used anywhere ?
!     rev. 10.1.99 Oct   08/17  - NK: Added error check for # sdc classes in Melt.f
          if(nsdc(ii).gt.2)then
              print*,'Error - nsdc in the par file is > 2'
              print*,'for class # ii'
              print*,'Check other classes'
              stop 'program aborted in melt @ 78'
          endif
        end do

      endif

d      if(iopt.eq.2)print*,'in melt @ 1'

!     NOTE:  SNOWC ADJUSTED FOR CHANGE IN SCA IN RUNOF5 <<<

!     FOLLOWING ADDED FOR HAMLIN CHANGES JAN 97

!     READ SNOW COVER AND MET DATA
!     RDSNOW WILL READ THE INITIAL SNOW COVER FOR EACH LAND CLASS
!     FOR JD'S OLD FILES, IT WILL ALSO READ THE MIN AND MAX TEMPS       
!     FOR THE NEW SYSTEM, THE MIN AND MAX TEMP ARE NOT USED AND HOURLY
!     TEMPS ARE EXPECTED             
!     HOWEVER, IF LONGER DELTA T'S ARE USED, A STEP FUNCTION IS ASSUMED

!     if this call is deleted, be sure to set new='t'  !!!!!
c      if(new.eq.'f')then
c        call rdsnow(time,jan,new)
c      endif
      new='t'

d      if(iopt.eq.2)print*,'in melt @ 2'

!     * * * * * * * * * * * * * *
!     SNOWMELT CALCULATION
!     * * * * * * * * * * * * * *
!     FOR EACH GRID IN THE BASIN, CALCULATE THE SNOWMELT:
!     TO PREVENT HEAT DEFICIT CARRY OVER FROM ONE YEAR TO THE NEXT:
!     FEB. 02.99   NK

	if(ju.eq.244)then
        do n=nastart,naend
          do ii=1,classcount
            def(n,ii)=0.0
          end do
        end do
      endif

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 9.8.28  Oct.  12/12  - NK: fixed heat deficit reset for resume
      if(dds_flag.eq.-1)then
 	  if(id.eq.1.and.time.le.1.001)then
          do n=nastart,naend
            do ii=1,classcount
              def(n,ii)=0.0
            end do
          end do
        endif
      endif

d      if(iopt.eq.2)print*,'in melt @ 3'

      do n=nastart,naend
        do ii=1,classcount
          if(aclass(n,ii).gt.0.0)then
!           WHAT'S THE TEMPERATURE?
      
!           RDTEMP READS THE TEMPERATURE ARRAY IN DELTA t INCREMENTS
!           THE OUTPUT VARIABLE IS TEMPV(n) - THE TEMPERATURE VECTOR

cc            if(new.eq.'t')then
c!             TEMPERATURE ARRAY FOR THIS DELTA T WAS READ IN MELT
c!             BUT HAS TO BE DEFINED FOR THIS GRID:
              ta(n,ii)=tempv(n)
cc            else
cc              call temper(n,ii,time,ttime)
cc              ta(n,ii)=ttime
cc            endif
c      
c            if(new.eq.'f')then
c!             IS IT SNOWING? CONVERT TO HOURLY RATE.
c              snowf(n,ii)=dsnow(n)/float(idt31)
c              if(snowf(n,ii).lt.0.0) snowf(n,ii)=0.0
c            else
c!             WE ARE USING MET FILES FOR TOTAL PRECIP
              snowf(n,ii)=0.0                       ! get rid of this variable
c            endif

!  --------------------------------------------------------------
!  WHAT TO DO? --> USE 0 DEG. C AS SNOW/RAIN BOURNDARY
!              --> IDENTIFY SNOW AND RAIN BY TEMPERATURE REGARDLESS
!                  OF WHETHER IT'S MEASURED AS RAIN OR SNOW.
!
!                  NB: SNOW AND RAIN CAN OCCUR ON THE SAME DAY
!                       (SNOW IS DAILY, RAIN IS HOURLY) 
!  -------------------------------------------------------------
!     TEMPERATURE GREATER THAN TBASE DEG C --> ALL PRECIP IS RAIN

!     REV. 7.74   May.  23/96 -  INCLUDE LAPSE RATE & ELVREF AS PART OF
!                                  .TMP FILE
            
!            if(n.eq.s(ipr,jpr).and.ii.eq.2)print*,fmadjust

!           ADJUST THE MELT FACTOR - INCREASE WITH DEGREE DAYS
            if(fmadjust.gt.0.0)then
              fmadj(n)=fmadjust*(tto(n)-ttomin(n))/100.0
              fmadj(n)=amin1(fmahigh,fmadj(n))
              fmadj(n)=amax1(fmalow,fmadj(n))
            else
              fmadj(n)=1.0
            endif

!	REV. 8.21 - Mar.  15/96 -    RAIN/SNOW CHOICE TIED TO BASE TEMP  

!		THIS FOLLOWING LINE WAS CHANGED SO THAT TA NOW ONLY HAS TO BE
!		GREATER THAN THE CURRENT BASE TEMPERATURE - FS: MARCH/97 

            if(tempv(n).gt.base(ii))then
c            if(tempv(n).gt.2)then
              deld(n,ii)=0.0
!             TOTAL PRECIP = SNOWF+R(N,II)
              raint(n,ii)=snowf(n,ii)+r(n,ii)
              snowt(n,ii)=0
              qtot(ii)=(fm(ii)*fmadj(n))*(tempv(n)-base(ii))
            else
!             TEMPERATURE LESS THAN OR EQUAL TO 0 DEG.C --> ALL PRECIP IS SNOW
!             CAN MELT IF MELT FACTOR FOR CLASS II IS LESS THAN O DEG.C
              raint(n,ii)=0 
              snowt(n,ii)=snowf(n,ii)+r(n,ii)

!             check if snow cover heat def. satisfied - if yes, ati=0
              if(def(n,ii).le.0.0) ati(n,ii)=0.0

!             CHANGE IN NEG. HEAT CONT. DUE TO ENERGY EXCHANGE
              deld(n,ii)=fmn(ii)*(ati(n,ii)-tempv(n))

!             CHANGE IN NEG. HEAT CONT. DUE TO NEW SNOW AT TA (TA -VE HERE)
              deld(n,ii)=deld(n,ii)-(snowf(n,ii)*tempv(n)/160)

!             UPDATE ATI        
              ati(n,ii)=ati(n,ii)+tipm(ii)*(tempv(n)-ati(n,ii))

!             LIMIT ATI TO -52.8 C (FROM NWSRFS)
              ati(n,ii)=amax1(-52.8,ati(n,ii))
           
!             AVAILABLE HEAT IN TERMS OF mm OF MELT:
              qtot(ii)=(fm(ii)*fmadj(n))*(tempv(n)-base(ii))
            endif

!            if(n.eq.naa/2.and.ii.eq.1)print,tto(n),ttomin(n),fmadj(n),fm(ii)
 
!           NB: MY SDC'S GO THRU 0,0 BUT NWSRFS DON'T - WHY??  

!           INITIALIZE SCA
            oldsca(n,ii)=sca(n,ii)
!            sca(n,ii)=0.0

!           CALC SNOW DEPTH & SCA
            if(snowt(n,ii).le.0.0)then
!             there is no new snow and the sca is adjusted
              dsno(n,ii)=snowc(n,ii)/rho(ii)
              
!             INTERPOLATE SCA FROM SDC
              if(dsno(n,ii).gt.sdcd(nsdc(ii),ii))then
!             See if depth of snow > 100 cover depth:
                sca(n,ii)=1.0
              elseif(dsno(n,ii).le.0.0)then
                sca(n,ii)=0.0
              else
                do j=1,nsdc(ii)-1
!                THESE CONDITIONALS OVERLAP  
                 if((dsno(n,ii).ge.sdcd(j,ii)).and.
     *              (dsno(n,ii).le.sdcd(j+1,ii)))then
	             top(n,ii)=dsno(n,ii)-sdcd(j,ii)
	             bot(n,ii)=sdcd(j+1,ii)-sdcd(j,ii)
	             sca(n,ii)=
     *                sdcsca(j,ii)+top(n,ii)/bot(n,ii)*
     *                (sdcsca(j+1,ii)-sdcsca(j,ii))
                   sca(n,ii)=amax1(0.0,sca(n,ii))
                   sca(n,ii)=amin1(1.0,sca(n,ii))
	           endif
                end do
              endif     
            else                                  ! SNOWT > 0.0
!             FOR FRESH SNOW, SNOWT > 0.0 AND SCA IS SET TO 1.0
!             AND THE SDC CURVES ARE IGNORED
!             THIS GETS RID OF INSTABILITY
              sca(n,ii)=1.0
            endif


!     rev. 0.1.04  Oct.   4/01  - added A7 for weighting old/new sca in melt
!     NOTE:
!     this results in slightly different evaporation from soil and
!     is why the new spl9 was different from the old spl8 (0.50)
!     so now this is a new parameter

!           force gradual changes in sca
            sca(n,ii)=amax1(a7*oldsca(n,ii),sca(n,ii))

!           ADDED BY FS - DEC/96 OTHERWISE SCA MIGHT BE 10E-45
            if(sca(n,ii).lt.0.000001)sca(n,ii)=0.00

!           ADJUST THE SNOW COVER  
C            if(sca(n,ii).ne.oldsca(n,ii))then
            if(sca(n,ii).ne.oldsca(n,ii).and.oldsca(n,ii).gt.0.0)then
              temmmp=wcl(n,ii)
              if(sca(n,ii).ge.0.000001)then
                snowc(n,ii)=snowc(n,ii)*oldsca(n,ii)/sca(n,ii)
                wcl(n,ii)=wcl(n,ii)*oldsca(n,ii)/sca(n,ii)
                water(n,ii)=water(n,ii)*oldsca(n,ii)/sca(n,ii)
!                jf=1
!                if(ii.eq.4)
!     *          if(writeflg(64))write(64,6201)temmmp,wcl(n,ii),oldsca(n,ii),sca(n,ii),jf
              else
	          wcl(n,ii)=0.0
!	          jf=2
!                if(ii.eq.4)
!     *          if(writeflg(64))write(64,6201)temmmp,wcl(n,ii),oldsca(n,ii),sca(n,ii),jf
              endif
            endif

!           CHECK IF SCA HAS CHANGED IN THIS GRID SINCE LAST TIME STEP
            if(sca(n,ii).lt.oldsca(n,ii))then
!             SCA IS GOING DOWN AND SHOULD BE LESS THAN 1
!             REDUCE D1 AND UZS TO REFLECT GREATER BARE GROUND AREAS
!             BASED ON CONSERVATION OF WATER 
!             ADJUST D1 AND UZS TO COMPENSATE FOR CHANGE IN SNOW COVERED GRND
              d1(n,ii)=d1(n,ii)+
     *                (oldsca(n,ii)-sca(n,ii))*(d1fs(n,ii)-d1(n,ii))/
     *                                          (1.0-sca(n,ii))
              uzs(n,ii)=uzs(n,ii)+
     *                (oldsca(n,ii)-sca(n,ii))*(uzsfs(n,ii)-uzs(n,ii))/
     *                                          (1.0-sca(n,ii))
!     fix fix  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
c              snowc(n,ii)=snowc(n,ii)*sca(n,ii)/oldsca(n,ii)
c              wcl(n,ii)=wcl(n,ii)*oldsca(n,ii)/sca(n,ii)

            elseif(sca(n,ii).gt.oldsca(n,ii))then
!             SCA IS INCREASING (AND SHOULD BE LARGER THAN 0)
              d1fs(n,ii)=d1fs(n,ii)+
     *                 (sca(n,ii)-oldsca(n,ii))*(d1(n,ii)-d1fs(n,ii))/
     *                                           sca(n,ii)
              uzsfs(n,ii)=amax1(uzsfs(n,ii),0.000001) !fixed ts 02/12/03

              uzsfs(n,ii)=uzsfs(n,ii)+
     *                 (sca(n,ii)-oldsca(n,ii))*(uzs(n,ii)-uzsfs(n,ii))/
     *                                           sca(n,ii)

!     fix fix  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
c              snowc(n,ii)=snowc(n,ii)*sca(n,ii)/oldsca(n,ii)
c              wcl(n,ii)=wcl(n,ii)*oldsca(n,ii)/sca(n,ii)
            endif

!     This section works fine when the snow is continuous but totally screws up when
!     you read in new snow course data on the fly.
!     It was fixed with the  .and. .....  added to the conditional

c            if(sca(n,ii).le.0.00001)then
            if(sca(n,ii).eq.0.0.and.oldsca(n,ii).gt.0.0)then
!             THERE IS NO SNOW BUT WHEN IT RETURNS, WATER WILL COME FROM
!             RECEEDING PACK
              d1fs(n,ii)=0.0 

c              uzsfs(n,ii)=0.02
              uzsfs(n,ii)=0.00

	        sca(n,ii)=0.0   ! new 22/04/02
!     fix fix  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            endif

c            if(sca(n,ii).ge.0.99999)then
            if(sca(n,ii).eq.1.0.and.oldsca(n,ii).lt.1.0)then
!             THERE IS NO BARE GROUND, BUT WHEN BARE GROUND OPENS UP, WATER
!             WILL COME FROM PACK 
              d1(n,ii)=0.0
!              uzs(n,ii)=0.0001
              sca(n,ii)=1.0    ! new 22/04/02
!     fix fix  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            endif

!           ADD NEW SNOW TO COVER    

!           WHEN SCA = 0.0, ie. FIRST SNOW ON BARE GROUND, LET IT COVER THE
!           WHOLE GROUND. IN THE NEXT TIME IT WILL BE DISTRIBUTED

            snowc(n,ii)=snowc(n,ii)+snowt(n,ii)

!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
!           sublim_factor is always set to max out at 0.5
!           so sublim < snowc
            if(sublimflg.eq.1)then
	        sublim(n,ii)=sublim_factor(ii)*snowt(n,ii)
	      else
!     rev. 9.7.29  Jul.  07/11  - NK: Add sublim_rate to set sublimation rate/day to par file
!             sublimate only when there is snow that is not melting 
	        if(snowc(n,ii).ge.sublim_rate(ii).and.def(n,ii).gt.0.0)then
	          sublim(n,ii)=sublim_rate(ii)
	        else
	          sublim(n,ii)=0.0
	        endif
	      endif

            snowc(n,ii)=snowc(n,ii)-sublim(n,ii)


!           eloss is used in the watbal only

            if(ii.eq.classcount.or.nclass(ii).eq.'water     ')then
!             do nothing - water class is not included in water balance
	      else
              eloss(n)=eloss(n)+sublim(n,ii)*aclass(n,ii)*sca(n,ii)
	      endif

            sum_sublim(n,ii)=sum_sublim(n,ii)+sublim(n,ii)
     *                         *aclass(n,ii)*sca(n,ii) !added Jul. 24/12 nk

!           UPDATE SNOW COVER HEAT DEFECIT
            def(n,ii)=def(n,ii)+deld(n,ii)
            if(def(n,ii).lt.0.0)def(n,ii)=0.0

!           LIMITS ON HEAT DEFICIT OF SNOW COVER
!           NWSRFS--> MAX. DEFICIT = .33*SWE
!           OTHERWISE THERE MIGHT BE TOO MUCH HEAT DEFICIT FOR ALL THE 
!           SNOW TO MELT - FEB 2/99 NK  

!     rev. 9.1.19  Jun.  22/02  - Added A9 as the max heat deficit/swe ratio
            if(def(n,ii).gt.a9*snowc(n,ii))then
              def(n,ii)=a9*snowc(n,ii)
            endif

!           REV. 7.77   Jul.  02/96 -     FIXED SNOW REDISTRIBUTION

            if(snocap(ii).gt.0.0)then
!             REDISTRIBUTION IS TURNED OFF IF SNOCAP = -VE
!             CHECK CAPACITY - REDIST TO RECEIVING CALSS IDUMP(ii)
!             FIRST CHECK CAPACITY:
              if(snowc(n,ii).gt.snocap(ii).and.idump(ii).ne.ii)then
!              CALCULATE EXCESS SNOW: 
               extra(ii)=snowc(n,ii)-snocap(ii)

!              REV 8.99H  MAY 9/00  NK
!              ADJUST FOR GRU SIZE:
               if(aclass(n,idump(ii)).gt.0.0)then
                 extra(ii)=extra(ii)*aclass(n,ii)/aclass(n,idump(ii))
               endif
!              CHECK IF RECEIVING CLASS HAS ROOM:

               if(snocap(idump(ii)).ge.snowc(n,idump(ii))+extra(ii))then
                 snowc(n,ii)=snocap(ii)
!                REDISTRIBUTE CLASS=IDUMP(ii)
                 snowc(n,idump(ii))=snowc(n,idump(ii))+extra(ii)
                 extra(ii)=0.0
               else
!                SNOW STAY'S PUT AND EXCESS IS SET BACK TO 0
                 extra(ii)=0.0
               endif
              endif
            endif

! NOTE: NO HEAT REDISTRIBUTION. OK???

!           ADJUST QTOT, RPOBG, ROSN FOR SCA
!           R(n,ii) CHANGED TO RAINT
!           RAINT INCLUDES SNOW & RAIN PRECIP
            robg(ii)=raint(n,ii)
            rosn(ii)=raint(n,ii)

!           CALCULATE QNET
!           qtot is heat input -ve or +ve
            qnet(ii)=qtot(ii)-def(n,ii)
            if(qnet(ii).lt.0)then
!             temp below base temp & heat is lost -> increase def
              def(n,ii)=def(n,ii)-qtot(ii)    ! ???????????????????????
!     rev. 9.08 - Mar.  26/01 -  checked limits on heat def.
              if(def(n,ii).lt.0.0)def(n,ii)=0.0
              qnet(ii)=0.0
            else
              def(n,ii)=0.0
            endif

!           CALCULATE SNOWMELT
            if(qnet(ii).gt.snowc(n,ii))then
!             MELT ALL SNOW     
              smelt(ii)=snowc(n,ii)
            else       
!             CAN'T MELT ALL SNOW
              if(qnet(ii).gt.0.0)then
!               RIPE PACK, NO HEAT DEFECIT 
                smelt(ii)=qnet(ii)
              else  
!               NO SNOW MELT       
                smelt(ii)=0.0
              endif              
            endif

!           NO MATTER, WE HAVE TO MAKE SURE THE WATER BALANCE IS OK
!           EVEN IF THE HEAT CALCS ARE WRONG!

!           BEGINNING OF HAMLIN CHANGES JAN/97
!           HEAT AND WATER BALANCE OF SNOW COVER      
!           --> SUBTRACT ANY EXCESS HEAT DEFICIT NOT YET SATISIFED
!           - COULD HAPPEN IF LIGHT RAIN ON VERY COOL DAY
!           def(n,ii) -  the heat deficit in mm melt
!           wcl(n,ii) -  free water in the pack I think???

!           water     - all available liquid water
            water(n,ii) = smelt(ii)+rosn(ii)+wcl(n,ii)-def(n,ii)

!           wlmax     -  the max amount the pack can hold
            wlmax(n,ii) = snowc(n,ii)*whcl(ii)

            snowc(n,ii)=snowc(n,ii)-smelt(ii)

            if(def(n,ii).gt.water(n,ii)) then
!             DEFICIT IS GREATER THAN THE LIQUID WATER
!             SNOWPACK IS NOT RIPE ===> SATISFY THE HEAT DEFICIT FIRST
!             FREEZE ALL THE LIQUID WATER AND ADD IT TO THE SNOW PACK
!             THERE IS NO FREE WATER AND NO EXCESS
!             THIS MEANS THAT THE MELT WAS UNDONE
!     rev. 9.9.78  Sep.  16/15  - NK: Fixed wcl in melt.f
c              wcl(n,ii)=0.0
              excess(ii)=0.0
!             THIS IS CHANGED. MELT WATER IS NOT ADDED BACK TO THE PACK
!             BUT THE -VE HEAT HAS BEEN TAKEN OUT OF DEF SO IT IS PUT BACK
              snowc(n,ii)=snowc(n,ii)+rosn(ii)+wcl(n,ii)             !nk
              wcl(n,ii)=0.0 !TH: wcl not being added to pack, moved wcl=0 to after snowc recalc        
!              def(n,ii)=def(n,ii)+rosn(ii)+wcl(n,ii)                 !nk
!     rev. 9.06    Feb.  15/01  - fixed deficit calc in melt
              def(n,ii)=def(n,ii)-rosn(ii)-wcl(n,ii)                 !nk

!             added line below March 26/01  nk
!     rev. 9.08 - Mar.  26/01 -  checked limits on heat def.
              if(def(n,ii).lt.0.0)def(n,ii)=0.0

            else
!             DEFICIT IS LESS THAN LIQUID WATER
!             SNOWPACK IS RIPE AND DEFICIT IS WIPED OUT
!             WHAT EVER DEFICIT THERE WAS, FROZE SOME WATER AND IT IS
!             ADDED TO THE PACK
!     rev. 9.9.78  Sep.  16/15  - NK: Fixed wcl in melt.f
c              water(n,ii)=water(n,ii)-def(n,ii)  !TH: ran into v. small numerical difference in isosnow, def removed twice.
!             REMOVE DEFICIT BY REFREEZING SOME LIQUID WATER & ADD TO PACK
              snowc(n,ii)=snowc(n,ii)+def(n,ii)
              def(n,ii)=0.0
!             CHECK IF WATER HOLDING CAPACITY HAS BEEN EXCEEDED (ie.RUNOFF) 
              if(water(n,ii).gt.wlmax(n,ii)) then
!               NOT ALL THE LIQUID WATER CAN LEAVE THE PACK 
!               WATER AVAILABLE FOR RUNOFF
                excess(ii)=water(n,ii)-wlmax(n,ii)
                wcl(n,ii)=wlmax(n,ii)
              else
!               WATER HOLDING CAPACITY HAS BEEN EXCEEDED (ie.NO RUNOFF)  
                wcl(n,ii)=water(n,ii)
                excess(ii)=0.0
              endif
            endif
            snowc(n,ii)=amax1(0.0,snowc(n,ii))
            wlmax(n,ii)=snowc(n,ii)*whcl(ii)
!           CHECK IF SNOWPACK IS RIPE THEN ATI=0.0 (ANDERSON'73 3-6(a))
            if(def(n,ii).le.0.0)then
              ati(n,ii)=0.0           
            endif
       
!           ++++++++++++++++++++++++++++++++++++++  FS BEGIN
!           THIS IS WHERE JD PUT TOGETHER SNOWPACK RUNOFF(EXCESS)
!           AND RAIN ON BARE GROUND (ROBG), SO FOR MY RUNOF5.FOR TO
!           WORK THERE IS A NEW VARIABLE CALLED FEXCESS(ii) WHICH 
!           HOLDS THE SNOWPACK RUNOFF.  THIS IS HOW I WOULD DO IT:
            fexcess(n,ii)=excess(ii)

!           REV. 8.22 - Mar.  15/96 - GLACIER MF2X WHEN NEW SNOW=GONE
!           REV. 8.24 - Apr.  07/96 - ADDED GLACIER MELT MULT USE

!           IF WE ARE LOOKING AT THE GLACIER CLASS 
!           THEN IF THERE IS NO SNOW ON TOP OF THE GLACIER 
!           (ie. snowc.lt.1.0) THEN FORCE THERE TO BE RUNOFF 2 TIMES > 
!           THE POTENTIAL MELT (NICK CAME UP WITH THE 2 TIES FIGURE)
!           FS: FEB/97
            if(sca(n,ii).le.1.0.and.
     *         nclass(ii)(1:7).eq.'glacier'
     *                 .and.qtot(ii).gt.0.0)then
              glmelt(n)=qtot(ii)*gladjust
            endif

!           ++++++++++++++++++++++++++++++++++++++  FS END
!           * * * * *  END OF HAMLIN CHANGES JAN 97  * * * * *   

          endif                         ! if(aclass(n,ii).gt.0.0)
        end do                          ! do ii=1, classcount

!       SUM TOTAL SNOWMELT AND RAINFALL CONTRIBUTION TO RUNOFF
!       FROM EACH GRU (BEFORE STREAMFLOW ROUTING)

!       -----------------  OUTPUT RESULTS ---------------------

!      if(iopt.eq.2)print*,'in melt @ 4'
   
!       FRANK CHANGES OPTION TO GO TO SNOUT1

c        if(maxn.eq.2001.and.time.eq.7000)then
c          call snout1(time,n)
c        endif

!       if(iopt.eq.2)print*,'in melt @ 4a'

!     rev. 10.1.57 Dec.  06/16  - NK: Added snwNN.txt files for iopt > 0
        if(iopt.ge.2)then
          if(numa.eq.0)then
            if(n.eq.nnprint)then
!             WRITE HEADER
              ii=iiprint           ! ii must be .le. classcount!!!!!
              ii=11           ! ii must be .le. classcount!!!!!
              if(jan.le.1)then
                do ii=1,classcount
                  write(800+ii,6000)ii
                  write(800+ii,6003)n
                  write(800+ii,6001) 
                end do  
              endif
!             WRITE TO SNW.csv FOR LAND CLASS II=IIOUT       
              do ii=1,classcount
                write(800+ii,6002) 
     *	        time,tempv(n),raint(n,ii),snowt(n,ii),
     *          sca(n,ii),qn(ii),qe(ii),qh(ii),
     *          qp(ii),qtot(ii),def(n,ii),qnet(ii),robg(ii),
     *          rosn(ii),smelt(ii),excess(ii),refrz(ii),wcl(n,ii),
     *          snowc(n,ii),qsnow(ii),qrain(ii),r(n,ii),water(n,ii),
     *          glmelt(n),sublim(n,ii),snowf(n,ii),fexcess(n,ii)
              end do
            endif
          endif
!         if(iopt.eq.2)print*,'in melt @ 5'
        endif
      end do                             ! do n=1, naa


c	if(totaltime.gt.8760)then
c	  do n=1,na
c	    do i=1,ii
c  	      if(snowc(n,ii).eq.0.0)then
c              penalty(n)=1.0
c	      endif
c	    end do
c	  end do
c	endif


d      if(iopt.eq.2)print*,'in melt @ return'

! FORMATS

 6000   format('land class =',i5)    
 6001   format(
     *       '   time,    temp, rainfall, snowfall,    sca,     qn,  ',
     *       '     qe,      qh,       qp,     qtot,    def,   qnet, ',
     *       '   robg,    rosn,    smelt,   excess,  refrz,    wcl, ',
     *       ' snowc ,  qsnow ,   qrain ,    r(  ),  water,  glmelt,',
     *       '  sublm,   snowf,  fexcess')
 6002   format(27(f8.2,',')) 
 6003   format(' vector element=',i5) 
 5700 format(' ',16f5.1)
 6201 format(4e12.5,3x,i1)


      RETURN

      END SUBROUTINE melt

      SUBROUTINE LWinnip(n,div,thr,l,jz,at,dtmin,date,time)

!     Coded by NK. Dec. 2016

      use area_watflood
	implicit none
	save

      integer  :: i,j,l,n,jz,ios
      character(14) date
      real*4   :: div, thr,at,dtmin,time 
      character(20) :: junk,stuff
      
      integer  :: jd(366),bp(366),nbps,ngaps,iz,jlast
      integer  :: jenpeg_grid,echnl_grid
      real*4   :: aaa1(366),bbb1(366),ccc1(366)
      real*4   :: aaa2(366),bbb2(366),ccc2(366)
      real*4   :: aaa3(366)
      real*4   :: Helv,Hpd,Htd,QOpd,QOtd,QIpd,QItd,STpd,STtd,QAApd,
     *            Qech,QnwchU,QnwchV,QnwchW,QnwchX,QnwchY,QnwchZ,
     *            QnwchAA,Qdecision,QnwchMax,Qobs
      real*4   :: Lwin_level,Lwin_calc_QO,Lwin_obs_QO 
      logical  :: firstpass,test,exists
      data        test/.false./
      
      data        firstpass/.true./
      data        jlast/0/


      if(firstpass)then
!!    for Jenpeg    in rerout
        open(unit=99,file='resrl\Lwin_OR.csv',
     *                 status='old',iostat=ios)
        if(ios.ne.0)then
          print*,'Unable to open resrl\Lwin_OR.csv'
          stop 'Program aborted in MH_LWinnip @ 284'
        endif
        open(unit=617,file='Lwin_coefficients_info.txt',
     *                 status='unknown',iostat=ios)
        read(99,*)
        j=1
!       j = data point #
!       i = julian day for the data point   
!       aaa1, bbb1, ccc1 are for corrected west channel flow - Lwin 
!       aaa2, bbb2, ccc2 are for west channel max. flow - Lwin 
        do while(.not.eof(99))
          read(99,*,iostat=ios)junk,junk,i,aaa1(i),bbb1(i),ccc1(i),
     *                          aaa2(i),bbb2(i),ccc2(i)
          write(617,*)i,aaa1(i),bbb1(i),ccc1(i)
!         AAA1, bbb1, ccc1  are for the             
!         this right off the bat assigns values at the break points     
          bp(j)=i     ! store the julian day for data point i
          j=j+1
        end do
        close(unit=99,status='keep')
        nbps=j-1
        ngaps=j-2
        write(617,*)nbps,ngaps
!       bp(1) = always = 1 
!             
        do j=1,366
          jd(j)=j
        end do  
!       Interpolate between the mid-month data points          
        do i=1,ngaps   ! # of segments
          do j=1,366
            if(j.gt.bp(i).and.j.lt.bp(i+1))then
!             Q Decision 711 - 715 
              aaa1(j)=aaa1(bp(i))+(aaa1(bp(i+1))-aaa1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              bbb1(j)=bbb1(bp(i))+(bbb1(bp(i+1))-bbb1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              ccc1(j)=ccc1(bp(i))+(ccc1(bp(i+1))-ccc1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
!             LWPG WC Maximun QO Calc     
              aaa2(j)=aaa2(bp(i))+(aaa2(bp(i+1))-aaa2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              bbb2(j)=bbb2(bp(i))+(bbb2(bp(i+1))-bbb2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              ccc2(j)=ccc2(bp(i))+(ccc2(bp(i+1))-ccc2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
            endif
          end do
        end do
        do j=1,366
          write(617,62600),j,aaa1(j),bbb1(j),ccc1(j),
     *                   aaa2(j),bbb2(j),ccc2(j)
62600     format(i5,6f10.3)     
        end do
        QIpd=2000.    !previous day inflow
        QItd=2000.    !today's inflow
        QOpd=2000.    !previous day outflow
        QOtd=2000.    !today's outflow
        Helv=217.38   !lake elevation
        Hpd=217.38     !lake elevation previous day
        Htd=217.38     !lake elevation today
        STpd=1.2*lake_area(l)  !previous day storage
        STtd=STpd      !today's storage
        QnwchAA=1500  !initial guess
c        write(617,*)'Lake area =',lake_area(l),store1(n),n
        open(unit=617,file='Lwin_test.csv',status='unknown')
        write(617,62701)'        jz,  Lake_elv,      Qech,    QnwchU,'
     *                 ,'    QnwchV,    QnwchW,    QnwchX,    QnwchY,'
     *                 ,'    QnwchZ,    nwchAA, Qdecision,Qdaybefore,'
     *                 ,'    qi1(n),    qi2(n),    qo1(n),    qo2(n),'
     *                 ,'    store1(n),      store2(n),   Helv,  Qobs' 
62701   format(5a44)     
        iz=jz
        jlast=0
!     added PS & JC
!     to read correction values for the east channel
        open(unit=99,file='resrl\NReastOWP.csv',
     *   status='old',iostat=ios)
        if(ios.ne.0)then
          print*,'Unable to open resrl\NReastOWP.csv'
          stop 'Program aborted in MH_rules @ 375'
        endif
        read(99,*)
        do while(.not.eof(99))
          read(99,*,iostat=ios)j,aaa3(j)
        end do
        if(j.ne.366)then
          print*,'Did not reach the 366 required values for aaa3'
          stop 'Program aborted in MHrules @ 384'
        endif
        close(unit=99,status='keep')
        
!       The outlet for Lake Winnipeg is assumed as the East Channel rapids
!       at the WSC flow gauge.  That is where Qsyn is calculated and reported.          
!       The Jenpeg flows are calculated in its grid so they can be compared with
!       the WSC data. 
!       Find the jenpeg grid number:
!       lat. 54.500  long, -98.050
        j=int((-98.050-xorigin)/xdelta)+1
        i=int((54.500-yorigin)/ydelta)+1
        jenpeg_grid=s(i,j)

!       Find the East channel grid number:
!       East channel outlet 54.24  -97.59        
        j=int((-97.59-xorigin)/xdelta)+1
        i=int((54.24-yorigin)/ydelta)+1
        Echnl_grid=s(i,j)
        
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       for testing only:
c        test=.true.    ! <<<<<<<<<<<<< comment out for production runs
        INQUIRE(FILE='rule_test.txt',EXIST=exists) 
!       if the file is not present the default = flase - i.e. test will not be run        
        if(exists)then
          open(unit=99,file='rule_test.txt',status='old',iostat=ios)
          if(ios.ne.0)then
            print*,'Problem opening rule_test.txt'
            stop 'Program aborted in Lwin @ 150'
          endif
          do i=1,4
            read(99,*)
          end do
          read(99,*)stuff,junk
          if(stuff(1:7).eq.'LakeWin'.and.junk(1:1).eq.'y')test=.true.
          close(unit=99,status='keep')
        endif

        if(test)then
          open(unit=765,file='resrl\Lwin_test_input.csv',
     *                         status='old',iostat=ios)
          if(ios.ne.0)then
            print*,'Looking for Lwin_test_input.csv'
            print*,'but file is not found. '
            stop 'Program aborted in Lwin @ 665'
          endif
          read(765,*)   ! read the header line. 
        endif  !test
        open(unit=666,file='Lwin_test_output.csv',status='unknown',
     *                       iostat=ios)
!       Lwin_calc_QO = JC's calculated outflow
!       Lwin_obs_QO = JC's input Lwin inflow          
        write(666,66601)'QItd','Lwin_level','Lwin_calc_QO',
     *      'Lwin_obs_QO','Htd','QOtd','Qjenpeg','Qech'
66601   format(99(a10,','))      
        
        firstpass=.false.

        print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        print*,'      Using Lake Winnipeg Operating Rule      '
        print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        
        
       
      endif    !firstpass  ~~~~~~~~~~~~~~~~~~~~~~~~~

      if(jul_day_now.ne.jlast)then   ! new hour
        j=jul_day_now
        jlast=jul_day_now
        QIpd=QItd   ! inflow previous day
        QOpd=QOtd   ! outflow previous day
        STpd=STtd   ! storage previous day
        Hpd=Htd
!       For actual use:
        QItd=qi2(n) ! from the model
        
        if(test)then
!         temporary input for chaecking with JC's model
!         reading rules_flow_input.csv
!           1.	Date
!           2.	QItd=LWPG QI  RTD  col F in Master  7 day smoothed  Inflow used for WF
!           3.	Lwin_level - Lake Winnipeg Water level -col. M in Q Decision 711 -to 715
!           4.	Lwin_calc_QO - Calc. total Lake Winnipeg Outflow  col AI
!           5.	Lwin_Obs_QO - Total Lake Winnipeg outflow  col. E & AJ in Master
          read(765,*)junk,QItd,Lwin_level,Lwin_calc_QO,Lwin_obs_QO 
        endif         
        
!       NOTE: have to use previous day lake level as today's is not yet calculated
!       Unlike spreadsheet, this model is not recursive.          
               
!       Col. U: lake_elv  <  711.75              Choice
!       Col. U: lake_elv  <  216.79              Choice
!       The minimum total lake Winnipeg outflow is ~26000cfs ( 736 cms)
!       The east channel is unregulated so the raimder is what needs to 
!       pass through the west channel
!        Qech=187.30154*(Helv-215.668)**1.25   !AE
!       Minimum total lake Winnipeg (East+west Channel) release (~26000cfs = 736 cms)
!       As per e-mail PS 'This needs to be adjusted by the OW% coefficient.' 30/12/2016
        Qech=aaa3(j)*187.30154*(Hpd-215.668)**1.25   !AE
        QnwchU=736.000-Qech
      
!       Col. Y:  lake_elv  >  715                Choice  LWPG WC Maximum QO Calc
!       Col. Y:  lake_elv  >  217.93             Choice  LWPG WC Maximum QO Calc
!       Calculate the Max west channel flow
!        QnwchY=aaa2(j)*(Helv-ccc2(j))**bbb2(j)
        QnwchY=aaa2(j)*(Hpd-ccc2(j))**bbb2(j)

!       Col. W:  712.25  < lake_elv  <  714.5    Choice  Q Decision 711 to 715
!       Col. W:  217.23  < lake_elv  <  217.78   Choice  Q Decision 711 to 715
!       Needs U & Y 
        j=jul_day_now
        Qdecision=aaa1(j)*(Hpd-ccc1(j))**bbb1(j)

!       Added by PS & JC:      this may cause a sudden drop of 500 cms
	  if(Qdecision.lt.900)then
          Qdecision =QnwchU
	  endif
        
        if(Qdecision.lt.QnwchU)then
          QnwchW=QnwchU
        elseif(Qdecision.gt.QnwchY)then
          QnwchW=QnwchY
        else
          QnwchW=Qdecision
        endif

!       Col. V:  711.75  < lake_elv  <  712.25   Transition    
!       Col. V:  216.79  < lake_elv  <  217.09   Transition    
!       Note: 217.09-216.94=0.15
!       Needs U & W & Qech 
!       Use yesterday's water level
!       Corrected by PS & JC
        if(QnwchU+(QnwchW-QnwchU)*(Hpd-216.94)/0.15.lt.QnwchU)then
          qnwchV=QnwchU
        elseif(QnwchU+(QnwchW-QnwchU)*(Hpd-216.94)/0.15.gt.QnwchW)then
          QnwchV=QnwchW
        else
          QnwchV=QnwchU+(QnwchW-QnwchU)*(Hpd-216.94)/0.15
        endif
       
!       Col. X:  714.5   <  lake_elv  < 715.0    Transition
!       Col. X:  217.78  <  lake_elv  < 217.93   Transition
!       Note: 217.93-217.78=0.15
!       Needs W & Y
!       Use yesterday's water level
        if(QnwchW+(QnwchY-QnwchW)*(Hpd-217.78)/0.15.lt.QnwchW)then
          QnwchX=QnwchW
        elseif(QnwchW+
     *            (QnwchY-QnwchW)*(Hpd-217.78)/0.15.gt.QnwchY)then
          QnwchX=QnwchY
        else
          QnwchX=QnwchW+(QnwchY-QnwchW)*(Hpd-217.78)/0.15
        endif

!       Col. Z:
        if(Hpd.lt.216.94)then
          QnwchZ=QnwchU
        elseif(Hpd.lt.217.09)then
          QnwchZ=QnwchV
        elseif(Hpd.lt.217.78)then
          QnwchZ=QnwchW
        elseif(Hpd.lt.217.93)then
          QnwchZ=QnwchX
        else     ! > 217.93 for max flow
          QnwchZ=QnwchY
        endif  
      
!       Col. AA - Decision with 15000 cfs (424.7 cms) restriction
        QAApd=QnwchAA      !previous day flow - west channel only!!!!!
        if(abs(qnwchZ-QAApd).lt.424.7)then
          QnwchAA=qnwchZ
        elseif(QnwchZ.gt.QAApd)then
          QnwchAA=QAApd+400.
        else
          QnwchAA=QAApd-400.
        endif
        
        QOtd=QnwchAA+Qech
        STpd=STtd      !store1 & store2 are reset in route for diff. Dt
               
!       43200. is daily time step in seconds / 2
        STtd=STpd+(QIpd+QItd-QOpd-QOtd)*43200.
        Htd=216.103+STtd/lake_area(l) ! new elv after today
        store2(n)=STtd
        store1(n)=STpd
!       previous day elv will be used to calculate todays outflow
!       as todays lake elevation is not nown at the start.

        If(test)then
!         write to Lwin_test.csv      
          write(617,62700)jz,Htd,Qech,QnwchU,QnwchV,QnwchW,
     *                  QnwchX,QnwchY,QnwchZ,QnwchAA,Qdecision,QOpd,
     *                  QIpd,QItd,qo1(n),qo2(n),store1(n),store2(n),
     *                  Lwin_level,Lwin_obs_QO
62700     format(i10,15(',',f10.3),2(',',f15.0),2(',',f10.3),',',f15.7)

!         temporary output rules_test_output.csv for checking with JC's output
!         Lwin_test_output.csv
66600     format(99(f10.3,','))  
        endif    
!       1.	QItd  Lake inflow from Excel spreadsheet or WF model in regular mode
!       2.	Lwin_level  Lake Winnipeg observed level  used as input in Excel model
!       3.	Lwin_calc_QO  Calculated outflow in Excel
!       4.	Lwin_obs_QO - Total observed Lake Winnipeg outflow  col. E & AJ in Master
!       5.	Htd  WF calculated lake level
!       6.	QOtd = WF total lake outflow
!       7.	QnwchAA  WF Jenpeg outflow
!       8.  Wech - WF east channel outflow
        
        write(666,66600)QItd,Lwin_level,Lwin_calc_QO,
     *                   Lwin_obs_QO,Htd,QOtd,QnwchAA,Qech


!       assigning outflows to the usual output files for reporting 
!       Flow station l is the East channel WSC gauge location
!       In lst.f hourly values are expected    
!       Note:  this is for reporting and compariing to gauge flows only
!       It is not part of the routing   

c        if(jz.lt.24)then
c          DO i=1,24
c              lake_elv(l,jz+i-1)=Htd
c              lake_outflow(l,jz+i-1)=QOtd
c 	        lake_inflow(l,jz+i-1)=qi2(n) ! previously taken out from QR in sub
c              net_lake_inflow(l,jz+i-1)=qi2(n)-qo2(n)
c              write(650,65000)jz,i,jz+i-1,lake_elv(l,jz+i-1),
c     *                Qech,QnwchAA,lake_inflow(l,jz+i-1)
c65000         format( 3i5,4f10.3)         
c          END DO
c        else
c          DO i=1,24
c              lake_elv(l,jz+i)=Htd
c              lake_outflow(l,jz+i)=QOtd
c 	        lake_inflow(l,jz+i)=qi2(n) ! previously taken out from QR in sub
c              net_lake_inflow(l,jz+i)=qi2(n)-qo2(n)
c              write(650,65000)jz,i,jz+i,lake_elv(l,jz+i),Qech,QnwchAA,
c     *                lake_inflow(l,jz+i)
c          END DO
c        endif
        
        if(jz.le.mhtot-24)then
            do i=jz,jz+24
              lake_elv(l,jz)=Htd
              lake_outflow(l,jz)=QOtd   
 	        lake_inflow(l,jz)=qi2(n) ! previously taken out from QR in sub
              net_lake_inflow(l,jz)=qi2(n)-qo2(n)
          END DO
        endif

      
      endif  ! jul_day_now.ne.jlast

!     East channel flow is the lake outlet     
      qo2(Echnl_grid)=Qech
!     Jenpeg is like a diversion is added inflow for the next grid
      qi2(Jenpeg_grid)=qi2(Jenpeg_grid)+QnwchAA
      
      return

      END SUBROUTINE LWinnip      SUBROUTINE Reindeer(n,div,thr,l,jz,at,dtmin,date,time)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     Coded by NK. June 2017

      use area_watflood
	implicit none
	save

      integer  :: i,j,k,l,n,jz,ios,jlast,day_count,SB_grid
      integer  :: Lcode,Ccode,Ocode
      integer  :: yearNR,monthNR,dayNR  
      character(14) date
      real*4   :: div, thr,at,dtmin,time,Qtemp
      real*4   :: lookup(12,6)
      real*4   :: Helv,Qcol_T,Qcol_AC,Qcol_O_RPR            ! Values from the spreadsheet
      real*4   :: Hpd,Htd,QOpd,QOtd,QIpd,QItd,STpd,STtd,QAApd
      real*4   :: Q_WS_min,H_RD_min,H_RD_max,Q_WS_max,Q_WS_opt1
      real*4   :: Q_bar_IFalls,Q_IFalls(31),Qsum,QIFlocal
      Real*4   :: Qtarget,Qweighted,Qlimit,Q_RD_final,Q_WS_middle
      real*4   :: Qdecision(8),Qaa(7),Qab
      real*4   :: Qdecn_M,Qdecn_N
      real*4   :: Qtrans1,Qtrans2,QcolV,Q_WS_last,Q_min,Q_max
      real*4   :: Qhourly(25),Qinflow(31)
      character(20) :: junk
      character*72 stuff,line
      logical  :: firstpass,test,exists,NFS
      
      real*4   :: islfallslocal,last14days,reinderlakelevel,
     *                   levelcode,churcflowcode,overallmincode,
     *                   targetflow,decisionflow,daydecflow7,wfandnoise
      character(6) season,seasonWF

      
      data        firstpass/.true./
      data        test/.false./
      data        jlast/0/
      data        day_count/0/
      data        Q_IFalls/31*0.0/     ! set the initial Island Falls vector = 0
      data        Qdecision/8*0.0/
      data        Qinflow/31*0.0/
      data        Qhourly/25*0.0/
      
!     QIpd = previous day inflow
!     QItd = today's inflow                     input of model run
!     QOpd = previous day outflow
!     QOtd = today's outflow
!     Helv= lake elevation                      input for test
!     Hpd = lake elevation previous day
!     Htd = lake elevation today
!     STpd = previous day storage
!     STtd = today's storage
!     Q_WS_min = min flow at Whitesand
!     Q_Ifalls = Island Falls discharge - not used
      
!     Qcol_T = Whitesnad Middle = col T in MASTER = col. O on the Reindeer Power Range
!     Qcol_AC = col. AC in MASTER = Final
      

      
      if(firstpass)then
        Print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        INQUIRE(FILE='resrl\Reindeer_test.txt',EXIST=exists) 
!       if the file is not present the default = flase - i.e. test will not be run        
        if(exists)then
          open(unit=99,file='resrl\Reindeer_test.txt',status='old',
     *                               iostat=ios)
          read(99,*)junk,junk
          close(unit=99,status='keep')
          if(junk(1:1).eq.'y')then
             test=.true.
          else
              test=.false.
          endif
        else
!         default - if file not pteresent, use model data            
          test=.false.
        endif
          
        open(unit=99,file='resrl\ReindeerL_Lookup.csv',
     *                 status='old',iostat=ios)
        if(ios.ne.0)then
          print*,'Unable to open resrl\ReindeerL_Lookup.csv'
          stop 'Program aborted in SIndian @ 284'
        endif
          do i=1,4
            read(99,*)
          end do
        do i=1,12
          read(99,*)(lookup(i,j),j=1,6)
        end do
        close(unit=99,status='keep')
c        do i=1,12
c          write(*,*)i
c          write(*,*)(lookup(i,j),j=2,6)
c        end do
        print*,'Finished reading Lookup table for Reindeer Lake'

        H_RD_min=334.7    ! Reindeer Lake min elv.
        H_RD_max=336.7    ! Reindeer Lake max elv.
        
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       for testing only:
        if(test)then
          INQUIRE(FILE='resrl\reindeer_test_input.csv',EXIST=exists) 
!         if the file is not present the default = flase - i.e. test will not be run        
          if(exists)then
              open(unit=885,file='resrl\reindeer_test_input.csv',
     *                          status='old',iostat=ios)
              if(ios.ne.0)then
                  print*,'Problem opening resrl\rule_test.txt'
                  stop 'Program aborted in Reindeer @ 150'
              endif
              print*,'CHARM Continues with Reindeer test input'
              read(885,*)   ! read the header line #1. 
              read(885,*)   ! read the header line #2. 
            
!             Go to the firts day of the run              
              nfs=.true.
              do while(nfs)
                  read(885,*)line
c                  print*,line(1:10)
                  read(line,88500)yearNR,monthNR,dayNR
88500             format(i4,1x,i2,1x,i2)  
c                  print*,yearNR,monthNR,dayNR,LWoutflow
                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
              end do
c              print*,yearNR,monthNR,dayNR
              backspace(885)  ! puts us back on the first data line to read
            
          else
            print*
            print*,'File resrl\reindeer_test_input.csv          '
            print*,'expected but not found'
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            print*
            stop 'Program aborted in MH_Reindeer @ 139'
          endif
          
      endif    !test 

!       Different files are written so the WF values (live) can be compared to the
!       spreadsheet values (test).      
        If(test)then
          open(unit=866,file='results\Reindeer_test_output.csv',
     *                         status='unknown',iostat=ios)
          open(unit=888,file='resrl\RDL_power_range.csv',
     *                         status='unknown',iostat=ios)
!         Go to the firts day of the run              
          nfs=.true.
          read(888,*)
          do while(nfs)
              read(888,*)line
c              print*,line
              read(line,88500)yearNR,monthNR,dayNR
c              print*,yearNR,monthNR,dayNR,LWoutflow
              if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
          end do
c          print*,yearNR,monthNR,dayNR
          backspace(888)  ! puts us back on the first data line to read
          open(unit=889,file='results\RPR_compare.csv',status='unknown')
        else
          open(unit=866,file='results\Reindeer_live_output.csv',
     *                         status='unknown',iostat=ios)
        endif
        
        write(866,86601)'    date ','QI_RTD__F','Level_Inp',
     *        'Q_WS_min',
     *        'Qtrans1','Qtrans2',   
     *        'Lcode','Ccode','Qtarget_L','Qdecn_M',
     *        'Col_O_RPR','Qcol_T','Qweighted','Q_WS_middle',
     *        'Qcol_V','Qcol_Y','Qaa(7)_AA',
     *        'Final_AC','qo2(n)_AC'    
86601   format(99(a9,','))     
      
!           Initial conditions
            QIpd=227.    !previous day inflow
            QItd=227.    !today's inflow
            qi1(n)=QIpd
            qi2(n)=QIpd
            
            Helv=335.34   !lake elevation
            Hpd=335.34     !lake elevation previous day
            Htd=335.34     !lake elevation today
            STtd=(Htd-330.0)*lake_area(l)
            STpd=STtd

!       Find the Sandy Bay grid number WSC 06EA002:
!       lat. 54.500  long, -98.050
        j=int((-102.316-xorigin)/xdelta)+1
        i=int((55.525-yorigin)/ydelta)+1
        SB_grid=s(i,j)
        print*,'Sandy Bay grid no = ',SB_grid
        print*,'Using Reindeer Lake Operating Rule     '
        Print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      endif  ! firstpass
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     Calculate past 24 hour average flow
      Qhourly(25)=qi2(n)
      k=24  ! k days moving average
      Qhourly(k+1)=qi2(n)
      do i=2,k+1
        If(totaltime.ge.float(k))then
          Qhourly(i-1)=Qhourly(i)
        else
          Qhourly(i-1)=qi2(n)
        endif
      end do
c      write(911,91100)date_now,hour_now,qi2(n),(Qhourly(i),i=1,25)
c91100 format(a10,i5,f6.0,5x,25f6.0)
      
      
      if(jul_day_now.ne.jlast.and.mod(hour_now+23,24).eq.0)then ! i.e. at 00:00 today
          
c          print*,'Julian day ',jul_day_now             ! < take out
          
          j=jul_day_now
          jlast=jul_day_now
          
          QIpd=QItd   ! inflow previous day
          QOpd=QOtd   ! outflow previous day
          STpd=STtd   ! storage previous day
          Hpd=Htd     ! storage previous day
          
          if(test)then
!             temporary input for chaecking with JC's model
!             reading resrl\Reindeer_test_input.csv
!             The model is driven by lake elevation - inflow is not considered
c              Hpd=Htd
              read(885,*,iostat=ios)line,
     *                   Helv,QItd,QIFlocal,Qcol_O_RPR,Qcol_T,Qcol_AC      ! test input from Excel
              if(ios.ne.0)then
                  print*,'Error reading resrl\reindeer_test_input.csv'
                  print*,'@ line beginning with ',line(1:10)
              endif
c              STtd=STpd+(QOpd-QIpd)*43200.      ! col. Q
c              Htd=17.768*alog(STtd)+87478.0     ! From a curve fit to the data in Island Falls Storage Curve
              Htd=Helv                           ! drives this rule
c             print*,stuff,Htd,junk,inflow_obs 
              
              read(888,*,iostat=ios)line,n,n,n,
     *                   islfallslocal,last14days,reinderlakelevel,
     *                   season,levelcode,churcflowcode,overallmincode,
     *                   targetflow,decisionflow,daydecflow7,wfandnoise
              if(ios.ne.0)then
                  print*,'Error reading resrl\RDL_power_range.csv'
                  print*,date_now,'@ line beginning with ',line(1:10)
              endif
              
              read(line,88500)yearNR,monthNR,dayNR
              if(yearNR.ne.year_now.or.monthNR.ne.month_now.or.
     *              dayNR.ne.day_now)
     *              print*,date_now,yearNR,monthNR,dayNR         

              
          else
!             For actual use:
!             Remove resrl\reindeer_test_input.csv
!             The model is driven by model inflows - lake elv is computed

c              QItd=qi2(n)       ! from the model - drives this rule
              
              
!             Smoothing inflows           
!             move allthe flows back one day
              k=7  ! k days moving average
!             mean daily flow:          
              Qinflow(k+1)=0.0
              do i=1,24
                  Qinflow(k+1)=qinflow(k+1)+Qhourly(i)
              end do
              Qinflow(k+1)=Qinflow(k+1)/24.0  ! today's mean flow
c              write(911,91101)Qinflow(k+1)
c91101         format(170x,f6.0)          
!             k day moving average:          
              do i=2,k+1
                  Qinflow(i-1)=Qinflow(i)
              end do
              If(totaltime.ge.float(k))then
                  Qsum=0.0
                  do i=1,k
                      Qsum=Qsum+Qinflow(i)
                  end do
                  QcolV=Qsum/float(k)
              else
c                 QcolV=QItd
                  QcolV=qi2(n)
              endif
              QItd=QcolV
c          write(491,49100)date_now,(Qinflow(i),i=1,7),Qsum,QItd
c49100     format(a10,99f10.3)          
              
!             Island falls local               
!             Sandy Bay grid # = 2181     <<<<<< use flow station location in future         
              QIFlocal=QOpd-qo2(SB_grid)
          endif
         
!         Whitesand min flow  Q_WS_min      ! col. R
          if(jul_day_now.le.15)then
             Q_WS_min=150.0
          elseif(jul_day_now.le.46)then
              Q_WS_min=225.0
          elseif(jul_day_now.le.73)then
              Q_WS_min=300.0
          elseif(jul_day_now.le.104)then
              Q_WS_min=250.0
          elseif(jul_day_now.le.119)then
              Q_WS_min=150.0
          elseif(jul_day_now.le.150)then
              Q_WS_min=100.0
          elseif(jul_day_now.le.211)then
              Q_WS_min=15.0
          elseif(jul_day_now.le.303)then
              Q_WS_min=30.0
          elseif(jul_day_now.le.318)then
              Q_WS_min=50.0
          elseif(jul_day_now.le.347)then
              Q_WS_min=125.0
          elseif(jul_day_now.le.365)then
              Q_WS_min=150.0
          endif   
          
c          STtd=STpd+(QOpd-QIpd)*43200.      ! col. Q
c          Htd=17.768*alog(STtd)+87478.0     ! From a curve fit to the data in Island Falls Storage Curve
                                          ! What's wrong with a simple curve fir??????????????????????????
      
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         Reindeer Power  Range QO
!         Use Island Falls demand
!         Determine the level code Col. I from the island Falls Staorage curve  <<<<
!                                          is this from a different lake ??????????????

!         Island Falls local is flow at Island Falls - Reindeer outflow so 
!         is the upstream Churchill River flow. The Reindeer outflows are set to meet the 
!         Island Falls power requirements 
          
!         Get the level code   col. I
          If(j.le.120.or.j.ge.274)then        ! winter
              if(Htd.gt.336.51)then
                  Lcode=5
              elseif(Htd.gt.336.27)then
                  Lcode=4
              elseif(Htd.gt.335.39)then
                  Lcode=3
              elseif(Htd.gt.334.78)then
                  Lcode=2
              else
                  Lcode=1
              endif              
              seasonwf='winter'
          else                                ! summer
              if(Htd.gt.336.51)then
                  Lcode=5
              elseif(Htd.gt.336.29)then
                  Lcode=4
              elseif(Htd.gt.335.40)then
                  Lcode=3
              elseif(Htd.gt.334.83)then
                  Lcode=2
              else
                  Lcode=1
              endif
              seasonwf='summer'
          endif
          
!         Determine the 14 day moving average of Island falls flows  col.
          Q_Ifalls(31)=QIFlocal
          If(int(totaltime/24.0).le.30)then     
              Q_bar_IFalls=QIFlocal
              day_count=day_count+1
              Q_Ifalls(day_count)=QIFlocal
c              print*,day_count,Q_Ifalls(day_count)
          else
              do i=2,31
                  Q_Ifalls(i-1)=Q_IFalls(i)
              end do
              Qsum=0.0
              do i=1,30
                  Qsum=Qsum+Q_IFalls(i)
              end do
              Q_bar_IFalls=Qsum/30.0
          endif
         
!         Get the Churchill flow code         col. J
          If(j.le.120.or.j.ge.274)then        ! winter
              if(Q_bar_IFalls.gt.444.)then
                  Ccode=5
              elseif(Q_bar_IFalls.gt.278.)then
                  Ccode=4
              elseif(Q_bar_IFalls.gt.160.)then
                  Ccode=3
              elseif(Q_bar_IFalls.gt.110.)then
                  Ccode=2
              else
                  Ccode=1
              endif   
          else                                ! summer
              if(Q_bar_IFalls.gt.535.)then
                  Ccode=5
              elseif(Q_bar_IFalls.gt.396.)then
                  Ccode=4
              elseif(Q_bar_IFalls.gt.240.)then
                  Ccode=3
              elseif(Q_bar_IFalls.gt.150.)then
                  Ccode=2
              else
                  Ccode=1
              endif              
          endif

!         Pick either the level code of the Churc. flow code Col. K
          if(Ccode.gt.3)then
              Ocode=Lcode
          else
              Ocode=min(Lcode,Ccode)
          endif
      
!         Get the target flow from the lookup table   col. L
          Qtarget=lookup(month_now,Ocode+1)    ! good to here
          
!         Decision flow                               col. M
!         Smoothing flows          
!         move allthe flows back one day          
          if(Qtarget-Q_bar_IFalls.lt.0.0)then
              Qdecision(7)=0.0
          else
              Qdecision(7)=Qtarget-Q_bar_IFalls
          endif
          Qdecn_M=Qdecision(7)
      
c!         6 day smooothed   (not 7)                           col. N  -  not used
c          do i=2,7
c              Qdecision(i-1)=Qdecision(i)
c          end do
c          If(totaltime.gt.6.0)then
c              Qsum=0.0
c              do i=1,6
c                  Qsum=Qsum+Qdecision(i)
c              end do
c              Qdecn_N=Qsum/6.0
c          else
c              Qdecn_N=Qdecision(6)      
c          endif
              
!         Reindeer Power Range QO                      col. O     
!         Whitesand outflows only changed 2x per month in summer, 1x per month in winter
          if(day_now.eq.1)Qweighted=Qdecn_M       ! in winter flow is changed only on the 1st.
          if(j.gt.120.and.j.lt.274)then        ! summer onthe 15th as well as the 1st
              if(day_now.eq.15)Qweighted=Qdecn_M
          endif
          
! >>>>>>>>>>>NOTE: many changes occurs next           
          
!         Qweighted = col. T in Master  =  col. O  in Reindeer Power Range
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!         Q_WS_min  =  Whitesand min flow                         col. W        
c          Qlimit=8.1067*Q_WS_min**2-5182.6*Q_WS_min+827763.0
          Qlimit=8.1067*Hpd**2-5182.6*Hpd+827763.0
          
!         Whitesand Middle                                      col. T
          if(Qweighted.lt.Q_WS_min)then
              Q_WS_middle=Q_WS_min
          elseif(Qweighted.gt.Qlimit)then
              Q_WS_middle=Qlimit
          else
              Q_WS_middle=Qweighted
          endif
          
!         Transition between 1098 & 1099                      col. S
          Qtemp=(Q_WS_middle-Q_WS_min)*(Hpd-334.67)/(335.0-334.67)
          
          if(Q_WS_min+Qtemp.lt.Q_WS_min)then
              Qtrans1=q_ws_MIN
          ELSEIF(Q_WS_min+Qtemp.Gt.Qweighted)then
              Qtrans1=Q_WS_middle
          else
              Qtrans1=Q_WS_min+Qtemp
          endif
          
c!         Mystery                                 col. V          
c!         Smoothing inflows flows col. F          
c!         move allthe flows back one day
c          Qinflow(8)=QItd
c          do i=2,8
c              Qinflow(i-1)=Qinflow(i)
c          end do
c          If(totaltime.gt.6.0)then
c              Qsum=0.0
c              do i=1,7
c                  Qsum=Qsum+Qinflow(i)
c              end do
c              QcolV=1.1*Qsum/7.0
c          else
c              QcolV=QItd
c          endif
c          write(491,49100)month_now,day_now,QItd,Qinflow,Qsum,Qsum/7.0
c49100     format(2i5,99f10.3)          
          
!         Whitesound Max                                 col. X
          Q_WS_max=amax1(Qweighted,amin1(Qinflow(7),Qlimit))
          
!         Transition between 1103 & 1104.6   (336.19 & 336.68)      col. U
          Qtemp=(Q_WS_max-Q_WS_middle)*(Hpd-336.19)/(336.68-336.19)
          if(Qweighted+Qtemp.lt.Q_WS_middle)then
              Qtrans2=Q_WS_middle
          elseif(Qweighted+Qtemp.gt.Q_WS_max)then
              Qtrans2=Q_WS_max
          else
              Qtrans2=Q_WS_middle+Qtemp
          endif
          
!         Decision Option 1  Whitesand QT          col. Y
!         This is just Reindeer Lake total outflow          
          Q_WS_last=Q_WS_opt1
          if(Hpd.gt.334.67)then       ! "Extreme drought" min Reinder Lake level
              if(Hpd.lt.334.67)then   ! "Drought Preparation" level (currently the same as extremme)
                  Q_WS_opt1=Q_WS_min  ! This can never happen re: note above - could be revised however.
              elseif(Hpd.lt.335.0)then
                  Q_WS_opt1=Qtrans1
              elseif(Hpd.lt.336.19)then
                  Q_WS_opt1=Q_WS_middle
              elseif(Hpd.lt.336.68)then
                  Q_WS_opt1=Qtrans2
              else
                  Q_WS_opt1=Q_WS_max
              endif
          else
              Q_WS_opt1=50.0        ! extreme drought
          endif
c          Qcol_Y=Q_WS_opt1
          
!         Decision with 142 cms per day Restriction     col. AA     
          
          if(abs(Q_WS_opt1-Q_WS_last).lt.142)then
              Qaa(7)=Q_WS_opt1
          elseif(Q_WS_opt1.gt.Q_WS_last)then
              Qaa(7)=Q_WS_last+142
          else
              Qaa(7)=Q_WS_last-142
          endif
      
!         FINAL  (Reindeer Lake = Whitesand outflow)    col. AC     
!         Find the max & min flows during the past 6 days
!         move allthe flows back one day          
          do i=2,7
              Qaa(i-1)=Qaa(i)
          end do
!         Find the min & max flows last 6 days
          Q_min=+99999.0
          Q_max=-99999.0
          do i=1,6
              Q_min=amin1(Q_min,Qaa(i))
              Q_max=amax1(Q_max,Qaa(i))
          end do
c          write(393,39300)j,Qaa,Q_min,Q_max
c39300     format(i5,99f10.0)          
!         Set weekly flow restriction          
          if(j.le.89)then
              Qab=150
          elseif(j.le.120)then
              Qab=250
          elseif(j.le.273)then
              Qab=300
          elseif(j.le.303)then
              Qab=250
          else
              Qab=200
          endif
          if(amax1(abs(Qaa(7)-Q_min),abs(Qaa(6)-Q_max)).lt.Qab)then
              QOtd=Qaa(7)
          elseif(Qaa(6).gt.Q_min)then
              QOtd=Q_min+Qab
          else
              QOtd=Q_max-Qab
          endif
          
          If(test)then
c          if(day_now.eq.1.or.day_now.eq.15)write(866,*)month_now,day_now
              write(866,86600)date_now,QItd,Helv,
     *            Q_WS_min,
     *            Qtrans1,Qtrans2,
     *            Lcode,Ccode,Qtarget,Qdecn_M,
     *            Qcol_O_RPR,Qcol_T,Qweighted,Q_WS_middle,
     *            QcolV,Q_WS_opt1,Qaa(7),
     *            Qcol_AC,QOtd    
86600         format(a10,5(',',f9.2),2(',',i9),99(',',f9.2))      
     
              
              write(889,88900)date_now,islfallslocal,QIFlocal,
     *                  last14days,Q_bar_IFalls,reinderlakelevel,Htd,
     *                   season,seasonwf,levelcode,Lcode,
     *                   churcflowcode,Ccode,overallmincode,Ocode,
     *                   targetflow,Qtarget,decisionflow,Qdecn_M,
     *                   daydecflow7,daydecflow7,wfandnoise,Qweighted
88900         format(a10,6f10.3,2a10,3(f5.0,i5), 8f10.3)  
              
              

c              qi2(n)=QItd
              store2(n)=(Htd-330.0)*lake_area(l)
          else
!             43200. is daily time step in seconds / 2
              STtd=STpd+(QIpd+QItd-QOpd-QOtd)*43200.
!             Lake datum taken as col N = 256.95        
              Htd=330.0+STtd/lake_area(l) ! new elv after today
              store2(n)=STtd

              write(866,86600)date_now,QItd,Htd,
     *            Q_WS_min,
     *            Qtrans1,Qtrans2,
     *            Lcode,Ccode,Qtarget,Qdecn_M,
     *            Qcol_O_RPR,Qcol_T,Qweighted,Q_WS_middle,
     *            QcolV,Q_WS_opt1,Qaa(7),
     *            Qcol_AC,QOtd    
              
c              if(day_now.eq.1.or.day_now.eq.15)
c     *                    write(866,*)month_now,day_now
c                  write(866,86611)date_now,
c     *                           QIpd,QItd,QOpd,QOtd,STtd,Htd
c86611             format(a10,4f10.2,f15.0,99f10.3)
          endif   ! test
          
              

      endif    !jul_day_now
          
!     assigning outflows to the usual output files for reporting 
!     In lst.f hourly values are expected    
!     Note:  this is for reporting lake conditions only.
!     It is not part of the routing   
      lake_elv(l,jz)=Htd
      qi2(n)=QItd
      qo2(n)=QOtd
      lake_elv(l,jz)=Htd
      lake_outflow(l,jz)=QOtd   
      lake_inflow(l,jz)=qi2(n) ! previously taken out from QR in sub
      net_lake_inflow(l,jz)=qi2(n)-qo2(n)
          
      firstpass=.false.

      return
      
      end subroutine Reindeer!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
          if(divertflg.eq.'g')then
            INQUIRE(FILE='basin\root_diversion_grids.xyz',
     *                         EXIST=exists)          
            if(exists)then
              allocate(gridtake(1),gridgive(1),stat=iAllocate)
                if(iAllocate.ne.0)then
                print*
                print*,'Error with allocation in MH_root_coord @17'
                print*,'firstpass =',firstpass
                STOP 'Program aborted in MH_root_coord @ 19'
              endif
              open(99,file='basin\root_diversion_grids.xyz',
     *             status='old',iostat=ios)
              if(ios.ne.0)then    ! added Nov. 10/14  nk
                print*,'Only for the Winnipeg River:'
                print*,'error opening  basin\root_diversion_grids.xyz'
                print*,'Possible cause(s):'
                print*,'file in use by another application'
                print*,'or target directory does not exist'
                stop 'Program aborted in MH_root_coord.fi @ 312'
              endif
              print*
              print*,'rev. 9.9.16  Jun.  06/14'
              print*,'Coordinates for Lake St. Joseph diversion rules'
              do i=1,3
                read(99,*,iostat=ios)divLon(i),divLat(i),j,cjunk(i)
                print*,divLon(i),divLat(i),j,cjunk(i)
              end do
              if(ios.ne.0)then
                print*
                print*,'error reading  basin\root_diversion_grids.xyz'
                stop 'Program aborted in MH_root_coord.fi @ 427'
              endif
              read(99,*,iostat=ios)
              read(99,*,iostat=ios)qtweak
              if(ios.ne.0)then
                qtweak=1.0
                print*
                print*,'qtweak assumed as 1.0'
                print*
              endif
              close(unit=99,status='keep')
!             1 = Ear Falls
!             2 = Slave Falls              
!             3 = gridgive = Root River  
!             4 = gridtake is taken care of in rerout           
              do i=1,3
                divX(i)=int((divLon(i)-xorigin)/xdelta)+1
                divY(i)=int((divLat(i)-yorigin)/ydelta)+1
                divGridNo(i)=s(divY(i),divX(i))
              end do
              gridgive(1)=divGridNo(3)
c              gridtake(1)=divGridNo(4)
              print*
              print*,'Local grid coordinates:'
              print*,'                      X           Y        Rank'
              do i=1,3
                print*,i,divX(i),divY(i),divgridno(i)
              end do
              print*,'qtweak =',qtweak
              print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            else
              print*
              print*,'the file:  basin\root_diversion_grids.xyz' 
              print*,'is not found in the expected place'
              print*,'Please fix'
              stop 'Program aborted in MH_root_coord.fi @ 445'
            endif
c           endif   ! divertflg
          
!           check to see if the receiving grid is lower than the
!           lake St. Jo outlet grid to make sure things are done
!           int he right order
            print*
            print*,'divertflg = `g`'
            
!           Added Conditional and serach for lake # Oct. 21/16 NK
!           What grid # is the Lake St. Jo outlet?
c            do l=1,noresv
c              if(resname(l)(1:7).eq.'L_St_Jo')then
                n=s(ires(l),jres(l))
c                if(s(ires(13),jres(13)).lt.divGridNo(3))then
                if(n.lt.divGridNo(3))then
                  print*
                  print*,'All`s well'
                  print*,'Lake St. Jo outlet rank =',n,'is lower '
                  print*,'than the receiving grid #', divGridNo(3)
                  print*,'Qdivert is calculated before it is routed'
                  print*,'by the receiving grid'
                  print*
                else
                  print*
                  print*,'Lake St. Jo outlet rank =',n,'is higher' 
                  print*,'than the receiving grid #', divGridNo(3)  
                  print*,'This is wrong - results in the wrong order of'
                  print*,'routing water from grid to grid'
                  print*,'Program will continue witht the previous'
                  print*,'time step value'
                  print*
c                  stop 'Program aborted in MH_root_coord.fi @ 87'
                endif
c              endif
c            end do            
            
            
!          moved endif(divertflg) to here to included the above coord check
!          only when divertflg = 'g'     Aug. 10/15  NK                     
          endif   ! divertflg
!     MH_root_diversion.fi

!~~~~~~~~~generate diversion flow~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!         no diversion file found so a diversion file is created
!         It will be written in lst.f at the end of each event
!         here we just calculate qdivert()
!         let's keep the lake elc above 371 masl = historic
          if(mhtot.gt.ndiv_max)then
            ndiv_max=mhtot
!           the event is longer than any of the previous events so 
!           more memory has to be allocated
            deallocate(qdivert,stat=iDeallocate)     
            if(iDeallocate.ne.0)print*,    
     *        'Error with deallocation of qdivert in rerout'
!           re-allocate for larger arrays
            allocate(qdivert(1,mhtot),stat=iAllocate)
            if(iAllocate.ne.0) STOP
     *       'Error with allocation of qdivert in rerout @ 410'
          endif
          wrtdiverflg=.true.
          if(temp_elv(l).gt.371.25)then
!           see L. St. Jo OR spreadsheet          
!           Stage	Discharge
!           370.01	0
!           370.66	10
!           371.05	20
!           371.62	40
!           372.04	60
!           372.38	80
!           372.67	100
!           373.18	140
!           373.63	180
!           374.31	245
            qdivert(1,jz)=11.998880*temp_elv(l)*temp_elv(l)
     *        -8873.797998*temp_elv(l)+1640658.896071
	    else
	      qdivert=0.0
	    endif
	    
	    write(456,*)1,jz,temp_elv(l),qdivert(1,jz)
	    
	    
	    qraw=qdivert(1,jz)
	    
!         restrictions due to downstream conditions	    
!         if flow at Ear Falls > 450 cms diversion is closed
!         use the previous flow because current flow may not be computed yet. 
!          if(qo1(2165).gt.450.0)qdivert(1,jz)=0.0
          if(qo2(divGridNo(1)).gt.450.0)qdivert(1,jz)=0.0
!         if flow at Slave Falls > 960 cms diversion is closed          
!          if(qo1(2965).gt.960.0)qdivert(1,jz)=0.0
          if(qo2(divGridNo(2)).gt.960.0)qdivert(1,jz)=0.0
          
!         Adjustment for LWCB not following their own rules:
          qdivert(1,jz)=qdivert(1,jz)*qtweak    
!         the rating curve may be low but there's a channel capacity:                
          qdivert(1,jz)=amin1(qdivert(1,jz),200.0)          
          
          store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
     *               -2.0*qdivert(1,jz)*div     
!         qdivert(n,jz) is added here for reporting only
!         it was subtraced in sub
          lake_inflow(l,jz)=qi2(n)                ! +qdivert(1,jz)
          net_lake_inflow(l,jz)=qi2(n)-qo2(n)-qdivert(1,jz)
          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          temp_elv(l)=lake_elv(l,jz)
c        endif
!         add the computed diversion flow into the Root river
!          qi2(1836)=qi2(1836)+qdivert(1,jz)

          qi2(divgridno(3))=qi2(divgridno(3))+qdivert(1,jz)

	    
	    write(456,45600)2,jz,temp_elv(l),qdivert(1,jz),
     *	    qo2(divGridNo(1)),qo2(divGridNo(2))
45600     format(2i10,99f10.3)     
	    

          
!         write the WF_*_div.tb0 file
          if(jz.eq.mhtot)then          ! flag set in rerout
            if(allocated(gname))then
              deallocate(gname,xsta,ysta,xsta1,ysta1,stat=iDeallocate)
              if(ideallocate.ne.0)print*,
     *          'problem deallocating outarray in rerout @ 506'
            endif
            allocate(gname(1),xsta(1),ysta(1),xsta1(1),ysta1(1),
     *              stat=iAllocate)
            if(iAllocate.ne.0)STOP
     *         'Error with allocation of gname lst & 522'
            write(line,99001)'diver\WF_',year_now,'0101_div.tb0'
99001       format(a9,i4,a12)
            read(line,*)fln(99)        
            author='SPL                                     '
            source_file_name='last SPL run'
            name='WATFLOOD: St. Jo. Diversion'
            coordsys_temp=coordsys1
!           GreenKenue uses LatLong - code below uses LATLONG
            if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
            if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
            zone_temp=zone1
            datum_temp=datum1
            xorigin_temp=xorigin
            yorigin_temp=yorigin
            xcount_temp=1
            startdate='unknown   '
            starttime='unknown   '
            unit_conversion=1.0
            deltat_temp=kt*3600
            column_units(1)='cms' 
            column_type(1)='float'
            source_file_name='last spl run'   
            gname(1)='05QB006WF'
c            xsta(1)=-91.3500
c            ysta(1)=50.9670
!           diversion water has to come out of L. St. Jo outlet grid
            xsta(1)=-90.201
            ysta(1)=51.100
            xsta1(1)=-91.4580
            ysta1(1)=50.8690
!           write the header:            
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_tb0(99,99,1,1,8)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ycount_temp=nl/kt
      
            if(allocated(outarray))then
              deallocate(outarray,stat=iDeallocate)
              if(ideallocate.ne.0)print*,
     *          'problem deallocating outarray in rerout @ 506'
            endif
            allocate(outarray(nl/kt,1),stat=iAllocate)
            if(iAllocate.ne.0)STOP
     *         'Error with allocation of outarray rerout & 474'
          
            qsum=0.0
            do k=1,nl
              qsum=qsum+qdivert(1,k)
              if(mod(k,kt).eq.0)then
                qsum=qsum/float(kt)
                outarray(k/kt,1)=qsum
                qsum=0.0
              endif
            end do
!           write the data
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_tb0(99,99,0,1,12)    
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            close(unit=99,status='keep')
            write(51,*)'Closed unit 99 Filename=  ',fln(99)(1:40)
            write(*,*)'Closed unit 99 Filename=  ',fln(99)(1:40)

            deallocate(outarray,stat=iDeallocate)
            if(ideallocate.ne.0)print*,
     *          'problem deallocating outarray in rerout  @ 493'
          endif
      SUBROUTINE SIndian(n,div,thr,l,jz,at,dtmin,date,time)

!     Coded by NK. Jan. 2017

      use area_watflood
	implicit none
	save

      integer  :: i,j,k,l,n,jz,ios
      character(10) date
      real*4   :: div, thr,at,dtmin,time 
      character(20) :: junk
      
      integer  :: jd(366),bp(366),nbps,ngaps,iz,jlast
      integer  :: RGno
      integer  :: yearNR,monthNR,dayNR  ! year, month & day for Notigi flow reduction
      real*4   :: aaa1(366),bbb1(366),ccc1(366)
      real*4   :: aaa2(366),bbb2(366),ccc2(366)
      real*4   :: aaa3(366)
      real*4   :: Helv,Hpd,Htd,QOpd,QOtd,QIpd,QItd,STpd,STtd,QAApd,
     *            QsilR,QsilS,QsilT,
     *            QsilU,QsilV,QsilW,QsilX,QsilY,QsilZ,QsilZpd,
     *            QsilLApd,QmissiAFpd,QsilALpd,QmissiAHpd,
     *            QmissiAE,QmissiAF,QmissiAH,QmissiAG,QsilAL,
     *            Qobs,LWoutflow,
     *            av7QItd,av7QsilZ
      real*4   :: level_obs,inflow_obs,notigi_calc_QO,Missi_obs_QO
      real*4   :: Notigi_min(12),Notigi_max,Notigi_dcn
      real*4   :: Qhourly(25),Qinflow(31)
      real*4   :: colR,colW,colV,colT,colU,colS,colX,colY,colZ,
     *            colAE,colAF,colAG,colAH,colAL 
      character*72 stuff,line
      logical  :: firstpass,test,exists,nfs  !(notfoundstart)
      
      data        firstpass/.true./
      data        test/.false./
      data        jlast/0/
!     Notigi min flow each month      
      data        notigi_min/900,700,500,500,500,500,
     *                       500,500,500,500,700,900/ 
     
      if(firstpass)then
        print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          
        INQUIRE(FILE='resrl\SIndian_test.txt',EXIST=exists) 
!       if the file is not present the default = flase - i.e. test will not be run        
        if(exists)then
          open(unit=99,file='resrl\SIndian_test.txt',status='old',
     *                                      iostat=ios)
          read(99,*)junk,junk
          close(unit=99,status='keep')
          if(junk(1:1).eq.'y')then
             test=.true.
          else
              test=.false.
          endif
        else
!         default - if file not pteresent, use model data            
          test=.false.
        endif
          
        INQUIRE(FILE='resrl\SIndianLake_OR.csv',EXIST=exists) 
        if(.not.exists)then
            print*,'resrl\SIndianLake_OR.csv not found'
            print*,'Program aborted in MH_SIndian.f @ 65'
            stop
        endif
        open(unit=99,file='resrl\SIndianLake_OR.csv',
     *                 status='old',iostat=ios)
        if(ios.ne.0)then
          print*,'Unable to open resrl\SIndianLake_OR.csv'
          stop 'Program aborted in SIndian @ 284'
        endif
        
        open(unit=616,file='SIndian_coefficients_info.txt',
     *                 status='unknown',iostat=ios)
        read(99,*)
        j=1
!       j = data point #
!       i = julian day for the data point   
!       aaa1, bbb1, ccc1 are for Notigi Desision outflow (844-847) 
!       aaa2, bbb2, ccc2 are for Notigi diversion max flow 
        do while(.not.eof(99))
          read(99,*,iostat=ios)junk,junk,i,aaa1(i),bbb1(i),ccc1(i),
     *                          aaa2(i),bbb2(i),ccc2(i)
          write(616,*)i,aaa1(i),bbb1(i),ccc1(i)
!         AAA1, bbb1, ccc1  are for the             
!         this right off the bat assigns values at the break points     
          bp(j)=i     ! store the julian day for data point i
          j=j+1
        end do
        close(unit=99,status='keep')
        nbps=j-1
        ngaps=j-2
        write(616,*)nbps,ngaps
!       bp(1) = always = 1 
!             
        do j=1,366
          jd(j)=j
        end do  
!       Interpolate between the mid-month data points          
        do i=1,ngaps   ! # of segments
          do j=1,366
            if(j.gt.bp(i).and.j.lt.bp(i+1))then
!             Q Decision 711 - 715 
              aaa1(j)=aaa1(bp(i))+(aaa1(bp(i+1))-aaa1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              bbb1(j)=bbb1(bp(i))+(bbb1(bp(i+1))-bbb1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              ccc1(j)=ccc1(bp(i))+(ccc1(bp(i+1))-ccc1(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
!             LWPG WC Maximun QO Calc     
              aaa2(j)=aaa2(bp(i))+(aaa2(bp(i+1))-aaa2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              bbb2(j)=bbb2(bp(i))+(bbb2(bp(i+1))-bbb2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
              ccc2(j)=ccc2(bp(i))+(ccc2(bp(i+1))-ccc2(bp(i)))*
     *                            (jd(j)-jd(bp(i)))/
     *                            (jd(bp(i+1))-jd(bp(i)))
            endif
          end do
        end do
        do j=1,366
          write(616,62600)j,aaa1(j),bbb1(j),ccc1(j),   ! SIndian_coefficients_info.txt
     *                   aaa2(j),bbb2(j),ccc2(j)       ! Checked vs spreadshhet NK 2017-07-24
62600     format(i5,6f10.3)     
        end do
        close(unit=99,status='keep')
        close(unit=616,status='keep')
        
!        Column R lookup table
!       initial values        
        QIpd=1000.    !previous day inflow
        QItd=1000.    !today's inflow
        QOpd=1000.    !previous day outflow
        QOtd=1000.    !today's outflow
        Helv=258.0   !lake elevation
        Htd=258.0     !lake elevation previous day
        Htd=258.0     !lake elevation today
        STpd=(258.0-256.95)*lake_area(l)  !previous day storage
        STtd=STpd      !today's storage
        QmissiAF=97.0
        QmissiAG=97.0
        QmissiAH=97.0
c        QsilAA=1500  !initial guess
c        write(617,*)'Lake area =',lake_area(l),store1(n),n
        iz=jz
        jlast=0
        
!       The outlet for S. Indian Lake is at Missi
!       That is where outflows and Qsyn are calculated and reported.          
!       The Notigi flows are calculated at the Missi outlet grid but
!       added to the diversion's rereceiving grid so they can be compared with
!       the WSC data there. Find the S. Indian Lake diversion grid number:
!       lat. 56.524  long, -99.076
        j=int((-99.076-xorigin)/xdelta)+1
        i=int((56.524-yorigin)/ydelta)+1
!       Receiving Grid no RGno        
        RGno=s(i,j)

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       for testing only:
        if(test)then
c          INQUIRE(FILE='resrl\SIndian_test_input.csv',EXIST=exists) 
c!         if the file is not present the default = flase - i.e. test will not be run        
c          if(exists)then
c              open(unit=785,file='resrl\SIndian_test_input.csv',
c     *                         status='old',iostat=ios)
c              if(ios.ne.0)then
c                  print*,'problem opening SIndian_test_input.csv'
c                  stop 'Program aborted in SIndian @ 665'
c              endif
c              print*,'CHARM Continues with S Indian test input'
c              read(785,*)   ! read the header line. 
c!             Go to the firts day of the run    
c              nfs=.true.
c              do while(nfs)
c                  read(785,*)line,Helv,junk,inflow_obs,
c     *                             Notigi_calc_QO,Missi_obs_QO
c                  print*,line(1:10),LWoutflow
c                  read(line,78600)yearNR,monthNR,dayNR
78600             format(i4,1x,i2,1x,i2)  
cc                  print*,yearNR,monthNR,dayNR,LWoutflow
c                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
c     *                     dayNR.eq.day_now)nfs=.false.         
c              end do
cc              print*,yearNR,monthNR,dayNR
c              backspace(785)  ! puts us back on the first data line to read
c          else
c            print*,'File resrl\SIndian_test_input.csv '
c            print*,'expected but not found'
c            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
c            print*
c            stop 'Program aborted in MH_SIndian @ 192'
c          endif  

!         To create this file, save CRD 1912 V2.5 Cleaned and sent to Nick as resrl\SIL_all.csv   
          INQUIRE(FILE='resrl\SIL_all.csv',EXIST=exists) 
!         if the file is not present the default = flase - i.e. test will not be run        
          if(exists)then
              open(unit=788,file='resrl\SIL_all.csv',
     *                         status='old',iostat=ios)
              do i=1,16           ! pass over the header lnes
                  read(788,*)junk
              end do

!             Open the file to compare all WF columns to the spreadsheet values              
              open(unit=789,file='results\SIL_compare.csv',
     *                                        status='unknown')
!             Go to the firts day of the run              
              nfs=.true.
              read(788,*)
              do while(nfs)
                  read(788,*)line
c                 print*,line
                  read(line,88500)yearNR,monthNR,dayNR
88500             format(i4,1x,i2,1x,i2)  
c                 print*,yearNR,monthNR,dayNR,LWoutflow
                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
              end do
c             print*,yearNR,monthNR,dayNR
              backspace(788)  ! puts us back on the first data line to read
              write(789,78901)'    date  ',',R',',R',',W',',W',
     *         ',V',',V',',T',',T',',U',',U',',S',',S',',X',',X',
     *         ',Y',',Y',',Z',',Z',',AE',',AE',',AF',',AF',
     *         ',AG',',AG',',AH',',AH',',AL',',AL',
     *         ',Notigi_max',',QsilV',',Notigi_dcn',',QsilT'
78901         FORMAT(a10,99a11)              
          else
            print*,'File resrl\SIL_all.csv'
            print*,'expected but not found'
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            print*
            stop 'Program aborted in MH_SIndian @ 192'
          endif
            
!         To create this file, save Notigi Max Q sheet as resrl\Notigi_max.csv   
          INQUIRE(FILE='resrl\Notigi_max.csv',EXIST=exists) 
!         if the file is not present the default = flase - i.e. test will not be run        
          if(exists)then
              open(unit=738,file='resrl\Notigi_max.csv',
     *                         status='old',iostat=ios)
              do i=1,16           ! pass over the header lnes
                  read(738,*)junk
              end do

!             Go to the firts day of the run              
              nfs=.true.
              read(738,*)
              do while(nfs)
                  read(738,*)line
c                 print*,line
                  read(line,88500)yearNR,monthNR,dayNR
c                 print*,yearNR,monthNR,dayNR,LWoutflow
                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
              end do
c             print*,yearNR,monthNR,dayNR
              backspace(738)  ! puts us back on the first data line to read
          endif
            
!         To create this file, save Notigi 844 to 847 Q sheet as resrl\Notigi_dcn.csv   
          INQUIRE(FILE='resrl\Notigi_decision.csv',EXIST=exists) 
!         if the file is not present the default = flase - i.e. test will not be run        
          if(exists)then
              open(unit=748,file='resrl\Notigi_decision.csv',
     *                         status='old',iostat=ios)
              do i=1,16           ! pass over the header lnes
                  read(748,*)junk
              end do

!             Go to the firts day of the run              
              nfs=.true.
              read(748,*)
              do while(nfs)
                  read(748,*)line
c                 print*,line
                  read(line,88500)yearNR,monthNR,dayNR
c                 print*,yearNR,monthNR,dayNR,LWoutflow
                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
              end do
c             print*,yearNR,monthNR,dayNR
              backspace(788)  ! puts us back on the first data line to read
          endif
            
        endif    !test 
            
!       Different files are written so the WF values (live) can be compared to the
!       spreadsheet values (test).      
        if(test)then
          open(unit=766,file='results\SIndian_test_output.csv',
     *                         status='unknown',iostat=ios)
        else  
          open(unit=766,file='results\SIndian_live_output.csv',
     *                         status='unknown',iostat=ios)
        endif
        
        if(test)then
          open(unit=717,file='results\SIL_test.csv',status='unknown')
        else
          open(unit=717,file='results\SIL_live.csv',status='unknown')
        endif
c        write(717,62701)'       jz,  Lake_elv,  QQsilR,    QsilS,'
c     *                 ,'    QsilT,    QsilU,    QsilV,    QsilW,'
c     *                 ,'    QsilX,    QsilY,    QsilZ, QmissiAE,'
c     *                 ,' QmissiAF, QmissiAG, QmissiAH,   QsilAL,'
c     *                 ,'    qi1(n),    qi2(n),    qo1(n),    qo2(n),'
c     *                 ,'    store1(n),      store2(n),   Helv,  Qobs' 
c62701   format(9a44)     

          write(766,76601)'Level_Obs','Inflow_obs','JC_Notigi',
     *               'WF_Notigi', 'QMissi_obs','WF_Qmissi','WF_level'
76601     format(99(a10,','))     

          print*,'Using South Indian Lake Operating Rule     '
          
          if(test)then
            open(unit=787,file='results\NotigiDiversion_test.csv',
     *                         status='unknown')
          else
            open(unit=787,file='results\NotigiDiversion_live.csv',
     *                         status='unknown')
          endif
          write(787,*)'      time,   Diversion_flow'
            
!         Data file limit Notigi Outflows if lower Nelson flooding is occurring:
!         Added July 07/17 NK
          INQUIRE(FILE='resrl\NotigiReduction_LakeWpgOutflows.csv',
     *                                    EXIST=exists) 
          if(exists)then
              print*,'Using resrl\NotigiReduction_LakeWpgOutflows.csv'
              open(unit=786,
     *              file='resrl\NotigiReduction_LakeWpgOutflows.csv',
     *              status='old',iostat=ios)
              if(ios.ne.0)then
                  print*,'Problems opening file:'
                  print*,'resrl\NotigiReduction_LakeWpgOutflows.csv'
                  print*
                  stop 'Program aborted in MH_SIndian @ 189'
              endif
!             Read the header line
              read(786,*)
!             Go to the firts day of the run              
              nfs=.true.
              do while(nfs)
                  read(786,*)line,LWoutflow
c                  print*,line(1:10),LWoutflow
                  read(line,78600)yearNR,monthNR,dayNR
c                  print*,yearNR,monthNR,dayNR,LWoutflow
                  if(yearNR.eq.year_now.and.monthNR.eq.month_now.and.
     *                     dayNR.eq.day_now)nfs=.false.         
              end do
c              print*,yearNR,monthNR,dayNR
              backspace(786)  ! puts us back on the first data line to read
          else
              print*
              print*,'resrl\NotigiReduction_LakeWpgOutflows.csv'
              print*,'not flound'
              stop 'Program aborted in MH_SIndian'
          endif
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        
      endif    !firstpass  
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     Calculate past 24 hour average flow
      Qhourly(25)=qi2(n)
      k=24  ! k hours moving average
      Qhourly(k+1)=qi2(n)
      do i=2,k+1
        If(totaltime.ge.float(k))then
          Qhourly(i-1)=Qhourly(i)
        else
          Qhourly(i-1)=qi2(n)
        endif
      end do
c      write(911,91100)date_now,hour_now,qi2(n),(Qhourly(i),i=1,25)
c91100 format(a10,i5,f6.0,5x,25f6.0)
      
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
c      if(jul_day_now.ne.jlast)then   ! new day
      if(jul_day_now.ne.jlast.and.mod(hour_now+23,24).eq.0)then ! i.e. at 00:00 today
          
        j=jul_day_now
        jlast=jul_day_now
        QIpd=QItd   ! inflow previous day
        QOpd=QOtd   ! outflow previous day
        STpd=STtd   ! storage previous day
!       previous day elv will be used to calculate todays outflow
!       as todays lake elevation is not known at the start.
        Hpd=Htd
        
        if(test)then
!         temporary input for chaecking with JC's model
c!         reading resrl\SIndian_test_input.csv
c          read(785,*,iostat=ios)line,Helv,junk,inflow_obs,
c     *                             Notigi_calc_QO,Missi_obs_QO
c          if(ios.ne.0)then
c              print*,'Error reading SIndian_test_input.csv'
c              print*,'@ line beginning with ',line(1:10)
c          endif
c          read(line,78600)yearNR,monthNR,dayNR
c          if(yearNR.ne.year_now.or.monthNR.ne.month_now.or.
c     *          dayNR.ne.day_now)print*,date_now,yearNR,monthNR,dayNR         
cc         print*,stuff,Htd,junk,inflow_obs,
cc     *                             Notigi_calc_QO,Missi_obs_QO  
c          QItd=inflow_obs   ! for testing only 
          
!         CRD 1912 V2.5 Cleaned and sent to Nick as resrl\SIL_all.csv   
          read(788,*,iostat=ios)line,n,n,n,          
     *        QItd,junk,junk,junk,junk,junk,junk,junk,junk,junk,
     *        junk,Htd,junk,     
     *        colR,colS,colT,colU,colV,colW,colX,colY,colZ,
     *        junk,junk,junk,junk,colAE,colAF,colAG,colAH,junk,
     *        junk,junk,colAL
c          print*,line,0,0,0,
c     *        0,0,0,0,0,0,0,0,0,0,
c     *        colR,colS,colT,colU,colV,colW,colX,colY,colZ,
c     *        0,0,0,0,colAE,colAF,colAG,colAH,0,
c     *        0,0,colAL
c          pause
          if(ios.ne.0)then
              print*,'Error reading resrl\SIL_all.csv'
              print*,date_now,'@ line beginning with ',line(1:10)
          endif
          read(line,88500)yearNR,monthNR,dayNR
c          if(yearNR.ne.year_now.or.monthNR.ne.month_now.or.
c     *              dayNR.ne.day_now)
c     *    print*,date_now,yearNR,monthNR,dayNR    
          
!         Notigi Max Q sheet as resrl\Notigi_max.csv   
          read(738,*,iostat=ios)line,           
     *        junk,junk,junk,junk,junk,junk,junk,junk,junk,junk,
     *        junk,junk,junk,junk,junk,junk,junk,junk,junk,junk,
     *        Notigi_max     
c          print*,line,0,0,0,
c     *        0,0,0,0,0,0,0,0,0,0,
c     *        colR,colS,colT,colU,colV,colW,colX,colY,colZ,
c     *        0,0,0,0,colAE,colAF,colAG,colAH,0,
c     *        0,0,colAL
c          pause
          if(ios.ne.0)then
              print*,'Error reading resrl\Notigi_max.csv'
              print*,date_now,'@ line beginning with ',line(1:10)
          endif
          read(line,88500)yearNR,monthNR,dayNR
c          if(yearNR.ne.year_now.or.monthNR.ne.month_now.or.
c     *              dayNR.ne.day_now)
c     *    print*,date_now,Notigi_max    
          
!         Notigi 844 to 847 Q sheet as resrl\Notigi_dcn.csv   
          read(748,*,iostat=ios)line,           
     *        junk,junk,junk,junk,junk,junk,junk,junk,junk,junk,
     *        junk,junk,junk,junk,junk,junk,junk,junk,junk,junk,
     *       Notigi_dcn     
c          print*,line,0,0,0,
c     *        0,0,0,0,0,0,0,0,0,0,
c     *        colR,colS,colT,colU,colV,colW,colX,colY,colZ,
c     *        0,0,0,0,colAE,colAF,colAG,colAH,0,
c     *        0,0,colAL
c          pause
          if(ios.ne.0)then
              print*,'Error reading resrl\Notigi_dcn.csv'
              print*,date_now,'@ line beginning with ',line(1:10)
          endif
          read(line,88500)yearNR,monthNR,dayNR
c          if(yearNR.ne.year_now.or.monthNR.ne.month_now.or.
c     *              dayNR.ne.day_now)
c     *    print*,date_now,Notigi_dcn    
          
          
        else
!         For actual use:
          QItd=qi2(n) ! from the model
        endif

        
!       NOTE: have to use previous day lake level as today's is not yet calculated
!       Unlike spreadsheet, this model is not recursive.          

!       Col.. R
        QsilR=notigi_min(month_now)
     
!       Col. W
!       Notigi max AFP
        if(jul_day_now.ge.137.and.jul_day_now.le.305)then
          QsilW=991.0
        else
          QsilW=962.0
        endif
                 
!       Col. V
!       Notigi max flow
        QsilV=amax1(amin1(aaa2(j)*(Htd-256.65),QsilW),QsilR)
        
        write(444,*)date_now,aaa2(j),Htd,aaa2(j)*(Htd-256.65),QsilV
        
     
!       Col. T
        if(aaa1(j)*(Htd-256.65).lt.QsilR)then      ! note: exponent = 1.00
          QsilT=QsilR
        elseif(aaa1(j)*(Htd-256.65).gt.QsilV)then
            QsilT=QsilV
        else
            QsilT=aaa1(j)*(Htd-256.65)
        endif
             
!       Col. U
        If(QsilT+(QsilV-QsilT)*(Htd-258.17)/0.07.lt.QsilT)then
          QsilU=QsilT
        elseif(QsilT+(QsilV-QsilT)*(Htd-258.17)/0.07.gt.QsilV)then
            QsilU=QsilV
        else
            QsilU=QsilT+(QsilV-QsilT)*(Htd-258.17)/0.07
        endif
        
!       Col. S
        if(QsilR+(QsilT-QsilR)*(Htd-257.07)/0.18.lt.QsilR)then   
          QsilS=QsilR
        elseif(QsilR+(QsilT-QsilR)*(Htd-257.07)/0.18.gt.QsilT)then
            QsilS=QsilT
        else
            QsilS=QsilR+(QsilT-QsilR)*(Htd-257.07)/0.18
        endif
           
!       Col. X
!       Decision option 1
        if(Htd.lt.256.98)then
          QsilX=450
        elseif(Htd.lt.257.07)then
          QsilX=QsilR
        elseif(Htd.lt.257.25)then
          QsilX=QsilS
        elseif(Htd.lt.258.17)then
          QsilX=QsilT
        elseif(Htd.lt.258.24)then
          QsilX=QsilU
        else
          QsilX=QsilV
        endif
          
!       Col. Y
!       Decision option 2
        if(1848.5.gt.QsilW)then  ! there's aproblem here:  col AB = 0 check it out!!
          QsilY=QsilW
        elseif(1848.5.lt.QsilR)then
          QsilY=QsilR
        else
          QsilY=1848.5
        endif   
        
!       Col. Z
!       with 5000 cfs pre day restriction
        QsilZpd=QsilZ   ! remember last value
        if(abs(amin1(QsilX,QsilY)-QsilZpd).lt.142)then
          QsilZ=amin1(QsilX,QsilY)
        elseIF(amin1(QsilX,QsilY).gt.QsilZpd)then
            QsilZ=QsilZpd+142
        else
            QsilZ=QsilZpd-142
        endif       
        
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NELSON restriction        
!       Limit Notigi outflows when flows on the Nelson River are high  
!       LWoutflow = Lake Winnipeg outflow - from optional read file  
!       QsilZ = final South Indian Lake diversion outflow   col. Z     
        read(786,*)line,LWoutflow
        read(line,78600)yearNR,monthNR,dayNR
        if(LWoutflow.gt.4400.0)then
c            QsilZ=amin1(570.0,QsilZ)      ! use lower value
        elseif(LWoutflow.gt.3900.0)then
c            QsilZ=amin1(850.0,QsilZ)      ! use lower value
        endif
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
!       Col. AE
!       min Missi flow
        if(jul_day_now.ge.345)then
          QmissiAE=97.029
        elseif(jul_day_now.ge.304)then          
          QmissiAE=125.345
        elseif(jul_day_now.ge.291)then       
          QmissiAE=68.712
        elseif(jul_day_now.ge.120)then          
          QmissiAE=19
        elseif(jul_day_now.ge.53)then  
          QmissiAE=54.554
        elseif(jul_day_now.ge.31)then          
          QmissiAE=68.712
        else          
          QmissiAE=97.029
        endif          
          
!       Col. AF
!       Missi Decision
!       use moving average of last 3 days
c        av7qi2=.......)   ! not averge yet <<<<<<<<<<<< averaging to be setup
        av7QItd=QItd
        av7QsilZ=QsilZ  ! not average yet
c        if(Htd.gt.258.24)then
c          if(av7QItd-av7QsilZ.gt.QmissiAE)then      
c            QmissiAF=av7QItd-av7QsilZ
c          else
c            QmissiAF=QmissiAE
c          endif
c        else
c          QmissiAF=QmissiAE
c        endif

        if(Htd.lt.258.24)then
          QmissiAF=QmissiAE
        elseif(av7QItd-av7QsilZ.gt.QmissiAE)then      
          QmissiAF=av7QItd-av7QsilZ
        else
          QmissiAF=QmissiAE
        endif
          
!       Col. AG
!       Decision with max daily flow change        
!       AH calculated below so still the last day's value here
        if(abs(QmissiAF-QmissiAH).lt.141.6)then  
          QmissiAG=QmissiAF
        elseif(QmissiAF.gt.QmissiAH)then
          QmissiAG=QmissiAH+141.6
        else
          QmissiAG=QmissiAH-141.6
        endif
       
!       Col. AH
!       Final decision Missi flow
        if(Htd.gt.258.30)then
          QmissiAH=QmissiAG*1.2
        else
          QmissiAH=QmissiAG
        endif
        
!       Col. AL Total SIL outflow
        QsilAL=QmissiAH+QsilZ
        
!       write to 'test_sil.csv' 'test_sil.csv' 'test_sil.csv' 'test_sil.csv'      
c        write(717,62700)jz,Htd,QsilR,QsilS,QsilT,QsilU,QsilV,QsilW,
c     *     QsilX,QsilY,QsilZ,QmissiAE,QmissiAF,QmissiAG,QmissiAH,QsilAL
c62700   format(i10,15(',',f10.3),2(',',f15.0),2(',',f10.3),',',f15.7)
        
!       End of spreadsheet calculations

        QOtd=QsilAL
        qo2(n)=QmissiAG    !  qo2 used in synflow to calclate qsyn - Missi station only 
        qi2(RGno)=QsilZ    !  Add diversion flow to the Burntwood tributary

        
!       43200. is daily time step in seconds / 2
        STtd=STpd+(QIpd+QItd-QOpd-QOtd)*43200.

      
        if(test)then
!         temporary output for checking with JC's output
!         SIndian_test_output.csv 
c          write(766,76600)Htd,inflow_obs,Notigi_calc_QO,QsilZ,
c     *                   Missi_obs_QO,QmissiAH
76600     format(99(f10.3,','))      
     
          write(789,78900)date_now,colR,QsilR,colW,QsilW,colV,QsilV,
     *             colT,QsilT,colU,QsilU,colS,QsilS,colX,QsilX,  
     *             colY,QsilY,colZ,QsilZ,colAE,QmissiAE,colAF,QmissiAF,
     *             colAG,QmissiAG,colAH,QmissiAH,colAL,QsilAL,
     *             Notigi_max,QsilV,Notigi_dcn,QsilT
78900     format(a10,99(',',f10.3,',',f10.3))          
          
          
          
        else
!         43200. is daily time step in seconds / 2
!       Lake datum taken as col N = 256.95        
          STtd=STpd+(QIpd+QItd-QOpd-QOtd)*43200.
!         Lake datum taken as col N = 256.95        
          Htd=256.95+STtd/lake_area(l) ! new elv after today
          store2(n)=STtd
!         SIndian_test_output.csv 
          write(766,76600)Htd,QItd,Notigi_calc_QO,QsilZ,
     *                   Missi_obs_QO,QmissiAH
        endif

!       assigning outflows to the usual output files for reporting 
!       Flow station is the Missi WSC gauge location
!       In lst.f hourly values are expected    
!       Note:  this is for reporting and compariing to gauge flows only
!       It is not part of the routing   

!       assigning outflows to the usual output files for reporting 
!       Flow station l is the East channel WSC gauge location
!       In lst.f hourly values are expected    
!       Note:  this is for reporting and compariing to gauge flows only
!       It is not part of the routing   
c      print*,jz,mhtot,year_now,month_now,day_now


!       write the diversion flows results\SIndianDiversion.csv
        write(787,*)date_now,',',QsilZ

      
      endif  ! jul_day_now.ne.jlast

      lake_elv(l,jz)=Htd
      qo2(n)=QmissiAH   ! QOtd
      qi2(n)=QItd
      lake_outflow(l,jz)=QmissiAH   ! Missi outflow only
      lake_inflow(l,jz)=qi2(n) ! previously taken out from QR in sub
      net_lake_inflow(l,jz)=qi2(n)-qo2(n)


      firstpass=.false.


      return

      END SUBROUTINE SIndian
      SUBROUTINE opt(*,*)

!***********************************************************************
!    Copyright (C) 1975  Monroe (NOAA) 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!***********************************************************************
!   MAY 25,1975    NOAA TECH MEMO NWS HYDRO-12

!***********************************************************************

      use area_watflood
	implicit none

!     REPLACED AREAIZY (TO SAVE VARIABLES) WITH SAVE()
      SAVE 

      integer  :: lc,ittn,izy,ncoun,icoun,ldelt,nsave,ifirs,ll,iflg,i,ii
      real*4   :: ys,yx1,yy1,cc1,cc2,cc0,cd

!     THESE THINGS NO LONGER ARE SET TO 0 EACH TIME OPT IS CALLED BEING
!     LEFT TO THEIR OWN DEVICES IN UNIX -- NEED TO BE ZEROED
      DATA lc,ittn,izy,ncoun,icoun,ldelt,nsave,ys,yx1,yy1,ifirs,ll/12*0/

      if(nstart.gt.0) GO TO 2

!     INTIALIZATION ROUTINE 
!     check for paramaters to within constraints
      iflg=0
      do 1 i=1,numa
         les(i)=0
         ba(i)=a(i)
         b(i)=a(i)
         iclosl(i)=0
         iclosh(i)=0
!        nper:  if = 0 delta = absolute value
!               if = 1 delta = a multiplier
         if(nper.le.0)then
            odelta(i)=ddelta(i)
         else
            odelta(i)=abs(ddelta(i)*a(i))
         endif

         if(checkh(i)-checkl(i).le.3.0*odelta(i))then
!           THE CONSTRAINTS ARE TO CLOSE TOGETHER
            write(6,6510)i
            write(52,6510)i
            iflg=1
         endif

         cc1=a(i)-1.01*odelta(i)
         if(cc1.le.checkl(i))then
            write(6,6500)i,a(i),cc1,ddelta(i),checkl(i),checkh(i)
            write(52,6500)i,a(i),cc1,ddelta(i),checkl(i),checkh(i)
            iflg=-1
         endif

         cc2=a(i)+1.01*odelta(i)
         if(cc2.ge.checkh(i))then
            write(6,6500)i,a(i),ddelta(i),checkl(i),checkh(i)
            write(52,6500)i,a(i),ddelta(i),checkl(i),checkh(i)
            iflg=-1
         endif
    1 CONTINUE

      if(iflg.ne.0) STOP 'please change init values or constraints'
       
      lc=0
      ittn=1
      izy=0
      nnn=0
      ncoun=1
      icoun=0
      ifirs=0
      ldelt=0
      nstart=1
      nsave=0
!      write(52,6221)
      write(52,6003)(i,i=1,numa)
      write(52,6005)ncoun,nnn,ys,(a(i),i=1,numa)
    2 ys=optim
      nnn=nnn+1
      if(nnn.gt.maxn) RETURN 1
      if(ifirs.eq.1) GO TO 4
      yx1=optim
      yy1=yx1
      ifirs=1
    4 write(52,6005)ncoun,nnn,ys,(a(i),i=1,numa)
   44 if(les(ittn).eq.1) GO TO 14
      if(izy.gt.0) GO TO 8
      if(ys.le.yy1)then
         nsave=1
         yx1=ys
         yy1=ys
         write(52,6003)(i,i=1,numa)
      endif
    6 izy=izy+1
      ittn=izy
     
	if(les(izy).eq.1) GO TO 107
  108 ll=0

!     LOCAL EXCURSION ROUTINE

!     LOCAL EXCURSION WITH + DDELTA(I) FIRST

      a(izy)=a(izy)+odelta(izy)
      nsign(izy)=0
      if(iclosh(izy).eq.0) GO TO 7
      ll=ll+1
      GO TO 88
    7 ll=ll+1

      RETURN 2

    8 if(yx1.gt.ys) GO TO 11
   88 GO TO (9,10,12),ll
    9 a(izy)=a(izy)-2.0*odelta(izy)
      nsign(izy)=1
      if(iclosl(izy).eq.1) GO TO 10
      GO TO 7
   10 a(izy)=a(izy)+odelta(izy)
      nsign(izy)=0
      GO TO 12
   11 yx1=ys
   12 if(izy.lt.numa) GO TO 6
      ittn=1
      izy=0
      if(yy1.eq.yx1) GO TO 25
      yy1=yx1

      GO TO 210

!     LOCAL EXCURSION WITH - ODELTA(I) FIRST

   14 if(izy.gt.0) GO TO 16
      if(ys.le.yy1)then
         nsave=1
         yx1=ys
         yy1=ys
      endif
      write(52,6003)(i,i=1,numa)
  106 izy=izy+1
      ittn=izy
      if(les(izy).eq.0) GO TO 108
  107 ll=0
! ONCE AGAIN WHY IS THIS LINE USING DDELTA?
! CHANGED TO ODELTA BY FRANK S DEC/2000
c      a(izy)=a(izy)-ddelta(izy)
      a(izy)=a(izy)-odelta(izy)
      nsign(izy)=1
      if(iclosl(izy).eq.0) GO TO 15
      ll=ll+1
      GO TO 166
   15 ll=ll+1

      RETURN 2

   16 if(yx1.gt.ys) GO TO 19
  166 GO TO (17,18,20),ll
   17 a(izy)=a(izy)+2.0*odelta(izy)
      nsign(izy)=0
      if(iclosh(izy).eq.1) GO TO 18
      GO TO 15
   18 a(izy)=a(izy)-odelta(izy)
      nsign(izy)=1
      GO TO 20
   19 yx1=ys
   20 if(izy.lt.numa) GO TO 106
      ittn=1
      izy=0

      if(yy1.eq.yx1) GO TO 25
      yy1=yx1
!         WATCH THE JUMP INTO HERE!         
  210     if(nper.ne.0)then
             do 21 i=1,numa
                odelta(i)=abs(ddelta(i)*a(i))
   21        CONTINUE
          endif
          
          lc=0
          nsave=0
          write(52,6005) ncoun,nnn,yy1,(a(i),i=1,numa)
          write(52,6220)
          if(numa.gt.1)write(6,6220)
          ncoun=ncoun+1
         
!              PATTERN MOVE ROUTINE
         
          do 24 i=1,numa
             les(i)=nsign(i)
             ba(i)=a(i)
             a(i)=2.0*a(i)-b(i)
!              CHECK UPPER AND LOWER CONSTRAINTS
           
             cc0=a(i)-1.01*odelta(i)
             cd=a(i)+1.01*odelta(i)

             if(cc0.le.checkl(i))then
                iclosl(i)=1
                a(i)=ba(i)
             else
                iclosl(i)=0
              endif

             if(cd.ge.checkh(i))then
                iclosh(i)=1
                a(i)=ba(i)
             else 
                iclosh(i)=0
             endif

             b(i)=ba(i)
   24     CONTINUE
          
          RETURN 2

   25 lc=lc+1

!          DESTROY PRESENT PATTERN

      if(lc-1)225,26,28

  225 RETURN 1

   26 if(nsave.eq.1) GO TO 260

      do 27 i=1,numa
         a(i)=ba(i)
   27 CONTINUE
      icoun=icoun+1
      GO TO 30

   28 if(ldelt.ge.kc) RETURN 1

!          HALVE ODELTA(I) (RESOLUTION)

  260 nsave=0
      do 29 i=1,numa
         ddelta(i)=ddelta(i)*0.5
         odelta(i)=odelta(i)*0.5
! frank was wrong. Checked with NOAA tech memo 12 NK Feb. 05/10
!     THIS IS WRONG, I CHANGED IT TO WHAT IT SHOULD BE
!     FRANK S DEC 2000
c         odelta(i)=ddelta(i)*0.5
   29 CONTINUE
      ldelt=ldelt+1
   30 write(52,6031)icoun,ldelt
      if(numa.gt.1) write(6,6031)icoun,ldelt
      write(52,6005) ncoun,nnn,yy1,(a(i),i=1,numa)

      GO TO 44
  
! FORMATS

 6003 format(' trial run     criteria  ',50('      a(',i2,')'))
 6005 format(i6,i5,e16.7,50e11.4)
 6220 format(21x,'pattern move')
 6221 format(21x,'initial values of the coefficients')
 6031 format(20x,'pattern=',i4,' resolution=',i5)
 6500 format(' init a(',i2,') to close to its constraint',5e10.3)
 6510 format(' the constraints on a(',i3,') are too close together')          

      RETURN

      END SUBROUTINE opt

      SUBROUTINE options(ix,e1,conv,scale,smc5,nhr,nhf)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!**********************************************************************
!   REV. 9.00   March 2000  - TS: CONVERSION TO FORTRAN 90
!   REV. 9.03   Nov   2000  - TS: ADDED WATFLOOD SWAMP ROUTING 
!   rev. 9.2.08  Jul.  29/05  - NK: opt work-around in options 
!	
!   REV		Nov/2005 - BT (Bryan Tolson).  Added DDS optimization option                      
!   rev. 9.2.24  Dec.  07/05  - BT: DDS optimization 
!     rev. 9.5.18  Mar.  03/08  - NK: added conv to options & sub argument list
!     rev. 9.5.44  Oct.  27/08  - NK: optlow= moved from options.f to compute_error.f
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!**********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(128):: qstr
      CHARACTER(72) :: junk
!      CHARACTER(14) :: date
      CHARACTER(1)  :: smok 
      CHARACTER*14    :: date
	INTEGER    :: iallcnt,icnt(5),ndir(5),nchr,ix,ios,icase,
     *              iallocate,igrdshft,iyshiftmin,iyshiftmax,
     *              jxshiftmin,jxshiftmax,ishift,jshift,inum,jnum,
     *              l,iw1,iw2,iv,iflg,i,n,ii,j,nhr,nhf,jan
      REAL(4)    ::   smc5(16),errold(5),err(5),chng(5),best(5)
      REAL(4)    :: optlow,e1,scale,ddtemp,cc1,cc2,crit,conv,best1
	real(4)    :: optlast
      integer*2  :: result1,ntest

!      DATA ntest/-1358/qstr/'options'/nchr/7/
      DATA ntest/43814/qstr/'optionsss'/nchr/9/
	DATA iallcnt/0/


!     *** MHTOT MUST BE LESS THAN 360 ***

! OPENING UP THE EVAPORATION FILES MOVED HERE SO THAT VER AND FLGEVP2
! HAVE VALUES - FRANK S: OCT/99
! VER 7.9 IF VER>7.9 OPEN EVAPORATION FILES
      if(ver.ge.7.9.and.flgevp2.eq.3.0)then
        open(unit=49,file=fln(19),status='unknown',iostat=ios)
        if(ios.ne.0)then
          write(*,99132)fln(19)
          write(98,99132)fln(19)
99132     format(' Warning: Error opening or reading fln:',a30/
     *'   Probable cause: missing yymmdd.flx - radiation input file'/
     *'   This file is optional - used to compute evaporation using '/
     *'   the priestly taylor routine'/
     *'   OR: in config.sys have you set files=100 & buffers=50?'/)
!          call errormsg(ios)
          print*,'iostat code =',ios
          STOP 'program aborted in spl.for @ 380'
        endif

        open(unit=50,file=fln(20),status='unknown',iostat=ios)
        if(ios.ne.0)then
          write(*,99142)fln(20)
          write(98,99142)fln(20)
99142     format(' Warning: Error opening or reading fln:',a30/
     *'   Probable cause: missing yymmdd.flx - point radiation file'/
     *'   This file is optional - used to compute evaporation using '/
     *'   the priestly taylor routine'/
     *'   needed if resinflg=y in yymmdd.evt'/
     *'   OR: in config.sys have you set files=100 & buffers=50?'/)
!          call errrormsg(ios)
          print*,'iostat code =',ios
          STOP 'program aborted in spl.for @ 381'
        endif
      endif


d      if(iopt.eq.2)print*, ' In options: 3 - before call rdsdc'

!      if(snwflg.eq.'y') call rdsdc()

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.5.44  Oct.  27/08  - NK: removed code & obj modules for hasp & rainbow
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c!     remove for unix
c      call keychk(qstr,nchr,result1)
c!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c      call userchk(ntest,result1)
c!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      totaltime=0.0
      mo=mo1
      icase=numa
      nnn=0


!! ALLOCATIONS MOVED HERE FROM BELOW SO AS TO MISS 7777 CONTINUE BYPASS
!! SUPPOSED TO BE ALLOCATED WITH INUM/JNUM, BUT NOT ALWAYS DEF'ND -> SO 500    
      if(iallcnt.eq.0)then

        if(numa.gt.50)then     ! added Apr. 5/06  nk.
          print*,'No of parameters chosen for optimization > 50)'
	    print*,'This too many and is not allowed'
	    print*
	    stop 'Program aborted in options @ 111'
	  endif

        if(numa.gt.0)then
!         TS - ALLOCATION OF AREA8A ARRAYS
          allocate(a(50),b(50),ddelta(50),checkl(50),checkh(50),
     *       ssave(50),les(50),ba(50),iclosl(50),iclosh(50),
     *       nsign(50),odelta(50),stat=iAllocate)
          if(iAllocate.ne.0) STOP
     *      'Error with allocation of area8a arrays in optionsa'
        else
          allocate(a(1),b(1),ddelta(1),checkl(1),checkh(1),
     *         ssave(1),les(1),
     *    ba(1),iclosl(1),iclosh(1),nsign(1),odelta(1),stat=iAllocate)
          if(iAllocate.ne.0) STOP
     *      'Error with allocation of area8a(a) arrays in optionsa'
        endif
	  iallcnt=1
	endif

!     icase = numa  -1 for smc opt; 0 for one run; >1 for par opt

!     rev. 9.2.24  Dec.  07/05  - BT: DDS optimization 
c	if(dds_flag.eq.1)go to 8888

      if(icase)9999,7777,8888
!     8888 -> pattern search
!     7777 -> regular run
!     9999 -> operation: precip adjustment factor      


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     SUBROUTINE SUBA DOES ALL RUNOFF AND FLOW CALCULATIONS  

 7777 CONTINUE

!     REV. 8.98   July 15/99 - MET GRID SHIFTING FOR WEATHER MODELS 
!     READ THE GRID SHIFTING PARAMETERS:
      open(unit=99,file='grdshift.txt',status='old',iostat=ios)
      if(ios.eq.0)then
        read(99,9901,iostat=ios)igrdshft
        if(ios.ne.0)then
          print*,' problems reading the gridshift.txt file'
          print*,' ios = ',ios
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          STOP ' program aborted in options @ 148'
        endif
        write(51,9902)igrdshft
        read(99,9903)junk
        write(98,9903)junk
9903    format(a72)
        read(99,9901)
     *     iyshiftmin,iyshiftmax,jxshiftmin,jxshiftmax,ishift,jshift
        write(51,9901)
     *     iyshiftmin,iyshiftmax,jxshiftmin,jxshiftmax,ishift,jshift
        close(unit=99)
        optlow=0.0
      else
!        these added Nov. 25/04  nk
         iyshiftmax=0
         jxshiftmax=0
         iyshiftmin=0
         jxshiftmin=0
         ishift=0
         jshift=0
         igrdshft=0
      endif

      inum=ycount+abs(iyshiftmin)+abs(iyshiftmax)
      jnum=xcount+abs(jxshiftmin)+abs(jxshiftmax)

d	if(iopt.eq.2)print*,'in options, inum.jnum/',inum,jnum

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
	sensitivityflg=.false.
      if(dds_flag.eq.-1)then
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  call sensitivity(jan,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return
      endif


!     WARNING: DON'T COMBINE NEXT SEGMENT WITH PREVIOUS SEGMENT 
!     BECAUSE IGRDSHFT CAN BE SET = 0 IN THE FILE (i.e. NO IOS ERROR)
      if(igrdshft.le.0)then
        maxn=1
!        nnn=nnn+1   changed this June 23/02 nk killed allocation in flowinit
d        if(iopt.eq.2)print*, ' In options: 4 - before call sub'

        jan=1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        nnn=nnn+1
      else
        maxn=((iyshiftmax-iyshiftmin)/ishift+1)*
     *     ((jxshiftmax-jxshiftmin)/jshift+1)
        write(52,5201)
5201    format(' dy_shift, dx_shift,peak_flows')
        do iyshift=iyshiftmin,iyshiftmax,ishift
          do jxshift=jxshiftmin,jxshiftmax,jshift
d            if(iopt.eq.2)print*, ' In options: 5 - before call sub'
            jan=1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d            if(iopt.eq.2)print*, ' In options: 6 - before call lst'
c        if(.not.netCDFflg.or.iopt99)then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call lst(scale,igrdshft)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        endif
            write(52,5202)iyshift,jxshift,(qpeaks(l),l=1,no)
5202        format(2i10,40f10.3)
            nnn=nnn+1
          end do
        end do
      endif

      RETURN

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

!              * * * OPTIMIZATION * * *

!8888  if(iw.eq.0)then
!        iw1=1
!        iw2=5
!      else
!        iw1=iw
!        iw2=iw
!      endif

8888  if(icase.gt.0.and.resumflg.ne.'y')then
        print*,' WARNING: You should use a resume.txt file'
        print*,'          to ensure that each opt run starts'
        print*,'          with the same initial conditions'
        print*,' Of course a spinup period is OK too'
        print*,' '
        write(*,'(A)',advance='no')
     *            '  Be warned! Be warned! Be warned!'
        print*,' '
!        read(*,*)
        write(98,10001)
10001   format(' WARNING: You should use a resume.txt file',
     *         '          to ensure that each opt run starts',
     *         '          with the same initial conditions')
      endif

!     ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:

      
      if(par_file_version.ge.par_file_version_latest)then
!       par file will be updated from rdpar
!       before user can proceed
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        call par_init()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
      endif

c        call write_par(99,1)
        call write_par_10(99,25)


        nnn=0
        nstart=0 
        optim=0.0
        optlow=0.1e+30
        optlast=-1.0

8000    CONTINUE
!       >>>>>>>>>> START OF OPTIMIZATION LOOP <<<<<<<<<

!       ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        call par_assign()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

!       SUB ORGANIZES ALL HYDROLOGIC COMPUTATIONS

        optlast=optim
        optim=0.0
	  totaltime=0.0
        mo=mo1
	  rewind 58  ! spl.plt
	  rewind 60  ! spl.scv
	  rewind 80  ! lake_sd

d       if(iopt.eq.2)print*, ' In options: 7 - before call sub'
        jan=1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!       A NEW PARAMETER FILE CALLED 'NEW.PAR' WILL BE WRITTEN
!       FOR THE LOWEST ERROR YIELDING PARAMETERS:
        if(optim.lt.optlow)then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c          call write_par(99,1)
          call write_par_10(99,25)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          optlow=optim
        endif

c          print*,optim,optlow
   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call opt(*8999,*8000)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

8999    RETURN
      
c	ENDIF ! DDS or PAttern option
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 9999 CONTINUE

!     REAL-TIME OPTIMIZATION of initial soil moisture:

!     	       * * * * * * * * * * * *
      if(icase.eq.-1)then
!       OPTIMIZATION FOR SOIL MOISTURE  
        if(ni.gt.1)then
          write(6,1001)
          write(6,1002)ni
          RETURN
        endif
!       CALCULATE THE ERROR FOR THE INITIAL PARAMETERS:
        nnn=0
        do ii=1,classcount-2
           best(ii)=smc5(ii)
           err(ii)=0.0
           errold(ii)=0.1e+32
           chng(ii)=0.05
           if(smc5(ii).lt.chng(ii)) smc5(ii)=chng(ii)+0.01
           if(smc5(ii).gt.por-chng(ii)) smc5(ii)=por-chng(ii)-0.01
           icnt(ii)=0
           ndir(ii)=0	
        end do
        write(52,8003)smc5
!       SET DIRECTION FOR SEARCH AND SET NEW SMC:
!       * * * * * * * * * * * * * * * * * * * * *
        crit=0.0
d        if(iopt.eq.2)print*, ' In options: 10 - before call sub'
        jan=1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 9015   call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       FIND THE ERROR ASSOCIATED WITH EACH PERMEABILITY CLASS
!       FOR EACH TRIAL SMC:
        nnn=nnn+1
!       NNN IS THE NNN'TH ITERATION
!        optim=0.0
        do l=1,no
           i=iy(l)	
           j=jx(l)
           n=s(i,j)
           ii=ibn(n)
c           optim=optim+delta(1,l)
           err(ii)=err(ii)+delta(1,l)
        end do
        write(52,8001)ii,(err(ii),ii=1,5)
!       a problem here with smc5
!       it needs to be somehow related to river classes of basin areas.
        do ii=1,classcount-2
!          IF ERROR IS REDUCED, KEEP GOING IN THE SAME DIRECTION
!          WE ARE ASSUMING A CONCAVE ERROR FUNCTION W/NO BUMPS
           if(err(ii).lt.errold(ii))then
              best(ii)=smc5(ii)
              smc5(ii)=smc5(ii)+chng(ii)
           else
              ndir(ii)=ndir(ii)+1
              if(ndir(ii).le.1)then
!                IF ERROR IS BIGGER, REVERSE DIRECTION
                 chng(ii)=-1.0*chng(ii)
              else 
!                AND CUT THE INTERVAL ON SECOND AND SUBSEQUENT 
!                DIRECTION CHANGES
                 chng(ii)=-0.4*chng(ii)
              endif
              smc5(ii)=smc5(ii)+chng(ii)
           endif
!          CHECK THE LIMITS AND STAY WITHIN
           if(smc5(ii).le.0.0)then
              chng(ii)=0.4* abs(chng(ii))
              smc5(ii)=0.0
           elseif(smc5(ii).ge.por)then
              chng(ii)=0.4*abs(chng(ii))
              smc5(ii)=por
           endif
           errold(ii)=err(ii)
           err(ii)=0.0
        end do
        write(52,8003)smc5
        write(52,8004)chng
        do ii=1,classcount-2
           if(smc5(ii).le.0.9*por)then
              crit=0.03*por
           else
              crit=0.01*por
           endif
           if(abs(chng(ii)).gt.crit)go to 9015
        end do
!         * * * * * * * * * * * * * * * * * * * * *
        do ii=1,classcount-2
           smc5(ii)=best(ii)
        end do
        write(52,6000)smc5
!       ICASEA IS SET AS A FLAG TO MAKE THE FINAL RUN FOR THE FULL 
!       FORECAST PERIOD
        icase=-11
!       UPDATE THE EVENT FILE:
        mo1=mo
        fln(20)='event/event.evt'
d        if(iopt.eq.2)print*, ' In options: 11 - before call outevt'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call outevt(conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      elseif(icase.eq.-2)then
      
!       * * * * RADAR SCALING (OPTIMIZATION) * * * *
!       ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:
        a(1)=1.0
        errflg=2
        numa=1
        ddelta(1)=0.25
        checkl(1)=0.1
        checkh(1)=3.
        nstart=0
        nnn=0
        optlow=0.1e+32
        optim=0.0
!       START OF OPTIMIZATION LOOP
 8080   CONTINUE
d        if(iopt.eq.2)print*, ' In options: 12 - before call sub'

        if(nnn.gt.0)then
          fln(99)='event/event.evt'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call read_evt(date,conv,scale,smc5,nhr,nhf)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ensimflg='n'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    call read_shed_ef(31,1)	
          call read_par_parser(32,2)    
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  endif
        optim=0.0
        scale=a(1)        
        errflg=2
        numa=1
        jan=1
        dds_flag=-1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(optim.lt.optlow)then
          best1=scale
          optlow=optim
        endif

!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call opt(*8081,*8080)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

8081	continue

!       Done optimizing - do a final run
        fln(99)='event/event.evt'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_evt(date,conv,scale,smc5,nhr,nhf)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ensimflg='n'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        scale=best1
        numa=0
        jan=1
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        if(ni.le.1)call lst(scale,igrdshft)

      RETURN



!       NUMA IS SET AS A FLAG TO MAKE THE FINAL RUN FOR THE FULL  
!       FORECAST PERIOD
 8089   icase=-12
        scale=best1
!       UPDATE THE EVENT FILE:
        mo1=mo
c        fln(20)='event/event.evt'
c        call outevt(conv,scale,smc5,nhr,nhf)
      endif
!     	       * * * * * * * * * * * *
!     TO MAKE A FORECAST RUN OF NL HRS SET:
!     ENTRY POINT IF ICASE = -10 IN XXXX.PAR FILE
d      if(iopt.eq.2)print*, ' In options: 15 - before call sub'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call read_evt(date,conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ensimflg='n'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	call read_shed_ef(31,1)	
      call read_par_parser(32,2)    
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      scale=best1
      numa=0
      jan=1
      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
      if(ni.le.1)call lst(scale,igrdshft)

      RETURN

! FORMATS
 1001 format
     *(' you cannot run smc optimization for more than 1 storm')
 1002 format('        you have',i3,' events')
 6000 format(' optimized smcs:'/5f10.3/)
 6500 format(6e10.3)
c 6501 format(' a(',i2,')too close to lower constraint')
 6502 format(' a(',i2,')too close to upper constraint')
c 6503 format(' ddtemp    cc2       checkl    checkh    a(i)')
 6510 format(' the constraints on a(',i3,') are too close together')
 8001 format(' err=',i5,5e10.3/)
 8003 format('    smc=',5f10.5)
 8004 format('   chng=',5f10.5)
 8123 format(' ','a(1),scale,best1,optim,optlow/',5f10.5)
 9345 format(' classcount,nbsn,numa/',3i5/)
 9901 format(10i5)
 9902 format(/' grid shift index =',i2,'  0=no shift  1=shifting')

      END SUBROUTINE options
      SUBROUTINE options(ix,e1,conv,scale,smc5,nhr,nhf)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!**********************************************************************
!   REV. 9.00   March 2000  - TS: CONVERSION TO FORTRAN 90
!   REV. 9.03   Nov   2000  - TS: ADDED WATFLOOD SWAMP ROUTING 
!   rev. 9.2.08  Jul.  29/05  - NK: opt work-around in options 
!	
!   REV		Nov/2005 - BT (Bryan Tolson).  Added DDS optimization option                      
!   rev. 9.2.24  Dec.  07/05  - BT: DDS optimization 
!     rev. 9.5.18  Mar.  03/08  - NK: added conv to options & sub argument list
!     rev. 9.5.44  Oct.  27/08  - NK: optlow= moved from options.f to compute_error.f
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 10.3.00 Dec.  **/19  = NK Conversion f77 to f90      
!**********************************************************************

      use area_watflood
      use area_debug
    implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(128):: qstr
      CHARACTER(72) :: junk
!      CHARACTER(14) :: date
      CHARACTER(1)  :: smok 
      CHARACTER*14    :: date
    INTEGER    :: iallcnt,icnt(5),ndir(5),nchr,ix,ios,icase,&
                   iallocate,igrdshft,iyshiftmin,iyshiftmax,&
                   jxshiftmin,jxshiftmax,ishift,jshift,inum,jnum,&
                   l,iw1,iw2,iv,iflg,i,n,ii,j,nhr,nhf,jan
      REAL(4)    ::   smc5(16),errold(5),err(5),chng(5),best(5)
      REAL(4)    :: optlow,e1,scale,ddtemp,cc1,cc2,crit,conv,best1
      real(4)    :: optlast
      integer    :: result1,ntest

!      DATA ntest/-1358/qstr/'options'/nchr/7/
      DATA ntest/43814/qstr/'optionsss'/nchr/9/
    DATA iallcnt/0/


!     *** MHTOT MUST BE LESS THAN 360 ***

! OPENING UP THE EVAPORATION FILES MOVED HERE SO THAT VER AND FLGEVP2
! HAVE VALUES - FRANK S: OCT/99
! VER 7.9 IF VER>7.9 OPEN EVAPORATION FILES
      if(ver.ge.7.9.and.flgevp2.eq.3.0)then
        open(unit=49,file=fln(19),status='unknown',iostat=ios)
        if(ios.ne.0)then
            write(98,*)'Error: Error opening or reading fln:',fln(19)(1:40)
            write(98,*)'Error: Probable cause: missing yymmdd.flx - radiation input file'
            write(98,*)'Error: This file is optional - used to compute evaporation using '
            write(98,*)'Error:  the priestly taylor routine'
            write(98,*)'Error:  OR: in config.sys have you set files=100 & buffers=50?'
            write(98,*)'Error: iostat code =',ios,' program aborted in options @ 380'
            STOP 'program aborted in spl.for @ 380'
        endif

        open(unit=50,file=fln(20),status='unknown',iostat=ios)
        if(ios.ne.0)then
            write(98,*)'Error:  opening or reading fln:',fln(20)(1:40)
            write(98,*)'Error: Probable cause: missing yymmdd.flx - point radiation file'
            write(98,*)'Error: This file is optional - used to compute evaporation using '
            write(98,*)'Error: the priestly taylor routine'
            write(98,*)'Error: needed if resinflg=y in yymmdd.evt'
            write(98,*)'Error: OR: in config.sys have you set files=100 & buffers=50?'
            write(98,*)'Error: iostat code =',ios,' program aborted in optionsr @ 381'
          STOP 'program aborted in spl.for @ 381'
        endif
      endif
 

        if(debug_output)write(63,*) ' In options: 3 - before call rdsdc'

!      if(snwflg.eq.'y') call rdsdc()

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.5.44  Oct.  27/08  - NK: removed code & obj modules for hasp & rainbow
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      totaltime=0.0
      mo=mo1
      icase=numa
      nnn=0


!! ALLOCATIONS MOVED HERE FROM BELOW SO AS TO MISS 7777 CONTINUE BYPASS
!! SUPPOSED TO BE ALLOCATED WITH INUM/JNUM, BUT NOT ALWAYS DEF'ND -> SO 500    
      if(iallcnt.eq.0)then

        if(numa.gt.50)then     ! added Apr. 5/06  nk.
          print*,'No of parameters chosen for optimization > 50)'
          print*,'This too many and is not allowed'
          print*
          stop 'Program aborted in options @ 111'
      endif

        if(numa.gt.0)then
!         TS - ALLOCATION OF AREA8A ARRAYS
          allocate(a(50),b(50),ddelta(50),checkl(50),checkh(50),&
            ssave(50),les(50),ba(50),iclosl(50),iclosh(50),&
            nsign(50),odelta(50),stat=iAllocate)
          if(iAllocate.ne.0) then
            write(98,*)'Error: Error with allocation of area8a(a) arrays in optionsa'
            STOP 'Error with allocation of area8a arrays in optionsa'
          endif
        else
          allocate(a(1),b(1),ddelta(1),checkl(1),checkh(1),ssave(1),les(1),&
         ba(1),iclosl(1),iclosh(1),nsign(1),odelta(1),stat=iAllocate)
          if(iAllocate.ne.0) then
            write(98,*)'Error: Error with allocation of area8a(a) arrays in optionsa'
            STOP'Error with allocation of area8a(a) arrays in optionsa'
          endif
        endif
      iallcnt=1
    endif

!     icase = numa  -1 for smc opt; 0 for one run; >1 for par opt

!     rev. 9.2.24  Dec.  07/05  - BT: DDS optimization 

      if(icase)9999,7777,8888
!     8888 -> pattern search
!     7777 -> regular run
!     9999 -> operation: precip adjustment factor      


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     SUBROUTINE SUBA DOES ALL RUNOFF AND FLOW CALCULATIONS  

 7777 CONTINUE

!     REV. 8.98   July 15/99 - MET GRID SHIFTING FOR WEATHER MODELS 
!     READ THE GRID SHIFTING PARAMETERS:
      open(unit=99,file='grdshift.txt',status='old',iostat=ios)
      if(ios.eq.0)then
        read(99,9901,iostat=ios)igrdshft
        if(ios.ne.0)then
          print*,' problems reading the gridshift.txt file'
          print*,' ios = ',ios
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          STOP ' program aborted in options @ 148'
        endif
        write(51,9902)igrdshft
        read(99,9903)junk
        write(98,9903)junk
9903    format(a72)
        read(99,9901)iyshiftmin,iyshiftmax,jxshiftmin,jxshiftmax,ishift,jshift
        write(51,9901)iyshiftmin,iyshiftmax,jxshiftmin,jxshiftmax,ishift,jshift
        close(unit=99)
        optlow=0.0
      else
!        these added Nov. 25/04  nk
         iyshiftmax=0
         jxshiftmax=0
         iyshiftmin=0
         jxshiftmin=0
         ishift=0
         jshift=0
         igrdshft=0
      endif

      inum=ycount+abs(iyshiftmin)+abs(iyshiftmax)
      jnum=xcount+abs(jxshiftmin)+abs(jxshiftmax)

	if(debug_output)write(63,*)'in options, inum.jnum/',inum,jnum

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
    sensitivityflg=.false.
      if(dds_flag.eq.-1)then
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call sensitivity(jan,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return
      endif


!     WARNING: DON'T COMBINE NEXT SEGMENT WITH PREVIOUS SEGMENT 
!     BECAUSE IGRDSHFT CAN BE SET = 0 IN THE FILE (i.e. NO IOS ERROR)
      if(igrdshft.le.0)then
        maxn=1
!        nnn=nnn+1   changed this June 23/02 nk killed allocation in flowinit
          if(debug_output)write(63,*) ' In options: 4 - before call sub'

        jan=1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        nnn=nnn+1
      else
        maxn=((iyshiftmax-iyshiftmin)/ishift+1)*((jxshiftmax-jxshiftmin)/jshift+1)
        write(52,5201)
5201    format(' dy_shift, dx_shift,peak_flows')
        do iyshift=iyshiftmin,iyshiftmax,ishift
          do jxshift=jxshiftmin,jxshiftmax,jshift
              if(debug_output)write(63,*) ' In options: 5 - before call sub'
            jan=1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              if(debug_output)write(63,*) ' In options: 6 - before call lst'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call lst(scale,igrdshft)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            write(52,5202)iyshift,jxshift,(qpeaks(l),l=1,no)
5202        format(2i10,40f10.3)
            nnn=nnn+1
          end do
        end do
      endif

      RETURN

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

!              * * * OPTIMIZATION * * *

!8888  if(iw.eq.0)then
!        iw1=1
!        iw2=5
!      else
!        iw1=iw
!        iw2=iw
!      endif

8888  if(icase.gt.0.and.resumflg.ne.'y')then
        print*,' WARNING: You should use a resume.txt file'
        print*,'          to ensure that each opt run starts'
        print*,'          with the same initial conditions'
        print*,' Of course a spinup period is OK too'
        print*,' '
        write(*,'(A)',advance='no')'  Be warned! Be warned! Be warned!'
        print*,' '
      endif

!     ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:

      
      if(par_file_version.ge.par_file_version_latest)then
!       par file will be updated from rdpar
!       before user can proceed
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        call par_init()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
      endif

!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        call write_par_10(99,25)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

        nnn=0
        nstart=0 
        optim=0.0
        optlow=0.1e+30
        optlast=-1.0

8000    CONTINUE
!       >>>>>>>>>> START OF OPTIMIZATION LOOP <<<<<<<<<

!       ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        call par_assign()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

!       SUB ORGANIZES ALL HYDROLOGIC COMPUTATIONS

        optlast=optim
        optim=0.0
        totaltime=0.0
        mo=mo1
      rewind 58  ! spl.plt
      rewind 60  ! spl.scv
      rewind 80  ! lake_sd

         if(debug_output)write(63,*) ' In options: 7 - before call sub'
        jan=1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!       A NEW PARAMETER FILE CALLED 'NEW.PAR' WILL BE WRITTEN
!       FOR THE LOWEST ERROR YIELDING PARAMETERS:
        if(optim.lt.optlow)then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_par_10(99,25)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          optlow=optim
        endif
  
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call opt(*8999,*8000)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

8999    RETURN
      
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 9999 CONTINUE

!     REAL-TIME OPTIMIZATION of initial soil moisture:

!     	       * * * * * * * * * * * *
      if(icase.eq.-1)then
!       OPTIMIZATION FOR SOIL MOISTURE  
        if(ni.gt.1)then
          write(6,1001)
          write(6,1002)ni
          RETURN
        endif
!       CALCULATE THE ERROR FOR THE INITIAL PARAMETERS:
        nnn=0
        do ii=1,classcount-2
           best(ii)=smc5(ii)
           err(ii)=0.0
           errold(ii)=0.1e+32
           chng(ii)=0.05
           if(smc5(ii).lt.chng(ii)) smc5(ii)=chng(ii)+0.01
           if(smc5(ii).gt.por-chng(ii)) smc5(ii)=por-chng(ii)-0.01
           icnt(ii)=0
           ndir(ii)=0
        end do
        write(52,8003)smc5
!       SET DIRECTION FOR SEARCH AND SET NEW SMC:
!       * * * * * * * * * * * * * * * * * * * * *
        crit=0.0
          if(debug_output)write(63,*) ' In options: 10 - before call sub'
        jan=1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 9015   call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       FIND THE ERROR ASSOCIATED WITH EACH PERMEABILITY CLASS
!       FOR EACH TRIAL SMC:
        nnn=nnn+1
!       NNN IS THE NNN'TH ITERATION
!        optim=0.0
        do l=1,no
           i=iy(l)	
           j=jx(l)
           n=s(i,j)
           ii=ibn(n)
           err(ii)=err(ii)+delta(1,l)
        end do
        write(52,8001)ii,(err(ii),ii=1,5)
!       a problem here with smc5
!       it needs to be somehow related to river classes of basin areas.
        do ii=1,classcount-2
!          IF ERROR IS REDUCED, KEEP GOING IN THE SAME DIRECTION
!          WE ARE ASSUMING A CONCAVE ERROR FUNCTION W/NO BUMPS
           if(err(ii).lt.errold(ii))then
              best(ii)=smc5(ii)
              smc5(ii)=smc5(ii)+chng(ii)
           else
              ndir(ii)=ndir(ii)+1
              if(ndir(ii).le.1)then
!                IF ERROR IS BIGGER, REVERSE DIRECTION
                 chng(ii)=-1.0*chng(ii)
              else 
!                AND CUT THE INTERVAL ON SECOND AND SUBSEQUENT 
!                DIRECTION CHANGES
                 chng(ii)=-0.4*chng(ii)
              endif
              smc5(ii)=smc5(ii)+chng(ii)
           endif
!          CHECK THE LIMITS AND STAY WITHIN
           if(smc5(ii).le.0.0)then
              chng(ii)=0.4* abs(chng(ii))
              smc5(ii)=0.0
           elseif(smc5(ii).ge.por)then
              chng(ii)=0.4*abs(chng(ii))
              smc5(ii)=por
           endif
           errold(ii)=err(ii)
           err(ii)=0.0
        end do
        write(52,8003)smc5
        write(52,8004)chng
        do ii=1,classcount-2
           if(smc5(ii).le.0.9*por)then
              crit=0.03*por
           else
              crit=0.01*por
           endif
           if(abs(chng(ii)).gt.crit)go to 9015
        end do
!         * * * * * * * * * * * * * * * * * * * * *
        do ii=1,classcount-2
           smc5(ii)=best(ii)
        end do
        write(52,6000)smc5
!       ICASEA IS SET AS A FLAG TO MAKE THE FINAL RUN FOR THE FULL 
!       FORECAST PERIOD
        icase=-11
!       UPDATE THE EVENT FILE:
        mo1=mo
        fln(20)='event/event.evt'
          if(debug_output)write(63,*) ' In options: 11 - before call outevt'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call outevt(conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      elseif(icase.eq.-2)then
      
!       * * * * RADAR SCALING (OPTIMIZATION) * * * *
!       ASSIGN INITIAL VALUES TO PARAMETERS TO BE OPTIMIZED:
        a(1)=1.0
        errflg=2
        numa=1
        ddelta(1)=0.25
        checkl(1)=0.1
        checkh(1)=3.
        nstart=0
        nnn=0
        optlow=0.1e+32
        optim=0.0
!       START OF OPTIMIZATION LOOP
 8080   CONTINUE
          if(debug_output)write(63,*) ' In options: 12 - before call sub'

        if(nnn.gt.0)then
          fln(99)='event/event.evt'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call read_evt(date,conv,scale,smc5,nhr,nhf)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ensimflg='n'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_shed_ef(31,1)	
          call read_par_parser(32,2)    
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif
        optim=0.0
        scale=a(1)        
        errflg=2
        numa=1
        jan=1
        dds_flag=-1
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(optim.lt.optlow)then
          best1=scale
          optlow=optim
        endif

!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call opt(*8081,*8080)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

8081	continue

!       Done optimizing - do a final run
        fln(99)='event/event.evt'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_evt(date,conv,scale,smc5,nhr,nhf)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ensimflg='n'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        scale=best1
        numa=0
        jan=1
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        if(ni.le.1)call lst(scale,igrdshft)

      RETURN



!       NUMA IS SET AS A FLAG TO MAKE THE FINAL RUN FOR THE FULL  
!       FORECAST PERIOD
 8089   icase=-12
        scale=best1
!       UPDATE THE EVENT FILE:
        mo1=mo
      endif
!     	       * * * * * * * * * * * *
!     TO MAKE A FORECAST RUN OF NL HRS SET:
!     ENTRY POINT IF ICASE = -10 IN XXXX.PAR FILE
        if(debug_output)write(63,*) ' In options: 15 - before call sub'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call read_evt(date,conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ensimflg='n'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call read_shed_ef(31,1)	
      call read_par_parser(32,2)    
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      scale=best1
      numa=0
      jan=1
      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
      if(ni.le.1)call lst(scale,igrdshft)

      RETURN
! FORMATS
 1001 format(' you cannot run smc optimization for more than 1 storm')
 1002 format('        you have',i3,' events')
 6000 format(' optimized smcs:'/5f10.3/)
 6500 format(6e10.3)
 6502 format(' a(',i2,')too close to upper constraint')
 6510 format(' the constraints on a(',i3,') are too close together')
 8001 format(' err=',i5,5e10.3/)
 8003 format('    smc=',5f10.5)
 8004 format('   chng=',5f10.5)
 8123 format(' ','a(1),scale,best1,optim,optlow/',5f10.5)
 9345 format(' classcount,nbsn,numa/',3i5/)
 9901 format(10i5)
 9902 format(/' grid shift index =',i2,'  0=no shift  1=shifting')


      END SUBROUTINE options
      SUBROUTINE outevt(conv,scale,smc5,nhr,nhf)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(12) :: date
      DIMENSION     :: smc5(16)
      integer  :: ios,nhr,nhf
      real*4   :: conv,scale,smc5

! WRITE A NEW EVENT.EVT FILE:
! SEE INPEVTA FOR VARIABLE DEFS

      open(unit=99,file=fln(99),status='unknown',iostat=ios)
      if(ios.ne.0)then
        print*,' problem opening ',fln(99),' in outevt.for @ line 15'
        print*,' ios=',ios,' possible problem: lile is locked'
        stop 'program aborted in outevt'
      endif

      write(99,5011,iostat=ios)date,snwflg

      if(ios.ne.0)then
        print*,' problem writing to',fln(99)
        print*,' ios=',ios
!        pause ' continue at your own risk!'
      endif

      write(99,5012)mo1
      write(99,5013)conv,scale
      write(99,5014)smc5  
      write(99,5015,iostat=ios)nhr
      print*,' ios=',ios
      write(99,5016)nhf
      write(99,6001)fln(1)
      write(99,6002)fln(2)
      write(99,6003)fln(3)
      write(99,6004)fln(4)
      write(99,6005)fln(5)
      write(99,6006)fln(6)
      write(99,6007)fln(7)
      write(99,6008)fln(8)
      write(99,6009)fln(9)
      write(99,6010)fln(10)
      write(99,6011)fln(11)
      write(99,6012)fln(12)
      write(99,6013)fln(13)
      write(99,6014)fln(14)
      write(99,6015)fln(15)
      write(99,6016)fln(16)
      write(99,6017)fln(17)
      write(99,6018)fln(18)
      write(99,6019)fln(19)

      close(unit=99,status='keep')

! THE DEFAULT IS TO RUN THE TEMPERATURE FILES:

! FORMATS

 5011 format('date & snow flag:         ',a14,a1,'nynnnnnnn')
 5012 format('month:                    ',i5)
 5013 format('rain conv. factor @ scale ',2f5.2)
 5014 format('ini moist each subbasin   ',5f5.2)
 5015 format('no hours of rain data     ',i5)
 5016 format('no hours of flow data     ',i5)
 6001 format('basin file name           ',a30,' unit= 31')
 6002 format('parameter file name       ',a30,'       32')
 6003 format('rain gage locn file name  ',a30,'       33')
 6004 format('stream gage locn file nam ',a30,'       34')
 6005 format('rain gage data file name  ',a30,'       35')
 6006 format('streamflow data file      ',a30,'       36')
 6007 format('reservoir release file    ',a30,'       37')
 6008 format('snow data file            ',a30,'       38')
 6009 format('radar met file            ',a30,'       39')
 6010 format('simple input met file     ',a30,'       40')
 6011 format('aes hourly radar rainfall ',a30,'       41')
 6012 format('clutter file              ',a30,'       42')
 6013 format('snow cover depln. curve   ',a30,'       43')
 6014 format('point temperatures        ',a30,'       44')
 6015 format('gridded temperatures      ',a30,'       45')
 6016 format('gridded min. temp.        ',a30,'       46')
 6017 format('gridded max. temp.        ',a30,'       47')
 6018 format('daily snow data file      ',a30,'       48')
 6019 format('spare                     ',a30,'       49')

      RETURN

      END SUBROUTINE outevt
	subroutine precip_adjust()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     this s/r created the precip adjustment factors
!     These are used in process_rain.f

!     rev. 9.5.69  Oct.  10/09  - NK: added xcount & ycount to error & paf files
!     rev. 9.8.30  Oct.  16/12  - NK: remove p(i,j)=0.0 from precip_adjust

      use area_watflood
	implicit none

	logical   ::    exists,newpafflg
	integer   ::    i,j,ios,block,ig,jg,iAllocate
      real*4, dimension(:,:),   allocatable :: grid_error
      real*4    ::    conv
      character*1 ::  answer
      
      allocate(grid_error(ycount,xcount),precadj(ycount,xcount),
     *      stat=iAllocate)
      if(iopt.eq.2)print*,'allocation done in precip_adjust '
      if(iopt.eq.2)print*
 
      nblock=0
      do i=ycount,1,-1
        do j=1,xcount
          precadj(i,j)=1.0
          grid_error=0.0
!     rev. 9.8.30  Oct.  16/12  - NK: remove p(i,j)=0.0 from precip_adjust
c          p(i,j)=0.0
        end do
      end do

      precflg=.false.
      INQUIRE(FILE='paf.r2s',EXIST=exists)
!     LOOK FOR A PAF.TXT FILE
!     IF IT IS NOT THERE, LOOK FOR AN ERROR.TXT FILE
      IF(exists)THEN
        precflg=.true.
        newpafflg=.true.
!       unit=99
        fln(99)='paf.r2s'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_r2s_beta(99,fln(99))
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  write(51,*)'Precip adjustment factors  PAF'
        do i=1,ycount,1
	    do j=1,xcount
            precadj(i,j)=amin1(2.0,inarray(i,j))
            precadj(i,j)=amax1(0.5,inarray(i,j))
	    end do
          write(51,201)(precadj(i,j),j=1,xcount)
	  end do
        print*,'read & closed the paf.r2s file'
        precflg=.true.

      else   ! paf.txt does not exist
!       look for an error.txt file instead
!       IF THERE IS NO PAF.r2s FILE, LOOK FOR A ERROR.txt FILE
!       AND IF IT'S NOT THERE EITHER, PASS OVER THE ADJUSTMENT SECTION
        INQUIRE(FILE='error.txt',EXIST=exists)
        IF(exists)THEN
          open(99,file='error.txt',form='formatted',iostat=ios)
	    if(ios.ne.0)then
	      print*,'Problems opening error.txt file'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
 	      print*
	      stop 'Program aborted in precip_adjust @ 481'
          else
              print*,'++++++++++++++++++++++++++++'
              print*,'+     Opened error.txt     +'
              print*,'++++++++++++++++++++++++++++'
          endif
          if(iopt.eq.2)print*,'@ 2 in precip_adjust @ 481'
          precflg=.true.
          newpafflg=.true.
          write(51,202)precflg
	    write(51,*)'Grid error'
          read(99,203,iostat=ios)nblock
	    if(ios.ne.0)then
	      print*,'Probelms reading the first line in error.txt'
	      print*
	      stop 'Program aborted in precip_adjust @ 112'
	    endif
	    write(51,*)'nblock= ',nblock
	    
          do while(nblock.gt.0)
            block=float(nblock)
            write(51,204)nblock
            print*,'reading error.txt file'
 !     rev. 9.5.69  Oct.  10/09  - NK: added xcount & ycount to error & paf files
!           Note:  the precip data may be in mc2 format - 99 fields
            read(99,*)   ! xcount - not needed
	      read(99,*)   ! ycount - not needed
            do i=ycount,1,-1
!             this is not a GK format so file is north up            
c              read(99,*,iostat=ios)(p(i,j),j=1,xcount)
              read(99,*,iostat=ios)(grid_error(i,j),j=1,xcount)
              if(ios.ne.0)then
	          print*,'Problems reading data line ',i,' in error.txt'
	          print*
	          stop 'Program aborted in precip_adjust @ 112'
	        endif
            end do
            write(*,*)'Reading block',block
           do i=1,ycount
              write(51,2000)(grid_error(i,j),j=1,xcount)
              do j=1,xcount
c               grid_error(i,j)=grid_error(i,j)+p(i,j)/float(1+nblock**2)    !1.5
                precadj(i,j)=precadj(i,j)*block/
     *                   (block+grid_error(i,j)/100.0)
              end do
            end do
            write(51,*)'PAF - precipitation adjustment factor'
            do i= ycount,1,-1
                write(51,2001)(precadj(i,j),j=1,xcount)
            end do          
            read(99,203,iostat=ios)nblock      
            if(ios.ne.0)then
!             IF WE HAVE REACHED THE END OF THE FILE, OK 
!             THERE SHOULD BE A BLOCK INDEX NUMBER IF THERE 
!             ANOTHER DATA BLOCK
	        print*,'Problems reading data line ',i,' in error.txt'
	        print*
	        stop 'Program aborted in precip_adjust @ 112'
	      endif
          end do
          
!         SET LIMITS ON THE PRECIPITATION ADJUSTMENT FACTORS:
          do i=1,ycount
            do j=1,xcount
              precadj(i,j)=amin1(2.0,precadj(i,j))
              precadj(i,j)=amax1(0.5,precadj(i,j))
            end do
          end do
          if(iopt.eq.2)print*, '2 in rain'
          close(99)

!         Write a new PAF.r2s file
          author='CHARM***.exe'     
          name='PrecipAdjustmentFactor'
          coordsys_temp=coordsys1
!         GreenKenue uses LatLong - code below uses LATLONG
          if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
          if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
          zone_temp=zone1
          datum_temp=datum1
          xorigin_temp=xorigin
          yorigin_temp=yorigin
          xcount_temp=xcount
          ycount_temp=ycount
          xdelta_temp=xdelta
          ydelta_temp=ydelta
          attribute_name='PAF                                     '
          attribute_units='1                                      ' 
          attribute_type='None                                    '  
          source_file_name='error.txt'
          unit_conversion=1.0     
          fln(99)='newpaf.r2s'  
          do i=1,ycount
            do j=1,xcount
              outarray(i,j)=precadj(i,j)
            end do
          end do
          call write_r2s(99,fln(99))
        endif
      endif
      
d      do i=ycount,1,-1
d        write(*,201)(precadj(i,j),j=1,xcount)
d      end do
      
      return

!     FORMATS
 2000 format(<xcount>f5.0)
  201 format(<xcount>f5.2)
 2001 format(<xcount>f5.2)        !for mc2 files for map
  202 format(' Precflg= ',l1,'  Precipitation adjustment factors:')
  203 format(i5)
  204 format(' nblock=',i5)
  205 format(3i5,f10.2)
  206 format('    l    i    j       PAF  ycount,xcount:',2i5)   
  207 format(' Please note: limits of 0.5 to 2.0 set on PAF`s')
  208 format(10x,l1)
  217 format(6x,2i5,5x,a5,a30,i5)
  218 format(6x,2i5,5x,a5,a30)
  220 format(10x,i10)

	end subroutine precip_adjust
      SUBROUTINE process_hum(time,n)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
! PROCESS_HUM written DEC/076 by Trish Stadnyk
!	- converts specific humidity from REMOiso output into relative
!       humidity required for isoWATFLOOD 
!	- This subroutine processes the specific humidity read by read_hum()
!***********************************************************************

      use area_watflood
	use areacg
	implicit none

      INTEGER :: n
      REAL*4  :: time,ea,es,pa,qa

!     change spech(n) into rel(h) based on
!     http://fish.cims.nyu.edu/project_aomip/forcing_data/atmosphere/humidity.html

      qa=spech(n)   ! specific humidty in g/kg
	pa=101325     ! atmospheric air pressure (Pa)

!     vapour pressure in air:
      ea=pa/(0.622/qa+0.378)
     
!     es - saturation vapour pressure (as in over oceans or water bodies)
      es=10**((0.7859+0.03477*tempv(n))/(1.0+0.00412*tempv(n))+2)

!     relative humidty (in percent) = ratio of vapour pressure to sat'n vap. pressure:
      relh(n)=ea/es


      write(103,1003)time,n,qa,pa,ea,es,relh(n)
 1003 FORMAT(f8.2,',',i8,10(f14.4))

	END SUBROUTINE process_hum      SUBROUTINE process_rain(conv,scale)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
C***********************************************************************
C  PROCESS_RAIN - written Jun/06 by Dave Watson
C     - Derived from process routines written by Nick Kouwen inside rdrain 
C     - This subroutine processes the rain loaded by read_rain_ef()
C***********************************************************************

!     rev. 9.3.06  Dec.  17/06  - NK: added precip adjustment for bias
!     rev. 9.3.07  Dec.  29/06  - NK: added sum_precip for whole domain
!     rev. 9.5.17  Feb.  28/08  - NK: moved scale snow from sub to process rain
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg

      use area_watflood
      implicit none
      save

      integer i,j,n,ios,i2,j2,m
      real*4   :: conv,scale,conv1
      logical  :: exists,offset,not_offset,remap,firstpass
c      real*4, dimension(:,:),   allocatable ::  array
      
      data firstpass/.true./
      
!     remap the precip to a finer grid
      if(.not.netCDFflg.and.firstpass)then
        if(iyoffset.eq.0.and.jxoffset.eq.0)then
          not_offset=.true.
        else
          offset=.true.
        endif
        if(xcount2.ne.xcount.or.ycount2.ne.ycount)then
          remap=.true.
          m=int((xdelta2+0.000001)/xdelta)
          n=int((ydelta2+0.000001)/ydelta)
          print*,'precip grid: xratio=',m,' yratio=',n
        endif
c		allocate(array(ycount,xcount),stat=iAllocate)
      endif

      if(not_offset.and.remap)then
        do i=ycount,1,-1
          do j=xcount,1,-1
!           avoid div by 0 for i=1 & j=1          
            p(i,j)=p((i+n-1)/n,(j+m-1)/m)
          end do
        end do
      endif
            
!     rev. 9.3.06  Dec.  17/06  - NK: added precip adjustment for bias
!     adjust bias found in radar precip using long-term accumulation
!     this takes precedence over any values from the paf files read by
!     precip_adjust.f - see below at *****
      if(firstpass)then
        inquire(FILE='under_by.csv',EXIST=exists)
        if(exists)then
          print*,'file under_by.csv  found'
          open(unit=99,file='under_by.csv',status='old',iostat=ios)
          if(ios.ne.0)then
            print*,'Problem opening file  under_by.csv'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*
            stop 'Program aborted in process_rain @ 32'
          endif
          precflg=.true.
          do i=ycount,1,-1
            read(99,*)(precadj(i,j),j=1,xcount)
            write(*,*)i,(precadj(i,j),j=1,xcount)
          end do
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            if(precadj(i,j).ne.0.0)then
              precadj(i,j)=1.0/precadj(i,j)
            else
              precadj(i,j)=1.0
            endif
          end do
        else
        
!         This needs to be done only at the start of a run. 
!         Process_rain is done every time step.
          if(pafflg.eq.'y')then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call precip_adjust()    ! *****
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
        endif
      endif

!       REV. 8.98   July  15/99 -  MET GRID SHIFTING FOR WEATHER MODELS  
!       REMAP INTO SOUTH-WEST CORNER:
!     rev. 9.3.07  Dec.  29/06  - NK: added sum_precip for whole domain

      if(offset)then
        do i=1,ycount
          do j=1,xcount
            p(i,j)=p(i+iyoffset,j+jxoffset)
          end do
        end do
      endif

C NICK from DAVE - do we need the following? or would precip already be adjusted
!       THIS SECTION MULTIPLIES THE PRECIP BY THE PRECIP ADJUSTMENT
!       FACTOR
!       FRANK S JAN 98 (IF PREADJ=0.0 THEN THERE IS NO CHANGE)
      if(precflg)then
            do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  p(i,j)=p(i,j)*precadj(i,j)
            end do
            if(iopt.eq.2)print*,'grid adjusted'
      endif

C NICK from DAVE-I would like to get away from this guage/radar differentiation
C we can set the entire MET file to gauge or radar in the header..but should we assume the data is 
C already converted

      if(conv.ne.1.0.or.scale.ne.1.0)then

            if(source.ne.'Gauge')then
!           RADAR IS SCALED IF THE OPTION IS USED BUT ONLY THE
!           RADAR DATA                
                  conv1=conv*scale
            else
!           WHEN MISSING RADAR IS REPLACED BY GAUGE DATA, 
!           IT IS NOT SCALED
                  conv1=conv
            endif
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
              p(i,j)=p(i,j)*conv1
            end do
      endif         
      
!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!     DN to NICK -- this is the only change required here!
!     (all the meat is in the sub)
!     rev. 2014-08 - DN: hook for precip corrections
c      if(fcstflg.eq.'y')then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call forecast_correct_precip()    ! correction happens in the sub
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       2014-08 -- DN
!       modifies p(i,j) in forecast mode (if applicable) based on adjustment factors
!       specified in forecast parameter file
        !print *, 'in process_rain@151, checking forecast mode flag'
        !print *, 'in process_rain@152, checking forecast mode flag'
        if(fcst_mode)then
          !print *, 'in process_rain@153, correcting precip!'
          !print *,'fcst_hr0,hour_now,hour1,hour_start:'
          !print *, fcst_hr0, hour_now, hour1, hour_start
          !print *, fcst_hr0, hour_now+24*jul_day_now, fcst_snow_adj
          if(fcst_hr0.gt.(hour_now+24*jul_day_now))then
          !         DN 2015-02-07 -- these are temporary debug statements
            !print*,'correcting precip at hour:',hour_now+24*jul_day_now
            !print*,hour_now+24*jul_day_now,'year:',year_now
            !print *, 'tempv: ',tempv(1),'rainsnowtemp: ',rainsnowtemp
            !print *, 'adj: ',fcst_snow_adj,fcst_rain_adj
            !print *, 'p_ij: ',p(1,1),'adjusted: ',p(1,1)*fcst_snow_adj
            !print *, p(1,1)*fcst_rain_adj
            do n=1,naa
!             which variable to get <current_hour> from reliably?
              i=yyy(n)
              j=xxx(n)
            ! use global rainsnowtemp from evt file to separate snow from rain
            ! often set to 0
              if(tempv(n).lt.rainsnowtemp)then    
                p(i,j)=p(i,j)*fcst_snow_adj
                !print *, 'adjusting snow! at ',hour_now+24*jul_day_now
              else
                p(i,j)=p(i,j)*fcst_rain_adj
                !print *, 'adjusting rain! at ',hour_now+24*jul_day_now
              end if
            end do
          end if
        end if
c      endif   ! fcstflg
!     end rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg

!     rev. 9.2.36  Mar.  30/06  - NK: Scaleallsnow changed to precip snow
!     rev. 9.5.17  Feb.  28/08  - NK: moved scale snow from sub to process rain
!     this little ditty was just a temp fix to scale precip when it is snow.
      if(scalesnw.gt.0.and.snwflg.eq.'y')then
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          if(tempv(n).lt.0.0)then    ! could pick a larger temp.
            p(i,j)=p(i,j)*scalesnw
          endif
        end do
      endif
      
      if(readscalesnw.gt.0.and.snwflg.eq.'y')then
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          if(tempv(n).lt.0.0)then    ! could pick a larger temp.
            p(i,j)=p(i,j)*readscalesnw
          endif
        end do
      endif

!     rev. 9.7.11  Nov.  21/10  - NK: added monthly_climate_deltas.txt file
	if(climate_delta_flg)then
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
            p(i,j)=p(i,j)*monthly_precipitation_delta(month_now)
	  end do
c	  print*,'month=',month_now,' delta_T=',
c               	  monthly_temperature_delta(month_now)
	endif

c        write(955,*)'in process rain time=',totaltime
c        do i=ycount,1,-1
c          write(955,99955)(p(i,j),j=1,xcount)
c99955     format(999f5.1)          
c        end do
c        write(955,*)totaltime



99999 firstpass=.false.

      return

      END SUBROUTINE process_rain      SUBROUTINE process_temp(jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
C***********************************************************************
C  PROCESS_TEMP - written Jun/06 by Dave Watson
C	- Derived from process routines written by Nick Kouwen inside rdtemp 
C	- This subroutine processes the temperatures loaded by read_temp_ef()
C***********************************************************************

!     rev. 9.5.63  Sep.  04/09  - NK: moved lapse rate from melt.f to process_temp.f
!     rev. 9.5.65  Sep.  26/09  - NK: lapse rate changed from dC per 100 m to dC per m

      USE area_watflood
	implicit none
	save

	integer i,j,n,i2,j2,m
	integer jz
	integer ntocorrect


      logical      :: offset,not_offset,remap,firstpass
      data firstpass/.true./

	ntocorrect = 0 !default value
      
!     remap the precip to a finer grid
      if(firstpass)then
        if(iyoffset.eq.0.and.jxoffset.eq.0)then
          not_offset=.true.
        else
          offset=.true.
        endif
        if(xcount2.ne.xcount.or.ycount2.ne.ycount)then
          remap=.true.
          m=int((xdelta2+0.000001)/xdelta)
          n=int((ydelta2+0.000001)/ydelta)
          print*,'temp grid:   xratio=',m,' yratio=',n
        endif
      endif

d     if(jz.le.1)then
d       if(iopt.ge.2)then
d	    print*,'iyoffset=   ',iyoffset
d	    print*,'jxoffset=   ',jxoffset
d         print*,'not_offset= ',not_offset
d         print*,'offset=     ',offset
d       endif
d     endif

      if(not_offset.and.remap)then
        do i=ycount,1,-1
          do j=xcount,1,-1
            ttemp(i,j)=ttemp((i+1)/n,(j+1)/m)
          end do
        end do
      endif

      if(offset)then
!       REMAP INTO SOUTH-WEST CORNER
        do i=1,ycount
           do j=1,xcount
             ttemp(i,j)=ttemp(i+iyoffset,j+jxoffset)
           end do
        end do
      endif
!     rev. 10.2.48 Feb.  25/19  - NK: Moved temp correction to read_temp from process_temp
!      moved to read_temp because it should be done on the read values
!      not over & over between reads
c!     RAISE OR LOWER THE TEMPERATURE FILED:
c      if(scaletem.gt.0.00001.or.scaletem.lt.-0.00001)then
c         do i=1,ycount
c            do j=1,xcount
c               ttemp(i,j)=ttemp(i,j)+scaletem
c            end do
c         end do
c      endif
      
!     rev. 9.01    Aug.   1/00  - added look up for minimum temperature
!                                 and function to calculate RH
!     reset the minimum temperature each midnight:
!     the offset for finding the min is a8 hours before midnight
!     a8 is entered in the parameter file.
!
!     only the centre grid is used ??????? fix fix ????
      if(mod(jz+int(a8),24).eq.0)then
        if(ttemp(yyy(naa/2),xxx(naa/2)).gt.-90.0)then
!         reset only if there is temperature data          
          do n=1,na
            tempvmin(n)=99.9
          end do
        endif
      endif

!     PUT INTO VECTOR FORMAT
      do n=1,naa
         i=yyy(n)
         j=xxx(n)
         if(ttemp(i,j).gt.-90.0)then
!          if missing data, leave temperature the same 
!          as last recorded value
!          store seed value for rh from previous calculation
!          initial value set in sub
!           x1=rh(n)
           tempv(n)=ttemp(i,j)
!          find minimum temperature for each day for rel humidity comp.
           tempvmin(n)=min(tempv(n),tempvmin(n))
         endif

!       rev. 9.5.63  Sep.  04/09  - NK: moved lapse rate from melt.f to process_temp.f
!       rev. 9.5.65  Sep.  26/09  - NK: lapse rate changed from dC per 100 m to dC per m

!        this is now done in tmp.exe
c        if(tlapse.ne.0.0)then
c!         ELEVATION IS IN HUNDREDS OF METERS
c!         LAPSE RATE IS IN DEGREE C / 1 m - USUALLY 0.5 DEGREE C
c          tempv(n)=tempv(n)-(elev(n)-elvref)*tlapse
c        end if
      end do        

!     rev. 9.7.11  Nov.  21/10  - NK: added monthly_climate_deltas.txt file
	if(climate_delta_flg)then
        do n=1,naa
          tempv(n)=tempv(n)+monthly_temperature_delta(month_now)
	  end do
	endif

      firstpass=.false.

      RETURN 

	END SUBROUTINE process_temp      SUBROUTINE rdsnow(time,jan,new)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
! SUBROUTINE TO READ DATA REQUIRED FOR SNOW ROUTINES

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        CHARACTER(1) :: new
      integer  :: jan,n,i,j,it31a,it31b,nhrs,mz,idt33
      real*4   :: tlast,time,tst31a,tst31b

!-------------------------------------------------------------------
!     FIRST TIME STEP STUFF  
!--------------------------------------------------------------------
!     JAN IS <= 1 ON FIRST TIME THROUGH ONLY
!     JAN IS SET TO 2 AFTER THE FIRST EXECUTION OF SUBROUTINE RUNOF5
   

!--------------------------------------------------------------------  
!     JD'S OLD STUFF:

      if(jan.eq.1)then



	go to 999





!        OPEN THE DISTRIBUTED SNOW GAUGE AND TEMPERATURE DATA FILES
  
!        FLN(16)=yymmdd.tmn
!        FLN(17)=yymmdd.tmx
!        FLN(18)=yymmdd.dsn

!         open(unit=46,file=fln(16),status='unknown',err=999)
!         open(unit=47,file=fln(17),status='unknown',err=999)
!         open(unit=48,file=fln(18),status='unknown',err=999)

!        REWIND FILES --  NEEDED TO REINITIALIZE FOR OPTIMIZATION   
 
         tlast=-10
        
!        DAILY SNOWFALL TIMESTEP AND CONVERSION FACTOR
         tlst31=-9999
!         read(48,5006,err=999)idt31,conv31
!         if(numa.eq.0) write(57,5001)idt31,conv31

!        DAILY MINIMUM TEMPERATURE TIMESTEP AND CONVERSION FACTOR 
         tlst32=-9999
!         read(46,5006)idt32,conv32
!         if(numa.eq.0) write(57,5003)idt32,conv32

!        DAILY MAXIMUM TEMPERATURE TIMESTEP AND CONVERSION FACTOR 
         tlst33=-9999
!         read(47,5006)idt33,conv33
!         if(numa.eq.0) write(57,5008)idt33,conv33

!-------------------------------------------------------------------
!        INITIALIZE DAILY MIN TEMPERATURE DATA - ALREADY DISTRIBUTED

         tlst32=time
         if(numa.eq.0) write(57,5004)time+1

!         read(46,*) 
!         do i=it,ib,-1
!            read(46,1000)(tmn(i,j),j=2,xcount-1)
!            if(numa.eq.0) write(57,1000)(tmn(i,j),j=2,xcount-1)
!         end do

!        PUT INTO VECTOR FORMAT
         do n=1,naa
            i=yyy(n)
            j=xxx(n)
            tmin1(n)=conv32*tmn(i,j)
         end do

!------------------------------------------------------------------
!        DAILY MIN TEMPERATURE DATA FOR SECOND DAY
!          - NEEDED FOR DIST'D TEMPERATURE 2ND HALF OF DAY 1

         tlst32=time
         if(numa.eq.0) write(57,5004)time+1+float(idt32)

!         read(46,*) 
!         do i=it,ib,-1
!            read(46,1000)(tmn(i,j),j=2,xcount-1)
!            if(numa.eq.0) write(57,1000)(tmn(i,j),j=2,xcount-1)
!         end do

!        PUT INTO VECTOR FORMAT
         do n=1,naa
            i=yyy(n)
            j=xxx(n)
            tmin2(n)=conv32*tmn(i,j)
         end do

      endif

!     * * * * *  END OF INITIALIZATION  * * * * * 

!  -----------------------------------------------------------------
!     READ MET DATA 
!                   - idt31 = snowfall data time interv.(hrs)
!                   - idt32 = min. temperature time interv.(hrs)
!                   - idt33 = max. temperature time interv.(hrs)   
!  -----------------------------------------------------------------
!     DAILY SNOWFALL DATA - ALREADY DISTRIBUTED SPATIALLY
!     FOR EACH TIME STEP. STILL MUST SPLIT BETWEEN CLASSES
 
!     READ SNOWFALL DATA IF NEXT TIME INCREMENT IS REACHED

      if(idt31.le.0)then
         print*, 'idt31 in rdsnow .le. 0.0'
         print*, 'idt31 assumes as 1'
         print*
         idt31=1
      endif
      tst31a=time/idt31
      tst31b=tlst31/idt31
      it31a=int(tst31a)
      it31b=int(tst31b)
 
      if(int(time/idt31).ne.int(tlst31/idt31))then
         tlst31=time
         if(numa.eq.0) write(57,5002)time+1

!        CHECK THAT TIME HASN'T RUN OUT
         nhrs=nr
         mz=int(time)+1
         if(mz.gt.nhrs)then
            do n=1,naa
               dsnow(n)=0.0
            end do
         else

!------------------------------------------------------------------
!           CHECK IF ANY SNOW FALL DURING TIME INTERVAL
!           IF YES THEN READ AND ASSIGN TO DSN(i,j)
!           IF NO THEN DSN(i,j) = 0 FOR ALL i,j's

!            read(48,5005) k

!            if(k.gt.0) then
!               do i=it,ib,-1
!                  read(48,1000)(dsn(i,j),j=2,xcount-1)
!                  if(numa.eq.0) write(57,1000)(dsn(i,j),j=2,xcount-1)
!               end do
!            else
               do i=it,ib,-1
                  do j=2,xcount-1
                     dsn(i,j)=0.0
                  end do
                  if(numa.eq.0) write(57,1000)(dsn(i,j),j=2,xcount-1)
               end do
!            endif

!           PUT INTO VECTOR FORMAT
            do n=1,naa
               i=yyy(n)
               j=xxx(n)
               dsnow(n)=conv31*dsn(i,j)
            end do

         endif
 
      endif
 
!-------------------------------------------------------------------
!     DAILY MIN TEMPERATURE DATA - ALREADY DISTRIBUTED
!     NB: DAILY MIN TEMPERATURE IS READ 1 TIME STEP AHEAD OF 
!         THE SIMULATION IN ORDER THAT TEMPERATURE CALCULATIONS
!         CAN BE CARRIED OUT FOR THE SECOND HALF OF THE DAY - SEE
!         CALC'S IN TEMPER.FOR 

!     READ TEMPERATURE DATA IF NEXT TIME INCREMENT IS REACHED

      if(int(time/idt32).ne.int(tlst32/idt32))then
         tlst32=time
         if(numa.eq.0) write(57,5010)time+1+float(idt32)
!        IS TIME+1+IDT32 BECAUSE WE ARE READING MIN TEMPS 1 STEP AHEAD

!        ASSIGN TMIN2 TO TMIN1 
         do n=1,naa
            tmin1(n)=tmin2(n)
         end do

!        CHECK THAT TIME HASN'T RUN OUT
!        NB: TMIN IS BEING READ 1 TIME STEP AHEAD OF THE OTHER DATA
!            - LEAVE IN OLD VALUES FOR TMIN 
         nhrs=nr
         mz=int(time+1)+idt32

         if(mz.gt.nhrs)then
            do n=1,naa
               tmin2(n)=tmin2(n)
            end do
         else
!            read(46,*) 
!            do i=it,ib,-1
!               read(46,1000)(tmn(i,j),j=2,xcount-1)
!               if(numa.eq.0) write(57,1000)(tmn(i,j),j=2,xcount-1)
!            end do

!           PUT INTO VECTOR FORMAT
            do n=1,naa
               i=yyy(n)
               j=xxx(n)
               tmin2(n)=conv32*tmn(i,j)
            end do
         endif
      
      endif

!-------------------------------------------------------------------
!     DAILY MAX TEMPERATURE DATA - ALREADY DISTRIBUTED

!     READ TEMPERATURE DATA IF NEXT TIME INCREMENT IS REACHED

      if(int(time/idt33).ne.int(tlst33/idt33))then
         tlst33=time
         if(numa.eq.0) write(57,5009)time+1

!        CHECK THAT TIME HASN'T RUN OUT
         nhrs=nr
         mz=int(time+1)
         if(mz.gt.nhrs) then
            do n=1,naa
!              USE LAST DAYS MAX TEMPERATURE	  
               tmax(n)=tmax(n)
            end do
        else
!            read(47,*) 
!            do i=it,ib,-1
!               read(47,1000)(tmx(i,j),j=2,xcount-1)
!               if(numa.eq.0) write(57,1000)(tmx(i,j),j=2,xcount-1)
!            end do

!           PUT INTO VECTOR FORMAT
            do n=1,naa
               i=yyy(n)
               j=xxx(n)
               tmax(n)=conv33*tmx(i,j)
            end do
        endif
        
      
      endif
	
  999 new='t'
      idt31=1
      idt32=1
      idt33=1
!      write(*,5999)new

! FORMATS:

 1000 format(16f10.1)
 5001 format(1x,'snow data time step=',i4,'  conv factor=',f6.2)
 5002 format(1x,'snowpack input data: time=',f5.0)
 5003 format(1x,'tmin data time step=',i4,'  conv factor=',f6.2)
 5004 format(1x,'temperature input data: time=',f5.0)
 5005 format(6x,i5)
 5006 format(i5,f6.1)
 5008 format(1x,'tmax data time step=',i4,'  conv factor=',f6.2)
 5009 format(1x,'max. temperature input data: time=',f5.0)
 5010 format(1x,'min.temperature input data: time=',f5.0)
 5999 format(' new = ',a1)


      RETURN

      END SUBROUTINE rdsnow


      subroutine rd_wfo_spec()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      REAL(4)		::     wfo_spec_version_number
      INTEGER           :: nratio,nj,iallcnt1,m,i,j,ios,n,ii,
     *                     iallocate
      logical           :: exists

	DATA iallcnt1/0/

!     NOTE: FOR MONTHLY RUNS, DIMENSIONS CAN BE CHANGED FROM 
!           3,8784,500  TO  12,366,3000

!>>>>>>>>>>>>>  AB: STUFF FOR ENSIM
      INTEGER(4) :: wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss,
     *                   wfo_ms
      INTEGER(4) :: wfo_seq

      if(iopt.eq.2)print*,' In rdwfospec after definitions'

!     RESET SETS ALL INITIAL VARIABLES

!      wfo_open_flg='n'
                
      INQUIRE(FILE='wfo_spec.txt',EXIST=exists)
      IF(exists)THEN
        open(unit=99,file='wfo_spec.txt',status='old',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file  wfo_spec.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          stop 'Program aborted in rd_wfo_spec @ 40'
        endif
      else
!     rev. 10.2.06 Oct   28/17  - NK: wfo_spec.txt in working OR basin directory
        INQUIRE(FILE='basin\wfo_spec.txt',EXIST=exists)
        IF(exists)THEN
          open(unit=99,file='basin\wfo_spec.txt',
     *                       status='old',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  basin\wfo_spec.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            stop 'Program aborted in rd_wfo_spec @ 40'
          endif
        else
          print*,' WFO_SPEC.TXT file not found in the working OR'
          print*,' basin directories'
          print*,' although ensim flag = y'
          print*,' Program continues with ensimflg set = n'
          print*
          print*,' BSN.EXE can create a wfo_spec.new file'
          print*,' that can be copied to the working directory'
          print*,' as wfo_spec.txt    '
          print*
          print*,' Hit Ctrl C to abort or'
          pause ' Hit enter to continue       (in rd_wfo @ 49)'
        endif  
      endif

!     rev. 9.1.50  Jan.  14/04  - NK: version number added to the wfo_spec.txt file
        read(99,99000,iostat=ios)wfo_spec_version_number
        if(ios.ne.0.or.wfo_spec_version_number.ne.6.0)then    ! see below <<<<<<!!!!
          print*,' Problem reading wfo_spec.txt'
          print*,' You may need to update the wfo_spec.txt file'
          print*,' File version number =',wfo_spec_version_number
          print*,' Required version number = 6.0'
	    print*,' As of Feb. 15/18'
          print*,' Run the current bsn.exe to create a new'
          print*,' basin\wfo_spec.new file and copy it to the'
          print*,' working directory as wfo_spec.txt'
          print*
          stop ' Program aborted in spl @ 1195'
        endif
        read(99,99004,iostat=ios)nj
!       This number comes from the bsn.for program
!       See "no of attributes"

        allocate(attname(nj),attunits(nj),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *   'Error with allocation of arrays in write_both_headers'

! Note:  number below needs to be updated if items are added <<<<<<<<<<<<<<<<<!!!!!
        
        if(nj.ne.15+15*(classcount))then
          print*,' The wfo_spec.txt file needs to be updated'
          print*,' additional attributes have been added'
          print*,' Re-run the updated bsn.exe on the map file ' 
          print*,'     and create a wfo_spec.new file'
          print*,' classcount=',classcount
          print*,' No entrees found =',nj
          print*,' Looking for', 15+15*(classcount)
          print*,' Copy wfo_spec.new to ..\wfo_spec.txt' 
          print*,' Revision 9.1.29'
          print*
          stop ' Program aborted in rd_wfo_spec @ 406'
        endif

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
        if(.not.allocated(wfo_pick))then
          allocate(wfo_pick(nj),wfo_attributes(nj),
     *          wfo_sum_p(na),wfo_cum_p(na),
     *          wfo_sum_qsyn(na),wfo_sum_qhyd(na),stat=iAllocate)
          if(iAllocate.ne.0)then
	      print*,'nj=',nj,'  na=',na
            STOP
     *     'Error with allocation of area2 arrays in rd_wfo_spec @ 74'
          endif
	  endif

!     Cumulative precip is set to 0.0 only the first time that the wfo stuff
!     is initialized. So if you want the total precip over a period, you have
!     to have the wfo flag on for just that period.

c       read(99,99004,iostat=ios)ireport
        read(99,*,iostat=ios)ireport
        if(ios.ne.0)then
          print*,' Problem reading line two of the'
          print*,' wfo_spec.txt file'
          print*
          stop ' Program aborted in spl @ 1195'
        endif
        if(ireport.eq.0)ireport=1

!       ireport_start and ireport_end mark the beginning and ens of the 
!       watflood.wfo file It is based on the total time from the beginning 
!       of a simulation - not the event time.

c       read(99,99004,iostat=ios)ireport_start
        read(99,*,iostat=ios)ireport_start
        if(ios.ne.0)then
          print*,' Problem reading  line two of the'
          print*,' wfo_spec.txt file'
          print*
          stop ' Program aborted in spl @ 1195'
        endif

c       read(99,99004,iostat=ios)ireport_end
        read(99,*,iostat=ios)ireport_end
        if(ios.ne.0)then
          print*,' Problem reading  line three of the'
          print*,' wfo_spec.txt file'
          print*
          stop ' Program aborted in spl @ 1195'
        endif
        if(ireport_end.eq.0)ireport_end=8760000         ! 1000 years

        do j=1,nj
          read(99,99003,iostat=ios)wfo_pick(j),wfo_attributes(j)
          if(ios.ne.0)then
            print*,'iostat code =',ios
            print*,' Read to line ',j,' in wfo_pick.txt'
            print*,' then a problem was found'
            STOP 'program aborted in sub.for @ 1190'
          endif
        end do
        close(unit=99,status='keep')

!     this check added 24/10/05  nk
      if(trcflg.ne.'y'.and.wfo_pick(5).eq.1)then
	  wfo_pick(5)=0
	  print*
	  print*,'Warning:'
	  print*,'You can not use the groundwater output function'
	  print*,'for ENSIM if trcflg = `n` '
	  print*,'wfo_pick(5) is set to 0'
	  print*,'I.e. the ground water contribution for ENSIM is'
	  print*,'turned off.'
	  print*
	  print*,'If you want the GW contribution for ENSIM, please'
	  print*,'set the trcflg = `y` in the event file'
	  print*
	  pause 'Hit enter to continue with GW turned off'
	endif

      print*,'Finished reading the wfo_spec.txt file'
      print*

99000 format(f5.1)
99001 format(f25.0)
99003 format(i1,5x,a50)
99004 format(i5)

      return
      end subroutine rd_wfo_spec! This is part of the netCDF package.
! Copyright 2006 University Corporation for Atmospheric Research/Unidata.
! See COPYRIGHT file for conditions of use.

! This subroutine is based on an example which reads some 4D pressure and
! temperatures. The data file read by this program is produced by
! the companion program pres_temp_4D_wr.f90. It is intended to
! illustrate the use of the netCDF Fortran 90 API.

! This program is part of the netCDF tutorial:
! http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-tutorial

! Full documentation of the netCDF Fortran 90 API can be found at:
! http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-f90

! $Id: pres_temp_4D_rd.f90,v 1.9 2010/04/06 19:32:09 ed Exp $



  subroutine read_swe_2D_nc(m,fn,ensemble)
  
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating

!  Argument from CHARM
!  m = sequence # 1, 2, 3, 4,.....,nrecs
!  nrecs = -ve = close file
!  fn = file name number
!  ensemble = index of ensemble member (ignored if there is no ensemble)
!  TEMP_NAME = variabel name e.g. flow, precipitation, temperature
!  TEMP_UNITS = units e.g. cms, mm

  use netcdf
  use area_debug
  use area_watflood
  implicit none
  save

  ! This is the name of the data file we will read.
  character (256) :: FILE_NAME
  integer :: ncid,iAllocate

! Also, I'd like to get rid of NLVLS altogether
  integer, parameter :: NDIMSMAX = 10  !<AM: ideally maximum number possible

  integer :: NDIMS, NRECS
  integer :: NLVLS, NLATS, NLONS


  integer, parameter             :: NOENSEMBLE = -999
  character (len = *), parameter :: ENSEMBLE_NAME = "realization" !< AM: note the conflict with levels ...
  character (len = *), parameter :: LVL_NAME = "level"
  character (len = *), parameter :: row_NAME = "y"
  character (len = *), parameter :: col_NAME = "x"
  character (len = *), parameter :: LAT_NAME = "y"
  character (len = *), parameter :: LON_NAME = "x"
  character (len = *), parameter               :: REC_NAME       = "time"
  character (len = *), parameter               :: TIME_NAME      = "time"
  character (len = *), parameter               :: TIME_STEP_NAME = "time_step"
  character (len = *), parameter               :: TIME_ID_NAME   = "time"
! We will read surface temperature and pressure fields etc. In netCDF
! terminology these are called "variables."
  character (len = *), parameter :: TEMP_NAME = "swe"
  character (len = *), parameter :: TEMP_UNITS = "mm"

  ! The start and count arrays will tell the netCDF library where to
  ! read our data.
  integer :: dimids(NDIMSMAX)
  integer, allocatable :: start(:), count(:)

  ! In addition to the latitude and longitude dimensions, we will also
  ! create latitude and longitude variables which will hold the actual
  ! latitudes and longitudes. Since they hold data about the
  ! coordinate system, the netCDF term for these is: "coordinate
  ! variables."
  real, allocatable :: lats(:), lons(:)
  integer, allocatable :: times(:)                              !, lons(:)
  integer :: lon_varid, lat_varid, rec_varid, lvl_varid
  integer :: lon_dimid, lat_dimid, rec_dimid, lvl_dimid
  integer :: temp_varid
  integer :: time_varid

  ! We recommend that each variable carry a "units" attribute.
  character (len = *), parameter :: UNITS = "units"
!  character (len = *), parameter :: PRES_UNITS = "hPa", TEMP_UNITS = "celsius"
!  character (len = *), parameter :: TEMP_UNITS = "celsius"
  character (len = *), parameter :: LAT_UNITS = "degrees_north"
  character (len = *), parameter :: LON_UNITS = "degrees_east"

  ! Program variables to hold the data we will read in. We will only
  ! need enough space to hold one timestep of data; one record.
  ! Allocate memory for data.
!  real, dimension(:,:,:), allocatable :: pres_in
  real, dimension(:,:,:), allocatable :: temp_in
  real, dimension(:,:), allocatable :: ratio2
  real(4)  :: class_sum

  ! Loop indices
  integer :: lvl, i , j,ios, step, fn, m
  integer :: n,ii
  

  integer           :: ensemble
  integer           :: ensemble_index
!  integer, save     :: number_members            !ask AM: do we need this if done for general save???
  integer           :: number_members             !ask AM: do we need this if done for general save???
  integer           :: ensemble_dimid

! Added for Dt  NK
  real   :: time_step, time
  integer :: time_id, time_step_id,start_time
  integer :: isecnds, iatime(9), ierror

  logical :: firstpass,done

  data firstpass/.true./done/.false./

  if(done)return

  if(firstpass)then
      NLVLS=1                   !<AM: this is actually the dimension of ensemble members ...
      FILE_NAME = fln(fn)

      if(debug_output)write(63,*)'*******************************'
      if(debug_output)write(63,*)'*******************************'
      if(debug_output)write(63,*)'*******************************'
      if(debug_output)write(63,*)'In read_swe_2D_nc'
      if(debug_output)write(63,*)m,fn,TEMP_NAME,' ',TEMP_UNITS
      if(debug_output)write(63,*)fln(fn)(1:40)

!     AM: we need to open the file and read the various dimensions
!         before we can enter the loop ...
!     Open the file.
      if(debug_output)write(63,*)FILE_NAME(1:20), nf90_nowrite, ncid
      call check( nf90_open(FILE_NAME, nf90_nowrite, ncid) )
      if(debug_output)write(63,*)'Opened ',FILE_NAME(1:40)
      write(98,*)'Info: Opened ',FILE_NAME(1:40)
!
!     Get the dimensions
      call check( nf90_inq_varid(ncid, LAT_NAME, lat_varid) )
      call check( nf90_inq_varid(ncid, LON_NAME, lon_varid) )
      if(debug_output)write(63,*)'step 200'

!!!!!!!!!!  call check( nf90_inq_dimid(ncid, LVL_NAME, lvl_dimid) ) !<AM: not a separate variable, only a dimension
      call check( nf90_inq_dimid(ncid, REC_NAME, rec_dimid) ) !<AM: ditto


!     Determine the number of ensemble members - if any
      ierror = nf90_inq_dimid(ncid, ENSEMBLE_NAME, ensemble_dimid) !<AM: ditto
      if ( ierror == nf90_noerr ) then
          ensemble_index = ensemble
      else
          if ( ierror == nf90_ebaddim ) then
              ensemble_index = NOENSEMBLE
          else
              call check( nf90_inq_dimid(ncid, ENSEMBLE_NAME, ensemble_dimid) ) ! Proper error message the lazy way
          endif
      endif

      if(debug_output)write(63,*)ncid, REC_NAME, rec_dimid
      if(debug_output)write(63,*)'step 300'

      call check( nf90_inquire_variable( ncid, lat_varid, ndims=ndims, dimids=dimids ) )
      lat_dimid = dimids(1)
      if(debug_output)write(63,*)'ndims\lat_varid =',ndims,lat_varid

      call check( nf90_inquire_variable( ncid, lon_varid, ndims=ndims, dimids=dimids ) )
      lon_dimid = dimids(1)
      if(debug_output)write(63,*)'ndims\lon_varid =',ndims,lon_varid
      if(debug_output)write(63,*)'step 400'

      call check( nf90_inquire_dimension( ncid, lat_dimid, len=nlats ) )
      if(debug_output)write(63,*)'ycount',nlats,ycount
      call check( nf90_inquire_dimension( ncid, lon_dimid, len=nlons ) )
      if(debug_output)write(63,*)'xcount',nlons,xcount
      call check( nf90_inquire_dimension( ncid, rec_dimid, len=nrecs ) ) !<AM: this is an "unlimited" dimension - we merely get the current size
!!!!!!!!!  call check( nf90_inquire_dimension( ncid, lvl_dimid, len=nlvls ) )
      if(debug_output)write(63,*) 'Lat/lon/levels: ', nlats, nlons, nlvls
      if(debug_output)write(63,*) 'Records:        ', nrecs
      if(debug_output)write(63,*)'step 500'

      if ( ensemble_index /= NOENSEMBLE ) then
          call check( nf90_inquire_dimension( ncid, ensemble_dimid, len=number_members ) )
      else
          number_members = NOENSEMBLE
      endif
!
!     Allocate the arrays we need
      allocate( temp_in(NLONS, NLATS, NLVLS) )   ! for arrays
      allocate(lats(nlats),lons(nlons))
      if(debug_output)write(63,*)'step 600'
!
!     We make it fully flexible, but we know that in the netCDF file the variable
!     temperature is a 4D array. As we use it per time step, the dimension in the
!     program needs to be 3 only.
!
      call check( nf90_inq_varid( ncid, TEMP_NAME, temp_varid) )
      if(debug_output)write(63,*)'TEMP_NAME =',TEMP_NAME
      call check( nf90_inquire_variable( ncid, temp_varid, ndims=ndims ) )
      allocate( count(ndims), start(ndims) )
      if(debug_output)write(63,*)'step 700'

!     insert code for finding the array dimensions
      ! Read the latitude and longitude data.
      call check( nf90_get_var(ncid, lat_varid, lats) )
      call check( nf90_get_var(ncid, lon_varid, lons) )
      if(debug_output)write(63,*)'step 1100'

!      Get the varids of the temperature netCDF variables.
       call check( nf90_inq_varid(ncid, TEMP_NAME, temp_varid) )
       if(debug_output)write(63,*)'step 1200'
!
       start = (/ 1, 1, 1, 1 /)
       if(debug_output)write(63,*)'start',start
       if(debug_output)write(63,*)'nrecs',nrecs
       if(debug_output)write(63,*)'step 1300'

       if(debug_output)write(63,*)'ncid, time_id, time, start',ncid, time_id, time, start
       call check( nf90_inq_varid(ncid, TIME_id_NAME, time_id) )
       if(debug_output)write(63,*)'TIME_id_NAME :',TIME_id_NAME
       if(debug_output)write(63,*)'time_id',time_id
      !  get time:
       call check( nf90_get_var(ncid, time_id, time) )
       
       if(debug_output)write(63,*)'time: ',time
       if(debug_output)write(63,*)'step 1400'

       allocate(times(nrecs))
       do I = 1, nrecs
            call check( nf90_get_var(ncid, time_id, times ,start = start ) )
       enddo
       if(debug_output)write(63,*)(times(i),i=1,nrecs)
       if(debug_output)write(63,*)'step 1500'

       deltaT2=(times(2)-times(1))/60
       epoch_min_start=times(1)-360

       write(98,*)'Info: Start time info in precip.nc:'
       write(98,*)'Info: deltaT_swe =',deltaT2,' hours'
       if(debug_output)write(63,*)'deltaT2 =',deltaT2
! time of the first frame in seconds from Jan. 1/1970 -0600
! FEWS time is at the end of 6hr deltaT
       isecnds=time*60                          !-6*60     ! time of the first frame in seconds from Jan. 1/1970 -0600
!      Get the date & time
      !******************************************
       call PXFLOCALTIME (isecnds, iatime, ierror)
      !******************************************
       if(debug_output)write(63,*)isecnds,iatime,ierror
!     Convert epoch time to yyyymmdd hhmmss 
!     isecnds - input integer with # of seconds since jan 1, 1970 
!     iatime - output array returning the following: 
!        1 - seconds (0 - 61, for leap seconds) 
!        2 - minutes (0 - 59) 
!        3 - hours (0 - 23) 
!        4 - day of the month (1 - 31) 
!        5 - month of the year (1 - 12) 
!        6 - Gregorian year (e.g., 2006) 
!        7 - Day of the week (0 = sunday) 
!        8 - Day of the year (1 - 366) 
!        9 - DST flag (0 = standard, 1 = DST) 
!     ierror - Returns 0 if successful, EINVAL if not.       
       if(debug_output)write(63,6000)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
       write(98,6000)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
       write(*,6000)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
6000   format(' Info: In read swe first frame time stamp        ',i4,'/',i2.2,'/',i2.2,'   ',i2.2,':',i2.2,'  Julian day ',i3)
       
      ! Read 1 record of NLONS*NLATS*NLVLS values, starting at the beginning
      ! of the record (the (1, 1, 1, rec) element in the netCDF file).
!       count(1:4) = (/ NLONS, NLATS, NLVLS, 1 /)            ! for arrays
        count = (/ NLONS, NLATS, NLVLS, 1 /)            ! for arrays
        start(1:4) = (/ 1, 1, 1, 1 /)

!       Only exact grid matching in FEWS!!!
!        iyoffset=0
!        jxoffset=0
!        xcount2=nlons
!        ycount2=nlats
!        nhtemp=nrecs*deltaT2  
      allocate(ratio2(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0)then
         print*,'Error with allocation of ratio2 in read_swe_2D_nc.f @ 63'
         STOP 'Program aborted  @ 595'
      endif
        
        firstpass=.false.
        write(63,*)'End first pass read_2D_swe_nc- initialization completed'

      if(debug_output)write(63,*)'step 1600 - end first pass'

  end if  !    end firstpass    end firstpass    end firstpass    end firstpass

  if(done)return
  if(debug_output)write(63,*)'step 1700'

!  Get the time of the swe update frame:  
       isecnds=time*60+m*deltaT2*3600                          
!      Get the date & time
      !******************************************
       call PXFLOCALTIME (isecnds, iatime, ierror)
      !******************************************
       if(debug_output)write(63,*)'swe update time',isecnds,iatime,ierror
       if(debug_output)write(63,6000)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
       write(98,6001)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
       write(*,6001)iatime(6),iatime(5),iatime(4),iatime(3),iatime(2),iatime(8)
6001   format(' Info: In read swe update frame time stamp       ',i4,'/',i2.2,'/',i2.2,'   ',i2.2,':',i2.2,'  Julian day ',i3)
  
  if ( ensemble_index > number_members .and. number_members /= NOENSEMBLE ) then
    write(98,*)'Error: Ensemble member does not exist - number of members is ', number_members
    write(98,*)'Error: program aborted in read_2D_swe_nc @ 278' 
    stop 'Error: program aborted in read_2D_swe_nc @ 278' 
  endif

! If there is an ensemble, the member index is the third dimension and the time
! the fourth. If there is NO ensemble, the time is the third.
  if ( ensemble_index /= NOENSEMBLE ) then
      start(3) = ensemble_index
      start(4) = m
  else
      start(3) = m      ! m = frame number
      start(4) = 1
  endif
  if(debug_output)write(63,*)'step 1800'
  
  
  
! Read the swe data from the file, one record at a time.
! Read the swe data from the file, one record at a time.
! Read the swe data from the file, one record at a time.
! Read the swe data from the file, one record at a time.
! Read the swe data from the file, one record at a time.
!  if(mod(k+deltaT2-1,deltaT2).eq.0)then
!   *********************************************************************  
    call check( nf90_get_var(ncid, temp_varid, temp_in, start = start, &
                                        count = count) )
!   *********************************************************************  
    if(debug_output)write(63,99001)temp_in(jpr,ipr,1),m
99001 format(' Info:  SW corner swe ',f8.2,i10)

    
    do i=1,ycount   ! allows a good check
            write(400,*)(temp_in(j,i,1),j=1,5)
    end do
    write(666,*)
  if(debug_output)write(63,*)'step 2000'
  
  
      
!   Put into local array
    do i = 1, NLATS
        do j=1,NLONS
             snw(i,j)=temp_in(j, i, 1)
        end do
    end do
    if(debug_output)write(63,*)'frame ',m,'  nrecs = ',nrecs,'swe ',snw(ipr,jpr)
    if(debug_output)write(63,*)'*** SUCCESS reading file ', FILE_NAME(1:20),'@ frame ',m
    write(98,*)'Info: swe from nc file in grid #',nnprint,' = ',snw(ipr,jpr)
!  endif
  if(debug_output)write(63,*)'step 2100'

!     rev. 10.3.07 Mar.  04/20  = NK Fixed weighted swe in wfo file for grids with water
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating
!     Start by finding the weighted swe for each grid   
  do n=1,naa
       totsnw(n)=0.0
       class_sum=0.0
       do ii=1,classcount
          if(aclass(n,ii).gt.0.0)then
             if(ii.ne.ii_water)then
               class_sum=class_sum+aclass(n,ii)
               totsnw(n)=totsnw(n)+snowc(n,ii)*aclass(n,ii)*sca(n,ii)
             endif
          endif
       end do
       totsnw(n)=totsnw(n)/class_sum
  end do     
    write(98,*)'Info: model se in grid #',nnprint,' = ',totsnw(nnprint)
  if(debug_output)write(63,*)'step 1900'
    
!     rev. 10.3.09 Mar.  07/20  = NK Revise swe updating to maintain relative swe in classes
!     Find the ratio of obs swe / weighted model swe
  do n=1,naa
        i=yyy(n)
        j=xxx(n)
          if(snw(i,j).gt.1.0)then
!              If there is not much snow, ratio is too erratic   
!              and just use the snow course data                  
               ratio2(i,j)=snw(i,j)/totsnw(n)
          else
               ratio2(i,j)=1.0000
          endif
          if(i.eq.ipr.and.j.eq.jpr)write(666,*)id,totaltime,snw(i,j),totsnw(n),&
                                      ratio2(ycount/2,xcount/2)
  end do
    write(98,*)'Info: ratio fews/model in grid #',nnprint,' = ',ratio2(ipr,jpr)
  if(debug_output)write(63,*)'step 2200'
      
!   Adjust and put INTO VECTOR FORMAT
  do ii=1,classcount
      do n=1,naa
         if(aclass(n,ii).gt.0.0)then
            i=yyy(n)
            j=xxx(n)
!             Old way: swe in all classes replaced by swe from the r2c file              
!			snowc(n,ii)=max(0.0,snw(i,j))
            if(debug_output.and.n.eq.nnprint)print*,n,ii,snowc(n,ii),aclass(n,ii),ratio2(i,j)              
!     rev. 10.3.09 Mar.  07/20  = NK Revise swe updating to maintain relative swe in classes
!             Multiply by the ratio so relative swe in classes stay the same
!             if(snowc(n,ii).gt.10)then
                 snowc(n,ii)=snowc(n,ii)*ratio2(i,j)
!             else
!                 snowc(n,ii)=snw(i,j)
!             endif
            if(snowc(n,ii).gt.0.0)then
                sca(n,ii)=1.0
                oldsca(n,ii)=1.0
!				set the initial heat deficit for the snow:
!				def(n,ii)=deffactor*snowc(n,ii)               ! <<<< needs to be defined
            else
!     May 10, 2002 Added these lines to avoid underflows later! AB
                sca(n,ii)=0.0
                oldsca(n,ii)=0.0
                def(n,ii)=0.0
            endif
            if(debug_output.and.n.eq.nnprint)print*,n,ii,snowc(n,ii)              
            if(debug_output.and.n.eq.nnprint)print*
      if(n.eq.nnprint)write(98,*)'Info: adjusted swe in grid - class #',nnprint,ii,' = ',snowc(n,ii)
         endif
      end do
  end do

  if(debug_output)write(63,*)'step 2300'
  if(debug_output)write(63,*)'******************************************'
  if(debug_output)write(63,*)'******************************************'
  if(debug_output)write(63,*)'******************************************'
  if(debug_output)write(63,*)'******************************************'
    
  if(m.eq.NRECS)then
!       Close the file.
        call check( nf90_close(ncid) )
        write(98,*)'Info: Closed ',fln(fn)(1:40)
        done=.true.
        return                           ! as part of WF    <<<<<<<<<<<<<<<<<<<<<<<<
  endif
  return

contains
  subroutine check(status)
    integer, intent ( in) :: status

    if(status /= nf90_noerr) then
      write(98,*)'Error: ', trim(nf90_strerror(status))
      write(98,*)'Error: Progran aborted in read_swe_2D_nc'
      write(98,*)'Error: with ',fln(fn)
      write(*,*)'Error: ', trim(nf90_strerror(status))
      write(*,*)'Error: Progran aborted in read_swe_2D_nc'
      write(*,*)'Error: with ',fln(fn)
      stop 
    end if
  end subroutine check

end subroutine read_swe_2D_nc

      SUBROUTINE read_divert(unitNum,flnNum)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
     
!*****************************************************************************
!  read_divert_ef - written Jan/09 by Nick Kouwen, UW
!     - Derived from rdresv written by Dave Watson CHC
!     This subroutine reads the diversion (div) file 
!     (tb0 format)
!*****************************************************************************

!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.81  Jan.  05/11  - NK: allow reservoirs outside watershed in resv file
!     rev. 9.7.24  Apr.  20/11  - NK: Added diverflg to indicate if a diversion is in grid
!******************
      use area_watflood

! TB0 data module
      USE EF_Module

      implicit none
      TYPE(DivParam) :: header
      TYPE(DivColumnMetaData) :: colHeader

      Integer  :: ios,j,k,i,n,l,jz,jj,ng,nt
      integer  :: nodivert_firstpass,ndiv_max,
     *            iAllocate,iDeallocate,
     *            ntake,ngive
      real*4   :: factor

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      LOGICAL exists,diversion_local
      CHARACTER(1)  :: firstpass
      

      data firstpass/'y'/

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

! Parameter type definitions
      integer*4 unitNum, flnNum, iStat

! Local variables
      character*4096 line, subString, tmpString
      character*128 keyword, value 
      character*12  outlet_type
      integer lineLen, keyLen, wordCount
      logical rStat, lineType, foundEndHeader, insideColMetaData

! Open the file
      INQUIRE(FILE=fln(flnNum),EXIST=exists)
      if(exists)then
            open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	      if(iopt.ge.1)print*,'opened unit=',unitNum,fln(flnNum)(1:40)
            if(ios.ne.0)then
                  print*,'Problems opening ',fln(flnNum)
                  print*
                  STOP ' Stopped in read_divert_ef'
            endif
        nodivert=1   ! assume there is at least one diversion if there is a file
      else
        if(numa.eq.0)then
          print*,'WARNING:'
          print*,'Diversion (div) file ',fln(flnNum)(1:40)
          print*,'is NOT found'
          print*,'Program continues with no diversions'
          print*
        endif
        nodivert=0
        ndiv=0
      endif

d      if(iopt.eq.2)print*,'in read_divert_ef passed 70'
cd      if(iopt.eq.2)pause 'in read_divert @ 70'


      if(nodivert.ge.1)then


! Initialize default values
        CALL InitDivParam(header)   

d       if(iopt.ge.2)print*,'in read_divert_ef passed 76'
cd       if(iopt.ge.2)pause 'passed 76'

! Search for and read tb0 file header
        line(1:1) = '#'
        foundEndHeader = .false.
        insideColMetaData = .false.

        do WHILE((.NOT.foundEndHeader) .AND.
     &        ((line(1:1) .eq. '#') .OR.
     &          (line(1:1) .eq. ':') .OR.
     &          (LEN_TRIM(line) .eq. 0)))     

          read(UNIT=unitNum, FMT='((A))', iostat=ios) line      ! read a line
c      print*,line(1:72)
          if(ios .eq. -1)then
             write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
             STOP ' Stopped in read_divert_ef'
          end if

          rStat = Detab(line)                       ! replace tabs with spaces
          line = ADJUSTL(line)          ! Get rid of leading white space
          lineLen = LEN_TRIM(line)            ! Find the length excluding trailing spaces

          if(line(1:1) .eq. ':')then
             wordCount = SplitLine(line, keyword, subString) ! find the keyword
             rStat = ToLowerCase(keyword)
             KeyLen = LEN_TRIM(keyword)

             if(keyword(1:KeyLen) .eq. ':endheader')then
                   foundEndHeader = .TRUE.

             else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
                   insideColMetaData = .TRUE.
             else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
                   insideColMetaData = .FALSE.

!             this is not needed I think as there are no coefficients
             else if(insideColMetaData) then
                iStat = ParseDivColumnMetaData
     &                      (colHeader,keyword,keyLen,subString)
                if(iStat .lt. 0) then
                   write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                   write(*,'(2(A))') '   in line: ',line                             
                   STOP ' Stopped in read_divert_ef'
                   return
                endif
             else
                iStat = ParseDivParam(header,keyword,keyLen,subString)
                if(iStat .lt. 0) then
                      write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                      write(*,'(2(A))') '   in line: ',line                             
                      STOP ' Stopped in read_divert_ef'
                      return
                else if(iStat .eq. 0) then
!                     write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &                                                   line
                endif
             end if
          end if
        end do    
!***************************************
!       Finished reading the header
!***************************************

d      if(iopt.ge.2)print*,'in read_divert_ef passed 132'
cd      if(iopt.ge.2)pause 'passed 132'


! Assign the variables from the types
        ktr =  header%tb0p%deltaT    !data time step in hours
!     rev. 9.8.54  Apr.  02/13  - NK: deltat conversion seconds to hours
!       In the past, deltat has bee in hours but GK wants them in seconds
!       This converts deltat to hours as needed in spl if a large deltat is found        
        if(ktr.gt.1000)then
          ktr=ktr/3600
        endif
        factor = header%tb0p%unitConv ! conversion to cms
        nodivert = colHeader%tb0cmd%colCount !no of reservoirs

!     ndiv    =     no of hours of data
! Scan lines of data
        rewind unitNum

!        added *ktr     Nov. 27/06  nk
        ndiv = CountDataLinesAfterHeader(unitNum)*ktr
        rewind unitNum
        CALL GoToStartOfData(unitNum)

      endif

!       allocate stuff      
      if(firstpass.eq.'y')then
        nodivert_firstpass=nodivert
        diversion_local=.true.
!       nl comes from the .str file and is the # hour of the event

c        ndiv_max=max0(ndiv,nl)
        if(ndiv.gt.nl)then
          print*,'div file longer than the str file'
          print*,'data past ',nl,' hours ignored'
        endif

!       but we need to provide enough memory to simulate a whole event
!       sometimes users specify the duration in the rel to be just 1 hr.
!       when a rule is given. However, we need memory of all the variables
        if(nodivert.gt.0)then
          allocate(divertname(nodivert),
     *    xtake(nodivert),ytake(nodivert),
     *    xgive(nodivert),ygive(nodivert),
     *    jtake(nodivert),itake(nodivert),
     *    jgive(nodivert),igive(nodivert),
     *    gridtake(nodivert),gridgive(nodivert),
     *    qdivert(nodivert,ndiv*ktr),
     *    divert_inbasin_flg(nodivert),
     *    upstrda(nodivert),stat=iAllocate)

          if(iAllocate.ne.0)then
            print*,'Error with allocation in read_divert_ef @172'
            print*,'firstpass =',firstpass
            STOP 'Program aborted in read_divert @ 198'
          endif
!         initialize upstrda
          do l=1,nodivert
            upstrda(l)=0.0
          end do
                    
        endif
!     rev. 9.9.43  Nov.  26/14  - NK: Allocation for divertflg = 'g' 
        if(divertflg.eq.'g')return   ! ' only here to allocate




!       ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
!       this is done only during the first pass if coefficient values 
!       are set to -1 for subsequent events. This makes tweaking easy
!       as only the values in the first event need to be adjusted.
        do n=1,nodivert
          divertname(n) = colHeader%tb0cmd%colName(n) ! diversion name
          xtake(n) = colHeader%tb0cmd%colLocX(n) ! x coordinate
          ytake(n) = colHeader%tb0cmd%colLocY(n) ! y coordinate
          xgive(n) = colHeader%tb0cmd%colLocX1(n) ! x coordinate
          ygive(n) = colHeader%tb0cmd%colLocY1(n) ! y coordinate
!     rev. 9.9.55  Jan.  22/15  - NK: Added diversion upstream drainage area in div file
          if(allocated(colHeader%colValue1))then
!           means upstream drainage area is present          
            upstrda(n) = colHeader%colValue1(n)     ! upstream drainage area
          else
            upstrda(n)=0.0
            print*,
     *          'Warning: upstream drainage area at diversion not found'
          endif
    
!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
!     check to see if diversion locations are in the watershed
!     first see if it is in the grid
          if(xtake(n).lt.xorigin.or.
     *       xtake(n).gt.xorigin+xcount*xdelta.or.
     *       ytake(n).lt.yorigin.or.
     *       ytake(n).gt.yorigin+ycount*ydelta)then
            print*
            print*,'WARNING:'
            print*,'Diversion origin and/or destination'
            print*,'not in watershed'
            print*,'Diversion ',n,' is ignored'
            print*
            write(51,*)'WARNING:'
            write(51,*)'diversion origin and/or destination'
            write(51,*)'not in watershed'
            write(51,*)'diversion ',n,' is ignored'
          endif

!     rev. 9.9.41  Nov.  20/14  - NK: Added check if diversion = in-basin
          write(51,*) 
          write(51,*)'Check if diversion locations are in the grid'
          write(51,*)'There are ',na,' grids' 
          write(51,*)
	    divert_inbasin_flg(n)=.false.
          i=int((ytake(n)-yorigin)/ydelta)+1
	    j=int((xtake(n)-xorigin)/xdelta)+1
	    write(51,*)'i,ycount,j,xcount',i,ycount,j,xcount
		  if(i.ge.1.and.i.le.ycount.and.j.ge.1.and.j.le.xcount)then
      	    if(s(i,j).ge.1.and.s(i,j).le.na)then
              gridtake(n)=s(i,j)
              write(51,*)'gridtake,n,i,j',gridtake(n),n,i,j,s(i,j)
            else
              gridtake(n)=-1
            endif
          else
            gridtake(n)=-1  
          endif
c          gridtake(n)=s(i,j)
          i=int((ygive(n)-yorigin)/ydelta)+1
          j=int((xgive(n)-xorigin)/xdelta)+1
	    if(i.ge.1.and.i.le.ycount.and.j.ge.1.and.j.le.xcount)then
      	    if(s(i,j).ge.1.and.s(i,j).le.naa)then
              gridgive(n)=s(i,j)
            else
              gridgive(n)=-1
            endif
          else
            gridgive(n)=-1  
          endif
          if(gridtake(n).ge.1.and.gridgive(n).ge.1)then
            divert_inbasin_flg(n)=.true.
          endif
         write(51,*)n,divert_inbasin_flg(n)
         write(51,*)xgive(n),ygive(n),n,'gridgive,x,y,n'
         write(51,*)
         write(51,*)
      end do

      
!     rev. 9.9.55  Jan.  22/15  - NK: Added diversion upstream drainage area in div file
!     REV. 10.1.40 Oct   11/16  - NK: Fixed bug in read_divert for missing u/s DA
        do l=1,nodivert
          n=gridgive(l)
d         print*,'source grid =',l,' in grid # ',n          
!         add the u/s area to the grid receiving the diversion
          if(n.ge.1)then
d            print*,n,da(n),upstrda(l),da(n)+upstrda(l)
            da(n)=da(n)+upstrda(l)
          endif
d          print*,'naa=',naa,'  in read_divert @ 309'
          i=0
!     rev. 10.2.19 Mar.  13/18  - NK: Fixed array fault read_divert.f
c          do while(n.lt.naa.and.n.gt.1)
          if(n.lt.naa.and.n.gt.1)then
            if(next(n).ge.1)then
              da(next(n))=da(next(n))+upstrda(l)
d              print*,n,next(n),da(next(n))
              n=next(n)
            endif
          endif
c          end do
c          do i=1,naa
c            if(next(n).ge.1)then
c              da(next(n))=da(next(n))+upstrda(l)
cd              print*,l,n,next(n),da(next(n))
c              n=next(n)
c            endif
c          end do
        end do
      
        firstpass='n'

      endif      !   firstpass
      
d      if(iopt.ge.2)print*,'End first pass in read_divert'
cd      if(iopt.ge.2)pause 'at 320'
      
!     rev. 10.1.85 May   17/17  - NK: Level_station_location.xyx for iopt > 0 only
!     rev. 10.1.86 May   17/17  - NK: Diversion_location.xyx for iopt > 0 only
      if(iopt99)then
      open(unit=99,file='diversion_location.xyz',status='unknown')
        do n=1,nodivert
          write(99,*)xtake(n),ytake(n),n
          write(99,*)xgive(n),ygive(n),n
        end do
        close(unit=99,status='keep')
      endif

c	if(nodivert_firstpass.eq.0)return
	if(.not.diversion_local)then
!       rule: if no diversion in the first event, then not later either
	  diversion=.false.
	  print*,'WARNING  <<<<<<<<<<<<<<<<<<<<'
	  print*,'A diversion file was found but the data can not be used'
	  print*,'for some reason'
	  print*,'Possible problem: locations not in watershed grids'
	  print*,'Program continues without diversion flows'
	  print*
	  return
	endif

!     subsequent passes
!     check to see memory allocated is adequate      
d      if(iopt.eq.2)print*,'In read_divert_ef @ 258'
      if(nodivert.ne.nodivert_firstpass)then
	  print*
        print*,'No of diversions has been changed in'
        print*,'in file ',fln(7)
        print*,'This is not permitted'
        print*
        stop 'Program aborted in read_divert @ 264'
      endif
d      if(iopt.eq.2)print*,'In read_divert_ef @ 266'

      if(nl.gt.ndiv_max)then
        ndiv_max=max0(ndiv,nl)
!       the event is longer than any of the previous events so 
!       more memory has to be allocated
!       DEALLOCATION OF ARRAYS FROM AREA10A:

d       if(iopt.eq.2)print*,'in read_divert_ef @ 213'

!       DEALLOCATION OF ARRAYS FROM AREA5A:
        deallocate(qdivert,stat=iDeallocate)     
        if (iDeallocate.ne.0) print*,    
     *    'Error with deallocation of area5a arrays'

!       re-allocate for larger arrays
        allocate(qdivert(nodivert,ndiv_max*ktr),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *   'Error with allocation of area10a arrays in read_divert'
!     rev. 9.5.23  Mar.  12/08  - NK: fixed allocation error in read_divert_ef
          endif

!       REASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
!       This part is used only if coefficient values area >0
!       Used if values change over time & need to be reassigned.
        do i=1,nodivert
          divertname(i) = colHeader%tb0cmd%colName(i) ! reservoir name
          xtake(i) = colHeader%tb0cmd%colLocX(i) ! x coordinate
          ytake(i) = colHeader%tb0cmd%colLocY(i) ! y coordinate
          xgive(i) = colHeader%tb0cmd%colLocX1(i) ! x coordinate
          ygive(i) = colHeader%tb0cmd%colLocY1(i) ! y coordinate
        end do

!       rev. 9.1.69  Dec.  19/04  - NK: rewrote rdresv c/w memory allocation 

d      if(iopt.eq.2)print*,'In read_divert_ef @ 295'

      if(nodivert.eq.0)return   !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----

      deallocate(colHeader%tb0cmd%colName)
      deallocate(colHeader%tb0cmd%colLocX)
      deallocate(colHeader%tb0cmd%colLocY)
      deallocate(colHeader%tb0cmd%colLocX1)
      deallocate(colHeader%tb0cmd%colLocY1)

d      if(iopt.eq.2)print*,'in read_divert_ef passed 274'


      if(nodivert.gt.0)then
!       FIND THE LOCAL COORDINATES FOR THE RESERVOIRS
!       THE VALUES FOR idiv AND jdiv ARE CHANGED

        do i=1,nodivert
!         convert to local coordinate unit system for new .res file
          jtake(i)=int((xtake(i)-xorigin)/xdelta)+1
          itake(i)=int((ytake(i)-yorigin)/ydelta)+1
          jgive(i)=int((xgive(i)-xorigin)/xdelta)+1
          igive(i)=int((ygive(i)-yorigin)/ydelta)+1
        end do
        if(iopt.ge.1)then
          write(53,*)
          write(53,*)'In read_divert_ef:'
          write(53,*)'Note: set iopt = 0 to not write this.'
          write(53,1011)
          write(53,1013)(i,itake(i),jtake(i),
     *           igive(i),jgive(i),divertname(i),i=1,nodivert)
        endif

!       THE ORDER OF READING THE COORDINATES OF THE RESERVOIRS
!       MUST BE THE SAME AS READING THE CORRESPONDING FLOWS
!       IN S/R REROUT.
!       READ RELEASES
!       THE RESERVOIR OUTFLOWS ARE ALL READ IN THE FIRST TIME
!       REROUT IS CALLED. THEY ARE THEN STORED AND USED EACH TIME
!       REROUT IS CALLED.
!       IF NATURAL CONTROL, FLOWS ARE SET TO -1.0 ABOVE

!       initialize releases
        do k=1,nodivert
          do j=1,ndiv
            qdivert(k,j)=-1.0
          end do
        end do
        
c!     rev. 9.7.24  Apr.  20/11  - NK: Added diverflg to indicate if a diversion is in grid
c!       set flags
c!       diverflg is initialized in read_shed_ef
c        do i=1,nodivert
c          ng=s(igive(i),jgive(i))
c          nt=s(itake(i),jtake(i))   
c          if(ng.eq.0.or.nt.eq.0)then     ! added Jan. 10/11 nk
c            if(ng.eq.0)then
c              print*,'WARNING:'
c              print*,'Diversion #',i,'receiving grid'
c              print*,'is not in the watershed.'
c              print*,'row=',igive(i),' column=',jgive(i)
cc              pause 'hit enter to continue & check others'
c            endif
c            if(nt.eq.0)then
c              print*,'WARNING:'
c              print*,'Diversion #',i,'source grid'
c              print*,'is not in the watershed.'
c              print*,'row=',itake(i),' column=',jtake(i)
cc              pause 'hit enter to continue & check others'
c            endif
c          else    
c            diverflg(ng)=.true.
c          endif
c        end do
            
c        if(b1(1).eq.0.0)then
        if(ndiv.gt.0)then
!         case with reservoir releases
!         do j=ktr,ndiv,ktr

!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
          do j=ktr,ndiv,ktr

c	print*,ktr,ndiv,ktr

            read(unitNum,*,iostat=ios)(qdivert(k,j),k=1,nodivert)
d            if(iopt.eq.2)print*,j,(qdivert(k,j),k=1,nodivert)
              if(ios.ne.0)then
                write(98,*)' Error on unit=',unitNum,' fln=',
     *                                     fln(flnNum)
                write(98,*)' Trying to read diversions hour =',j
                print*,' Error on unit=',unitNum,' fln=',fln(flnNum)
                print*,' Trying to read diversions'
                print*,' ios= ',ios
                if(ios.eq.-1)then
                  write(98,*)'End of file in fln= ',fln(flnNum)
                  write(98,*)
     *                 'Possibly last line does not have a return'
                  print*,'End of file in fln= ',fln(flnNum)
                  print*,'Possibly last line does not have a return'
                  print*
                else
                  print*
                  STOP ' program aborted in read_divert_ef.for'
                endif
              endif
!     rev. 9.5.24  Mar.  18/08  - NK: fixed missing data in read_resl_ef.f
!             fill in the gaps to hourly data
              if(ktr.gt.1)then
                do k=1,nodivert
	              do jj=ktr-1,1,-1
                      qdivert(k,j-jj)=qdivert(k,j)
c	print*,j,jj,j-jj,qdivert(k,j-jj)
	              end do
                end do
              endif

!             fill in missing data (-ve data)
              do k=1,nodivert
!     rev. 9.5.29  May.  26/08  - NK: fixed initialization in read_divert_ef
                if(qdivert(k,ktr).lt.0.0)then
                  print*
                  print*,'WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'
                  print*,'first diversion flow should not be < 0.0'
                  print*,'diversions set to 0.0 until +ve value found'
                  qdivert(k,ktr)=0.0
                endif
!     rev. 9.5.29  May.  26/08  - NK: fixed initialization in read_divert_ef
                if(qdivert(k,j).lt.0.0)then
                  do jj=j,j+ktr-1
                    qdivert(k,jj)=qdivert(k,jj-1)
                  end do
                endif
              end do
            end do
          endif     !  if(ndiv.gt.0)


      endif !         if(nodivert.gt.0)

d     if(iopt.eq.2)print*,'in read_divert_ef passed 187'

!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

 
      istep=al/1000
c     if(iopt.eq.2)print*,'in read_divert_ef passed 272'

      if(nodivert.gt.0)then                             !999999999999999
!       FIND THE LOCAL COORDINATES FOR THE RESERVOIRS
!       THE VALUES FOR idiv AND jdiv ARE CHANGED

!       THE ORDER OF READING THE COORDINATES OF THE RESERVOIRS
!       MUST BE THE SAME AS READING THE CORRESPONDING FLOWS
!       IN S/R rdresv.

!       READ RELEASES
!       THE RESERVOIR OUTFLOWS ARE ALL READ IN THE FIRST TIME
!       rdresv IS CALLED. THEY ARE THEN STORED AND USED EACH TIME
!       rdresv IS CALLED.

!       IF NATURAL CONTROL, FLOWS ARE SET TO -1.0 ABOVE
d       if(iopt.eq.2)print*,'in read_divert_ef passed 304'

      endif           !   if(nodivert.gt.0)

d     if(iopt.eq.2)print*,'in read_divert_ef passed 551'

!     WE CAN'T HAVE -VE flows WHEN WE START
      do k=1,nodivert
        if(qdivert(k,1).lt.0.0)qdivert(k,ktr)=0.001
      end do

!     SET FUTURE RELEASES = LAST NON-NEGATIVE RELEASE
!     REALLY, WE'RE WORKING IN HOURLY INTERVALS ALTHOUGH THE      
!     RELEASES MAY BE READ IN ONLY WHEN THE RES OUTFLOW IS CHANGED.

!     rev. 9.5.14  Feb.  26/08  - NK: padded rel file for missing data
!     fill in missing data if rel file is shorter than the str file
!     nl is the length in nrs of the str file
!     ndiv is the length of the rel file
!     added Feb. 26/08  -nk-

      if(ndiv.gt.0)then
!       fill data at end of file only if there are values
        if(ndiv.lt.nl)then
          do j=ndiv+1,nl
            do k=1,nodivert
              qdivert(k,j)=qdivert(k,j-1)
            end do
          end do
          
          print*
          print*,'WARNING:'
          print*,'reservoir release file is shorter than the str file'
          print*,'missing data has been set = to last recorder release'
          print*
          do j=2,nl
            do k=1,nodivert
              if(qdivert(k,j).lt.0.0)qdivert(k,j)=qdivert(k,j-1)
            end do
          end do
        endif
      endif                        

      close(unit=unitNum,status='keep')

      firstpass='n'

  999 RETURN                 !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----

! FORMATS

  500 format(256f10.3)
 1011 format(' ',3x,'  i  idiv(i) jdiv(i)    b1(i)     b2(i)',
     *      '    b3(i)     b4(i)')
 1013 format(' ',3x,i3,4i8,a12/)
 6801 format('   read_divert_ef: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',i5,256f8.2)

      END SUBROUTINE read_divert

      SUBROUTINE read_divert(unitNum,flnNum)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
     
!*****************************************************************************
!  read_divert_ef - written Jan/09 by Nick Kouwen, UW
!     - Derived from rdresv written by Dave Watson CHC
!     This subroutine reads the diversion (div) file 
!     (tb0 format)
!*****************************************************************************

!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.81  Jan.  05/11  - NK: allow reservoirs outside watershed in resv file
!     rev. 9.7.24  Apr.  20/11  - NK: Added diverflg to indicate if a diversion is in grid
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
!******************
      use area_watflood

! TB0 data module
      USE EF_Module

      implicit none
      TYPE(DivParam) :: header
      TYPE(DivColumnMetaData) :: colHeader

      Integer  :: ios,j,k,i,n,l,jz,jj,ng,nt
      integer  :: nodivert_firstpass,ndiv_max,iAllocate,iDeallocate,ntake,ngive
      real*4   :: factor

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      LOGICAL exists,diversion_local
      CHARACTER(1)  :: firstpass
      

      data firstpass/'y'/

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

! Parameter type definitions
      integer*4 unitNum, flnNum, iStat

! Local variables
      character*4096 line, subString, tmpString
      character*128 keyword, value 
      character*12  outlet_type
      integer lineLen, keyLen, wordCount
      logical rStat, lineType, foundEndHeader, insideColMetaData

      if(FLtype(flnNum).eq.'tb0')then
          ! Open the file
          INQUIRE(FILE=fln(flnNum),EXIST=exists)
          if(exists)then
                open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	          if(iopt.ge.1)print*,'opened unit=',unitNum,fln(flnNum)(1:40)
                if(ios.ne.0)then
                      print*,'Problems opening ',fln(flnNum)
                      print*
                      STOP ' Stopped in read_divert_ef'
                endif
            nodivert=1   ! assume there is at least one diversion if there is a file
          else
            if(numa.eq.0)then
              print*,'WARNING:'
              print*,'Diversion (div) file ',fln(flnNum)(1:40)
              print*,'is NOT found'
              print*,'Program continues with no diversions'
              print*
            endif
            nodivert=0
            ndiv=0
          endif

    !d      if(iopt.eq.2)print*,'in read_divert_ef passed 70'


          if(nodivert.ge.1)then


    ! Initialize default values
            CALL InitDivParam(header)   

    !d       if(iopt.ge.2)print*,'in read_divert_ef passed 76'

    ! Search for and read tb0 file header
            line(1:1) = '#'
            foundEndHeader = .false.
            insideColMetaData = .false.

            do WHILE((.NOT.foundEndHeader) .AND.((line(1:1) .eq. '#') .OR.(line(1:1) .eq. ':') .OR.(LEN_TRIM(line) .eq. 0)))     

              read(UNIT=unitNum, FMT='((A))', iostat=ios) line      ! read a line
    !c      print*,line(1:72)
              if(ios .eq. -1)then
                 write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
                 STOP ' Stopped in read_divert_ef'
              end if

              rStat = Detab(line)                       ! replace tabs with spaces
              line = ADJUSTL(line)          ! Get rid of leading white space
              lineLen = LEN_TRIM(line)            ! Find the length excluding trailing spaces

              if(line(1:1) .eq. ':')then
                 wordCount = SplitLine(line, keyword, subString) ! find the keyword
                 rStat = ToLowerCase(keyword)
                 KeyLen = LEN_TRIM(keyword)

                 if(keyword(1:KeyLen) .eq. ':endheader')then
                       foundEndHeader = .TRUE.

                 else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
                       insideColMetaData = .TRUE.
                 else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
                       insideColMetaData = .FALSE.

    !             this is not needed I think as there are no coefficients
                 else if(insideColMetaData) then
                    iStat = ParseDivColumnMetaData(colHeader,keyword,keyLen,subString)
                    if(iStat .lt. 0) then
                       write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                       write(*,'(2(A))') '   in line: ',line                             
                       STOP ' Stopped in read_divert_ef'
                       return
                    endif
                 else
                    iStat = ParseDivParam(header,keyword,keyLen,subString)
                    if(iStat .lt. 0) then
                          write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                          write(*,'(2(A))') '   in line: ',line                             
                          STOP ' Stopped in read_divert_ef'
                          return
                    else if(iStat .eq. 0) then
    !                     write(*,'((A), (A))')  'Unrecognized keyword line: ',
    !     &                                                   line
                    endif
                 end if
              end if
            end do    
    !***************************************
    !       Finished reading the header
    !***************************************

    !d      if(iopt.ge.2)print*,'in read_divert_ef passed 132'


    ! Assign the variables from the types
            ktr =  header%tb0p%deltaT    !data time step in hours
    !     rev. 9.8.54  Apr.  02/13  - NK: deltat conversion seconds to hours
    !       In the past, deltat has bee in hours but GK wants them in seconds
    !       This converts deltat to hours as needed in spl if a large deltat is found        
            if(ktr.gt.1000)then
              ktr=ktr/3600
            endif
            factor = header%tb0p%unitConv ! conversion to cms
            nodivert = colHeader%tb0cmd%colCount !no of reservoirs

    !     ndiv    =     no of hours of data
    ! Scan lines of data
            rewind unitNum

    !        added *ktr     Nov. 27/06  nk
            ndiv = CountDataLinesAfterHeader(unitNum)*ktr
            rewind unitNum
            CALL GoToStartOfData(unitNum)

          endif

      else    ! FLtype(flnNum).eq.'tb0'
      
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_ts_diversion_nc(flnNum)                                    ! netCDF
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           FILL IN FLOW DATA 
            flowfillflg='y'
      
      endif   ! FLtype(flnNum).eq.'tb0'
      
      
!       allocate stuff      
      if(firstpass.eq.'y')then
        nodivert_firstpass=nodivert
        diversion_local=.true.
!       nl comes from the .str file and is the # hour of the event

        ndiv_max=max0(ndiv,nl)
        if(ndiv.gt.nl)then
          print*,'div file longer than the str file'
          print*,'data past ',nl,' hours ignored'
        endif

!       but we need to provide enough memory to simulate a whole event
!       sometimes users specify the duration in the rel to be just 1 hr.
!       when a rule is given. However, we need memory of all the variables
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
        if(FLtype(flnNum).eq.'tb0')then
            if(nodivert.gt.0)then
              allocate(divertname(nodivert),&
              xtake(nodivert),ytake(nodivert),&
              xgive(nodivert),ygive(nodivert),&
              jtake(nodivert),itake(nodivert),&
              jgive(nodivert),igive(nodivert),&
              gridtake(nodivert),gridgive(nodivert),&
              qdivert(nodivert,ndiv*ktr),&
              divert_inbasin_flg(nodivert),&
              upstrda(nodivert),stat=iAllocate)

              if(iAllocate.ne.0)then
                print*,'Error with allocation in read_divert_ef @172'
                print*,'firstpass =',firstpass
                STOP 'Program aborted in read_divert @ 198'
              endif
    !         initialize upstrda
              do l=1,nodivert
                upstrda(l)=0.0
              end do
                    
            endif
    !     rev. 9.9.43  Nov.  26/14  - NK: Allocation for divertflg = 'g' 
            if(divertflg.eq.'g')return   ! ' only here to allocate

    !       ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
    !       this is done only during the first pass if coefficient values 
    !       are set to -1 for subsequent events. This makes tweaking easy
    !       as only the values in the first event need to be adjusted.
            do n=1,nodivert
              divertname(n) = colHeader%tb0cmd%colName(n) ! diversion name
              xtake(n) = colHeader%tb0cmd%colLocX(n) ! x coordinate
              ytake(n) = colHeader%tb0cmd%colLocY(n) ! y coordinate
              xgive(n) = colHeader%tb0cmd%colLocX1(n) ! x coordinate
              ygive(n) = colHeader%tb0cmd%colLocY1(n) ! y coordinate
    !     rev. 9.9.55  Jan.  22/15  - NK: Added diversion upstream drainage area in div file
              if(allocated(colHeader%colValue1))then
    !           means upstream drainage area is present          
                upstrda(n) = colHeader%colValue1(n)     ! upstream drainage area
              else
                upstrda(n)=0.0
                print*,'Warning: upstream drainage area at diversion not found'
              endif
            end do
        endif   ! FLtype(flnNum).eq.'tb0'
    
!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
!     check to see if diversion locations are in the watershed
!     first see if it is in the grid
        do n=1,nodivert
          if(xtake(n).lt.xorigin.or.&
            xtake(n).gt.xorigin+xcount*xdelta.or.&
            ytake(n).lt.yorigin.or.&
            ytake(n).gt.yorigin+ycount*ydelta)then
            write(98,*)'WARNING: Diversion origin and/or destination not in watershed Diversion ',n,' is ignored'
          endif

!     rev. 9.9.41  Nov.  20/14  - NK: Added check if diversion = in-basin
          write(51,*) 
          write(51,*)'Check if diversion locations are in the grid'
          write(51,*)'There are ',na,' grids' 
          write(51,*)
	      divert_inbasin_flg(n)=.false.
          i=int((ytake(n)-yorigin)/ydelta)+1
	      j=int((xtake(n)-xorigin)/xdelta)+1
          
          if(FLtype(flnNum).eq.'tb0')then
	        write(51,*)'i,ycount,j,xcount',i,ycount,j,xcount
		    if(i.ge.1.and.i.le.ycount.and.j.ge.1.and.j.le.xcount)then
      	      if(s(i,j).ge.1.and.s(i,j).le.na)then
                gridtake(n)=s(i,j)
                write(51,*)'gridtake,n,i,j',gridtake(n),n,i,j,s(i,j)
              else
                gridtake(n)=-1
              endif
            else
              gridtake(n)=-1  
            endif
          else
!            for FEWS - there is no source grid - just take the outlet              
             gridtake(n)=na  
          endif   ! FLtype(flnNum).eq.'tb0'
          
!c          gridtake(n)=s(i,j)
            i=int((ygive(n)-yorigin)/ydelta)+1
            j=int((xgive(n)-xorigin)/xdelta)+1
	        if(i.ge.1.and.i.le.ycount.and.j.ge.1.and.j.le.xcount)then
      	      if(s(i,j).ge.1.and.s(i,j).le.naa)then
                gridgive(n)=s(i,j)
              else
                gridgive(n)=-1
              endif
            else
              gridgive(n)=-1  
            endif
!          endif          ! FLtype(flnNum).eq.'tb0'
          
          print*,'n,gridtake(n),gridgive(n)',n,gridtake(n),gridgive(n)
          
          if(gridtake(n).ge.1.and.gridgive(n).ge.1)then
            divert_inbasin_flg(n)=.true.
          endif
         write(51,*)n,divert_inbasin_flg(n)
         write(*,*)xgive(n),ygive(n),n,'gridgive,x,y,n'
         write(51,*)
         write(51,*)
        end do
        
!     rev. 9.9.55  Jan.  22/15  - NK: Added diversion upstream drainage area in div file
!     REV. 10.1.40 Oct   11/16  - NK: Fixed bug in read_divert for missing u/s DA
        if(FLtype(flnNum).eq.'tb0')then
            do l=1,nodivert
              n=gridgive(l)
    !d         print*,'source grid =',l,' in grid # ',n          
    !         add the u/s area to the grid receiving the diversion
              if(n.ge.1)then
    !d            print*,n,da(n),upstrda(l),da(n)+upstrda(l)
                da(n)=da(n)+upstrda(l)
              endif
    !d          print*,'naa=',naa,'  in read_divert @ 309'
              i=0
    !     rev. 10.2.19 Mar.  13/18  - NK: Fixed array fault read_divert.f
              if(n.lt.naa.and.n.gt.1)then
                if(next(n).ge.1)then
                  da(next(n))=da(next(n))+upstrda(l)
    !d              print*,n,next(n),da(next(n))
                  n=next(n)
                endif
              endif
            end do
        endif   ! FLtype(flnNum).eq.'tb0'
      
        firstpass='n'

      endif      !   firstpass
      
!d      if(iopt.ge.2)print*,'End first pass in read_divert'
      
!     rev. 10.1.85 May   17/17  - NK: Level_station_location.xyx for iopt > 0 only
!     rev. 10.1.86 May   17/17  - NK: Diversion_location.xyx for iopt > 0 only
      if(iopt99)then
        open(unit=99,file='diversion_location.xyz',status='unknown')
        do n=1,nodivert
          write(99,*)xtake(n),ytake(n),n
          write(99,*)xgive(n),ygive(n),n
        end do
        close(unit=99,status='keep')
      endif

	if(.not.diversion_local)then
!       rule: if no diversion in the first event, then not later either
	  diversion=.false.
	  print*,'WARNING  <<<<<<<<<<<<<<<<<<<<'
	  print*,'A diversion file was found but the data can not be used'
	  print*,'for some reason'
	  print*,'Possible problem: locations not in watershed grids'
	  print*,'Program continues without diversion flows'
	  print*
	  return
	endif

    if(FLtype(flnNum).eq.'tb0')then
!     subsequent passes
!     check to see memory allocated is adequate      
!d      if(iopt.eq.2)print*,'In read_divert_ef @ 258'
      if(nodivert.ne.nodivert_firstpass)then
	  print*
        print*,'No of diversions has been changed in'
        print*,'in file ',fln(7)
        print*,'This is not permitted'
        print*
        stop 'Program aborted in read_divert @ 264'
      endif
!d      if(iopt.eq.2)print*,'In read_divert_ef @ 266'
      
      
      
      
      if(nl.gt.ndiv_max)then
        ndiv_max=max0(ndiv,nl)
!       the event is longer than any of the previous events so 
!       more memory has to be allocated
!       DEALLOCATION OF ARRAYS FROM AREA10A:

!d       if(iopt.eq.2)print*,'in read_divert_ef @ 213'

!       DEALLOCATION OF ARRAYS FROM AREA5A:
        deallocate(qdivert,stat=iDeallocate)     
        if (iDeallocate.ne.0) print*,'Error with deallocation of area5a arrays'

!       re-allocate for larger arrays
        allocate(qdivert(nodivert,ndiv_max*ktr),stat=iAllocate)
        if(iAllocate.ne.0) STOP'Error with allocation of area10a arrays in read_divert'
!     rev. 9.5.23  Mar.  12/08  - NK: fixed allocation error in read_divert_ef
        endif

!       REASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
!       This part is used only if coefficient values area >0
!       Used if values change over time & need to be reassigned.
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
        if(FLtype(flnNum).eq.'tb0')then
            do i=1,nodivert
              divertname(i) = colHeader%tb0cmd%colName(i) ! reservoir name
              xtake(i) = colHeader%tb0cmd%colLocX(i) ! x coordinate
              ytake(i) = colHeader%tb0cmd%colLocY(i) ! y coordinate
              xgive(i) = colHeader%tb0cmd%colLocX1(i) ! x coordinate
              ygive(i) = colHeader%tb0cmd%colLocY1(i) ! y coordinate
            end do
        endif

!       rev. 9.1.69  Dec.  19/04  - NK: rewrote rdresv c/w memory allocation 

!d      if(iopt.eq.2)print*,'In read_divert_ef @ 295'
      if(nodivert.eq.0)return   !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
        if(FLtype(flnNum).eq.'tb0')then
          deallocate(colHeader%tb0cmd%colName)
          deallocate(colHeader%tb0cmd%colLocX)
          deallocate(colHeader%tb0cmd%colLocY)
          deallocate(colHeader%tb0cmd%colLocX1)
          deallocate(colHeader%tb0cmd%colLocY1)
        endif
!d      if(iopt.eq.2)print*,'in read_divert_ef passed 274'


      if(nodivert.gt.0)then
!       FIND THE LOCAL COORDINATES FOR THE RESERVOIRS
!       THE VALUES FOR idiv AND jdiv ARE CHANGED

        do i=1,nodivert
!         convert to local coordinate unit system for new .res file
          jtake(i)=int((xtake(i)-xorigin)/xdelta)+1
          itake(i)=int((ytake(i)-yorigin)/ydelta)+1
          jgive(i)=int((xgive(i)-xorigin)/xdelta)+1
          igive(i)=int((ygive(i)-yorigin)/ydelta)+1
        end do
        if(iopt.ge.1)then
          write(53,*)
          write(53,*)'In read_divert_ef:'
          write(53,*)'Note: set iopt = 0 to not write this.'
          write(53,1011)
          write(53,1013)(i,itake(i),jtake(i),igive(i),jgive(i),divertname(i),i=1,nodivert)
        endif
      endif    
    endif               ! FLtype(flnNum).eq.'tb0'

!       THE ORDER OF READING THE COORDINATES OF THE RESERVOIRS
!       MUST BE THE SAME AS READING THE CORRESPONDING FLOWS
!       IN S/R REROUT.
!       READ RELEASES
!       THE RESERVOIR OUTFLOWS ARE ALL READ IN THE FIRST TIME
!       REROUT IS CALLED. THEY ARE THEN STORED AND USED EACH TIME
!       REROUT IS CALLED.
!       IF NATURAL CONTROL, FLOWS ARE SET TO -1.0 ABOVE

!       initialize releases
        if(FLtype(flnNum).eq.'tb0')then
            do k=1,nodivert
              do j=1,ndiv
                qdivert(k,j)=-1.0
              end do
            end do
        endif
        
        if(ndiv.gt.0)then
!         case with reservoir releases
!         do j=ktr,ndiv,ktr

!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
          if(FLtype(flnNum).eq.'tb0')then
              do j=ktr,ndiv,ktr
                read(unitNum,*,iostat=ios)(qdivert(k,j),k=1,nodivert)
    !d            if(iopt.eq.2)print*,j,(qdivert(k,j),k=1,nodivert)
                  if(ios.ne.0)then
                    write(98,*)' Error on unit=',unitNum,' fln=',fln(flnNum)
                    write(98,*)' Trying to read diversions hour =',j
                    print*,' Error on unit=',unitNum,' fln=',fln(flnNum)
                    print*,' Trying to read diversions'
                    print*,' ios= ',ios
                    if(ios.eq.-1)then
                      write(98,*)'End of file in fln= ',fln(flnNum)
                      write(98,*)'Possibly last line does not have a return'
                      print*,'End of file in fln= ',fln(flnNum)
                      print*,'Possibly last line does not have a return'
                      print*
                    else
                      print*
                      STOP ' program aborted in read_divert_ef.for'
                    endif
                  endif
    !     rev. 9.5.24  Mar.  18/08  - NK: fixed missing data in read_resl_ef.f
    !             fill in the gaps to hourly data
                  if(ktr.gt.1)then
                    do k=1,nodivert
	                  do jj=ktr-1,1,-1
                          qdivert(k,j-jj)=qdivert(k,j)
	                  end do
                    end do
                  endif

    !             fill in missing data (-ve data)
                  do k=1,nodivert
    !     rev. 9.5.29  May.  26/08  - NK: fixed initialization in read_divert_ef
                    if(qdivert(k,ktr).lt.0.0)then
                      print*
                      print*,'WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'
                      print*,'first diversion flow should not be < 0.0'
                      print*,'diversions set to 0.0 until +ve value found'
                      qdivert(k,ktr)=0.0
                    endif
    !     rev. 9.5.29  May.  26/08  - NK: fixed initialization in read_divert_ef
                    if(qdivert(k,j).lt.0.0)then
                      do jj=j,j+ktr-1
                        qdivert(k,jj)=qdivert(k,jj-1)
                      end do
                    endif
                  end do
                end do
              else              ! FLtype(flnNum).eq.'tb0'
              
!     rev. 10.2.59 Aug.  17/19  - NK Convert read_flow_ef & read_divert to F90
!     rev. 9.5.24  Mar.  18/08  - NK: fixed missing data in read_resl_ef.f
!             fill in the gaps to hourly data

                if(ktr.gt.1)then
                  do k=1,nodivert
                    do j=ktr,ndiv,ktr
	                do jj=ktr-1,1,-1
                        qdivert(k,j-jj)=qdivert(k,j)
                      end do
                    end do
                  end do
                endif
            endif             ! FLtype(flnNum).eq.'tb0'
        endif     !  if(ndiv.gt.0)

!d     if(iopt.eq.2)print*,'in read_divert_ef passed 187'

!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

 
      istep=al/1000

      if(nodivert.gt.0)then                             !999999999999999
!       FIND THE LOCAL COORDINATES FOR THE RESERVOIRS
!       THE VALUES FOR idiv AND jdiv ARE CHANGED

!       THE ORDER OF READING THE COORDINATES OF THE RESERVOIRS
!       MUST BE THE SAME AS READING THE CORRESPONDING FLOWS
!       IN S/R rdresv.

!       READ RELEASES
!       THE RESERVOIR OUTFLOWS ARE ALL READ IN THE FIRST TIME
!       rdresv IS CALLED. THEY ARE THEN STORED AND USED EACH TIME
!       rdresv IS CALLED.

!       IF NATURAL CONTROL, FLOWS ARE SET TO -1.0 ABOVE
!d       if(iopt.eq.2)print*,'in read_divert_ef passed 304'

      endif           !   if(nodivert.gt.0)

!d     if(iopt.eq.2)print*,'in read_divert_ef passed 551'

!     WE CAN'T HAVE -VE flows WHEN WE START
      do k=1,nodivert
        if(qdivert(k,1).lt.0.0)qdivert(k,ktr)=0.001
      end do

!     SET FUTURE RELEASES = LAST NON-NEGATIVE RELEASE
!     REALLY, WE'RE WORKING IN HOURLY INTERVALS ALTHOUGH THE      
!     RELEASES MAY BE READ IN ONLY WHEN THE RES OUTFLOW IS CHANGED.

!     rev. 9.5.14  Feb.  26/08  - NK: padded rel file for missing data
!     fill in missing data if rel file is shorter than the str file
!     nl is the length in nrs of the str file
!     ndiv is the length of the rel file
!     added Feb. 26/08  -nk-

      if(ndiv.gt.0)then
!       fill data at end of file only if there are values
        if(ndiv.lt.nl)then
          do j=ndiv+1,nl
            do k=1,nodivert
              qdivert(k,j)=qdivert(k,j-1)
            end do
          end do
          
          print*
          print*,'WARNING:'
          print*,'diversion file is shorter than the str file'
          print*,'missing data has been set = to last recorder release'
          print*
          do j=2,nl
            do k=1,nodivert
              if(qdivert(k,j).lt.0.0)qdivert(k,j)=qdivert(k,j-1)
            end do
          end do
        endif
      endif                        

      close(unit=unitNum,status='keep')

      firstpass='n'
      
  999 RETURN                 !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----

! FORMATS

  500 format(256f10.3)
 1011 format(' ',3x,'  i  idiv(i) jdiv(i)    b1(i)     b2(i)    b3(i)     b4(i)')
 1013 format(' ',3x,i3,4i8,a12/)
 6801 format('   read_divert_ef: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',i5,256f8.2)

      END SUBROUTINE read_divert

      SUBROUTINE read_drn(unitNum,flnNum,hdrflg,jan,jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  read_r2c - written May/06 by Dave Watson
!     - Adapdet for general r2c read by NK  Jul. 24/06
!	- Derived from rdtemp written by Nick Kouwen
!	- This subroutine reads the ensim compatible gridded r2c format
!     - for delta rain for the isotope model
!***********************************************************************

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	use EF_Module
	implicit none
	type(TempParam) :: header
	type(FrameRecord) :: frameRec


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION :: ntoc(9000)

      real*4  :: x1,deltatmp,teltatmp
      integer :: idlast,mhlast,jan,ntocorrect,ios,ios1,
     *           ntoc,i,iend,j,jz,n,
     *           ndeltatt,tem_hr,iostat,iAllocate,iDeallocate,
     *           nh_count,un,fn,xcount_local,ycount_local,
     *           nolines,xcount_max,ycount_max
      character(10) ::  fileformat
	real*4	timeHrs

      character*20  :: junk
	character*1   :: junk2,newfmtflg,firstpass,lineflg,hdrflg
	character*6   :: junk0
      DATA idlast/0/
      data firstpass/'y'/
      LOGICAL      :: exists

     
! Local variables
	integer*4 unitNum, flnNum, iStat
	character*4096 line, subString
	character*128 keyword, value 
	integer lineLen, keyLen, wordCount
	logical rStat, foundEndHeader,foundFirstFrame,foundFrame
	integer frameCount

      integer framesSkipped !# of frames skipped beforefirst data /nk
	integer modelHour !used to be k
	integer modelHourLast !used to be klast
	integer dataHour !used to be nr_count

! Dave's debug variables
!	integer daveInt
!	real daveReal

! Initialize default values within frame module
	CALL InitFrameRecord(frameRec)

	foundEndHeader = .false.

! Debug line
!	print*, 'Inside read_r2c at time = ',timeHrs, 'hrs'

! If hdrflg==1 ,then it's the first time through for this event
	if(hdrflg.eq.'1')then
		inquire(FILE=fln(flnNum),EXIST=exists)
		if(exists) then
		  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	    if(ios.ne.0)then
		    print*,'Problems opening the tem file',fln(flnNum)(1:40)
		    STOP ' Stopped in read_r2c'
		  endif
	    if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
		else
		  print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	    print*, 'Unit number ',unitNum
		  print*, 'but it is not found (in this location)'
		  STOP 'Program aborted in read_r2c @89'
		endif

!     Dave:  this needs to be fixed for this s/r  NK

! Initialize default values within XXXXXXXX module
		call InitTempParam(header)	

! Search for and read r2c file header
		line(1:1) = '#'
		do while((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(len_trim(line) .eq. 0))) 	

			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
				print*, 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line
			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)

				if(keyword(1:KeyLen) .eq. ':endheader')then
					foundEndHeader = .TRUE.
				else
					! parse the header
					iStat = ParseTempParam(header,keyword,keyLen,
     &													subString)
					if(iStat .lt. 0) then
						write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return 
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ',line
					endif
				end if
			end if
		end do

! Assign the parsed parameters to the model variables		
		xcount_temp = header%r2cp%xCount
		ycount_temp = header%r2cp%yCount
		xorigin_temp = header%r2cp%xOrigin
		yorigin_temp = header%r2cp%yOrigin
		xdelta_temp = header%r2cp%xDelta
		ydelta_temp = header%r2cp%yDelta
		
!     This section copied from read_swe_ef by NK  Jul. 5/07
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *    print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *    print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'    and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_r2c_ef @ 169'
	endif

! Scan data frames
		frameCount = 0
		do while((.NOT.EOF(unitNum)))
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
			 write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line

			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &													subString)
					
!	Identify the first and last frame's timestamp 
					if(iStat .lt. 0) then
					   write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ', line
					else if(frameRec%frame.EQ.1) then
						header%startJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%startHour = frameRec%tStamp%hour
					else
						header%endJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%endHour = frameRec%tStamp%hour
					end if
					header%r2cp%frameCount = header%r2cp%frameCount+1
				end if
			end if
		enddo	
	
!	deltat2 = model timestep in hours 
		deltat2 = 1	
!	nr = number of hours spanned by this tem file
!	convert to julian days to properly calculate hours spanned
		nr = (header%endJulianDay - header%startJulianDay)*24
     &				 + (header%endHour - header%startHour) + 1

!      pause 20		
!	Position to start of data (immediately after first frame record but before first frame data)
		REWIND (unitNum)
		foundFirstFrame = .false.
		do WHILE(.NOT.foundFirstFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &							keyLen,subString)
					foundFirstFrame = .true.
				end if
			end if		      
		enddo	
		
		modelHour=1 ! set model hour to first hour
		dataHour = 0 ! set data hour to just before first hour



!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
      framesSkipped=modelHour-1
!           modelHour=1 ! set model hour to first hour
!      print*,junk,modelhour,framesSkipped
!      pause 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            


!      pause 30
! firstpass means this is the first tem file of the first event...which is the only time it needs to be done
		if(firstpass.eq.'y')then
		  firstpass='n'        
!		  allocate(ttemp(ycount3,xcount3),tempv(na),tempvmin(na),
!     *						rh(na),stat=iAllocate)
              if(.NOT.allocated(inarray))then    
!               inarray not previously allocated
		    allocate(inarray(ycount_temp,xcount_temp),
     *                                         stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *	   'Error with allocation in read_r2c'
			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
                  
              else
!               inarray previously allocated but check to see this 
!               data fits in the allocated memory
 		    if(xcount_temp.gt.xcount_max.or.ycount_temp.gt.ycount_max)then
		      deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0)then
			  print*,'Warning: error with deallocation of inarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
!       outarray is in areawfo
!       this has to be allocated before calling write_r2c
		      allocate(inarray(ycount_max,xcount_max),
     *                             stat=iAllocate)
			if(iAllocate.ne.0)then
			  STOP 'Error with allocation of inarray in read_qlz'      
			end if
	          endif
              endif
		endif

 

! Check for change of grid size (could happen for next event)
            if(allocated(inarray))then    ! check that inarray is allocated
		  if(xcount_temp.gt.xcount_max.
     *                          or.ycount_temp.gt.ycount_max)then
			deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0) then
			  print*,'Warning: error with deallocation of intarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
!       outarray is in areawfo
!       this has to be allocated before calling write_r2c
		  allocate(inarray(ycount_max,xcount_max),stat=iAllocate)
			if(iAllocate.ne.0) then
			STOP 'Error with allocation of inarray in read_r2c'      
			end if
		  endif
	      endif

		xcount_temp=xcount_local
		ycount_temp=ycount_local

      print*,'finished reading header on unitNum=',unitNum

		return 
      endif          ! (hdrflg.eq.'1')

      if(iopt.eq.2)print*,'Finished reading the header      '

!***********************************************************
	
!     Finished reading the header      

!***********************************************************

!     We are looking for data for this step
	dataHour = dataHour + 1

!	if(modelHour.eq.modelHourLast)then
!		print*,'Error in ',fln(flnNum),' data repeated??'
!	endif    
 
!	If there is a record for this hour than modelHour = dataHour
!	print*,	'modelHour:',modelHour, 'dataHour:',dataHour


!	if(modelHour.eq.dataHour)then
	if(modelHour.eq.jz+framesSkipped)then


!	Go ahead and read the data for this frame 

		do i=1, ycount_local
		  read(unitNum,*,iostat=ios)(inarray(i,j),j=1,xcount_local)
!	        write(*,*)(inarray(i,j),j=1,xcount_local)
		  if(ios.ne.0)then
			write(*,9993)modelHour,i
			print*,' last data read:'
			print*,' jradw= 1 jrade= ',jrade
			print*,' iradn= ',iradn,' irads= 1'
			STOP ' program aborted - read_r2c @ 364'
		  endif
		end do

!      print*,'data read on unit =',unitNum

!	Read the next frame. If we are at the end of the file...close
		foundFrame = .false.
		do WHILE(.NOT.foundFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
!      print*,line
			if(EOF(unitNum)) then 

!     NK  Oct. 29/06
!     Added global flag to end event
!     end of event is when eof file found in first file
!     other files may have more data but we can only run shortest
	                  found_data_end=.true.

				close(unit=unitNum,status='keep',iostat=ios)
        write(51,*)'Closed unit ',unitNum,' Filename=  ',fln(flnNum)
	  write(*,*) 'Closed unit ',unitNum,' Filename=  ',fln(flnNum)

				RETURN 
			endif

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
					foundFrame = .true.
				end if
			end if		      
		enddo	

!           so the grid size can be checked in sub at any time
		xcount_temp=xcount_local
		ycount_temp=ycount_local

		modelHourLast=modelHour

!	Determine the next modelhour		
		modelHour=(JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &		frameRec%tStamp%day) - header%startJulianDay) * 24
     &			+ (frameRec%tStamp%hour - header%startHour) + 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
     &            +framesSkipped
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      print*,'in read_r2c next modelHour=',modelHour

!	else
!		do nothing...keep last temperature values...

	endif

	RETURN 

!     FORMATS

 9993 format(' error reading inarray at hour/line ',2i10/)
	

      END SUBROUTINE read_drn
      SUBROUTINE read_dsn(unitNum,flnNum,hdrflg,jan,jz)

!***********************************************************************
!    Copyright (C) 1987 by Dave Watson (NRC) and Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  read_r2c - written May/06 by Dave Watson
!     - Adapdet for general r2c read by NK  Jul. 24/06
!	- Derived from rdtemp written by Nick Kouwen
!	- This subroutine reads the ensim compatible gridded r2c format
!***********************************************************************

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	use EF_Module
	implicit none
	type(TempParam) :: header
	type(FrameRecord) :: frameRec

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION :: ntoc(9000)

      real*4  :: x1,deltatmp,teltatmp
      integer :: idlast,mhlast,jan,ntocorrect,ios,ios1,
     *           ntoc,i,iend,j,jz,n,
     *           ndeltatt,tem_hr,iostat,iAllocate,iDeallocate,
     *           nh_count,un,fn,xcount_local,ycount_local,
     *           nolines,xcount_max,ycount_max
      character(10) ::  fileformat
	real*4	timeHrs

      character*20  :: junk
	character*1   :: junk2,newfmtflg,firstpass,lineflg,hdrflg
	character*6   :: junk0
      DATA idlast/0/
      data firstpass/'y'/
      LOGICAL      :: exists
     
! Local variables
	integer*4 unitNum, flnNum, iStat
	character*4096 line, subString
	character*128 keyword, value 
	integer lineLen, keyLen, wordCount
	logical rStat, foundEndHeader,foundFirstFrame,foundFrame
	integer frameCount

      integer framesSkipped !# of frames skipped beforefirst data /nk
	integer modelHour !used to be k
	integer modelHourLast !used to be klast
	integer dataHour !used to be nr_count

! Dave's debug variables
!	integer daveInt
!	real daveReal

! Initialize default values within frame module
	CALL InitFrameRecord(frameRec)

	foundEndHeader = .false.

! Debug line
!	print*, 'Inside read_r2c at time = ',timeHrs, 'hrs'

! If hdrflg==1 ,then it's the first time through for this event
	if(hdrflg.eq.'1')then
		inquire(FILE=fln(flnNum),EXIST=exists)
		if(exists) then
		  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	    if(ios.ne.0)then
		    print*, 'Problems opening the tem file',fln(flnNum)(1:40)
		    STOP ' Stopped in read_r2c'
		  endif
	    if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
		else
		  print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	    print*, 'Unit number ',unitNum
		  print*, 'but it is not found (in this location)'
		  STOP 'Program aborted in read_dsn @89'
		endif

!     Dave:  this needs to be fixed for this s/r  NK

! Initialize default values within XXXXXXXX module
		call InitTempParam(header)	

! Search for and read r2c file header
		line(1:1) = '#'
		do while((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(len_trim(line) .eq. 0))) 	

			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
				print*, 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line
			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)

				if(keyword(1:KeyLen) .eq. ':endheader')then
					foundEndHeader = .TRUE.
				else
					! parse the header
					iStat = ParseTempParam(header,keyword,keyLen,
     &													subString)
					if(iStat .lt. 0) then
						write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return 
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ',line
					endif
				end if
			end if
		end do

! Assign the parsed parameters to the model variables		
		xcount_temp = header%r2cp%xCount
		ycount_temp = header%r2cp%yCount
		xorigin_temp = header%r2cp%xOrigin
		yorigin_temp = header%r2cp%yOrigin
		xdelta_temp = header%r2cp%xDelta
		ydelta_temp = header%r2cp%yDelta
		
!     This section copied from read_swe_ef by NK  Jul. 5/07
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *    print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *    print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'    and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_r2c_ef @ 169'
	endif

! Scan data frames
		frameCount = 0
		do while((.NOT.EOF(unitNum)))
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
			 write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line

			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &													subString)
					
!	Identify the first and last frame's timestamp 
					if(iStat .lt. 0) then
					   write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ', line
					else if(frameRec%frame.EQ.1) then
						header%startJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%startHour = frameRec%tStamp%hour
					else
						header%endJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%endHour = frameRec%tStamp%hour
					end if
					header%r2cp%frameCount = header%r2cp%frameCount+1
				end if
			end if
		enddo	
	
!	deltat2 = model timestep in hours 
		deltat2 = 1	
!	nr = number of hours spanned by this tem file
!	convert to julian days to properly calculate hours spanned
		nr = (header%endJulianDay - header%startJulianDay)*24
     &				 + (header%endHour - header%startHour) + 1

!	Position to start of data (immediately after first frame record but before first frame data)
		REWIND (unitNum)
		foundFirstFrame = .false.
		do WHILE(.NOT.foundFirstFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &							keyLen,subString)
					foundFirstFrame = .true.
				end if
			end if		      
		enddo	
		
		modelHour=1 ! set model hour to first hour
		dataHour = 0 ! set data hour to just before first hour

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
      framesSkipped=modelHour-1
!           modelHour=1 ! set model hour to first hour
!      print*,junk,modelhour,framesSkipped
!      pause 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

! firstpass means this is the first tem file of the first event...which is the only time it needs to be done
		if(firstpass.eq.'y')then
		  firstpass='n'        
!		  allocate(ttemp(ycount3,xcount3),tempv(na),tempvmin(na),
!     *						rh(na),stat=iAllocate)
              if(.NOT.allocated(inarray))then    
!               inarray not previously allocated
		    allocate(inarray(ycount_temp,xcount_temp),
     *                                         stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *	   'Error with allocation in read_r2c'
			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
                  
              else
!               inarray previously allocated but check to see this 
!               data fits in the allocated memory
 		    if(xcount_temp.gt.xcount_max.or.ycount_temp.gt.ycount_max)then
		      deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0)then
			  print*,'Warning: error with deallocation of inarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
		      allocate(inarray(ycount_max,xcount_max),
     *                             stat=iAllocate)
			if(iAllocate.ne.0)then
			  STOP 'Error with allocation of inarray in read_qlz'      
			end if
	          endif
              endif
		endif

 
! Check for change of grid size (could happen for next event)
            if(allocated(inarray))then    ! check that inarray is allocated
		  if(xcount_temp.gt.xcount_max.
     *                          or.ycount_temp.gt.ycount_max)then
			deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0) then
			  print*,'Warning: error with deallocation of intarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
		  allocate(inarray(ycount_max,xcount_max),stat=iAllocate)
			if(iAllocate.ne.0) then
			STOP 'Error with allocation of inarray in read_r2c'      
			end if
		  endif
	      endif

		xcount_temp=xcount_local
		ycount_temp=ycount_local

      print*,'finished reading header on unitNum=',unitNum

		return 
      endif          ! (hdrflg.eq.'1')

      if(iopt.eq.2)print*,'Finished reading the header      '

!***********************************************************
	
!     Finished reading the header      

!***********************************************************

!     We are looking for data for this step
	dataHour = dataHour + 1

!	if(modelHour.eq.modelHourLast)then
!		print*,'Error in ',fln(flnNum),' data repeated??'
!	endif    
 
!	If there is a record for this hour than modelHour = dataHour
!	print*,	'modelHour:',modelHour, 'dataHour:',dataHour


!	if(modelHour.eq.dataHour)then
	if(modelHour.eq.jz+framesSkipped)then

!	Go ahead and read the data for this frame 

		do i=1, ycount_local
		  read(unitNum,*,iostat=ios)(inarray(i,j),j=1,xcount_local)
!	        write(*,*)(inarray(i,j),j=1,xcount_local)
		  if(ios.ne.0)then
			write(*,9993)modelHour,i
			print*,' last data read:'
			print*,' jradw= 1 jrade= ',jrade
			print*,' iradn= ',iradn,' irads= 1'
			STOP ' program aborted - read_r2c @ 364'
		  endif
		end do

!      print*,'data read on unit =',unitNum

!	Read the next frame. If we are at the end of the file...close
		foundFrame = .false.
		do WHILE(.NOT.foundFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
!      print*,line
			if(EOF(unitNum)) then 

!     NK  Oct. 29/06
!     Added global flag to end event
!     end of event is when eof file found in first file
!     other files may have more data but we can only run shortest
	                  found_data_end=.true.

				close(unit=unitNum,status='keep',iostat=ios)
        write(51,*)'Closed unit ',unitNum,' Filename=  ',fln(flnNum)
	  write(*,*) 'Closed unit ',unitNum,' Filename=  ',fln(flnNum)

				RETURN 
			endif

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
					foundFrame = .true.
				end if
			end if		      
		enddo	

!           so the grid size can be checked in sub at any time
		xcount_temp=xcount_local
		ycount_temp=ycount_local

		modelHourLast=modelHour

!	Determine the next modelhour		
		modelHour=(JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &		frameRec%tStamp%day) - header%startJulianDay) * 24
     &			+ (frameRec%tStamp%hour - header%startHour) + 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
     &            +framesSkipped
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      print*,'in read_r2c next modelHour=',modelHour

!	else
!		do nothing...keep last temperature values...

	endif

	RETURN 

!     FORMATS

 9993 format(' error reading inarray at hour/line ',2i10/)
	

      END SUBROUTINE read_dsn

      SUBROUTINE read_flowinit(flnNum)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and dave Watson
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     borrowed swe reader for this s/r
!     nk  Oct. 9/06


!***********************************************************************
!  based on:  READ_SWE_EF -  written Mar/06 by Dave Watson, CHC
!     - Derived from rdswe written by Nick Kouwen
!     - This subroutine reads the ensim compatible gridded SWE file (r2c format)
!***********************************************************************
   
      use area_watflood

! R2C data module
	USE EF_Module

	implicit none
	TYPE(SWEParam) :: header

! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer       :: nclasses,ios,iallocate,iDeallocate
      real*4        :: deffactor

      LOGICAL exists
 
! parameter type definitions
	integer*4 unitNum, flnNum, iStat
	integer*4 n,i,j

! Local variables
	character*4096 line, subString, tmpString
	character*128 keyword, value
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader
	integer xCountLoc, yCountLoc, attCountLoc
	integer ai, xi, yi, vi, error

! Set unit and fln number
c	unitNum = 99
c	flnNum = 99
 
! Open the file
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	IF(exists)then
		open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
 		if(ios.ne.0)then
		  write(98,*)'Error: Problems opening ',fln(flnNum)(1:40)
		  STOP ' Stopped in read_flowinit @ 52_ef'
		endif
      else
          print*
		write(98,*)'Error: the file: ',	fln(flnNum)(1:40)
          write(98,*)'Error: Unit # =',unitNum
		write(98,*)'Error:is NOT found'
		STOP ' Program STOPPED in read_flowinit @ 57'
	endif
	write(98,*)'Info: Opened ',fln(flnnum)(1:40)

! Initialize default values
	CALL InitSWEParam(header)	

! Search for and read r2c file header
	line(1:1) = '#'
	foundEndHeader = .false.

	do WHILE((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(LEN_TRIM(line) .eq. 0))) 	

		read(UNIT=unitNum, FMT='((A))', iostat=ios) line	! read a line
		if(ios .eq. -1)then
			write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
			STOP ' Stopped in read_swe_ef'
		end if

		rStat = Detab(line)				! replace tabs with spaces
		line = ADJUSTL(line)		! Get rid of leading white space
		lineLen = LEN_TRIM(line)		! Find the length excluding trailing spaces

		if(line(1:1) .eq. ':')then
			wordCount = SplitLine(line, keyword, subString)	! find the keyword
			rStat = ToLowerCase(keyword)
			KeyLen = LEN_TRIM(keyword)

			if(keyword(1:KeyLen) .eq. ':endheader')then
				foundEndHeader = .TRUE.

			else
				iStat = ParseSWEParam(header,keyword,keyLen,
     &													subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_swe_ef'
					return
				else if(iStat .eq. 0) then
!					write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &										line
				endif
			end if
		end if
	end do
!***************************************
!	Finished reading the header
!***************************************

! Assign the parsed parameters to the model variables		
	xCountLoc = header%r2cp%xCount
	yCountLoc = header%r2cp%yCount
	attCountLoc =header%r2cp%ep%attCount
c	imax=header%r2cp%yCount
c	jmax=header%r2cp%xCount 
	deffactor = header%initHeatDeficit !Set InitHeatDeficit


! Read the data section
	CALL LoadAttributeData(header%r2cp%ep, xCountLoc,
     &						yCountLoc, unitNum)	
	
      
!      write(63,*)xCountLoc,yCountLoc,unitNum
      
      	
! Validate parameters
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *    write(63,*)'xorig_rte.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *    write(63,*)'yorig_rte.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	write(63,*)'xdelta_rte.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	write(63,*)'ydelta_rte.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	      write(63,*)'xcount_rte.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	      write(63,*)'ycount_rte.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
            print*
	      write(63,*)'Mismatch between ',fln(flnNum)
            write(63,*)'    and SHD files'
            write(63,*)'Check files for origins, deltas and counts'
            write(63,*)'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_flowinit_ef @ 159'
	endif

	nclasses = header%r2cp%ep%attCount

c         imax=ycount
c     	  jmax=xcount

!     check added Jul. 13/11 nk
      if(yCountLoc.ne.ycount)then
        write(63,*)'ycount in ',fln(flnNum)
        write(63,*)'does not match the ycount in the shd file'
        stop 'Program aborted in read_flowinit.f @ 165'
      endif
      if(xCountLoc.ne.xcount)then
        write(63,*)'xcount in ',fln(flnNum)
        write(63,*)'does not match the xcount in the shd file'
        stop 'Program aborted in read_flowinit.f @ 171'
      endif

      if(allocated(inarray))then
        deallocate(inarray)
        write(63,*)'deallocated inarray in read_flowinit'
      endif
      if(.NOT.allocated(inarray))then
        allocate(inarray(ycount,xcount),stat=iAllocate)
        if(iAllocate.ne.0)then
          write(63,*)'Error with allocation of inarray in read_flowinit'    
          stop 'Program aborted in read_flowinit @ 178'
        endif
      endif

! Copy Attribute data over to Nick's global variables
	do ai=1,attCountLoc
		vi = 0
!		do yi=yCountLoc,1,-1      <<<<<<<top to bottom reversed !!!
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  inarray(yi,xi) = header%r2cp%ep%attList(ai)%val(vi)
!	write(63,*)yi,xi,header%r2cp%ep%attList(ai)%val(vi)
			end do
c            write(55,55555)(inarray(yi,xi),xi=1,xCountLoc)          !?????????????????????
		end do
	      write(55,*)
55555       format(999e10.3)
	    do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
	        if(ai.eq.1)then
                  qi1(n)=inarray(i,j)
	            qi2(n)=inarray(i,j)
	        elseif(ai.eq.2)then
	            qo1(n)=inarray(i,j)
	            qo2(n)=inarray(i,j)
      	    elseif(ai.eq.3)then
	            store1(n)=inarray(i,j)
	            store2(n)=inarray(i,j)
	        elseif(ai.eq.4)then
	            over(n)=inarray(i,j)
	        elseif(ai.eq.5)then
	            lzs(n)=inarray(i,j)
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
	        elseif(ai.eq.6)then
	            qold(n)=inarray(i,j)
              endif
          end do
                  
        if(wetflg.eq.'y')then
	    do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
	        if(ai.eq.7)then
	            qiwet1(n)=inarray(i,j)
	            qiwet2(n)=inarray(i,j)
	        elseif(ai.eq.8)then
	            qowet1(n)=inarray(i,j)
	            qowet2(n)=inarray(i,j)
	        elseif(ai.eq.9)then
	            wstore1(n)=inarray(i,j)
	            wstore2(n)=inarray(i,j)
	        elseif(ai.eq.10)then
	            hcha1(n)=inarray(i,j)
	            hcha2(n)=inarray(i,j)
	        elseif(ai.eq.11)then
	            hwet1(n)=inarray(i,j)
	            hwet2(n)=inarray(i,j)
	        endif
          end do
        endif
      end do

! Deallocate the attribute data now that global attributes have been set
	do ai=1,attCountLoc
		deallocate ( header%r2cp%ep%attList(ai)%val, STAT = error )
		if (error.ne.0) STOP 'deallocation error in read_gsm_ef()' 
	end do

      close (unit=unitNum)
      
      deallocate(inarray,stat=iDeallocate)
      if(iDeallocate.ne.0)then
        write(63,*)'Error with deallocation of p array in read_flowinit'    
d       stop 'Program aborted in read_flowinit @ 247'
      endif
      
	write(98,*)'Info: Finished reading ',fln(flnNum)(1:40)

      RETURN

      END SUBROUTINE read_flowinit



      SUBROUTINE read_gsm_ef()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  READ_GSM_EF - written Mar/06 by Dave Watson, CHC
!	- Derived from read_gsm written by Nick Kouwen.
!	- This subroutine reads the ensim compatible gridded soil moisture
!     (GSM) file (r2c format)
!***********************************************************************

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	USE EF_Module

	implicit none
	TYPE(GSMPARAM) :: header


! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      logical       :: exists
	integer i,j,n,ios,iAllocate,iDeallocate,classcount_local,ii
	real*4 conv

! Parameter type definitions
	integer*4 unitNum, flnNum, iStat

! Local variables
      character*1 firstpass
	character*128 keyword, value
	character*4096 line, subString, tmpString
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader
	integer xCountLoc, yCountLoc, attCountLoc
	integer ai, xi, yi, vi, error

      data firstpass/'y'/

! Set unit and fln number
	unitNum = 287
	flnNum = 37

! Open the file
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	if(exists)then
!       gsm file will be read even in a run with resume = 'y'
	  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	    if(ios.ne.0)then
	  	print*,'Problems opening ',fln(flnNum)
	 	print*
		STOP ' Stopped in read_gsm_ef'
	  endif
	else
	  if(resumflg.ne.'y')then
          print*,'ERROR: the gridded soil moisture (GSM) file ',
     *			fln(flnNum)
	    print*,'is NOT found'
	    STOP ' Program STOPPED in read_gsm_ef'
	  else
!         this means using the swe from the soilinit.r2c file
	    return
	  endif
	endif

! Initialize default values
	CALL InitGSMParam(header)	

! Search for and read r2c file header
	line(1:1) = '#'
	foundEndHeader = .false.

	do WHILE((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(LEN_TRIM(line) .eq. 0))) 	

		read(UNIT=unitNum, FMT='((A))', iostat=ios) line	! read a line
		if(ios .eq. -1)then
			write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
			STOP ' Stopped in read_gsm_ef'
		end if

		rStat = Detab(line)				! replace tabs with spaces
		line = ADJUSTL(line)		! Get rid of leading white space
		lineLen = LEN_TRIM(line)		! Find the length excluding trailing spaces
		if(line(1:1) .eq. ':')then
			wordCount = SplitLine(line, keyword, subString)	! find the keyword
			rStat = ToLowerCase(keyword)
			KeyLen = LEN_TRIM(keyword)

			if(keyword(1:KeyLen) .eq. ':endheader')then
				foundEndHeader = .TRUE.

			else
				iStat = ParseGSMParam(header,keyword,keyLen,
     &													subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_gsm_ef'
					return
				else if(iStat .eq. 0) then
!					write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &										line
				endif
			end if
		end if
	end do	
!***************************************
!	Finished reading the header
!***************************************

! Assign the parsed parameters to the model variables	
	xCountLoc = header%r2cp%xCount
	yCountLoc = header%r2cp%yCount
	attCountLoc =header%r2cp%ep%attCount
	conv = header%r2cp%unitConv 
	classcount_local = header%r2cp%ep%attCount

! Read the data section
	CALL LoadAttributeData(header%r2cp%ep, xCountLoc,
     &						yCountLoc, unitNum)

!     This section copied from read_swe_ef by NK  Jul. 5/07
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *    print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *    print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum) 
            print*,'     and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_gsm_ef @ 141'
	endif

! We have finished reading the file so close it
	close(unit=unitNum,status='keep',iostat=ios)

!	if(classcount_local.ne.classcount)then
	if(classcount_local.ne.classcount)then     ! <<<<<<<<<<<<<<nk sep 28/06
		print*,'No of classes in the gridded soil moisture file'
		print*,'do not match the number of classes in the shed'
		print*,'file.'
		print*,'no of classes in the shd file =',classcount
        print*,'Including impervious'
		print*,'no of classes in the gsm file =',classcount_local
		print*,'All classes assumed to have same init soil moisture'
		print*
		pause 'Hit enter to continue or ctrl C to abort.'	      
	endif

! Allocate the ssmc array - deallocate if one already exists
	if(ALLOCATED(ssmc)) then
		deallocate(ssmc,stat=iDeallocate)
		if(iDeallocate.ne.0) STOP
     *		'ERROR: Failed to deallocate ssmc array in read_gsm_ef'
	endif
		

      if(firstpass.eq.'y')then
	  allocate(api(na,classcount),stat=iAllocate)
	  if(iAllocate.ne.0) STOP
     *   'ERROR: Failed to allocate ssmc array in read_gsm_ef'
      endif

	allocate(ssmc(ycountloc,xcountloc),stat=iAllocate)
	  if(iAllocate.ne.0) STOP
     *   'ERROR: Failed to allocate ssmc array in read_gsm_ef'

!      print*,'ssmc allocated for ',ycountloc,xcountloc
!	pause

!     check added Jul. 17/12 nk
      if(yCountLoc.ne.ycount)then
        print*,'ycount in ',fln(flnNum)
        print*,'does not match the ycount in the shd file'
        print*
        stop 'Program aborted in read_gsm_ef.f @ 199'
      endif
      if(xCountLoc.ne.xcount)then
        print*,'xcount in ',fln(flnNum)
        print*,'does not match the xcount in the shd file'
        print*
        stop 'Program aborted in read_gsm_ef.f @ 205'
      endif
      if(attCountLoc.ne.classcount)then
        print*,'classcount in ',fln(flnNum)
        print*,'does not match the classcount in the shd file'
        print*
        stop 'Program aborted in read_gsm_ef.f @ 211'
      endif

! Copy Attribute data over to Nick's global variables
	do ai=1,attCountLoc
	  vi = 0
!	    do yi=yCountLoc,1,-1   !  backwards  nk  Mar. 20/07
	    do yi=1,yCountLoc
		do xi=1,xCountLoc
	        vi = vi+1
	        ssmc(yi,xi) =  header%r2cp%ep%attList(ai)%val(vi)*conv
!             ................... 
!             added Jan. 21/07  nk
!             need to vectorize ssmc here to save memory
!             just one 2D array needed this way
              ssmc(yi,xi)=amin1(0.55,ssmc(yi,xi))
              ssmc(yi,xi)=amax1(0.001,ssmc(yi,xi))
              n=s(yi,xi)
              if(n.gt.0)then     ! i.e. we're in the watershed
!               api here is the initial soil moisture
!               but it will be the antecedent precip index in runoff
!               It is converted in soilinit
	          api(n,ai)=ssmc(yi,xi)
	        endif
!             ................... 
	    end do
        end do
	end do

! Deallocate the attribute data now that the global variable have been set
	do ai=1,attCountLoc
	  deallocate ( header%r2cp%ep%attList(ai)%val, STAT = error )
	  if (error.ne.0) STOP 'deallocation error %val in read_gsm_ef()' 
	end do

 	deallocate (ssmc,STAT=error )
	if (error.ne.0) STOP 'deallocation error ssmc in read_gsm_ef()' 

      firstpass='n'

	if(iopt.ge.1)print*,'Finished reading ',fln(flnNum)(1:30)

      return
  
      end SUBROUTINE read_gsm_ef










      SUBROUTINE read_gsn(unitNum,flnNum,hdrflg,jan,jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  read_r2c - written May/06 by Dave Watson
!     - Adapdet for general r2c read by NK  Jul. 24/06
!	- Derived from rdtemp written by Nick Kouwen
!	- This subroutine reads the ensim compatible gridded r2c format
!***********************************************************************

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	use EF_Module
	implicit none
	type(TempParam) :: header
	type(FrameRecord) :: frameRec


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION :: ntoc(9000)

      real*4  :: x1,deltatmp,teltatmp
      integer :: idlast,mhlast,jan,ntocorrect,ios,ios1,
     *           ntoc,i,iend,j,jz,n,
     *           ndeltatt,tem_hr,iostat,iAllocate,iDeallocate,
     *           nh_count,un,fn,xcount_local,ycount_local,
     *           nolines,xcount_max,ycount_max
      character(10) ::  fileformat
	real*4	timeHrs

      character*20  :: junk
	character*1   :: junk2,newfmtflg,firstpass,lineflg,hdrflg
	character*6   :: junk0
      DATA idlast/0/
      data firstpass/'y'/
      LOGICAL      :: exists
     
! Local variables
	integer*4 unitNum, flnNum, iStat
	character*4096 line, subString
	character*128 keyword, value 
	integer lineLen, keyLen, wordCount
	logical rStat, foundEndHeader,foundFirstFrame,foundFrame
	integer frameCount
      integer framesSkipped !# of frames skipped beforefirst data /nk
	integer modelHour !used to be k
	integer modelHourLast !used to be klast
	integer dataHour !used to be nr_count

! Dave's debug variables
!	integer daveInt
!	real daveReal

! Initialize default values within frame module
	CALL InitFrameRecord(frameRec)

	foundEndHeader = .false.

! Debug line
!	print*, 'Inside read_r2c at time = ',timeHrs, 'hrs'

! If hdrflg==1 ,then it's the first time through for this event
	if(hdrflg.eq.'1')then
		inquire(FILE=fln(flnNum),EXIST=exists)
		if(exists) then
		  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	        if(ios.ne.0)then
		    print*, 'Problems opening the tem file',fln(flnNum)(1:40)
		    STOP ' Stopped in read_gsn @ 73'
		  endif
	    if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
		else
		  print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	    print*, 'Unit number ',unitNum
		  print*, 'but it is not found (in this location)'
		  STOP 'Program aborted in read_gsn @89'
		endif

!     Dave:  this needs to be fixed for this s/r  NK  fix fix
! Initialize default values within XXXXXXXX module
		call InitTempParam(header)	

! Search for and read r2c file header
		line(1:1) = '#'
		do while((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(len_trim(line) .eq. 0))) 	

			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
				print*, 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line
			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)

				if(keyword(1:KeyLen) .eq. ':endheader')then
					foundEndHeader = .TRUE.
				else
					! parse the header
					iStat = ParseTempParam(header,keyword,keyLen,
     &													subString)
					if(iStat .lt. 0) then
						write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return 
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ',line
					endif
				end if
			end if
		end do

! Assign the parsed parameters to the model variables		
		xcount_temp = header%r2cp%xCount
		ycount_temp = header%r2cp%yCount
		xorigin_temp = header%r2cp%xOrigin
		yorigin_temp = header%r2cp%yOrigin
		xdelta_temp = header%r2cp%xDelta
		ydelta_temp = header%r2cp%yDelta
		
!     This section copied from read_swe_ef by NK  Jul. 5/07
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *        print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *         print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'    and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_r2c_ef @ 169'
	endif

! Scan data frames
		frameCount = 0
		do while((.NOT.EOF(unitNum)))
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
			 write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line

			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &													subString)
					
!	Identify the first and last frame's timestamp 
					if(iStat .lt. 0) then
					   write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ', line
					else if(frameRec%frame.EQ.1) then
						header%startJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%startHour = frameRec%tStamp%hour
					else
						header%endJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%endHour = frameRec%tStamp%hour
					end if
					header%r2cp%frameCount = header%r2cp%frameCount+1
				end if
			end if
		enddo	
	
!	deltat2 = model timestep in hours 
		deltat2 = 1	
!	nr = number of hours spanned by this tem file
!	convert to julian days to properly calculate hours spanned
		nr = (header%endJulianDay - header%startJulianDay)*24
     &				 + (header%endHour - header%startHour) + 1

!	Position to start of data (immediately after first frame record but before first frame data)
		REWIND (unitNum)
		foundFirstFrame = .false.
		do WHILE(.NOT.foundFirstFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &							keyLen,subString)
					foundFirstFrame = .true.
				end if
			end if		      
		enddo	
		
		modelHour=1 ! set model hour to first hour
		dataHour = 0 ! set data hour to just before first hour

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
      framesSkipped=modelHour-1
!           modelHour=1 ! set model hour to first hour
!      print*,junk,modelhour,framesSkipped
!      pause 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! firstpass means this is the first tem file of the first event...which is the only time it needs to be done
		if(firstpass.eq.'y')then
		  firstpass='n'        
!		  allocate(ttemp(ycount3,xcount3),tempv(na),tempvmin(na),
!     *						rh(na),stat=iAllocate)
              if(.NOT.allocated(inarray))then    
!               inarray not previously allocated
		    allocate(inarray(ycount_temp,xcount_temp),
     *                                         stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *	   'Error with allocation in read_r2c'
			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
                  
              else
!               inarray previously allocated but check to see this 
!               data fits in the allocated memory
 		    if(xcount_temp.gt.xcount_max.or.ycount_temp.gt.ycount_max)then
		      deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0)then
			  print*,'Warning: error with deallocation of inarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
!       this has to be allocated before calling write_r2c
		      allocate(inarray(ycount_max,xcount_max),
     *                             stat=iAllocate)
			if(iAllocate.ne.0)then
			  STOP 'Error with allocation of inarray in read_qlz'      
			end if
	          endif
              endif
		endif

! Check for change of grid size (could happen for next event)
            if(allocated(inarray))then    ! check that inarray is allocated
		  if(xcount_temp.gt.xcount_max.
     *                          or.ycount_temp.gt.ycount_max)then
			deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0) then
			  print*,'Warning: error with deallocation of intarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
!       this has to be allocated before calling write_r2c
		  allocate(inarray(ycount_max,xcount_max),stat=iAllocate)
			if(iAllocate.ne.0) then
			STOP 'Error with allocation of inarray in read_r2c'      
			end if
		  endif
	      endif
		xcount_temp=xcount_local
		ycount_temp=ycount_local

      print*,'finished reading header on unitNum=',unitNum

		return 
      endif          ! (hdrflg.eq.'1')

      if(iopt.eq.2)print*,'Finished reading the header      '

!***********************************************************
!     Finished reading the header      
!***********************************************************

!     We are looking for data for this step
	dataHour = dataHour + 1

!	If there is a record for this hour than modelHour = dataHour
!	print*,	'modelHour:',modelHour, 'dataHour:',dataHour

!	if(modelHour.eq.dataHour)then
	if(modelHour.eq.jz+framesSkipped)then

!	Go ahead and read the data for this frame 
		do i=1, ycount_local
		  read(unitNum,*,iostat=ios)(inarray(i,j),j=1,xcount_local)
!	        write(*,*)(inarray(i,j),j=1,xcount_local)
		  if(ios.ne.0)then
			write(*,9993)modelHour,i
			print*,' last data read:'
			print*,' jradw= 1 jrade= ',jrade
			print*,' iradn= ',iradn,' irads= 1'
			STOP ' program aborted - read_r2c @ 364'
		  endif
		end do

!      print*,'data read on unit =',unitNum
!	Read the next frame. If we are at the end of the file...close
		foundFrame = .false.
		do WHILE(.NOT.foundFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
!      print*,line
			if(EOF(unitNum)) then 

!     NK  Oct. 29/06
!     Added global flag to end event
!     end of event is when eof file found in first file
!     other files may have more data but we can only run shortest
	                  found_data_end=.true.

				close(unit=unitNum,status='keep',iostat=ios)
        write(51,*)'Closed unit ',unitNum,' Filename=  ',fln(flnNum)
	  write(*,*) 'Closed unit ',unitNum,' Filename=  ',fln(flnNum)

				RETURN 
			endif

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
					foundFrame = .true.
				end if
			end if		      
		enddo	

!           so the grid size can be checked in sub at any time
		xcount_temp=xcount_local
		ycount_temp=ycount_local

		modelHourLast=modelHour

!	Determine the next modelhour		
		modelHour=(JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &		frameRec%tStamp%day) - header%startJulianDay) * 24
     &			+ (frameRec%tStamp%hour - header%startHour) + 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
     &            +framesSkipped
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      print*,'in read_r2c next modelHour=',modelHour

!	else
!		do nothing...keep last temperature values...

	endif

	RETURN 

!     FORMATS

 9993 format(' error reading inarray at hour/line ',2i10/)

      END SUBROUTINE read_gsn
      SUBROUTINE read_hum(unitNum,flnNum,hdrflg,jan,jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
C***********************************************************************
!  read_r2c - written May/06 by Dave Watson
!     - Adapdet for general r2c read by NK  Jul. 24/06
C	- Derived from rdtemp written by Nick Kouwen
C	- This subroutine reads the ensim compatible gridded r2c format
C***********************************************************************

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	use EF_Module
	implicit none
	type(TempParam) :: header
	type(FrameRecord) :: frameRec


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION :: ntoc(9000)

      real*4  :: x1,deltatmp,teltatmp
      integer :: idlast,mhlast,jan,ntocorrect,ios,ios1,
     *           ntoc,i,iend,j,jz,n,
     *           ndeltatt,tem_hr,iostat,iAllocate,iDeallocate,
     *           nh_count,un,fn,xcount_local,ycount_local,
     *           nolines,xcount_max,ycount_max
      character(10) ::  fileformat
	real*4	timeHrs

      character*20  :: junk
	character*1   :: junk2,newfmtflg,firstpass,lineflg,hdrflg
	character*6   :: junk0
      DATA idlast/0/
      data firstpass/'y'/
      LOGICAL      :: exists

     
! Local variables
	integer*4 unitNum, flnNum, iStat
	character*4096 line, subString
	character*128 keyword, value 
	integer lineLen, keyLen, wordCount
	logical rStat, foundEndHeader,foundFirstFrame,foundFrame
	integer frameCount

      integer framesSkipped !# of frames skipped beforefirst data /nk
	integer modelHour !used to be k
	integer modelHourLast !used to be klast
	integer dataHour !used to be nr_count

! Dave's debug variables
!	integer daveInt
!	real daveReal

! Initialize default values within frame module
	CALL InitFrameRecord(frameRec)

	foundEndHeader = .false.

! Debug line
!	print*, 'Inside read_r2c at time = ',timeHrs, 'hrs'

! If hdrflg==1 ,then it's the first time through for this event
	if(hdrflg.eq.'1')then
		inquire(FILE=fln(flnNum),EXIST=exists)
		if(exists) then
		  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	        if(ios.ne.0)then
		    print*, 'Problems opening the hum file',fln(flnNum)(1:40)
		    STOP ' Stopped in read_r2c'
		  endif
	    if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
		else
		  print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	    print*, 'Unit number ',unitNum
		  print*, 'but it is not found (in this location)'
		  STOP 'Program aborted in read_hum @89'
		endif

!     Dave:  this needs to be fixed for this s/r  NK

! Initialize default values within XXXXXXXX module
		call InitTempParam(header)	

! Search for and read r2c file header
		line(1:1) = '#'
		do while((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(len_trim(line) .eq. 0))) 	

			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
				print*, 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line
			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)

				if(keyword(1:KeyLen) .eq. ':endheader')then
					foundEndHeader = .TRUE.
				else
					! parse the header
					iStat = ParseTempParam(header,keyword,keyLen,
     &													subString)
					if(iStat .lt. 0) then
						write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return 
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ',line
					endif
				end if
			end if
		end do

! Assign the parsed parameters to the model variables		
		xcount_temp = header%r2cp%xCount
		ycount_temp = header%r2cp%yCount
		xorigin_temp = header%r2cp%xOrigin
		yorigin_temp = header%r2cp%yOrigin
		xdelta_temp = header%r2cp%xDelta
		ydelta_temp = header%r2cp%yDelta
		
!     This section copied from read_swe_ef by NK  Jul. 5/07
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *      print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *      print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     *    	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'    and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_r2c_ef @ 169'
	endif

! Scan data frames
		frameCount = 0
		do while((.NOT.EOF(unitNum)))
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(ios .eq. -1)then
			 write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
				STOP ' Stopped in read_r2c'
			end if
!      if(iopt.eq.2)print*,line

			rStat = Detab(line)				! replace tabs with spaces
			line = adjustl(line)		! Get rid of leading white space
			lineLen = len_trim(line)		! Find the length excluding trailing spaces

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &													subString)
					
!	Identify the first and last frame's timestamp 
					if(iStat .lt. 0) then
					   write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
						write(*,'(2(A))') '   in line: ',line					
						STOP ' Stopped in read_r2c'
						return
					else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ', line
					else if(frameRec%frame.EQ.1) then
						header%startJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%startHour = frameRec%tStamp%hour
					else
						header%endJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
						header%endHour = frameRec%tStamp%hour
					end if
					header%r2cp%frameCount = header%r2cp%frameCount+1
				end if
			end if
		enddo	
	
!	deltat2 = model timestep in hours 
		deltat2 = 1	
!	nr = number of hours spanned by this tem file
!	convert to julian days to properly calculate hours spanned
		nr = (header%endJulianDay - header%startJulianDay)*24
     &				 + (header%endHour - header%startHour) + 1

!      pause 20		
!	Position to start of data (immediately after first frame record but before first frame data)
		REWIND (unitNum)
		foundFirstFrame = .false.
		do WHILE(.NOT.foundFirstFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &							keyLen,subString)
					foundFirstFrame = .true.
				end if
			end if		      
		enddo	
		
		modelHour=1 ! set model hour to first hour
		dataHour = 0 ! set data hour to just before first hour



!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
      framesSkipped=modelHour-1
!           modelHour=1 ! set model hour to first hour
!      print*,junk,modelhour,framesSkipped
!      pause 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            


!      pause 30
! firstpass means this is the first tem file of the first event...which is the only time it needs to be done
		if(firstpass.eq.'y')then
		  firstpass='n'        
!		  allocate(ttemp(ycount3,xcount3),tempv(na),tempvmin(na),
!     *						rh(na),stat=iAllocate)
              if(.NOT.allocated(inarray))then    
!               inarray not previously allocated
		    allocate(inarray(ycount_temp,xcount_temp),
     *                                         stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *	   'Error with allocation in read_r2c'
			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
                  
              else
!               inarray previously allocated but check to see this 
!               data fits in the allocated memory
 		    if(xcount_temp.gt.xcount_max.or.ycount_temp.gt.ycount_max)then
		      deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0)then
			  print*,'Warning: error with deallocation of inarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
			xcount_local=xcount_temp
			ycount_local=ycount_temp
!       outarray is in areawfo
!       this has to be allocated before calling write_r2c
		      allocate(inarray(ycount_max,xcount_max),
     *                             stat=iAllocate)
			if(iAllocate.ne.0)then
			  STOP 'Error with allocation of inarray in read_qlz'      
			end if
	          endif
              endif
		endif

 

! Check for change of grid size (could happen for next event)
            if(allocated(inarray))then    ! check that inarray is allocated
		  if(xcount_temp.gt.xcount_max.
     *                          or.ycount_temp.gt.ycount_max)then
			deallocate(inarray,stat=iDeallocate)
			if(iDeallocate.ne.0) then
			  print*,'Warning: error with deallocation of intarray'
			endif

			xcount_max=xcount_temp
			ycount_max=ycount_temp
!       this has to be allocated before calling write_r2c
		  allocate(inarray(ycount_max,xcount_max),stat=iAllocate)
			if(iAllocate.ne.0) then
			STOP 'Error with allocation of inarray in read_r2c'      
			end if
		  endif
	      endif

		xcount_temp=xcount_local
		ycount_temp=ycount_local

      print*,'finished reading header on unitNum=',unitNum

		return 
      endif          ! (hdrflg.eq.'1')

      if(iopt.eq.2)print*,'Finished reading the header      '

!***********************************************************
	
!     Finished reading the header      

!***********************************************************

!     We are looking for data for this step
	dataHour = dataHour + 1

!	If there is a record for this hour than modelHour = dataHour
!	print*,	'modelHour:',modelHour, 'dataHour:',dataHour


!	if(modelHour.eq.dataHour)then
	if(modelHour.eq.jz+framesSkipped)then


!	Go ahead and read the data for this frame 

		do i=1, ycount_local
		  read(unitNum,*,iostat=ios)(inarray(i,j),j=1,xcount_local)
!	        write(*,*)(inarray(i,j),j=1,xcount_local)
		  if(ios.ne.0)then
			write(*,9993)modelHour,i
			print*,' last data read:'
			print*,' jradw= 1 jrade= ',jrade
			print*,' iradn= ',iradn,' irads= 1'
			STOP ' program aborted - read_r2c @ 364'
		  endif
		end do

!      print*,'data read on unit =',unitNum

!	Read the next frame. If we are at the end of the file...close
		foundFrame = .false.
		do WHILE(.NOT.foundFrame)
			read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
!      print*,line
			if(EOF(unitNum)) then 

!     NK  Oct. 29/06
!     Added global flag to end event
!     end of event is when eof file found in first file
!     other files may have more data but we can only run shortest
	                  found_data_end=.true.

				close(unit=unitNum,status='keep',iostat=ios)
        write(51,*)'Closed unit ',unitNum,' Filename=  ',fln(flnNum)
	  write(*,*) 'Closed unit ',unitNum,' Filename=  ',fln(flnNum)

				RETURN 
			endif

			if(line(1:1) .eq. ':')then
				wordCount = SplitLine(line, keyword, subString)	! find the keyword
				rStat = ToLowerCase(keyword)
				KeyLen = len_trim(keyword)
				if(keyword(1:KeyLen).eq.':frame')then
					iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
					foundFrame = .true.
				end if
			end if		      
		enddo	

!           so the grid size can be checked in sub at any time
		xcount_temp=xcount_local
		ycount_temp=ycount_local

		modelHourLast=modelHour

!	Determine the next modelhour		
		modelHour=(JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &		frameRec%tStamp%day) - header%startJulianDay) * 24
     &			+ (frameRec%tStamp%hour - header%startHour) + 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
     &            +framesSkipped
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      print*,'in read_r2c next modelHour=',modelHour

!	else
!		do nothing...keep last temperature values...

	endif

	RETURN 

!     FORMATS

 9993 format(' error reading inarray at hour/line ',2i10/)
	

      END SUBROUTINE read_hum
      SUBROUTINE read_level(unitNum,flnNum)
    
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***************************************************************************
! PROGRAM BY: NK  June 2012
!
      use area_watflood
      USE EF_Module

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      implicit none
      save

      TYPE(LvlParam) :: header
      TYPE(LvlColumnMetaData) :: colHeader

      CHARACTER(1) :: new
      INTEGER      :: jan,ju,iallcnt2,iallocate,n,ii,i,j,k,l,nold
      integer      :: n_max,ideallocate,no_hdr_lines
      integer      :: ios,linecount,unitnum,flnNum,iStat
      integer      :: nlines,nlines_old
      integer      :: ll1,ll2
      REAL*4       :: time,ttime,taold,temmmp  
      character*16 :: swe_file              
      logical      :: exists,firstpass,errflg1

! Local variables
      character*128 keyword, value
      character*4096 line, subString, tmpString
      CHARACTER(1)  :: col0(13),col1(13),col2(26)
      integer lineLen, keyLen, wordCount
      logical rStat, lineType, foundEndHeader, insideColMetaData

      save
      
      DATA new/'f'/firstpass/.true./errflg1/.false./
      DATA iallcnt2/0/

      DATA col1/'b','d','f','h','j','l','n','p','r','t','v','x','z'/
      DATA col0/'c','e','g','i','k','m','o','q','s','u','w','y','a'/
      DATA col2/' ','a','b','c','d','e','f','g','h','i','j','k','l'&
               ,'m','n','o','p','q','r','s','t','u','v','w','x','y'/

!d      if(iopt.eq.2)print*,'in melt @ 0'

      print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
      print*,'NEW  <<<<<'

          
      if(IsFileTypeTB0(fln(flnNum)))then
  
!     Open the file
          INQUIRE(FILE=fln(flnNum),EXIST=exists)
          if(exists)then
          
            open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
            if(ios.ne.0)then
              print*,'Problems opening:',fln(flnNum)(1:40)
              print*
              STOP ' Stopped in read_lvl @ 39'
            endif
            print*,'Opened ',fln(flnNum)(1:40)
          else
            print*,fln(flnNum)(1:40),'not found'
            print*,'program continues without lake level analysis'
            lvlflg=.false.
            return
          endif

!    c      pause 2

!     Initialize default values
          CALL InitlvlParam(header)	
      
!    c	pause 3
      
!     Search for and read tb0 file header
          linecount=0
          line(1:1) = '#'
          foundEndHeader = .false.
          insideColMetaData = .false.
          no_hdr_lines=0

          write(51,*)
          write(51,*)'Level - observed level/elv. file'
          write(51,*)

          do WHILE((.NOT.foundEndHeader) .AND.((line(1:1) .eq. '#') .OR.(line(1:1) .eq. ':') .OR.(LEN_TRIM(line) .eq. 0)))   
                      linecount=linecount+1
!         if(iopt.eq.2)print*,'reading line ',linecount,' in read_lvl'
              read(UNIT=unitNum, FMT='((A))', iostat=ios) line!     read a line
              write(51,*)line(1:60)
              if(ios .eq. -1)then
                  write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
                  STOP ' Stopped in read_lvl @ 88'
              end if
              no_hdr_lines=no_hdr_lines+1
          
              rStat = Detab(line)         !     replace tabs with spaces
              line = ADJUSTL(line)    !     Get rid of leading white space
              lineLen = LEN_TRIM(line)    !     Find the length excluding trailing spaces

              if(line(1:1) .eq. ':')then
                  wordCount = SplitLine(line, keyword, subString) ! find the keyword
                  rStat = ToLowerCase(keyword)
                  KeyLen = LEN_TRIM(keyword)

                  if(keyword(1:KeyLen) .eq. ':endheader')then
                      foundEndHeader = .TRUE.
                  else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
                      insideColMetaData = .TRUE.
                  else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
                      insideColMetaData = .FALSE.
                  else if(insideColMetaData) then
                      iStat = ParseLvlColumnMetaData(colHeader,keyword,keyLen,subString)
                      if(iStat .lt. 0) then
                          write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                          write(*,'(2(A))') '   in line: ',line                   
                          STOP ' Stopped in read_lvl @113'
                          return
                      endif
                  else
                      iStat = ParseLvlParam(header,keyword,keyLen,subString)
                      if(iStat .lt. 0) then
                          write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                          write(*,'(2(A))') '   in line: ',line                   
                          STOP ' Stopped in read_lvl @122'
                          return
                      else if(iStat .eq. 0) then
!                         write(*,'((A), (A))')  'Unrecognized keyword line: ',
!         &                                       line
                      endif
                  end if
              endif
          
          end do  
!    ***************************************
!         Finished reading the header
!    ***************************************

!         nolvl    = no of level data data
          ktlvl =  header%tb0p%deltaT!    data time step in hours
          nolvl    = colHeader%tb0cmd%colCount
          print*,'no of level columns found =',nolvl
          print*,'no header lines =',no_hdr_lines

!    d     print*
!    d     print*,'In read_lvl'
!    d     print*,colHeader%tb0cmd%colCount
!    d     print*,'No of level columns found =',nolvl
!    d     print*

!    c      pause 111

      
!     Scan lines of data
          rewind unitNum
          nlines = CountDataLinesAfterHeader(unitNum)*ktlvl
          print*,'no of data lines found =',nlines
      
          rewind unitnum
          do n=1,no_hdr_lines
            read(unitnum,*)line
!    c        print*,line(1:60)
          end do
      

!         rev. 9.1.68  Dec.  19/04  - NK: rewrote rdflow c/w memory allocation 
!         rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
!         allocate stuff      
          if(firstpass)then
            n_max=n
            nold=nolvl
            nlines_old=nlines
            allocate(lvl_obs(nolvl,nlines),stat=iAllocate)
            allocate(lvl_calc(nolvl,nlines),stat=iAllocate)
            write(51,*)'lvl_obs dimensioned for:',nlines
            if(iAllocate.ne.0) STOP 'Error with allocation of arrays in read_lvl_ef @ 192'
          else                !      firstpass
!           check to see memory allocated is adequate      
            if(nolvl.ne.nold)then
              print*,'No of level stations has been changed in'
!         rev. 10.1.92 Aug   29/17  - NK: Fixed col check bug in read_lvl
              print*,'nold=',nold,' nolvl=',nolvl
              print*,'in file ',fln(53)(1:60)
              print*,'This is not permitted'
              print*
              stop 'Program aborted in read_lvl_ef @ 202'
            endif
            if(nlines.gt.nlines_old)then
              print*,'No of data lines have changed in'
              print*,'nlines_old=',nlines_old,' nlines=',nlines
              print*,'in file ',fln(53)(1:60)
              print*
!    c	  	if(n.gt.n_max)then
              n_max=n

!             the file length is longer than any of the previous events so 
!             more memory has to be allocated

!             DEALLOCATION OF ARRAYS FROM AREA10A:
              deallocate(lvl_obs,stat=iDeallocate)
              if(iDeallocate.ne.0)then
                print*,'Error with deallocation of lvl_obs'
                print*
                stop 'Program aborted in read_lvl_ef @ 220'
              endif
              allocate(lvl_obs(nolvl,nlines),stat=iAllocate)
              if(iAllocate.ne.0) STOP 'Allocation Error: arrays in read_lvl_ef @228'
                               nlines_old=nlines
              write(51,*)'lvl_obs re-dimensioned for:',nlines
            endif
          endif               !      firstpass

      
          if(.not.allocated(xlvl))then
!         rev. 10.1.69 Mar.  03/17  - NK: Changed allocation for lvl_reach in read_lvl.f 
              allocate(xlvl(nolvl),ylvl(nolvl),gname_lvl(nolvl),ewg_lvl(nolvl),sng_lvl(nolvl),&
                            lvl_reach(nolvl),stat=iAllocate)
            if(iAllocate.ne.0)then
              print*,'Error with allocation of station descripters'
              print*,' in read_lvl_ef'
              STOP 'Program aborted in read_lvl_ef @ 241'
            endif
          endif
  
!         ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
          do n=1,nolvl
            gname_lvl(n) = colHeader%tb0cmd%colName(n) ! station name
            xlvl(n) = colHeader%tb0cmd%colLocX(n) ! x coordinate
            ylvl(n) = colHeader%tb0cmd%colLocY(n) ! y coordinate
          end do
          deallocate(colHeader%tb0cmd%colName)
          deallocate(colHeader%tb0cmd%colLocX)
          deallocate(colHeader%tb0cmd%colLocY)

      
      else  !     FLtype(flnNum).eq.'tb0'
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_ts_levels_nc(flnNum)                                !     netCDF
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            lvlflg=.true.
      endif!     FLtype(flnNum).eq.'tb0'
      
!c      pause '261'

      if(firstpass)then
        write(51,*)(gname_lvl(n),gname_lvl(n),n=1,nolvl)
91101   format(<2*nolvl>(1x,a12))      
!     rev. 10.2.69 Nov.  11/19  - NK New level\levelstation.xyz to set locations of the level gages
        inquire(file='level\levelstations.xyz',EXIST=exists)          
        if(exists)then
!             Replace lvl file locations with those in levelstations.xyz          
              open(unit=99,file='level\levelstations.xyz',status='unknown',iostat=ios)
              if(ios.ne.0)then
                write(98,*)'Error: problems opening level\levelstations.xyz'&
                    'program aborted in read_level @ 276'
                stop
              endif
              l=0
              if(allocated(x_temp))deallocate(x_temp,y_temp,gname_temp)
              allocate(x_temp(no),y_temp(no),gname_temp(no),stat=iAllocate)
              do while(.not.eof(99))
                l=l+1
                read(99,*)x_temp(l),y_temp(l),gname_temp(l)
              end do
            
!             This is written so the order in the nudge flag file can be different from the flow file              
              do i=1,nolvl    ! flowstations.xyz file
                  do l=1,nolvl! flow file
                      ll1 = LEN_TRIM(gname_temp(i))
                      ll2 = LEN_TRIM(gname_lvl(l))
                      ll1=min(ll1,ll2)
                      if(gname_temp(i)(1:ll1).eq.gname_lvl(l)(1:ll1))then
                          ! when the station name matches, set lat-long to match also:
                          xlvl(l)=x_temp(i)
                          ylvl(l)=y_temp(i)
                      endif
                  end do
              end do
              deallocate(x_temp,y_temp,gname_temp)
        endif
      endif
      
!c      pause '269'

!     write lake level location file
!     rev. 9.8.38  Nov.  13/12  - NK: changed name level_plotting.xyz > level_station_location.xyz
!     rev. 10.1.85 May   17/17  - NK: Level_station_location.xyx for iopt > 0 only
      if(iopt99)then
        open(unit=99,file='level_station_location.xyz',status='unknown',iostat=ios)
        do l=1,nolvl
          i=l
          j=1+i/13
          k=j
          if(l.gt.13)i=l-(i/13)*13
          if(i.eq.0)i=13
          if(mod(i,13).eq.0)j=j-1
          write(99,*)xlvl(l),ylvl(l),l,gname_lvl(l),col2(j),col1(i),col2(k),col0(i)
!c 6012   format(2f15.3,i5,1x,a12,3x,2a1,3x,2a1)
        end do
        close(unit=99,status='keep')
      endif

      if(IsFileTypeTB0(fln(flnNum)))then
!       turn into local coordinates
        do n=1,nolvl
!c            ylvl(n)=(ylvl(n)-yorigin)/ydelta+1.0  
!c            xlvl(n)=(xlvl(n)-xorigin)/xdelta+1.0
!c            print*,n,'xlvl',xlvl(n),'ylvl',ylvl(n)
            ewg_lvl(n)=int((xlvl(n)-xorigin)/xdelta+1.0)
            sng_lvl(n)=int((ylvl(n)-yorigin)/ydelta+1.0)
          end do
          write(51,*)'Echo levels',ktlvl
          do j=ktlvl,nlines,ktlvl   
            read(unitNum,*,iostat=ios)(lvl_obs(n,j),n=1,nolvl)
            if(ios.ne.0)then
              print*, 'In read_lvl_ef @ 298'
              write(*,*)j,(lvl_obs(n,j),n=1,4)
              print*,'Got as far as data line',j
            endif
        end do
      endif  !     (IsFileTypeTB0(fln(flnNum)))then

!     rev. 10.2.31 Aug.  23/18  - NK: Echo recorded levels for iopt>=99 only 
      if(iopt99)then
          do j=ktlvl,nlines,ktlvl   
              write(51,*,iostat=ios)(lvl_obs(n,j),n=1,nolvl)
          end do
      endif
    
      close(unit=99,status='keep')

      close(unit=unitNum,status='keep',iostat=ios)
      if(ios.ne.0)then
		print*,'Problem closing unit 36 fln=',fln(6)
		print*
		stop ' program aborted in rdflow @ 623'
      endif

      if(firstpass)then
!       find out what lake (reach) each point is in
        write(51,*)
        write(51,*)'   level_station  grid#    reach#'
!        write(*,*)'   level_station  grid#       reach#'
        do l=1,nolvl
          if(sng_lvl(l).le.ycount.and.ewg_lvl(l).le.xcount.and.sng_lvl(l).gt.1.and.ewg_lvl(l).gt.1)then   ! added Jan. 23/14 NK
            n=s(sng_lvl(l),ewg_lvl(l))
            lvl_reach(l)=ireach(n)
            if(lvl_reach(l).eq.0)then
              errflg1=.true.
!c               write(*,*)l,n,lvl_reach(l)
            endif
!            write(51,*)l,n,lvl_reach(l)
          endif
        end do
      if(errflg1)then
        write(98,98000)'WARNING: 1 or more Level locations are not in lakes i.e.designated as a reach.         '
        write(98,98000)'WARNING: Please correct input data: Either add grid to a lake or move the level station'
        write(98,98000)'WARNING: into a grid designated as a reach. Put the level_station_location.xyz file on '
        write(98,98000)'WARNING: the map file with the reach entries showing. If you don`t elect to make this  '
        write(98,98000)'WARNING: change, the data will be set to -999 for a dummy reach - CHARM may crash      '
98000   format(a88)
!       don't delete this stop!!  will crash in lst        
!        stop 'Program terminated in read_lvl_ef @ 312'
      endif
      endif

      firstpass=.false.  ! reset for next event to read header only
      
      return

      END SUBROUTINE read_level
      SUBROUTINE read_lvl(unitNum,flnNum)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***************************************************************************
! PROGRAM BY: NK  June 2012
!
      use area_watflood
      USE EF_Module

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      implicit none
      save

      TYPE(LvlParam) :: header
      TYPE(LvlColumnMetaData) :: colHeader

      CHARACTER(1) :: new
      INTEGER      :: jan,ju,iallcnt2,iallocate,n,ii,i,j,k,l,nold
      integer      :: n_max,ideallocate,no_hdr_lines
      integer      :: ios,linecount,unitnum,flnNum,iStat
      integer      :: nlines,nlines_old
      REAL*4       :: time,ttime,taold,temmmp  
      character*16 :: swe_file              
      logical      :: exists,firstpass,errflg1

! Local variables
      character*128 keyword, value
      character*4096 line, subString, tmpString
      CHARACTER(1)  :: col0(13),col1(13),col2(26)
      integer lineLen, keyLen, wordCount
      logical rStat, lineType, foundEndHeader, insideColMetaData

      save
      
      DATA new/'f'/firstpass/.true./errflg1/.false./
      DATA iallcnt2/0/

      DATA col1/'b','d','f','h','j','l','n','p','r','t','v','x','z'/
      DATA col0/'c','e','g','i','k','m','o','q','s','u','w','y','a'/
      DATA col2/' ','a','b','c','d','e','f','g','h','i','j','k','l'
     *         ,'m','n','o','p','q','r','s','t','u','v','w','x','y'/

d      if(iopt.eq.2)print*,'in melt @ 0'

      print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
      print*,'NEW  <<<<<'

! Open the file
      INQUIRE(FILE=fln(flnNum),EXIST=exists)
      if(exists)then
        open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
        if(ios.ne.0)then
          print*,'Problems opening:',fln(flnNum)(1:40)
          print*
          STOP ' Stopped in read_lvl @ 39'
        endif
        print*,'Opened ',fln(flnNum)(1:40)
      else
        print*,fln(flnNum)(1:40),'not found'
        print*,'program continues without lake level analysis'
        lvlflg=.false.
        return
      endif

c      pause 2

! Initialize default values
      CALL InitlvlParam(header)	
      
c	pause 3
      
! Search for and read tb0 file header
      linecount=0
      line(1:1) = '#'
      foundEndHeader = .false.
      insideColMetaData = .false.
      no_hdr_lines=0

      write(51,*)
      write(51,*)'Level - observed level/elv. file'
      write(51,*)

      do WHILE((.NOT.foundEndHeader) .AND.
     &        ((line(1:1) .eq. '#') .OR.
     &        (line(1:1) .eq. ':') .OR.
     &        (LEN_TRIM(line) .eq. 0)))   
                  linecount=linecount+1
!     if(iopt.eq.2)print*,'reading line ',linecount,' in read_lvl'
          read(UNIT=unitNum, FMT='((A))', iostat=ios) line    ! read a line
          write(51,*)line(1:60)
          if(ios .eq. -1)then
              write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
              STOP ' Stopped in read_lvl @ 88'
          end if
          no_hdr_lines=no_hdr_lines+1
          
          rStat = Detab(line)             ! replace tabs with spaces
          line = ADJUSTL(line)        ! Get rid of leading white space
          lineLen = LEN_TRIM(line)        ! Find the length excluding trailing spaces

          if(line(1:1) .eq. ':')then
              wordCount = SplitLine(line, keyword, subString) ! find the keyword
              rStat = ToLowerCase(keyword)
              KeyLen = LEN_TRIM(keyword)

              if(keyword(1:KeyLen) .eq. ':endheader')then
                  foundEndHeader = .TRUE.
              else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
                  insideColMetaData = .TRUE.
              else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
                  insideColMetaData = .FALSE.
              else if(insideColMetaData) then
                  iStat = ParseLvlColumnMetaData(colHeader,
     &                        keyword,keyLen,subString)
                  if(iStat .lt. 0) then
                      write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                      write(*,'(2(A))') '   in line: ',line                   
                      STOP ' Stopped in read_lvl @113'
                      return
                  endif
              else
                  iStat = ParseLvlParam
     *                (header,keyword,keyLen,subString)
                  if(iStat .lt. 0) then
                      write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                      write(*,'(2(A))') '   in line: ',line                   
                      STOP ' Stopped in read_lvl @122'
                      return
                  else if(iStat .eq. 0) then
!                     write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &                                       line
                  endif
              end if
          endif
          
      end do  
!***************************************
!     Finished reading the header
!***************************************

!     nolvl    = no of level data data
      ktlvl =  header%tb0p%deltaT    !data time step in hours
      nolvl    = colHeader%tb0cmd%colCount
      print*,'no of level columns found =',nolvl
      print*,'no header lines =',no_hdr_lines

d     print*
d     print*,'In read_lvl'
d     print*,colHeader%tb0cmd%colCount
d     print*,'No of level columns found =',nolvl
d     print*

c      pause 111

      
! Scan lines of data
      rewind unitNum
      nlines = CountDataLinesAfterHeader(unitNum)*ktlvl
      print*,'no of data lines found =',nlines
      
      rewind unitnum
      do n=1,no_hdr_lines
        read(unitnum,*)line
c        print*,line(1:60)
      end do
      

!     rev. 9.1.68  Dec.  19/04  - NK: rewrote rdflow c/w memory allocation 
!     rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
!     allocate stuff      
      if(firstpass)then
        n_max=n
        nold=nolvl
        nlines_old=nlines
        allocate(lvl_obs(nolvl,nlines),stat=iAllocate)
        allocate(lvl_calc(nolvl,nlines),stat=iAllocate)
        write(51,*)'lvl_obs dimensioned for:',nlines
        if(iAllocate.ne.0) STOP
     *		'Error with allocation of arrays in read_lvl_ef @ 192'
      else                    !  firstpass
!       check to see memory allocated is adequate      
        if(nolvl.ne.nold)then
          print*,'No of level stations has been changed in'
!     rev. 10.1.92 Aug   29/17  - NK: Fixed col check bug in read_lvl
          print*,'nold=',nold,' nolvl=',nolvl
          print*,'in file ',fln(53)(1:60)
          print*,'This is not permitted'
          print*
          stop 'Program aborted in read_lvl_ef @ 202'
        endif
        if(nlines.gt.nlines_old)then
          print*,'No of data lines have changed in'
          print*,'nlines_old=',nlines_old,' nlines=',nlines
          print*,'in file ',fln(53)(1:60)
          print*
c	  	if(n.gt.n_max)then
          n_max=n

!         the file length is longer than any of the previous events so 
!         more memory has to be allocated

!         DEALLOCATION OF ARRAYS FROM AREA10A:
          deallocate(lvl_obs,stat=iDeallocate)
          if(iDeallocate.ne.0)then
            print*,'Error with deallocation of lvl_obs'
            print*
            stop 'Program aborted in read_lvl_ef @ 220'
          endif
          allocate(lvl_obs(nolvl,nlines),
     *         				stat=iAllocate)
          if(iAllocate.ne.0) STOP
     *	      'Allocation Error: arrays in read_lvl_ef @228'
                           nlines_old=nlines
          write(51,*)'lvl_obs re-dimensioned for:',nlines
        endif
      endif                   !  firstpass

      
      if(.not.allocated(xlvl))then
!     rev. 10.1.69 Mar.  03/17  - NK: Changed allocation for lvl_reach in read_lvl.f 
          allocate(xlvl(nolvl),ylvl(nolvl),gname_lvl(nolvl),
     *                   ewg_lvl(nolvl),sng_lvl(nolvl),
     *                   lvl_reach(nolvl),stat=iAllocate)
        if(iAllocate.ne.0)then
          print*,'Error with allocation of station descripters'
          print*,' in read_lvl_ef'
          STOP 'Program aborted in read_lvl_ef @ 241'
        endif
      endif
  
!     ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
      do n=1,nolvl
        gname_lvl(n) = colHeader%tb0cmd%colName(n) ! station name
        xlvl(n) = colHeader%tb0cmd%colLocX(n) ! x coordinate
        ylvl(n) = colHeader%tb0cmd%colLocY(n) ! y coordinate
      end do
      deallocate(colHeader%tb0cmd%colName)
      deallocate(colHeader%tb0cmd%colLocX)
      deallocate(colHeader%tb0cmd%colLocY)

c      pause '261'

      if(firstpass)then
        write(51,*)(gname_lvl(n),gname_lvl(n),n=1,nolvl)
91101   format(<2*nolvl>(1x,a12))      
      endif

c      pause '269'

!     write lake level location file
!     rev. 9.8.38  Nov.  13/12  - NK: changed name level_plotting.xyz > level_station_location.xyz
!     rev. 10.1.85 May   17/17  - NK: Level_station_location.xyx for iopt > 0 only
      if(iopt99)then
        open(unit=99,file='level_station_location.xyz',
     *            status='unknown',iostat=ios)
        do l=1,nolvl
          i=l
          j=1+i/13
          k=j
          if(l.gt.13)i=l-(i/13)*13
          if(i.eq.0)i=13
          if(mod(i,13).eq.0)j=j-1
          write(99,*)xlvl(l),ylvl(l),l,gname_lvl(l),
     *                  col2(j),col1(i),col2(k),col0(i)
c 6012   format(2f15.3,i5,1x,a12,3x,2a1,3x,2a1)
        end do
        close(unit=99,status='keep')
      endif

!     turn into local coordinates

      do n=1,nolvl
        ylvl(n)=(ylvl(n)-yorigin)/ydelta+1.0  
        xlvl(n)=(xlvl(n)-xorigin)/xdelta+1.0
c        print*,n,'xlvl',xlvl(n),'ylvl',ylvl(n)
        ewg_lvl(n)=int(xlvl(n))
        sng_lvl(n)=int(ylvl(n))
      end do

c      pause 297

      write(51,*)'Echo levels',ktlvl
      do j=ktlvl,nlines,ktlvl   
        read(unitNum,*,iostat=ios)(lvl_obs(n,j),n=1,nolvl)
        if(ios.ne.0)then
          print*, 'In read_lvl_ef @ 298'
c          write(*,*)j,(lvl_obs(n,j),n=1,4)
          print*,'Got as far as data line',j
        endif
      end do
!     rev. 10.2.31 Aug.  23/18  - NK: Echo recorded levels for iopt>=99 only 
      if(iopt99)then
          do j=ktlvl,nlines,ktlvl   
              write(51,*,iostat=ios)(lvl_obs(n,j),n=1,nolvl)
          end do
      endif
    
      close(unit=99,status='keep')

      close(unit=unitNum,status='keep',iostat=ios)
      if(ios.ne.0)then
		print*,'Problem closing unit 36 fln=',fln(6)
		print*
		stop ' program aborted in rdflow @ 623'
      endif

      if(firstpass)then
!       find out what lake (reach) each point is in
        write(51,*)
        write(51,*)'   level_station  grid#    reach#'
        write(*,*)'   level_station  grid#       reach#'
        do l=1,nolvl
          if(sng_lvl(l).le.ycount.and.ewg_lvl(l).le.xcount
     *             .and.sng_lvl(l).gt.1.and.ewg_lvl(l).gt.1)then   ! added Jan. 23/14 NK
            n=s(sng_lvl(l),ewg_lvl(l))
            
c            print*,l,n
c            print*,ireach(n)
c            print*,lvl_reach(l)
            lvl_reach(l)=ireach(n)
            if(lvl_reach(l).eq.0)then
              errflg1=.true.
c               write(*,*)l,n,lvl_reach(l)
            endif
            write(51,*)l,n,lvl_reach(l)
          endif
        end do
        
      if(errflg1)then
        print*
        print*,'WARNING'
        print*,'1 or more Level locations are not in lakes'
        print*,'designated as a reach - i.e. in a lake'
        print*,'Please correct input data:'
        print*,'Either add grid to a lake or move the level station'
        print*,'into a grid designated as a reach'
        print*,'Put the level_station_location.xyz file on the '
        print*,'map file with the reach entries showing' 
        print*,'If you don`t elect to make this change, the'
        print*,'date will be set to -999 for a dummy reach'
!       don't delete this stop!!  will crash in lst        
!        stop 'Program terminated in read_lvl_ef @ 312'
      endif
      endif

      firstpass=.false.  ! reset for next event to read header only
      
      return

      END SUBROUTINE read_lvl
      subroutine read_outfiles
      
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.1.76 Apr.  05/17  - NK: Reorganized the outfiles.* file
      
      use area_watflood
      USE EF_module
      save
      logical exists
      integer i,j,ios
      
      ! THE OUTFILES.TXT FILE READS THE NAMES OF ALL THE OUTPUT FILES
      outfileflg='n'    ! used in sub
      ioflg=0
      INQUIRE(FILE='outfiles.txt',EXIST=exists)
      IF(exists)THEN
	  outfileflg='y'
        open(unit=99,file='outfiles.txt',
     *               status='old',iostat=ios)
        if(ios.eq.0)then
          print*
!         AN OUTFILES.TXT FILE EXISTS AND WE'LL READ IT:
          print*,'reading outfile names'
          read(99,*)  ! header line
          do i=26,30
            ioflg=ioflg+1
            read(99,5001,iostat=ios)j,outfln(i)
d            print*,i,j,outfln(i)(1:50)
            if(ios.ne.0)then 
              print*,'Problems on unit 99'
              print*,'Warning: error reading file name outfiles.txt'
              print*,'possible cause: existing file is read-only'
              print*,'or end of file is reached - need 76 lines'
              print*,'iostat code =',ios
	        print*,'Got as far as line ',ioflg
              STOP 'program aborted in spl.for @ 810'
            endif
          end do
          do i=51,80
            ioflg=ioflg+1
            read(99,5001,iostat=ios)j,outfln(i)
d            print*,i,j,outfln(i)(1:50)
            if(ios.ne.0)then 
              print*,'Problems on unit 99'
              print*,'Warning: error reading file name outfiles.txt'
              print*,'possible cause: existing file is read-only'
              print*,'or end of file is reached'
              print*,'iostat code =',ios
	        print*,'Got as far as line ',ioflg
              STOP 'program aborted in spl.for @ 771'
            endif
          end do
          do i=90,100
            ioflg=ioflg+1
            read(99,5001,iostat=ios)j,outfln(i)
d            print*,i,j,outfln(i)(1:50)
            if(ios.ne.0)then 
              print*,'Problems on unit 99'
              print*,'Warning: error reading file name outfiles.txt'
              print*,'possible cause: existing file is read-only'
              print*,'or end of file is reached - need 76 lines'
              print*,'iostat code =',ios
	        print*,'Got as far as line ',ioflg
              STOP 'program aborted in spl.for @ 797'
            endif
          end do
          do i=901,900+classcount
            ioflg=ioflg+1
            read(99,5001,iostat=ios)j,outfln(i)
d            print*,i,j,outfln(i)(1:50)
            if(ios.ne.0)then 
              print*,'Problems on unit 99'
              print*,'Warning: error reading file name outfiles.txt'
              print*,'possible cause: existing file is read-only'
              print*,'or end of file is reached - need 76 lines'
              print*,'iostat code =',ios
	        print*,'Got as far as line ',ioflg
              STOP 'program aborted in spl.for @ 784'
            endif
          end do
          close(unit=99)
!         opened in watbal.for
          fln(61)=outfln(61)
          fln(67)=outfln(67)           !used in write_r2s
          fln(70)=filename(70)             !used in write_tb0
	    fln(72)=outfln(72)
	    fln(79)=outfln(79)
	    fln(100)=outfln(100)
          filename(96)=outfln(96)
          filename(97)=outfln(97)
          fln(100)=outfln(100)             !used in write_r2c
          print*,'finished reading outfiles.txt'
          print*
        else
          write(98,*)'Error: opening outfiles.txt'
	    write(98,*)'Error: Continuing using default output files'
        endif 
      else
       write(98,*)'Info: outfiles.txt file not found, defaults used'
      endif
 5001 format(i5,a256)

      return
      
      END SUBROUTINE read_outfiles
c      SUBROUTINE read_rain_ef(hdrflg,jz,jan,timeHrs)
      SUBROUTINE read_rain_ef(hdrflg,conv,jz,jan)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
c      arguments changed  Nov. 9/06 nk
c      SUBROUTINE read_rain_ef(hdrflg,conv,scale,jan,timeHrs)
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced Precip & temp files for sub-basins
!     rev. 9.7.18  Jan.  17/11  - NK: Changed tolerance on the grid check in rear_rain & read_temp
!     rev. 9.8.59  May   14/13  - NK: REmoved psmear & punused from the program
!     rev. 9.9.07  Jan.  10/14  - NK: Overhaul of the frame numbers to EnSim specs
 
C*****************************************************************************
C  READ_RAIN_EF - written Mar/06 by Dave Watson, CHC
C     - Derived from rdrain written by Nick Kouwen
C     This subroutine reads the ensim compatible gridded rain (MET) file 
C     (r2c format)
C*****************************************************************************

c     use area1
c     use area2
c      use area3
c     use area6   ! added for sum_precip  nk Dec. 29/06 nk
c     use area10
c     use area12
c     use area16

      use area_watflood

C R2C data module
      use EF_Module
      implicit none
      type(RainParam) :: header
      type(FrameRecord) :: frameRec


C SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      save

      character(1) :: hdrflg,firstpass
      logical      :: exists
      integer  :: jan,i,j,n,ios,jz,
     *              iAllocate,iDeallocate,
     *              xcount_max,ycount_max
      real*4   :: conv,scale
      real*4      timeHrs
      data firstpass/'y'/

C Local variables
      integer*4 unitNum, flnNum, iStat
      character*4096 line, subString
      character*128 keyword, value 
      character*10 junk
      integer lineLen, keyLen, wordCount
      logical rStat, foundEndHeader,foundFirstFrame,foundFrame
      integer frameCount
      integer framesSkipped !# of frames skipped beforefirst data /nk
      integer modelHour !used to be k
      integer modelHourLast !used to be klast
      integer dataHour !used to be nr_count
      integer yearLLL
      integer monthLLL 
      integer dayLLL 
      integer hourLLL

C Dave's debug variables
C     integer daveInt
C     real daveReal

C Initialize default values within frame module
      CALL InitFrameRecord(frameRec)

C Set unit and fln number
      unitNum = 40
      flnNum = 10
      
C Debug line
C     print*, 'Inside read_rain_ef at time = ',timeHrs, 'hrs'

C If hdrflg==1 ,then it's the first time through for this event
      if(hdrflg.eq.'1')then
       
c            open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
c            if(ios.ne.0)then
c              print*, 'Problems opening the met file',fln(flnNum)
c              STOP ' Stopped in read_rain_ef @ 82'
c            endif
            
	  	inquire(FILE=fln(flnNum),EXIST=exists)
		    if(exists) then
		      open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	          if(ios.ne.0)then
		        print*, 'Problems opening file',fln(flnNum)(1:40)
		        STOP ' Stopped in read_rain_ef @ 89'
		      endif
	          if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
                if(iopt.ge.2)then
                  print*,'If program dies here, check to see'
                  print*,'there`s data in the met file'
                endif
		    else
		      print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	          print*, 'Unit number ',unitNum
		      print*, 'but it is not found (in this location)'
		      STOP 'Program aborted in read_rain @95'
		    endif

C Initialize default values within rain module
            call InitRainParam(header)    

C Search for and read r2c file header
            line(1:1) = '#'
            foundEndHeader = .false.
            do while((.NOT.foundEndHeader) .AND.
     &          ((line(1:1) .eq. '#') .OR.
     &            (line(1:1) .eq. ':') .OR.
     &            (len_trim(line) .eq. 0)))     

                  read(unit=unitNum, FMT='((A))', iostat=ios) line      ! read a line
                  if(ios .eq. -1)then
                        print*, 'ERROR: Premature EndOfFile encountered'
                        STOP ' Stopped in read_rain_ef'
                  end if

d      if(iopt.eq.3)print*,line(1:40)

                  rStat = Detab(line)                       ! replace tabs with spaces
                  line = adjustl(line)          ! Get rid of leading white space
                  lineLen = len_trim(line)            ! Find the length excluding trailing spaces

                  if(line(1:1) .eq. ':')then
                        wordCount = SplitLine(line, keyword, subString) ! find the keyword
                        rStat = ToLowerCase(keyword)
                        KeyLen = len_trim(keyword)

                        if(keyword(1:KeyLen) .eq. ':endheader')then
                              foundEndHeader = .TRUE.
                        else
                              ! parse the header
                          iStat = ParseRainParam(header,keyword,keyLen,
     &                                                      subString)
                              if(iStat .lt. 0) then
                        write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                                  write(*,'(2(A))') '   in line: ',line                             
                                    STOP ' Stopped in read_rain_ef'
                                    return
                              else if(iStat .eq. 0) then
C                                   write(*,'((A), (A))')
C     &                                               'Unrecognized keyword line: ',line
                              endif
                        end if
                  end if
            end do

C Assign the parsed parameters to the model variables       
            xcount2 = header%r2cp%xCount
            ycount2 = header%r2cp%yCount
            xorigin2 = header%r2cp%xOrigin
            yorigin2 = header%r2cp%yOrigin
            xdelta2 = header%r2cp%xDelta
            ydelta2 = header%r2cp%yDelta
            
            conv = header%r2cp%unitConv   
            
!           for grid consistency checking
            xcount_precip=xcount2
            ycount_precip=ycount2            
            
C Scan data frames
            frameCount = 0
            do while((.NOT.EOF(unitNum)))
                  read(unit=unitNum, FMT='((A))', iostat=ios) line      ! read a line
d                 if(iopt.eq.3)print*,line(1:40)
                  if(ios .eq. -1)then
               write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
                        STOP ' Stopped in read_rain_ef'
                  end if

                  rStat = Detab(line)                       ! replace tabs with spaces
                  line = adjustl(line)          ! Get rid of leading white space
                  lineLen = len_trim(line)            ! Find the length excluding trailing spaces

                  if(line(1:1) .eq. ':')then
                        wordCount = SplitLine(line, keyword, subString) ! find the keyword
                        rStat = ToLowerCase(keyword)
                        KeyLen = len_trim(keyword)
                        
                        if(keyword(1:KeyLen).eq.':frame')then
                         iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &                                subString)
                              frameCount = frameCount+1
                              
C     Identify the first and last frame's timestamp 
                              if(iStat .lt. 0) then
                         write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                                 write(*,'(2(A))') '   in line: ',line                             
                                    STOP ' Stopped in read_flow_ef'
                                    return
                              else if(iStat .eq. 0) then
C                                   write(*,'((A), (A))')
C     &                                               'Unrecognized keyword line: ', line
                              else if(frameCount.EQ.1) then
                                    header%startJulianDay =
     &                                    JDATE(frameRec%tStamp%year,
     &                                          frameRec%tStamp%month,
     &                                          frameRec%tStamp%day)
                                 header%startHour = frameRec%tStamp%hour
                              else
                                    header%endJulianDay =
     &                                    JDATE(frameRec%tStamp%year,
     &                                          frameRec%tStamp%month,
     &                                          frameRec%tStamp%day)
                                   header%endHour = frameRec%tStamp%hour
                              end if
                              header%r2cp%frameCount = frameCount
                        end if
                  end if
            enddo 
      
C     deltat2 = model timestep in hours 
            deltat2 = 1 
C     nr = number of hours spanned by this met file
C     convert to julian days to properly calculate hours spanned
            nr = (header%endJulianDay - header%startJulianDay)*24
     &                         + (header%endHour - header%startHour) + 1
      

C     Position to start of data (immediately after first frame record but before first frame data)
            REWIND (unitNum)
            foundFirstFrame = .false.
            do WHILE(.NOT.foundFirstFrame)
                  read(unit=unitNum, FMT='((A))', iostat=ios) line      ! read a line
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
                   precip_frame_header=line
                  new_precip_frame_header=line
                  precip_flg=.true.
                  if(line(1:1) .eq. ':')then
                       wordCount = SplitLine(line, keyword, subString) ! find the keyword
                        rStat = ToLowerCase(keyword)
                        KeyLen = len_trim(keyword)
                        if(keyword(1:KeyLen).eq.':frame')then
                              iStat = ParseFrameLine(frameRec,keyword,
     &                                              keyLen,subString)
                              foundFirstFrame = .true.
                        end if
                  end if                  
            enddo 


!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     changed Dec. 4/07 nk to allow for missing data at start of met file
      backspace unitNum
      read(unitNum,*)junk,modelHour
      framesSkipped=modelHour-1
c           modelHour=1 ! set model hour to first hour
c      print*,junk,modelhour,framesSkipped
c      pause 1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            dataHour = 0 ! set data hour to just before first hour

C Are we LatLong or Projected
            if(IsLatLong(header%r2cp%csp).eq.(.true.))then
                  rgrde=xdelta2*60.
                  rgrdn=ydelta2*60.  
                  rads=int(yorigin2*60.0)
                  radn=int((yorigin2+ycount2*ydelta2)*60.0) 
                  radw=int(xorigin2*60.0)  
                  rade=int((xorigin2+xcount2*xdelta2)*60.0)  
            else    
                  rgrde=xdelta2/1000.
                  rgrdn=ydelta2/1000. 
                  rads=int(yorigin2/1000.)
                  radn=iymin+grde*(ycount2-1)
                  radw=int(xorigin2/1000.)
                  rade=jxmin+grdn*(xcount2-1)
                  if(abs(xdelta2-ydelta2).lt.0.001)then  !changed jan21/08 nk
                        rgrd=xdelta2/1000.
                  else
                        print*, 'ERROR - xdelta .ne. ydelta'
	                  print*,' xdelta =',xdelta
	                  print*,' ydelta =',ydelta
                        STOP 'Program aborted in read_rain_ef @ 249'
                  endif
            endif

C firstpass means this is the first met file of the first event...which is the only time it needs to be done
            if(firstpass.eq.'y')then
                  firstpass='n'        
                  xcount_max=max(xcount+1,xcount2)
                  ycount_max=max(ycount+1,ycount2)
                allocate(p(ycount_max,xcount_max),
     *                 sum_precip(ycount_max,xcount_max),
     *                 stat=iAllocate)
c     *                 psmear(na),punused(na),stat=iAllocate)
                       if(iAllocate.ne.0) STOP
     *       'Error with allocation of area6/16a arrays in read_rain_ef'
c                  xcount_max=xcount2
c                  ycount_max=ycount2
            endif

      if(jan.eq.1)then     
C       CALCULATE THE GRID OFFSETS:
            if(iymin.ge.rads.and.jxmin.ge.radw)then
C         COMPARE THE SOUTH-WEST CORNER COORDINATES
                  if(IsLatLong(header%r2cp%csp).eq.(.true.))then
                        iyoffset=int(float(iymin-rads)/rgrdn)+iyshift
                        jxoffset=int(float(jxmin-radw)/rgrde)+jxshift
                  else
                        iyoffset=int(float(iymin-rads)/grdn)+iyshift
                        jxoffset=int(float(jxmin-radw)/grde)+jxshift
                  endif
            elseif(abs(iymin-rads).gt.1.or.abs(jxmin-radw).gt.1)then
!     rev. 9.7.18  Jan.  17/11  - NK: Changed tolerance on the grid check in rear_rain & read_temp
!         WATERSHED GRID IS NOT WITHIN MET GRID
                  print*
                  print*,'WARNING:'
                  print*,' In read_rain_ef:'
                  print*,'Met grid does not coincide with shd file'
                  print*,'This could be due to round off when using'
                  print*,'fractions of degrees as the grid size'
                  print*,'iymin,jxmin,rads,radw/',iymin,jxmin,rads,radw
                  print*,'Please check the headers on the shd & met'
                  print*,'for compatibility'
                  print*                     
                  STOP 'Program aborted in read_rain_ef @ 301'
            else
                  iyoffset=0
                  jxoffset=0
                  ! DO NOTHING
            endif

!     rev. 9.5.16  Feb.  28/08  - NK: moved precip_adjust to sub
c            call precip_adjust()

!       initialize sum_precip
        do i=1,ycount2  
          do j=1,xcount2
            sum_precip(i,j)=0.0
          end do
        end do
      endif   ! END OF JAN=1

C Check for change of grid size
      if(xcount2.gt.xcount_max.or.ycount2.gt.ycount_max)then
            deallocate(p,stat=iDeallocate)
            if(iDeallocate.ne.0) then
              print*,     'Warning: error with deallocation of outarray'
            endif

            xcount_max=xcount2
            ycount_max=ycount2
C       outarray is in areawfo
C       this has to be allocated before calling write_r2c
            allocate(p(ycount_max,xcount_max),stat=iAllocate)
            if(iAllocate.ne.0) then
                  STOP 'Error with allocation of outarray in tr_sub'      
            end if
      endif

!     rev. 10.2.33 Sep.  14/18  - NK: Changed unit=42  fln(12) from clutter to model\*.r2c file '
!           needed when there is only one hour of data in an r2c file      
!           probably should be added to all read r2c s/r's      
            modelHourLast=0

      
            return
      endif          ! (hdrflg.eq.'1')

C***********************************************************
C************************************
C     Finished reading the header 
C************************************   
C***********************************************************

C     We are looking for rain data for this step
      dataHour = dataHour + 1
c        print*,'modelHourLast =',modelHourLast
c        print*,'modelHour =',modelhour,'  ',fln(flnNum)(1:40)
c      if(modelHour.eq.modelHourLast)then
      if(modelHour.eq.modelHourLast)then
        print*,'modelHourLast =',modelHourLast
        print*,'modelHour =',modelhour,' Error in ',fln(flnNum)(1:40)
     *                 ,' met data repeated??'
        write(*,51000)'Error in the met file @ frame #',frameRec%frame
     &            ,frameRec%tStamp%year,'/',frameRec%tStamp%month,'/',
     &            frameRec%tStamp%day,'/',frameRec%tStamp%hour

        write(*,*)'Same time stamp as previous?'
        write(51,*)'Error in the met file @ frame #',frameRec%frame,
     &            frameRec%tStamp%year,'/',frameRec%tStamp%month,'/',
     &            frameRec%tStamp%day,'/',frameRec%tStamp%hour
51000   format(a34,i10,i8,a1,i4,a1,i4,a1,i4) 
        print*
        print*,'Possible cause:'
        print*,'If this file is based on model data, this error can'
        print*,'result from overlapping frames - e.g. last frame in one'
        print*,'monthly CaPA file = same as first frame in next month'
        print*,line(1:62) 
        
        
        
        
        stop 'Program aborted in read_rain @ 379'
        
        
        
        

      endif    
 
C     If there is a record for this hour than modelHour = dataHour

c      print*,'modelHour:',modelHour, 'dataHour:',dataHour
c      print*,'modelHour:',modelHour, 'spl hour:',jz
c      pause


c     if(modelHour.eq.dataHour)then

c      print*,'modelHour,jz',modelHour,jz

      if(modelHour.eq.jz)then
!           the modelHour is found after reading the previous data. 
!           I.e. it is the hour
!           of the next set of data. So here we just wait until 
!           we get the next data set.
C           Go ahead and read the data for this frame 
            do i=1,ycount2
!                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                  read(unitNum,*,iostat=ios)(p(i,j),j=1,xcount2)
99955             format(999f6.1)                  
!                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                  if(ios.ne.0)then
                        write(*,9993)modelHour,i
                        print*,' last data read:'
                        print*,' jradw= 1 jrade= ',jrade
                        print*,' iradn= ',iradn,' irads= 1'
                        STOP ' program aborted - read_rain_ef'
                  endif
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
                  precip_frame_header=new_precip_frame_header
                  precip_flg=.true.
            end do
!           sum_precip as read in
!           see also addition of snow in read_gsn.f
            do i=1,ycount2  
              do j=1,xcount2
                 sum_precip(i,j)=sum_precip(i,j)+p(i,j)*conv
              end do
            end do

C           Read the next frame. If we are at the end of the file...close
            foundFrame = .false.
            do WHILE(.NOT.foundFrame)
                  read(unit=unitNum, FMT='((A))', iostat=ios) line      ! read a line
c                  print*,'rain ',line(1:60)
                  if(EOF(unitNum)) then 
                        close(unit=unitNum,status='keep',iostat=ios)
                        RETURN
                  endif
                  if(line(1:1) .eq. ':')then
                        wordCount = SplitLine(line, keyword, subString) ! find the keyword
                        rStat = ToLowerCase(keyword)
                        KeyLen = len_trim(keyword)
                        if(keyword(1:KeyLen).eq.':frame')then
                              iStat = ParseFrameLine(frameRec,keyword,
     &                                    keyLen,subString)
                              foundFrame = .true.
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
                              new_precip_frame_header=line
                              new_precip_flg=.true.
                        end if
                  end if            
                  
            enddo 

            modelHourLast=modelHour

            yearLLL=frameRec%tStamp%year
            monthLLL=frameRec%tStamp%month
            dayLLL=frameRec%tStamp%day
            hourLLL=frameRec%tStamp%hour
            
C           Determine the next modelhour        
            modelHour = 
     &           (JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &            frameRec%tStamp%day) - header%startJulianDay) * 24
     &            + (frameRec%tStamp%hour - header%startHour) + 1
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                 changed Dec. 4/07 nk to allow for missing data at start of met file
     &            +framesSkipped
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           check added May 2/12  nk
!     rev. 10.2.24 May   21/18  - NK: Added error message in Read_rain & read_tmp
            if(modelHour-modelHourLast.lt.0)then
              print*,'modelHourLast =  ',modelHourLast
              print*,'modelHour =      ',modelHour
              print*,'headerStartHour =',header%startHour
              print*,'Note: Frame date & time must be monotomically '
              print*,'increasing in an r2c time series file.'
              print*,'Stopped at:'
              print*,line(1:72)
              print*,'year  ',frameRec%tStamp%year
              print*,'month ',frameRec%tStamp%month
              print*,'day   ',frameRec%tStamp%day
              print*,'hour  ',frameRec%tStamp%hour
              print*,'Previour frame @:'
              print*,'year  ',yearLLL
              print*,'month ',monthLLL
              print*,'day   ',dayLLL
              print*,'hour  ',hourLLL
              print*
              print*,'possible cause: month repeated in ',
     *                                     fln(flnNum)(1:40)
              print*
              stop 'Program aborted in read_rain_ef @ L411'
            endif
c           print*,'in read_rain modelHour=',modelHour
c	      print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      else                          !IF(K.EQ.1)...
c           print*,'                                skipped read'
!           No data this hour
!           Nothing was read in this call in this time step
!           The model is continuing with zero precip until 
!           an hour with precip is found
            do i=1,ycount2  
              do j=1,xcount2
                p(i,j)=0.0
              end do
            end do
      endif
      RETURN

!     FORMATS

 9993 format(' error reading precip at hour/line ',2i10/)
      
      END SUBROUTINE read_rain_ef
      subroutine rdresume()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.2.31  Feb.  09/06  - NK: Added area check to rdresume
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
!     rev. 9.8.87  Oct.  25/13  - NK: Added error message for mismatched resume file

      use area_watflood
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      real*4, dimension(:),   allocatable :: area_temp

      DIMENSION     :: smc5(16)
      CHARACTER(14) :: date
      CHARACTER(3)  :: eofmark
      CHARACTER(1)  :: lineflg,smok,change_flag
      character(20) :: junk
      character(256) :: line
      REAL(4)		:: optlow,time,tot1,qwert,conv,scale,&
                  smc5,tj1,clock,t,thr,dtmin,dtmax,div,aintvl,sintvl,&
                  tot2,tdum,qtemp,diff2,sdlz,&
                  wfo_spec_version_number
      INTEGER       :: rbin,inta,block,no1,classcount1,na1,&
                      ycount1,xcount1,&
                      iallcnt1,n1,ii1,jan,m,ios,n,iallocate,&
                      l,ii,juold,jj,lun,nhr,nhf,&
                      i,j,icase,iz,jz,nchr,mz,ju,mon,&
                      iwest,ieast,isouth,inorth,nocolumns,nno,k,&
                      nu,igrdshft,minsnwflg,oldjan,flgevp22,&
                      noresv1,nj,npick,n_version
      CHARACTER(128):: qstr
      character*15  :: junk1
      logical       :: exists

      INTEGER(kind=2) :: result1,ntest

      CHARACTER(10) :: coordsys
!      INTEGER      :: xcount,ycount
!      REAL         :: xorigin,yorigin,xdelta,ydelta,
      real         :: a66

      real :: ha,fpw,kdn,nratio

!     rev. 9.9.33  Oct.  16/14  - NK: Added checks for files existing for a resume'
      INQUIRE(FILE='resume.txt',EXIST=exists)
      IF(.not.exists)THEN
        print*
        print*,'Expecting to find a file called'
        print*,'resume.txt'
        print*,'in the working directory but it is not found'
        print*
        stop 'Program aborted in rdresume @ 54'
      endif
      open(unit=99,file='resume.txt',status='unknown',iostat=ios)
      if(ios.ne.0)then
        print*,' Problems opening the resume.txt file'
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        print*
        stop ' Program aborted in rdresume @ ~625'
      endif

      read(99,*,iostat=ios)junk1,n_version
      if(ios.ne.0.or.n_version.ne.7)then
        print*,'*********************************************'
        print*
        print*,'Resume file format has changed'
        print*,'You must create a new resume file to be '
        print*,'compatible with this program version'
        print*,'Version found =',n_version,' Ver. 5 required'
        print*
        print*,'Resume now required the use of the' 
        print*,'soil_init.r2c and flow_init.r2c files'
        print*,'These are automatically created with'
        print*,'resumflg=`y'
        print*
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
        print*,'NEW:      Jan. 21, 2019'
        print*,'A new array has been added to the flow_init.r2c file'
        print*,'to make a smoother transition for a resume'
        print*,'Please rerun your spinup period to create new '
        print*,'resume files'
        print*
        print*,'*********************************************'
        stop 'Program aborted in rd_resume @ 80'
      endif
      
      read(99,*)          ! read start date  ver. 5
      read(99,*)          ! read end date    ver. 5

      read(99,*,iostat=ios)classcount1,na1,ycount1,xcount1,no1,noresv1
      if(ios.ne.0)then
        write(98,*)'Error'
        write(98,*)'Resume file format has changed'
        write(98,*)'You must create a new resume file to be '
        write(98,*)'compatible with this program version'
        write(98,*)'Program aborted in rd_resume @ 90'
        print*,'Resume file format has changed'
        print*,'You must create a new resume file to be '
        print*,'compatible with this program version'
        print*
        stop 'Program aborted in rd_resume @ 90'
      endif
      
!     rev. 9.8.87  Oct.  25/13  - NK: Added error message for mismatched resume file
      if(no1.ne.no)then
        write(98,*)'Error'
        write(98,*)'No of flow stations in the str file is different'
        write(98,*)'before & after the resume'
        write(98,*)'Program aborted in rdresume @ line 91'
        print*
        print*,'No of flow stations in the str file is different'
        print*,'before & after the resume'
        print*
        stop 'Program aborted in rdresume @ line 132'
      endif
      if(noresv1.ne.noresv)then
        print*
        print*,'No of flow stations in the rin file is different'
        print*,'before & after the resume'
        print*
        stop 'Program aborted in rdresume @ line 98'
      endif

      if(.NOT.allocated(area_temp))then         ! added Dec. 29/07 nk
        allocate(area_temp(no1),stat=iAllocate)
        if(iAllocate.ne.0) STOP 'Error with allocation of area_temp() in rdresume'
      endif


!     rev. 10.2.61 Aug.  28/19  - NK removed inbsnflg from read_resume
      read(99,*)(junk1,n=1,no1+noresv1)
!c      read(99,*,iostat=ios)(inbsnflg(n),n=1,no1+noresv1)
!      print*,inbsnflg
!    pause 55555

    
    
      if(ios.ne.0)then
        print*,'problems reading the first block'
        print*,' in the resume.txt file'
        print*
        stop ' Program aborted in sub @ 787'
      endif
      if(classcount1.ne.classcount.or.na1.ne.na.or.ycount1.ne.ycount.or.xcount1.ne.xcount)then
        print*,' resume file array size not compatible'
        print*,' with present watershed (.shd) file'
        print*,' '
        write(*,'(A)',advance='no') 'hit enter to continue - at your own risk'
        read(*,*)
      endif
      
!d      print*,'meta data read'
!d      print*,'Reading block 1'
      read(99,*,iostat=ios)block,junk    !block 1
!     print*,block
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
      do n=1,na1
        read(99,*,iostat=ios)n1,sump(n),qmax(n),sumrff(n)
        if(ios.ne.0)then
          print*,' Problems reading ',block
          print*,' at grid no. ',n,' out of ',na1
          print*,n1,sump(n),qmax(n),sumrff(n)
          print*
          stop 'Program aborted in rdresume @ 833'
        endif
      end do
!d      print*,'Part 1 of block 1 read'
      do n=1,na1
        read(99,*,iostat=ios)n1,(effpor(n,ii),ii=1,classcount)
        if(ios.ne.0)then
          print*,' Problems reading ',block
          print*,' at grid no. ',n,' out of ',na1
          print*,'n,ii,effpor/',n,ii,effpor(n,ii)
          print*
          stop 'Program aborted in rdresume @ 148'
        endif
      end do
!d      print*,'Part 2 of block 1 read'

      read(99,*,iostat=ios)block,junk    !block 2
!d      print*,'Reading block 2'
      do n=1,na1-1
        read(99,*,iostat=ios)tto(n),ttomin(n),ttomax(n)
        if(ios.ne.0)then
          print*,' Problems reading ',block
          print*,' at grid no. ',n,' out of ',na1-1
          print*
          stop 'Program aborted in rdresume @ 146'
        endif
      end do
!     took out qsn(n)  Nov. 7/01  NK
!d      print*,' block ',block,'  read'

!     taken out at one point but needed to make continuous rff files
!     there's no harm at all in having it
      read(99,*,iostat=ios)block,junk    !block 3
!d      print*,'Reading block 3'
      read(99,*,iostat=ios)(sr(ii),x4(ii),sexcess(ii),&
           sq1(ii),sq1fs(ii),sqint(ii),sqintfs(ii),&
           sdrng(ii),sdrngfs(ii),ii=1,classcount1)
!c           sdrng(ii),sdrngfs(ii),ii=1,classcount1+1)
      if(ios.ne.0)then
        write(*,98001)block
        write(98,98001)block
        print*
        STOP ' Program aborted in rdresume @ 169'
      endif
!c      if(iopt.eq.2)print*,' block ',block,'  read'
!d      print*,' block ',block,'  read'

      read(99,*,iostat=ios)block,junk    !block 4
!d      print*,'Reading block 4'
      do n=1,na
        do ii=1,classcount
          read(99,*,iostat=ios)n1,ii1,ssumr(n,ii),sumf(n,ii),sumffs(n,ii)
          if(ios.ne.0)then
            write(*,98001)block
            write(98,98001)block
            write(*,*)'grid no.=',n,' class no.=',ii
            print*
             stop 'Program aborted at 187'
          endif
        end do
      end do

!c      if(iopt.eq.2)print*,' block ',block,'  read'
!d      print*,' block ',block,'  read'
      read(99,*,iostat=ios)block,junk    !block 5
!d      print*,'Reading block 5'
      do n=1,na
        i=yyy(n)
        j=xxx(n)
        read(99,*,iostat=ios)sn1(i,j),basinerr(i,j),nhyd(i,j),nbasin(i,j)
      end do
      if(ios.ne.0)then
        print*,' error in block =',block
             stop 'Program aborted at 201'
      endif

!     rev. 9.8.34  Oct.  23/12  - NK: Added sums to the resume.txt file
!d      print*,'Reading block 7'
      read(99,*,iostat=ios)block,junk    !block 7
      read(99,*)intevt
      read(99,*)evt
      read(99,*)sump
      read(99,*)ssumr
      read(99,*)sumf
      read(99,*)sumffs
      read(99,*)sumrff
      read(99,*)slzinflw
      read(99,*)sdlz
      read(99,*)sum_sublim
      read(99,*)sum_pet
      read(99,*)sum_et



!d      print*,'Reading block 8'
      read(99,*,iostat=ios)block,junk    !block 8
      read(99,*,iostat=ios)&
           (aa(i),bb(i),cc(i),ashnum(i),ashden(i),qpeakh(i),&
           qpeaks(i),nq(i),nqc(i),nxtbasin(i)&
                ,area_temp(i),i=1,no1)

      if(ios.ne.0)then
        write(*,98001)block
        write(98,98001)block
        print*
             stop 'Program aborted at 237'
      endif
!c      if(iopt.eq.2)print*,' block ',block,'  read'
!d      print*,' block ',block,'  read'
      
!     rev. 10.3.03 Jan.  21/20  = NK added dd_ice & dd_thaw to the resume.txt file      
!     For additional dd_ice & dd_thaw data fields 
      read(99,99002)line
99002 format(a256)      
      if(line(1:3).ne.'eof')then
            read(line,*)i,junk
            if(i.eq.9)then
                read(99,*)(dd_ice(n),n=1,na)
                read(99,99002)line
                read(line,*)i,junk
                if(i.eq.10)then
                    read(99,*)(dd_thaw(n),n=1,na)
                endif
            else
                read(line,9701,iostat=ios)eofmark
 9705           if(eofmark.ne.'eof')then
                    write(6,9702)
                    STOP 'Program stopped in sub @ eof check'
                endif

                close(unit=99,status='keep')
          
            endif
      else      
          close(unit=99,status='keep')
      endif
      
      



!     rev. 9.2.31  Feb.  09/06  - NK: Added area chaeck to rdresume
      open(unit=99,file='changed_areas.txt',status='unknown',iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file  changed_areas.txt'
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        stop 'Program aborted in rdresume @ 276'
      endif
      change_flag='n'
      do i=1,no1
        if(area_temp(i).ne.area(i))then
          if(change_flag.eq.'n')then
            write(98,98000)'Warning: The drainage area has been changed since the ',&
           'resume file was written likely due to ',&
           'due to re-ordering the flow stations ',&
           'New values are used in this run ',&
           'Program continues but initial flows may take ',&
           'time to settle. ',&
           'Changed_areas have been written ',&
           'in debug\warnings.txt'
98000       format(a9,a45,a38,a37,a32,a45,a16,a32,a21)            
     
            write(98,*)'Warning: Flow Station #, area from resume file, new area computed in flowinit:'

            change_flag='y'
          endif
          write(98,*)'Warning: ',i,'     ',area_temp(i),'     ',area(i)
        endif
      end do
      close(unit=99,status='keep')
      write(98,*)'Info: FINISHED READING THE RESUME.TXT FILE'

      !     REV. 8.61 - Dec.12/97 - ADDED CONTFLG FOR STATS CONTN
      if(contflg.ne.'y')then    
!       RESTART CALC'S FOR THE STATISTICS
        do l=1,no  
          nq(l)=0
          nqc(l)=0
          aa(l)=0.
          bb(l)=0.
          cc(l)=0.
          ashnum(l)=0.0
          ashden(l)=0.0
          qpeakh(l)=0.1e-10
          dpeakh(l)=0.1e-10
          qpeaks(l)=0.0e-10
          dpeaks(l)=0.0e-10
        end do
        do n=1,naa  
          do ii=1,classcount       
            intevt(n,ii)=0.0
            evt(n,ii)=0.0
            sump(n)=0.0
            ssumr(n,ii)=0.0
            sumf(n,ii)=0.0
            sumffs(n,ii)=0.0
            sumrff(n)=0.0
!c        slzinflw(n)=0.0
!c        sdlz(n)=0.0
            sum_sublim(n,ii)=0.0
            sum_pet(n,ii)=0.0
            sum_et(n,ii)=0.0
          end do
        end do
      endif

      if(iopt.ge.1)print*,'Finished reading the resume.txt file' 
      if(iopt.ge.2)pause 'Hit enter to continue'
      
      return

 9701 format(a3)
 9702 format(' resume.txt file length does not match current'/&
             ' memory array spec. Regenerate the file'/)

99000 format(f5.1)
99001 format(f25.0)
99003 format(i1,5x,a50)
99004 format(i5)
!c99182   format(' Warning: Error opening or reading fln:',a30/
!c     *  ' Probable cause: missing strfw/yymmdd.str input file'/
!c     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
98001 format(' Warning: Error reading resume.txt'/&
     ' Probable cause: wrong format or end of file reached'/&
     ' This could be due to a change in grid characteristics'/&
     ' since creating the resume file'/&
     ' Solution: create a new resume file with current executable'//&
     ' OR, look for *** or NaN in the resume file and change to '/&
     ' 0.0E+00     Look in:'//&
     ' block= ',i5)


      end subroutine rdresume

      SUBROUTINE read_resvin_ef()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
!* READ_RESVIN_EF - written Sep/06 by Dave Watson, CHC
!	- Derived from rdresvin written by Nick Kouwen
!	This subroutine reads the measured reservoir inflow (RIN) file 
!	(tb0 format)
!*****************************************************************************

!     rev. 9.5.68  Oct.  07/09  - NK: debugged read_resvin_ef.f
!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
!     rev. 9.5.82  Jan.  26/09  - NK: replaced error check for inflow locations
!     rev. 9.7.12  Nov.  10/10  - NK: fix array bugs for reservoir inflows
!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
!     rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
!     rev. 9.8.41  Jan.  31/13  - NK: fixed bug in read_resvin: nopti int conversion

      USE area_watflood

!*TB0 data module
	USE EF_Module

	implicit none
	TYPE(ResvinParam) :: header
	TYPE(ResvinColumnMetaData) :: colHeader

      Integer  :: ios,j,k,i,n,l
	integer  :: nrel_in_max,iAllocate,iDeallocate
      real*4   :: factor

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      LOGICAL exists
	CHARACTER(1)  :: firstpass

      data firstpass/'y'/

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

!*Parameter type definitions
	integer*4 unitNum, flnNum, iStat

!*Local variables
	character*4096 line, subString, tmpString
	character*128 keyword, value
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader, insideColMetaData
	logical errflg1

! Set unit and fln number
	unitNum = 99
	flnNum = 8

! Open the file
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	if(exists)then
		open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
		if(ios.ne.0)then
			print*,'Problems opening ',fln(flnNum)(1:40)
			print*
			STOP ' Stopped in read_resvin_ef @ 62'
		endif
	  if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
	else
		print*,'ERROR: reservoir inflows (rin) file ',fln(flnNum)(1:40)
		print*,'is NOT found'
		STOP ' Program STOPPED in read_resvin_ef @ 67'
	endif

! Initialize default values
	CALL InitResvinParam(header)	

! Search for and read tb0 file header
	line(1:1) = '#'
	foundEndHeader = .false.
	insideColMetaData = .false.

	do WHILE((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(LEN_TRIM(line) .eq. 0))) 	

		read(UNIT=unitNum, FMT='((A))', iostat=ios) line	! read a line
		if(ios .eq. -1)then
			write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
			STOP ' Stopped in read_resvin_ef'
		end if

		rStat = Detab(line)				! replace tabs with spaces
		line = ADJUSTL(line)		! Get rid of leading white space
		lineLen = LEN_TRIM(line)		! Find the length excluding trailing spaces

		if(line(1:1) .eq. ':')then
			wordCount = SplitLine(line, keyword, subString)	! find the keyword
			rStat = ToLowerCase(keyword)
			KeyLen = LEN_TRIM(keyword)

			if(keyword(1:KeyLen) .eq. ':endheader')then
				foundEndHeader = .TRUE.

			else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
				insideColMetaData = .TRUE.
			else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
				insideColMetaData = .FALSE.
			else if(insideColMetaData) then
				iStat = ParseResvinColumnMetaData(colHeader,keyword,
     &												keyLen,subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_resvin_ef'
					return
				end if
			else
				iStat = ParseResvinParam(header,keyword,keyLen,subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_resvin_ef'
					return
				else if(iStat .eq. 0) then
!					write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &										line
				endif
			end if
		end if
	end do	
!***************************************
!	Finished reading the header
!***************************************

! Assign the variables from the types
	ktri =  header%tb0p%deltaT    !data time step in hours
	factor = header%tb0p%unitConv ! conversion to cms
	noresvi = colHeader%tb0cmd%colCount !no of reservoirs

d     print*
d     print*,'In read_resvin'
d     print*,'No of reservoirs found =',noresvi
d     print*


!     rev. 9.5.68  Oct.  07/09  - NK: debugged read_resvin_ef.f
      if(allocated(delta))then
        deallocate(delta,qpeakh,qpeaks,dpeakh,dpeaks,volsyn,volhyd,
     *               stat=iAllocate)
        if(iDeallocate.ne.0)then
          print*,'Error with deallocation of resvin stuff'
          print*
          stop 'Program aborted in read_resvin_ef @ 141'
        endif

        allocate(
     *    delta(nnch,no+noresvi),     ! fixed bug 24/07/00
     *    qpeakh(no+noresvi),qpeaks(no+noresvi),
     *    dpeakh(no+noresvi),dpeaks(no+noresvi),
     *    volsyn(no+noresvi),volhyd(no+noresvi),
     *    stat=iAllocate)
          if(iAllocate.ne.0) STOP
     *       'Error with allocation error arrays in read_resvin_ef'

      endif


!     nreli    =     no of hours of data
! Scan lines of data
      rewind unitNum
	nreli = CountDataLinesAfterHeader(unitNum)
	nreli=nreli*ktri         ! want no of hours, not no of lines
	rewind unitNum
	CALL GoToStartOfData(unitNum)

!     allocate stuff here
!     array size defined by noresv which is already defined in rdresv     
	if(firstpass.eq.'y')then
		firstpass='n'
		nrel_in_max=nreli
		if(iopt.ge.1)then
		  print*,'no days of resv. inflows found =',nreli/ktri
		endif

!     rev. 9.7.12  Nov.  10/10  - NK: fix array bugs for reservoir inflows
		if(noresvi.gt.0)then
			allocate(resnamei(noresv),qinfl(noresv,nreli),
     *                        xresin(noresv),yresin(noresv),
     *                        jresin(noresv),iresin(noresv),
     *                        resin_reach(noresv),
     *                        nopti(noresv),stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *			'Error with allocation in rdresvin @172'
d	        print*,'noresvi=',noresvi
		else
			allocate(resnamei(1),qinfl(1,nreli),nopti(1),
     *              stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *			'Error with allocation in rdresvin @178'
		endif
	  if(iopt.ge.1)then
		  print*,'res. inflow  allocation for ',noresv,nreli
		endif
	else	
		if(nreli.gt.nrel_in_max)then
!			this happens when the current event is longer than a
!			previoius one
			nrel_in_max=nreli
!			the file fegnth is longer than any of the previous events so 
!			more memory has to be allocated
	
!			DEALLOCATION OF ARRAYS FROM AREA5A:
			deallocate(qinfl,stat=iDeallocate)     
			if (iDeallocate.ne.0) print*,    
     *			'Error with deallocation of area5a arrays'
!			re-allocate for larger arrays
!     rev. 9.8.41  Jan.  28/13  - NK: fixed bug in lst for level print statement
	        if(iopt.ge.1)then
		      print*,'re-allocating res. inflow to ',noresv,nreli
		    endif
c			allocate(qinfl(noresvi,nreli),stat=iAllocate)
			allocate(qinfl(noresv,nreli),stat=iAllocate)
			if(iAllocate.ne.0) STOP
     *			'Error with allocation of area10a arrays in read_resvin'
		endif
	endif

 
!     RESERVOIR INFLOWS
!     RESERVOIR INFLOWS
!     RESERVOIR INFLOWS

!       READ RESERVOIR INFLOWS (FOR OPTIMIZATIONS ETC.)
!       SET ALL FLAGS TO 0:
	do i=1,noresvi
		nopti(i)=0
	end do

!     NOTE:  we use unit 99 (scratch) here because unit 38 is used for 
!     snow data elsewhere

!	ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
	do i=1,noresvi
		resnamei(i) = colHeader%tb0cmd%colName(i) ! reservoir name
          xresin(i) = colHeader%tb0cmd%colLocX(i) ! x coordinate
          yresin(i) = colHeader%tb0cmd%colLocY(i) ! y coordinate
		  nopti(i) = int(colHeader%colValue1(i)) ! coefficient 1
!     rev. 9.8.41  Jan.  31/13  - NK: fixed bug in read_resvin: nopti int conversion
	end do
	deallocate(colHeader%tb0cmd%colName)
	deallocate(colHeader%colValue1)

!     rev. 9.5.81  Jan.  16/09  - NK: allow reservoirs outside watershed in resv file
	if(noresvi.gt.noresv)then    !  nk  Jul. 28/04
		print*,'Number of lakes or reservours = ',noresv
		print*,'Number of reservoir inflows   = ',noresvi
		print*,'This can not be. no of inflows must be '
		print*,'.le. no of lakes. We will try to just ignore the'
		print*,'extra inflow.'
		noresvi=noresv
		print*
c		pause 'Hit enter to continue '
	endif

!     rev. 9.5.78  Nov.  04/09  - NK: matched resvin locations to reach numbers
!     find out what reach inflows are associated with
	do i=1,noresvi
        jresin(i)=int((xresin(i)-xorigin)/xdelta)+1
        iresin(i)=int((yresin(i)-yorigin)/ydelta)+1
	end do

      do i=1,noresv
        jres(i)=int((xres(i)-xorigin)/xdelta)+1
        ires(i)=int((yres(i)-yorigin)/ydelta)+1
        do j=1,noresvi
	      if(jres(i).eq.jresin(j).and.ires(i).eq.iresin(j))then
	        resin_reach(j)=i
            endif
	  end do
      end do

!	DATA CHECKING:
	if(iopt.ge.1.and.noresvi.gt.0)then
		write(53,5301)
		write(53,4901)(nopti(i),i=1,noresvi)
		write(53,4902)noresvi,nreli,ktri
		write(53,5303)(resnamei(i),i=1,noresvi)
	    write(53,5304)(xresin(i),i=1,noresvi)
	    write(53,5304)(yresin(i),i=1,noresvi)
 	    write(53,5305)(jresin(i),i=1,noresvi)
 	    write(53,5305)(iresin(i),i=1,noresvi)
	    write(53,5305)(resin_reach(i),i=1,noresvi)
d		write(*,5301)
d		write(*,4901)(nopti(i),i=1,noresvi)
d		write(*,4902)noresvi,nreli,ktri
d		write(*,5303)(resnamei(i),i=1,noresvi)
d	    write(*,5304)(xresin(i),i=1,noresvi)
d	    write(*,5304)(yresin(i),i=1,noresvi)
d	    write(*,5305)(jresin(i),i=1,noresvi)
d	    write(*,5305)(iresin(i),i=1,noresvi)
d	    write(*,5305)(resin_reach(i),i=1,noresvi)
	endif

!     rev. 9.5.82  Jan.  26/09  - NK: replaced error check for inflow locations
      errflg1=.false.
	do i=1,noresvi
	  if(resin_reach(i).le.0.or.resin_reach(i).gt.noresv)then
	    print*,'No matching lake/reservoir for inflow '
	    print*,'location ',i,resnamei(i)
	    print*,'Please check the location of the inflow'
	    print*,'in the yyyymmdd_rin.tb0 file'
	    print*,'and in inflow\inflow_locations.xyz'
	    print*
	    errflg1=.true.
	  endif
	end do
	if(errflg1)stop 'Program aborted in read_resvin_ef.f @ 288'

	if(noresvi.gt.0)then
		do j=ktri,nreli,ktri
			read(unitNum,*)(qinfl(k,j),k=1,noresvi)
			write(53,4904)(qinfl(k,j),k=1,noresvi)
cd			write(*,4904)(qinfl(k,j),k=1,noresvi)
		end do
	endif
	close(unit=unitNum,status='keep')

 4901 format(<noresvi>i1)
 4902 format(3i5)
 4904 format(256f10.3)
 5301 format(' ','Reservoir inflow data echoed:')
 5303 format(256(' ',a12))
 5304 format(256(f13.4))
 5305 format(256(i13))
	end subroutine read_resvin_ef      SUBROUTINE read_soilinit()
	      
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     borrowed swe reader for this s/r
!     nk  Oct. 9/06

!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
!     rev. 9.8.35  Oct.  23/12  - NK: Fixed bug in read_soilinit_ef

!***********************************************************************
!  based on:  READ_SWE_EF -  written Mar/06 by Dave Watson, CHC
!     - Derived from rdswe written by Nick Kouwen
!     - This subroutine reads the ensim compatible gridded SWE file (r2c format)
!***********************************************************************
   
      use area_watflood

! R2C data module
	USE EF_Module

	implicit none
	TYPE(SWEParam) :: header

! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer       :: classcount_local,ios
      real*4        :: deffactor

      LOGICAL exists
 
! parameter type definitions
	integer*4 unitNum, flnNum, iStat

! Local variables
	character*4096 line, subString, tmpString
	character*128 keyword, value
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader
	integer xCountLoc,yCountLoc,attCountLoc
	integer ai,xi,yi,vi,error,i,j,n,ii

! Set unit and fln number
	unitNum = 99
	flnNum = 99
 
! Open the file
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	IF(exists)then
		open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
 		if(ios.ne.0)then
			print*,'Problems opening ',fln(flnNum)(1:40)
			print*
			STOP ' Stopped in read_soil_init @ 53'
		endif
	else
		print*,'ERROR: the soil_init file: ',fln(flnNum)(1:40)
		print*,'is NOT found'
		STOP ' Program STOPPED in read_soilinit @ 58'
	endif


! Initialize default values
	CALL InitSWEParam(header)	

! Search for and read r2c file header
	line(1:1) = '#'
	foundEndHeader = .false.
      write(63,*)'Reading the header in read_soilinit'
	do WHILE((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(LEN_TRIM(line) .eq. 0))) 	

		read(UNIT=unitNum, FMT='((A))', iostat=ios) line	! read a line
		
d		write(63,*)line(1:72)
		
		if(ios .eq. -1)then
			write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
			STOP ' Stopped in read_swe_ef'
		end if

		rStat = Detab(line)				! replace tabs with spaces
		line = ADJUSTL(line)		! Get rid of leading white space
		lineLen = LEN_TRIM(line)		! Find the length excluding trailing spaces

		if(line(1:1) .eq. ':')then
			wordCount = SplitLine(line, keyword, subString)	! find the keyword
			rStat = ToLowerCase(keyword)
			KeyLen = LEN_TRIM(keyword)

			if(keyword(1:KeyLen) .eq. ':endheader')then
				foundEndHeader = .TRUE.

			else
				iStat = ParseSWEParam(header,keyword,keyLen,
     &													subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_swe_ef'
					return
				else if(iStat .eq. 0) then
C					write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &										line
				endif
			end if
		end if
	end do
!***************************************
!	Finished reading the header
!***************************************

! Assign the parsed parameters to the model variables		
	xCountLoc = header%r2cp%xCount
	yCountLoc = header%r2cp%yCount
	attCountLoc =header%r2cp%ep%attCount
c	imax=header%r2cp%yCount
c	jmax=header%r2cp%xCount 
	deffactor = header%initHeatDeficit !Set InitHeatDeficit


! Read the data section
	CALL LoadAttributeData(header%r2cp%ep, xCountLoc,
     &						yCountLoc, unitNum)	
	
      
!      print*,xCountLoc,yCountLoc,unitNum
     	
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *        print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *         print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'    and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_soilinit_ef @ 145'
	endif

c	classcount_local = header%r2cp%ep%attCount
	attCountLoc = header%r2cp%ep%attCount
d	print*,'attribute count=',attCountLoc

!     the number of state variables = 10  < change if needed
	classcount_local=(attCountLoc-3)/10   !changed fron 9 -> 10 Mar15/11 nk

d	print*,'header%r2cp%ep%attCount=',header%r2cp%ep%attCount
d	print*,'classcount_local=',classcount_local
d	print*
!	pause 'in read_soilinit_ef.for @ 179'

c        imax=ycount
c	  jmax=xcount

!     check added Jul. 13/11 nk
      if(yCountLoc.ne.ycount)then
        print*,'ycount in ',fln(flnNum)
        print*,'does not match the ycount in the shd file'
        print*
        stop 'Program aborted in read_flowinit.f @ 165'
      endif
      if(xCountLoc.ne.xcount)then
        print*,'xcount in ',fln(flnNum)
        print*,'does not match the xcount in the shd file'
        print*
        stop 'Program aborted in read_flowinit.f @ 171'
      endif

! Copy Attribute data over to Nick's global variables
	do ii=1,classcount_local
	      ai=ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
!	              print*,yi,xi,header%r2cp%ep%attList(ai)%val(vi)
			end do
d             if(iopt.ge.2)write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
55555       format(999e10.3)

	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              v(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
!	              print*,yi,xi,header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              d1(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=2*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              d1fs(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=3*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              uzs(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=4*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              uzsfs(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do
	do ii=1,classcount_local
	      ai=5*classcount_local+ii
		vi = 0
d         write(63,*)'snowc ',ii
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              snowc(n,ii)=p(i,j)
            end do
      end do
	do ii=1,classcount_local
	      ai=6*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              sca(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=7*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              wcl(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=8*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              def(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

	do ii=1,classcount_local
	      ai=9*classcount_local+ii
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
			  vi = vi+1
			  p(yi,xi)=header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(63,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(63,*)
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
              api(n,ii)=p(i,j)
!             print*,n,qi1(n)
            end do
      end do

!             SET INITIAL UNSATURATED ZONE EFFECTIVE POROSITY:
!             THE EFFECTIVE POROSITY DEPENDS ON SOIL MOISTURE
!             WHICH IS ENTERED FOR EACH GRID
!             effpor is for the intermediate zone so same for bare & sca
      do n=1,naa
	  do ii=1,classcount
              effpor(n,ii)=spore(ii)-api(n,ii)
              effpor(n,ii)=amax1(0.0001,effpor(n,ii))
              effpor(n,ii)=amin1(spore(ii),effpor(n,ii))
              if(api(n,ii).lt.0.0)then
                api(n,ii)=0.0
              endif
        end do
	end do

! Copy Attribute data over to Nick's global variables
	do ai=1,attCountLoc
		vi = 0
		do yi=1,yCountLoc
			do xi=1,xCountLoc
				vi = vi+1
			 p(yi,xi) = header%r2cp%ep%attList(ai)%val(vi)
			end do
d                  write(55,55555)(p(yi,xi),xi=1,xCountLoc)
		end do
d	      write(55,*)
!     rev. 9.8.35  Oct.  23/12  - NK: Fixed bug in read_soilinit_ef
	      do n=1,naa
	        i=yyy(n)
	        j=xxx(n)
c	        if(ai.eq.61)then
	        if(ai.eq.10*classcount_local+1)then
                  tto(n)=p(i,j)
	        elseif(ai.eq.62)then
	        elseif(10*classcount_local+2.eq.62)then
	            ttomin(n)=p(i,j)
c      	      elseif(ai.eq.63)then
      	      elseif(10*classcount_local+3.eq.63)then
	            ttomax(n)=p(i,j)
	        endif
            end do
      end do

      do n=1,naa
	  do ii=1,classcount
              effpor(n,ii)=spore(ii)-api(n,ii)
              effpor(n,ii)=amax1(0.0001,effpor(n,ii))
              effpor(n,ii)=amin1(spore(ii),effpor(n,ii))
              if(api(n,ii).lt.0.0)then
                api(n,ii)=0.0
              endif
        end do
	end do

! Deallocate the attribute data now that global attributes have been set
	do ai=1,attCountLoc
		deallocate ( header%r2cp%ep%attList(ai)%val, STAT = error )
		if (error.ne.0) STOP 'deallocation error in read_gsm_ef()' 
	end do

      close (unit=unitNum)

	if(iopt.ge.1)then
	  print*,'Finished reading ',fln(flnNum)(1:20)
	  print*,'Earlier initialization overwritten'
	endif

      RETURN

      END SUBROUTINE read_soilinit



      SUBROUTINE read_swe()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***************************************************************************
! PROGRAM BY: NK  June 2012
!
      use area_watflood
	USE EF_Module

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
	implicit none
	save

	TYPE(CourseParam) :: header
	TYPE(CourseColumnMetaData) :: colHeader

      CHARACTER(1) :: new
      INTEGER      :: jan,ju,iallcnt2,iallocate,n,ii,i,j,nold
      integer      :: n_max,ideallocate,no_hdr_lines
      integer      :: ios,linecount,unitnum,flnNum,iStat
      integer      :: nlines,nlines_old
	REAL*4       :: time,ttime,taold,temmmp  
	character*16 :: swe_file              
	logical      :: exists,firstpass

! Local variables
	character*128 keyword, value
	character*4096 line, subString, tmpString
      CHARACTER(1)  :: col0(13),col1(13),col2(27)
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader, insideColMetaData

      save
	
      DATA new/'f'/
      DATA firstpass/.true./
	DATA iallcnt2/0/

      DATA col0/'a','c','e','g','i','k','m','o','q','s','u','w','y'/
      DATA col1/'b','d','f','h','j','l','n','p','r','t','v','x','z'/
      DATA col2/' ','a','b','c','d','e','f','g','h','i','j','k','l','m',
     *         'n','o','p','q','r','s','t','v','u','w','x','y','z'/

d      if(iopt.eq.2)print*,'in melt @ 0'

      stop

      if(iopt.ge.1)then
        print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
        print*,'NEW  <<<<<'
        print*,'SWE report'
      endif
! Set unit and fln number
	unitNum = 284
	flnNum = 54      ! ! unit=284  fln(54)- swe time series pillows & crs  yyyymmdd_swe.tb0

      write(line,10000)year_now
      if(iopt.ge.1)print*,'year_now=',year_now
10000 format('snowg\',i4,'0101_swe.tb0')
      read(line,10001)fln(flnNum)
10001 format(a22)            
      if(iopt.ge.1)then
        print*,'fl#=',flnNum
        print*,'file name =',fln(flnNum)(1:50)
      endif
     
c      pause 1
! Open the file
!     rev. 10.1.81 May   05/17  - NK: Added snowg\yyyymmdd_swe.tb0 obs. swe
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	if(exists)then
	  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	    if(ios.ne.0)then
	  	print*,'Problems opening:',fln(flnNum)(1:40)
	   	print*
		   STOP ' Stopped in read_swe @ 39'
	  endif
	  print*,'Opened ',fln(flnNum)(1:40)
	else
        if(dds_flag.eq.0)then
          print*,fln(flnNum)(1:60),'not found'
	    print*,'program continues without swe analysis'
	  endif
	  courseflg=.false.
	  return
	endif

c      pause 2

! Initialize default values
	CALL InitCourseParam(header)	
	
c	pause 3
	
! Search for and read tb0 file header
      linecount=0
      line(1:1) = '#'
      foundEndHeader = .false.
      insideColMetaData = .false.
      no_hdr_lines=0

      write(51,*)
      write(51,*)'SWE - observed snow course/pillow file'
      write(51,*)

      do WHILE((.NOT.foundEndHeader) .AND.
     &        ((line(1:1) .eq. '#') .OR.
     &        (line(1:1) .eq. ':') .OR.
     &        (LEN_TRIM(line) .eq. 0)))   
                  linecount=linecount+1
!     if(iopt.eq.2)print*,'reading line ',linecount,' in read_swe'
          read(UNIT=unitNum, FMT='((A))', iostat=ios) line    ! read a line
          write(51,*)line(1:60)
          if(ios .eq. -1)then
              write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
              STOP ' Stopped in read_swe @ 88'
          end if
          no_hdr_lines=no_hdr_lines+1
          
          rStat = Detab(line)             ! replace tabs with spaces
          line = ADJUSTL(line)        ! Get rid of leading white space
          lineLen = LEN_TRIM(line)        ! Find the length excluding trailing spaces

          if(line(1:1) .eq. ':')then
              wordCount = SplitLine(line, keyword, subString) ! find the keyword
              rStat = ToLowerCase(keyword)
              KeyLen = LEN_TRIM(keyword)

              if(keyword(1:KeyLen) .eq. ':endheader')then
                  foundEndHeader = .TRUE.
              else if(keyword(1:KeyLen) .eq. ':columnmetadata')then
                  insideColMetaData = .TRUE.
              else if(keyword(1:KeyLen) .eq. ':endcolumnmetadata')then
                  insideColMetaData = .FALSE.
              else if(insideColMetaData) then
                  iStat = ParseCourseColumnMetaData(colHeader,
     &                        keyword,keyLen,subString)
                  if(iStat .lt. 0) then
                      write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                      write(*,'(2(A))') '   in line: ',line                   
                      STOP ' Stopped in read_swe @113'
                      return
                  endif
              else
                  iStat = ParseCourseParam
     *                (header,keyword,keyLen,subString)
                  if(iStat .lt. 0) then
                      write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                      write(*,'(2(A))') '   in line: ',line                   
                      STOP ' Stopped in read_swe @122'
                      return
                  else if(iStat .eq. 0) then
!                     write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &                                       line
                  endif
              end if
          endif
          
      end do  
!***************************************
!     Finished reading the header
!***************************************

!     nswe    = no of snow course data
	nswe    = colHeader%tb0cmd%colCount
      print*,'no of snow courses found =',nswe
      print*,'no header lines =',no_hdr_lines
      
! Scan lines of data
      rewind unitNum
	nlines = CountDataLinesAfterHeader(unitNum)
	print*,'no of data lines found =',nlines
      print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
	
      rewind unitnum
      do n=1,no_hdr_lines
        read(unitnum,*)line
c        print*,line(1:60)
      end do
      

!       rev. 9.1.68  Dec.  19/04  - NK: rewrote rdflow c/w memory allocation 
!       allocate stuff      
c		if(id.eq.1)then
		if(firstpass)then
			n_max=n
			nold=n
			nlines_old=nlines
	      allocate(course_obs(nswe,max(366,nlines)),
     *              course_calc(nswe,max(366,nlines)),
     *             	      indomainflg(nswe),stat=iAllocate)
!           corrected bug above - replaced na by nswe   Nov. 19/14  nk     
            If(iopt.ge.1)print*,'course_obs dimensioned for:',
     *                        max(nlines,366)
			if(iAllocate.ne.0) STOP
     *		'Error with allocation of  arrays in read_swe @ 147'
		else                    !  firstpass
!         check to see memory allocated is adequate      

			if(n.ne.nold)then
				print*,'No of swe stations has been changed in'
				print*,'nold=',nold,' n=',n
				print*,'in file ',fln(99)(1:60)
				print*,'This is not permitted'
				print*
				stop 'Program aborted in read_swe @ 156'
			endif
			if(nlines.gt.nlines_old)then
				print*,'No of data lines have changed in'
				print*,'nlines_old=',nlines_old,' nlines=',nlines
				print*,'in file ',fln(99)(1:60)
				print*
c			if(n.gt.n_max)then
				n_max=n

!           the file length is longer than any of the previous events so 
!           more memory has to be allocated

!           DEALLOCATION OF ARRAYS FROM AREA10A:
				deallocate(course_obs,course_calc,stat=iDeallocate)
				if(iDeallocate.ne.0)then
					print*,'Error with deallocation ofswe)obs'
					print*
					stop 'Program aborted in read_swe @ 170'
				endif

                print*,'reallocation for more swe locations',nswe

				allocate(course_obs(nswe,max(366,nlines)),
     *                    course_calc(nswe,max(366,nlines)),
     *         				stat=iAllocate)
				if(iAllocate.ne.0) STOP
     *			'Allocation Error: arrays in read_swe @177'
                nlines_old=nlines
d               print*,'course_obs re-dimensioned for:',max(nlines,366)
			endif
		endif                   !  firstpass
		
      if(.not.allocated(xswe))then
          allocate(xswe(nswe),yswe(nswe),gname_swe(nswe),
     *                   ewg_swe(nswe),sng_swe(nswe),stat=iAllocate)
          if(iAllocate.ne.0)then
            print*,'Error with allocation of station descripters'
            print*,' in read_swe'
            STOP 'Program aborted in read_swe @ 213'
          endif
        endif
!     rev. 9.1.68  Dec.  19/04  - NK: rewrote read_tbo c/w memory allocation 
  
!     ASSIGN THE GAUGE LOCATIONS NAMES AND FUNCTION COEFFICIENTS
      do n=1,nswe
        gname_swe(n) = colHeader%tb0cmd%colName(n) ! station name
        xswe(n) = colHeader%tb0cmd%colLocX(n) ! x coordinate
        yswe(n) = colHeader%tb0cmd%colLocY(n) ! y coordinate
      end do
      deallocate(colHeader%tb0cmd%colName)
      deallocate(colHeader%tb0cmd%colLocX)
      deallocate(colHeader%tb0cmd%colLocY)

c      pause '261'

!     write the header on the swe.csv file
c      filename(951)='results\swe.csv'       !snow course comparison

c      if(id.eq.1)then
      if(firstpass)then
        write(951,91101)(gname_swe(n),gname_swe(n),n=1,nswe)
91101   format(<2*nswe>(a9,','))      
      endif

c      pause '269'

c      if(id.eq.1)then
      if(firstpass)then
!       turn into local coordinates
        do n=1,nswe
          ewg_swe(n)=int((xswe(n)-xorigin)/xdelta+1.0)
          sng_swe(n)=int((yswe(n)-yorigin)/ydelta+1.0)
        end do

!       write snow course & pillow the location file
        open(unit=99,file='swe_location.xyz',
     *            status='unknown',iostat=ios)
        i=0
        j=-3
        do n=1,nswe
          i=n-n/13*13
          if(i.eq.0)then
            i=13
          endif
          j=(n-1)/13+1
          if(sng_swe(n).ge.1.and.ewg_swe(n).ge.1.and.
     *       sng_swe(n).le.ycount.and.ewg_swe(n).le.xcount)then
            if(s(sng_swe(n),ewg_swe(n)).gt.0)then
!             print only if in the watershed
              write(99,6012)xswe(n),yswe(n),n,gname_swe(n),
     *                col2(j),col0(i),col2(j),col1(i)
 6012         format(2f12.3,i5,1x,a12,3x,2a1,3x,2a1)
            endif
          endif
        end do
        close(unit=99,status='keep')
      endif

c      pause 297


      do j=1,nlines   
        read(unitNum,*,iostat=ios)(course_obs(n,j),n=1,nswe)
c        print*,j,(course_obs(n,j),n=1,4)
        if(ios.ne.0)then
          print*, 'In read_swe.f'
          write(*,*)j,(course_obs(n,j),n=1,4)
          print*,'Got as far as data line',j
        endif
      end do
      
      close(unit=99,status='keep')

!     check to see if stations are in the model domain
      do n=1,nswe
        if(ewg_swe(n).ge.1.and.ewg_swe(n).le.xcount.and.
     *     sng_swe(n).ge.1.and.sng_swe(n).le.ycount)then
          if(s(sng_swe(n),ewg_swe(n)).gt.0)then
            indomainflg(n)=.true.
d           print*,n,xswe(n),yswe(n),s(sng_swe(n),ewg_swe(n)),
d    *         indomainflg(n)
          else
            indomainflg(n)=.false.
          endif
        else
          indomainflg(n)=.false.
        endif
      end do
c      pause 'domain check'

      close(unit=unitNum,status='keep')

      firstpass=.true.  ! reset for next event to read header only
      firstpass=.false.  ! reset for next event to read header only

      return

      END SUBROUTINE read_swe
      SUBROUTINE read_sweinit(unitNum,flnNum)
	      
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more detiils.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  READ_SWE_EF -  written Mar/06 by Dave Watson, CHC
!     - Derived from rdswe written by Nick Kouwen
!     - This subroutine reads the ensim compatible gridded SWE file (r2c format)
!***********************************************************************
   
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001

      use area_watflood

! R2C data module
	USE EF_Module

	implicit none
	TYPE(SWEParam) :: header

! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer       :: nclasses,ios,i,j,ii,n,iallocate
      real*4        :: deffactor,class_sum

      LOGICAL exists
 
! parameter type definitions
	integer*4 unitNum, flnNum, iStat

! Local variables
!      chracter*1  firstpass
	character*4096 line, subString, tmpString
	character*128 keyword, value
	integer lineLen, keyLen, wordCount
	logical rStat, lineType, foundEndHeader
	integer xCountLoc, yCountLoc, attCountLoc
	integer xi, yi, vi, error

      real*4,  dimension(:,:),allocatable :: ratio2

      allocate(ratio2(ycount,xcount),stat=iAllocate)
      if(iAllocate.ne.0)then
         print*,'Error with allocation of ratio2 in read_sweinit.f @ 63'
         STOP 'Program aborted in sub @ 595'
      endif
      
!      data /firstpass/'y'/

! Set unit and fln number
c	unitNum = 99
c	flnNum = 36   ! gridded swe.r2c file
 
! Open the file
	INQUIRE(FILE=fln(flnNum),EXIST=exists)
	IF(exists)then
!       sweinit file will be read even in a run with resume = 'y'
	  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
 	  if(ios.ne.0)then
	    print*,'Problems opening ',fln(flnNum)(1:40)
	    print*
	    STOP ' Stopped in read_sweinit_ef @ 53'
	  endif
	else
	  if(resumflg.ne.'y')then
	    print*,'ERROR: the SWE file: ',	fln(flnNum)(1:40)
	    print*,'is NOT found'
	    STOP ' Program STOPPED in read_sweinit @ 59'
	  else
!         this means reading the swe from the soilinit.r2c file
	    return
	  endif
	endif


! Initialize default values
	CALL InitSWEParam(header)	

! Search for and read r2c file header
	line(1:1) = '#'
	foundEndHeader = .false.

	do WHILE((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(LEN_TRIM(line) .eq. 0))) 	

		read(UNIT=unitNum, FMT='((A))', iostat=ios) line	! read a line
		if(ios .eq. -1)then
			write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
			STOP ' Stopped in read_swe_ef'
		end if

		rStat = Detab(line)				! replace tabs with spaces
		line = ADJUSTL(line)		! Get rid of leading white space
		lineLen = LEN_TRIM(line)		! Find the length excluding trailing spaces

		if(line(1:1) .eq. ':')then
			wordCount = SplitLine(line, keyword, subString)	! find the keyword
			rStat = ToLowerCase(keyword)
			KeyLen = LEN_TRIM(keyword)

			if(keyword(1:KeyLen) .eq. ':endheader')then
				foundEndHeader = .TRUE.

			else
				iStat = ParseSWEParam(header,keyword,keyLen,
     &													subString)
				if(iStat .lt. 0) then
					write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
					write(*,'(2(A))') '   in line: ',line					
					STOP ' Stopped in read_swe_ef'
					return
				else if(iStat .eq. 0) then
!				write(*,'((A), (A))')  'Unrecognized keyword line: ',
!     &										line
				endif
			end if
		end if
	end do
!***************************************
!	Finished reading the header
!***************************************

! Assign the parsed parameters to the model variables		
	xCountLoc = header%r2cp%xCount
	yCountLoc = header%r2cp%yCount
	attCountLoc =header%r2cp%ep%attCount
c	imax=header%r2cp%yCount
c	jmax=header%r2cp%xCount 
	deffactor = header%initHeatDeficit !Set InitHeatDeficit

! Read the data section
	CALL LoadAttributeData(header%r2cp%ep, xCountLoc,
     &						yCountLoc, unitNum)	
		
! Validate parameters
!     rev. 9.5.13  Feb.  25/08  - NK: changed tolerance for coordinate check to .gt.0.001
	if(abs(header%r2cp%xOrigin-xorigin).gt.0.001)
     *    print*,'xorig_swe.ne.xorigin'
	if(abs(header%r2cp%yOrigin-yorigin).gt.0.001)
     *    print*,'yorig_swe.ne.yorigin'
      if(abs(header%r2cp%xDelta-xdelta).gt.0.001)
     * 	print*,'xdelta_swe.ne.xdelta'
	if(abs(header%r2cp%yDelta-ydelta).gt.0.001)
     * 	print*,'ydelta_swe.ne.ydelta'
      if(header%r2cp%xCount.ne.xcount)
     * 	print*,'xcount_swe.ne.xcount'
      if(header%r2cp%yCount.ne.ycount)
     * 	print*,'ycount_swe.ne.ycount'
      if(abs(header%r2cp%xOrigin-xorigin).gt.0.001.or.
     &	abs(header%r2cp%yOrigin-yorigin).gt.0.001.or.
     &	abs(header%r2cp%xDelta-xdelta).gt.0.001.or.
     &	abs(header%r2cp%yDelta-ydelta).gt.0.001.or.
     &	header%r2cp%xCount.ne.xcount.or.
     &	header%r2cp%yCount.ne.ycount) then
	      PRINT*,'Mismatch between ',fln(flnNum)
            print*,'       and SHD files'
            print*,'Check files for origins, deltas and counts'
            print*,'Could be due to # significant digits in header' 
		STOP 'Program aborted in read_swe_ef @ 141'
	endif

	nclasses = header%r2cp%ep%attCount
	if(nclasses.lt.classcount)then
!         there are fewer classes in the swe file than needed
		print*
		print*,' The swe file has ',nclasses,' land cover classes'
		print*,' The shd file stipulates ',classcount,' which'
		print*,' includes the impervious class'
		print*,' Please fix the swe file for proper # of classes'
		print*
          STOP 'Program aborted in read_swe_ef'
      endif

!     rev. 10.3.07 Mar.  04/20  = NK Fixed weighted swe in wfo file for grids with water
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating
!     Start by finding the weighted swe for each grid   
      do n=1,naa
          totsnw(n)=0.0
          class_sum=0.0
          do ii=1,classcount
             if(aclass(n,ii).gt.0.0)then
                if(ii.ne.ii_water)then
                  class_sum=class_sum+aclass(n,ii)
                  totsnw(n)=totsnw(n)+snowc(n,ii)*aclass(n,ii)*sca(n,ii)
                endif
             endif
          end do
          totsnw(n)=totsnw(n)/class_sum
      end do     

c        imax=ycount
c	  jmax=xcount

!     check added Jul. 13/11 nk
      if(yCountLoc.ne.ycount)then
        print*,'ycount in ',fln(flnNum)
        print*,'does not match the ycount in the shd file'
        print*
        stop 'Program aborted in read_swe_ef.f @ 165'
      endif
      if(xCountLoc.ne.xcount)then
        print*,'xcount in ',fln(flnNum)
        print*,'does not match the xcount in the shd file'
        print*
        stop 'Program aborted in read_swe_ef.f @ 171'
      endif
      if(attCountLoc.ne.classcount)then
        print*,'classcount in ',fln(flnNum)(1:50)
        print*,'does not match the classcount in the shd file'
        print*
        stop 'Program aborted in read_sweinit.f @ 187'
      endif
      
! Copy Attribute data over to Nick's global variables
	do ii=1,attCountLoc
		vi = 0
!		do yi=yCountLoc,1,-1   !  backwards  nk  Mar. 20/07
		do yi=1,yCountLoc
			do xi=1,xCountLoc
!                 put the same swe in all classes                  
				vi = vi+1
			    snw(yi,xi) = header%r2cp%ep%attList(ii)%val(vi)
			end do
          end do
          end do

!     rev. 10.3.09 Mar.  07/20  = NK Revise swe updating to maintain relative swe in classes
!     Find the ratio of obs swe / weighted model swe
      do n=1,naa
			i=yyy(n)
			j=xxx(n)
              if(totsnw(n).gt.10.0)then
!                  If there is not much snow in the model, ratio is too erratic   
!                  and just use the snow course data                  
                   ratio2(i,j)=snw(i,j)/totsnw(n)
              else
                   ratio2(i,j)=1.0000
              endif
      if(i.eq.ycount/2.and.j.eq.xcount/2)
     *      write(666,*)id,totaltime,snw(i,j),totsnw(n),
     *                ratio2(ycount/2,xcount/2)
      end do
      
!   Adjust and put INTO VECTOR FORMAT
	do ii=1,attCountLoc
		do n=1,naa
			i=yyy(n)
			j=xxx(n)
!             Old way: swe in all classes replaced by swe from the r2c file              
!			snowc(n,ii)=max(0.0,snw(i,j))
              
!     rev. 10.3.09 Mar.  07/20  = NK Revise swe updating to maintain relative swe in classes
!             Multiply by the ratio so relative swe in classes stay the same
              snowc(n,ii)=snowc(n,ii)*ratio2(i,j)
              
			if(snowc(n,ii).gt.0.0)then
				sca(n,ii)=1.0
				oldsca(n,ii)=1.0
!				set the initial heat deficit for the snow:
				def(n,ii)=deffactor*snowc(n,ii)
			else
!     May 10, 2002 Added these lines to avoid underflows later! AB
				sca(n,ii)=0.0
				oldsca(n,ii)=0.0
				def(n,ii)=0.0
			endif
		end do
      end do

! Deallocate the attribute data now that global attributes have been set
	do ii=1,attCountLoc
		deallocate ( header%r2cp%ep%attList(ii)%val, STAT = error )
		if (error.ne.0) STOP 'deallocation error in read_sweinit()' 
      end do
      
      deallocate(ratio2,STAT = error)
	if (error.ne.0) STOP 'deallocation error in read_sweinit()' 

      close (unit=unitNum)

	if(iopt.ge.1)print*,'Finished reading ',fln(flnNum)(1:30)

      RETURN

      END SUBROUTINE read_sweinit



subroutine read_swe_date

!***********************************************************************
!    Copyright (C) 2019 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.


!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!---------------------------------------------------------------
! xmlparse.f90 - Simple, limited XML parser in Fortran
    use xmlparse
! $Id: xmlparse.f90,v 1.14 2007/12/07 10:10:19 arjenmarkus Exp $
!
! Arjen Markus
! Adopted & modified for WATFLOOD: Nicholas Kouwen June 2019 
! to read swe and uzs modifiers for FEWS    
!---------------------------------------------------------------
! This s/r opens & reads the adjustment factor for swe in FEWS
    
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
    use area_watflood
    implicit none
    
    character(len=20) :: fname
    character(len=20) :: structname
    character(len=30):: line,junk(10)
    logical :: mustread
    type(XML_PARSE) :: info
    character(len=80) :: tag
    logical :: endtag
    character(len=80), dimension(1:2,1:20) :: attribs
    integer :: no_attribs
    character(len=200), dimension(1:100) :: data
    integer :: no_data
    integer :: i,Zoffset
    
!   NK    
    logical                  :: ign_whitespace
    character(2)             :: units
    character(6)             :: parameterID
    
! get name of XML file (store in fname)
    fname='snow1\swe_date.xml'
   
    mustread = .true.
    call xml_open( info, fname, mustread )
!
! Check for errors
!
    if ( xml_error(info) ) then
        print*,'Error opening ',fname
        print*,info
        stop 'Program aborted @ 43'
    else
!
! Start reading the file
!
        call xml_options( info, ignore_whitespace = ign_whitespace )
        do
            call xml_get( info, tag, endtag, attribs, no_attribs, data, &
            no_data )
            if ( xml_error(info) ) then
                print*,'Error reading ',fname
                print*,info
                stop 'Program aborted @ 43'
            endif
! Just write out the tag, its attributes and the character
!data we found
            write( 20,*)'x', (i, '>',trim(data(i)), '<', i=1,no_data)
            
            if(tag.eq.'stringValue')then
               write( 20,*)'x', (i, '>',trim(data(i)), '<', i=1,no_data)
               write(20,*)trim(data(1))
               write(20,*)data(1)
               line=trim(data(1))
!    integer :: yy_swe_update,mm_swe_update,dd_swe_update,hh_swe_update
!               read(data(1),6000)junk,line,dd_swe_update,hh_swe_update,junk,yy_swe_update
               read(line,*)(junk(i),i=1,6)
               write(20,*)(junk(i),i=1,6)
               read(junk(3)(1:3),*)dd_swe    !day
               read(junk(4)(1:2),*)hh_swe    !hour
               read(junk(5)(4:6),*)junk(10)
               read(junk(10),*)Zoffset
               read(junk(6)(1:4),*)yy_swe    !year
               
               if(junk(2)(1:3).eq.'Jan')then
                   mm_swe=1
               elseif(junk(2)(1:3).eq.'Feb')then
                   mm_swe=2
               elseif(junk(2)(1:3).eq.'Mar')then
                   mm_swe=3
               elseif(junk(2)(1:3).eq.'Apr')then
                   mm_swe=4
               elseif(junk(2)(1:3).eq.'May')then
                   mm_swe=5
               elseif(junk(2)(1:3).eq.'Jun')then
                   mm_swe=6
               elseif(junk(2)(1:3).eq.'Jul')then
                   mm_swe=7
               elseif(junk(2)(1:3).eq.'Aug')then
                   mm_swe=8
               elseif(junk(2)(1:3).eq.'Sep')then
                   mm_swe=9
               elseif(junk(2)(1:3).eq.'Oct')then
                   mm_swe=10
               elseif(junk(2)(1:3).eq.'Nov')then
                   mm_swe=11
               elseif(junk(2)(1:3).eq.'Dec')then
                   mm_swe=12
               endif
               print*, yy_swe,mm_swe,dd_swe,hh_swe   
               write(20,*) yy_swe,mm_swe,dd_swe,hh_swe,Zoffset   
               write(20,*) yy_swe,mm_swe,dd_swe,hh_swe,Zoffset   
               write(20,*) yy_swe,mm_swe,dd_swe,hh_swe,Zoffset  
               exit
            endif
                
            if ( .not. xml_ok(info) ) exit
        enddo
    endif
    call xml_close( info )

    return
    
end subroutinesubroutine read_swe_use    

!***********************************************************************
!    Copyright (C) 2019 by Nicholas Kouwen  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.


!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!---------------------------------------------------------------
! xmlparse.f90 - Simple, limited XML parser in Fortran
    use xmlparse
! $Id: xmlparse.f90,v 1.14 2007/12/07 10:10:19 arjenmarkus Exp $
!
! Arjen Markus
! Adopted & modified for WATFLOOD: Nicholas Kouwen June 2019 
! to read swe and uzs modifiers for FEWS    
!---------------------------------------------------------------
! This s/r opens & reads the adjustment factor for swe in FEWS
    
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
    use area_watflood
    implicit none
    
    
    character(len=20) :: fname
    character(len=20) :: structname
    character(len=256):: line
    logical :: mustread
    type(XML_PARSE) :: info
    character(len=80) :: tag
    logical :: endtag
    character(len=80), dimension(1:2,1:20) :: attribs
    integer :: no_attribs
    character(len=200), dimension(1:100) :: data
    integer :: no_data
    integer :: i
    
!   NK    
    logical                  :: ign_whitespace
    character(2)             :: units
    character(6)             :: parameterID
    
! get name of XML file (store in fname)
    fname='snow1\SWE_use.xml'
   
    mustread = .true.
    call xml_open( info, fname, mustread )
!
! Check for errors
!
    if ( xml_error(info) ) then
        print*,'Error opening ',fname
        print*,info
        stop 'Program aborted in read_swe_use @ 43'
    else
!
! Start reading the file
!
        call xml_options( info, ignore_whitespace = ign_whitespace )
        do
            call xml_get( info, tag, endtag, attribs, no_attribs, data, &
            no_data )
            if ( xml_error(info) ) then
                print*,'Error reading ',fname
                print*,info
                stop 'Program aborted in read_swe_use @ 43'
            endif
! Just write out the tag, its attributes and the character
!data we found
            
            if(tag(1:9).eq.'boolValue')then
!               write( 20,*)'x', (i, '>',trim(data(i)), '<', i=1,no_data)
!               write(20,*)trim(data(1))
               if(trim(data(1)).eq.'true')then
                   use_swe_update=.true.
                   write(98,*)'Info: SWE update = TRUE'
               else
                   use_swe_update=.false.
                   write(98,*)'Info: SWE update = FALSE'
               endif
               write(20,*)use_swe_update
               exit
            endif
                
            if ( .not. xml_ok(info) ) exit
        enddo
    endif
    call xml_close( info )

    return
    
end  subroutine read_swe_use      SUBROUTINE read_temp_ef(hdrflg,jan,jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!  READ_TEMP_EF - written May/06 by Dave Watson
!	- Derived from rdtemp written by Nick Kouwen
!	- This subroutine reads the ensim compatible gridded temperature
!	  (TEM) file (r2c format)
!***********************************************************************
!     rev. 9.7.04  Aug.  30/10  - NK: added to error message in read_rain & read_temp
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
!     rev. 9.7.18  Jan.  17/11  - NK: Changed tolerance on the grid check in rear_rain & read_temp

      use area_watflood
      use EF_Module

      implicit none
      type(TempParam) :: header
      type(FrameRecord) :: frameRec

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION :: ntoc(9000)

      real*4  :: x1,deltatmp,teltatmp
      integer :: idlast,mhlast,jan,ntocorrect,ios,ios1,
     *           ntoc,i,iend,j,jz,n,
     *           ndeltatt,tem_hr,iostat,iAllocate,iDeallocate,
     *           nh_count,
     *           nolines,xcount_max,ycount_max
!      character(10) ::  fileformat,starttime,startdate
      character(10) ::  fileformat
      real*4	timeHrs

      character*20  :: junk
      character*1   :: junk2,newfmtflg,firstpass,lineflg,hdrflg
      character*6   :: junk0
      DATA idlast/0/
      data firstpass/'y'/
      LOGICAL      :: exists

     
! Local variables
      integer*4 unitNum, flnNum, iStat
      character*4096 line, subString
      character*128 keyword, value
      integer lineLen, keyLen, wordCount
      logical rStat, foundEndHeader,foundFirstFrame,foundFrame
      integer frameCount

      integer modelHour !used to be k
      integer modelHourLast !used to be klast
      integer dataHour !used to be nr_count

! Dave's debug variables
!	integer daveInt
!	real daveReal

! Initialize default values within frame module
      CALL InitFrameRecord(frameRec)

! Set unit and fln number
      unitNum = 45
      flnNum = 15

      foundEndHeader = .false.

! Debug line
!	print*, 'Inside read_temp_ef at time = ',timeHrs, 'hrs'

! If hdrflg==1 ,then it's the first time through for this event
      if(hdrflg.eq.'1')then
c        open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
c        if(ios.ne.0)then
c            print*, 'Problems opening the tem file',fln(flnNum)
c            STOP ' Stopped in read_temp_ef'
c        endif


		inquire(FILE=fln(flnNum),EXIST=exists)
		if(exists) then
		  open(unit=unitNum,file=fln(flnNum),status='old',iostat=ios)
	    if(ios.ne.0)then
		    print*, 'Problems opening file',fln(flnNum)(1:40)
		    STOP ' Stopped in read_temp_ef @ 85'
		  endif
	    if(iopt.ge.1)print*,'Opened unit'
     *                      ,unitNum,' filename  ',fln(flnNum)(1:40)
		else
		  print*, 'Attempting to open file name ',fln(flnNum)(1:40)
	    print*, 'Unit number ',unitNum
		  print*, 'but it is not found (in this location)'
		  STOP 'Program aborted in read_temp_ef @95'
		endif



! Initialize default values within rain module
        call InitTempParam(header)	

! Search for and read r2c file header
        line(1:1) = '#'
        do while((.NOT.foundEndHeader) .AND.
     &	    ((line(1:1) .eq. '#') .OR.
     &		(line(1:1) .eq. ':') .OR.
     &		(len_trim(line) .eq. 0))) 	

            read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
            if(ios .eq. -1)then
                print*, 'ERROR: Premature EndOfFile encountered'
                STOP ' Stopped in read_temp_ef'
            end if

            rStat = Detab(line)				! replace tabs with spaces
            line = adjustl(line)		! Get rid of leading white space
            lineLen = len_trim(line)		! Find the length excluding trailing spaces

            if(line(1:1) .eq. ':')then
                wordCount = SplitLine(line, keyword, subString)	! find the keyword
                rStat = ToLowerCase(keyword)
                KeyLen = len_trim(keyword)

                if(keyword(1:KeyLen) .eq. ':endheader')then
                    foundEndHeader = .TRUE.
                else
                    ! parse the header
                    iStat = ParseTempParam(header,keyword,keyLen,
     &													subString)
                    if(iStat .lt. 0) then
                       write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                        write(*,'(2(A))') '   in line: ',line					
                        STOP ' Stopped in read_temp_ef'
                        return
                    else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ',line
                    endif
                end if
            end if
        end do

! Assign the parsed parameters to the model variables		
        xcount3 = header%r2cp%xCount
        ycount3 = header%r2cp%yCount
        xorigin3 = header%r2cp%xOrigin
        yorigin3 = header%r2cp%yOrigin
        xdelta3 = header%r2cp%xDelta
        ydelta3 = header%r2cp%yDelta
        
c!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
c        if(xcount3.ne.xcount_precip.or.ycount3.ne.ycount_precip)then
c          print*
c          print*,'Fatal error:'
c          print*,'xcount3 =',xcount3,'   xcount_precip =',xcount_precip
c          print*,'ycount3 =',ycount3,'   ycount_precip ='ycount_precip
c          print*,'Precip and temperature grids do not match'
c          stop 'Program aborted in read_temp_ef @ 141'
c        endif

! Scan data frames
        frameCount = 0
        do while((.NOT.EOF(unitNum)))
            read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
            if(ios .eq. -1)then
             write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
                STOP ' Stopped in read_temp_ef'
            end if

            rStat = Detab(line)				! replace tabs with spaces
            line = adjustl(line)		! Get rid of leading white space
            lineLen = len_trim(line)		! Find the length excluding trailing spaces

            if(line(1:1) .eq. ':')then
                wordCount = SplitLine(line, keyword, subString)	! find the keyword
                rStat = ToLowerCase(keyword)
                KeyLen = len_trim(keyword)
                
                if(keyword(1:KeyLen).eq.':frame')then
                    iStat = ParseFrameLine(frameRec,keyword,keyLen,
     &													subString)
                    
!	Identify the first and last frame's timestamp 
                    if(iStat .lt. 0) then
                       write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                        write(*,'(2(A))') '   in line: ',line					
                        STOP ' Stopped in read_temp_ef'
                        return
                    else if(iStat .eq. 0) then
!						write(*,'((A), (A))')
!     &								'Unrecognized keyword line: ', line
                    else if(frameRec%frame.EQ.1) then
                        header%startJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
                        header%startHour = frameRec%tStamp%hour
                    else
                        header%endJulianDay =
     &						JDATE(frameRec%tStamp%year,
     &							frameRec%tStamp%month,
     &							frameRec%tStamp%day)
                        header%endHour = frameRec%tStamp%hour
                    end if
                    header%r2cp%frameCount = header%r2cp%frameCount+1
                end if
            end if
        enddo	
      
!	deltat2 = model timestep in hours 
        deltat2 = 1	
!	njtemp = number of hours spanned by this tem file
!	convert to julian days to properly calculate hours spanned
        nhtemp = (header%endJulianDay - header%startJulianDay)*24
     &				 + (header%endHour - header%startHour) + 1

!		nr = (header%endJulianDay - header%startJulianDay)*24
!     &				 + (header%endHour - header%startHour) + 1

!     Dave used nr instead of nhtemp here becasue file was copied from read_rain_ef
!     we need a different variable for the # hours of data for the tem file
!     nk  Nov. 23/06

        
!	Position to start of data (immediately after first frame record but before first frame data)
        REWIND (unitNum)
        foundFirstFrame = .false.
        do WHILE(.NOT.foundFirstFrame)
            read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
            temp_frame_header=line
            new_temp_frame_header=line
            temp_flg=.true.
            if(line(1:1) .eq. ':')then
                wordCount = SplitLine(line, keyword, subString)	! find the keyword
                rStat = ToLowerCase(keyword)
                KeyLen = len_trim(keyword)
                if(keyword(1:KeyLen).eq.':frame')then
                    iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
                    foundFirstFrame = .true.
                end if
            end if		      
        enddo	
        
        modelHour=1 ! set model hour to first hour
        dataHour = 0 ! set data hour to just before first hour

! Are we LatLong or Projected
        if(IsLatLong(header%r2cp%csp).eq.(.true.))then
            rgrde=xdelta2*60.
            rgrdn=ydelta2*60.  
            rads=int(yorigin2*60.0)
            radn=int((yorigin2+ycount2*ydelta2)*60.0) 
            radw=int(xorigin2*60.0)  
            rade=int((xorigin2+xcount2*xdelta2)*60.0)  
        else
            rgrde=xdelta2/1000.
            rgrdn=ydelta2/1000. 
            rads=int(yorigin2/1000.)
            radn=iymin+grde*(ycount2-1)
            radw=int(xorigin2/1000.)
            rade=jxmin+grdn*(xcount2-1)
            if(abs(xdelta2-ydelta2).lt.0.001)then  ! changed jan20/08 nk
                rgrd=xdelta2/1000.
            else
              print*, 'ERROR - xdelta .ne. ydelta'
              print*,' xdelta =',xdelta
              print*,' ydelta =',ydelta
              STOP 'Program aborted in read_temp_ef @ 249'
            endif
        endif

! firstpass means this is the first tem file of the first event...which is the only time it needs to be done
        if(firstpass.eq.'y')then
            firstpass='n'      
            xcount_max=max(xcount+1,xcount3)
            ycount_max=max(ycount+1,ycount3)
            allocate(ttemp(ycount_max,xcount_max),tempv(na),
     *						tempvmin(na),rh(na),stat=iAllocate)
            if(iAllocate.ne.0) STOP
     *	   'Error with allocation in read_temp_ef'
c			xcount_max=xcount3
c			ycount_max=ycount3
        endif

 
! Nick initializes stuff here...may want to move this to process_temp()
        do n=1,na
            tempvmin(n)=99.99
            rh(n)=.50
        enddo

!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability

        if(jan.eq.1.and..not.netCDFflg)then     
!       CALCULATE THE GRID OFFSETS:
            if(iymin.ge.rads.and.jxmin.ge.radw)then
!         COMPARE THE SOUTH-WEST CORNER COORDINATES
                if(IsLatLong(header%r2cp%csp).eq.(.true.))then
                    iyoffset=int(float(iymin-rads)/rgrdn)+iyshift
                    jxoffset=int(float(jxmin-radw)/rgrde)+jxshift
                else
                    iyoffset=int(float(iymin-rads)/grdn)+iyshift
                    jxoffset=int(float(jxmin-radw)/grde)+jxshift
                endif
            elseif(abs(iymin-rads).gt.1.or.abs(jxmin-radw).gt.1)then
!     rev. 9.7.18  Jan.  17/11  - NK: Changed tolerance on the grid check in rear_rain & read_temp
!         WATERSHED GRID does not coincide with met gris
                  print*
                  print*,'WARNING:'
                  print*,' In read_temp_ef:'
                  print*,'tmp grid does not coincide with shd file'
                  print*,'This could be due to round off when using'
                  print*,'fractions of degrees as the grid size'
                  print*,'iymin,jxmin,rads,radw/',iymin,jxmin,rads,radw
                  print*,'Please check the headers on the shd & tmp'
                  print*,'for compatibility'
                  print*                     
                  STOP 'Program aborted in read_tmp_ef @ 298'
            else
                iyoffset=0
                jxoffset=0
                ! DO NOTHING
            endif
c           what is this doing here??????????????????????????????
c			call precip_adjust()
        endif   ! END OF JAN=1
        
! Check for change of grid size
        if(xcount3.gt.xcount_max.or.ycount3.gt.ycount_max)then
            deallocate(ttemp,stat=iDeallocate)
            if(iDeallocate.ne.0) then
                print*,	'Warning: error with deallocation of outarray'
            endif

            xcount_max=xcount2
            ycount_max=ycount2
!       outarray is in areawfo
!       this has to be allocated before calling write_r2c
            allocate(ttemp(ycount_max,xcount_max),stat=iAllocate)
            if(iAllocate.ne.0) then
                STOP 'Error with allocation of outarray in tr_sub'      
            end if
        endif


        return
      endif          ! (hdrflg.eq.'1')

!***********************************************************
!***********************************************************
      
!     Finished reading the header      

!***********************************************************
!***********************************************************

! Moved from above        
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
        if(xcount3.ne.xcount_precip.or.ycount3.ne.ycount_precip)then
          print*
          print*,'Fatal error:'
          print*,'xcount3 =',xcount3,'   xcount_precip =',xcount_precip
          print*,'ycount3 =',ycount3,'   ycount_precip =',ycount_precip
          print*,'Precip and temperature grids do not match'
          stop 'Program aborted in read_temp_ef @ 141'
        endif


!     We are looking for temp data for this step
      dataHour = dataHour + 1

      if(modelHour.eq.modelHourLast.and.dds_flag.eq.0)then
c        print*,'Hr=',modelhour,' Error in ',
c     *                 fln(flnNum)(1:40),' met data repeated??'
         write(*,*)'Error in the tem file @ ',frameRec%frame
c     &            frameRec%tStamp%year,'/',frameRec%tStamp%month,'/',
c     &            frameRec%tStamp%day,'/',frameRec%tStamp%hour
         write(51,*)'Error in the tem file @ frame #',frameRec%frame
c     &            frameRec%tStamp%year,'/',frameRec%tStamp%month,'/',
c     &            frameRec%tStamp%day,'/',frameRec%tStamp%hour
51000     format(a24,i4,a1,i2,a1,i2,a1,i2)    
      endif    
 
!	If there is a record for this hour than modelHour = dataHour
!	print*,	'modelHour:',modelHour, 'dataHour:',dataHour
!	if(modelHour.eq.dataHour)then

!     This is changed so if we've passed the time this data should have
!     been read - we'd better read it now      
      if(modelHour.eq.jz)then
          
!	Go ahead and read the data for this frame 
        do i=1, ycount3
!           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            read(45,*,iostat=ios)(ttemp(i,j),j=1,xcount3)
!           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            if(ios.ne.0)then
                write(*,9993)modelHour,i
                print*,'iostat =',ios
                print*,' last data read:'
                print*,' jradw= 1 jrade= ',jrade
                print*,' iradn= ',iradn,' irads= 1'
                print*,'Event #',id
                PRINT*,'DataHour,ModelHour(jz)',modelHour,jz
                STOP ' program aborted - read_temp_ef @ 396'
            endif
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
            temp_frame_header=new_temp_frame_header
            temp_flg=.true.
            
        end do
        
!     rev. 10.2.48 Feb.  25/19  - NK: Moved temp correction to read_temp from process_temp
!     RAISE OR LOWER THE TEMPERATURE FILED:
      if(scaletem.gt.0.00001.or.scaletem.lt.-0.00001)then
         do i=1,ycount3
            do j=1,xcount3
               ttemp(i,j)=ttemp(i,j)+scaletem
            end do
         end do
      endif
      

!	  Read the next frame. If we are at the end of the file...close
        foundFrame = .false.
        do WHILE(.NOT.foundFrame)
            read(unit=unitNum, FMT='((A))', iostat=ios) line	! read a line
            if(EOF(unitNum)) then 
                close(unit=unitNum,status='keep',iostat=ios)
                RETURN
            endif

            if(line(1:1) .eq. ':')then
                wordCount = SplitLine(line, keyword, subString)	! find the keyword
                rStat = ToLowerCase(keyword)
                KeyLen = len_trim(keyword)
                if(keyword(1:KeyLen).eq.':frame')then
                    iStat = ParseFrameLine(frameRec,keyword,
     &												keyLen,subString)
                    foundFrame = .true.
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
                    new_temp_frame_header=line
                    new_temp_flg=.true.
                end if
            end if		      
        enddo	

        modelHourLast=modelHour

!	Determine the next modelhour		
        modelHour =	(JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
     &				frameRec%tStamp%day) - header%startJulianDay) * 24
     &				+ (frameRec%tStamp%hour - header%startHour) + 1

!       check added May 2/12  nk
c        write(555,55500)modelHour,
c     &                frameRec%tStamp%year,frameRec%tStamp%month,
c     &				frameRec%tStamp%day,frameRec%tStamp%hour,
c     &                header%startJulianDay,header%startHour,
c     &                JDATE(frameRec%tStamp%year,frameRec%tStamp%month,
c     &				frameRec%tStamp%day) 
c55500   format(10i10)
!     rev. 10.2.24 May   21/18  - NK: Added error message in Read_rain & read_tmp
        if(modelHour-modelHourLast.lt.0)then
          print*
          print*,'Error:'
          print*,'file name ',fln(flnNum)(1:50)
          print*,'modelHour =',modelHour
          print*,'modelHourLast =',modelHourLast
          print*,'Note: Frame numbers must be monotomically increasing'
          print*,'in an r2c time series file.'
          print*,'year ',frameRec%tStamp%year
          print*,'month',frameRec%tStamp%month
          print*,'day  ',frameRec%tStamp%day
          print*,'hour ',frameRec%tStamp%hour
          print*
          print*,'possible cause: month repeated in the r2c file'
          print*
          stop 'Program aborted in read_temp_ef @ 411'
        endif

!		do nothing...keep last temperature values...

      endif

      RETURN

!     FORMATS

 9993 format(' error reading temp at hour/line ',2i10/)
      

      END SUBROUTINE read_temp_ef

      !-----------------------------------------------------------------
       SUBROUTINE REL_HUM(x1,rh,temp,dewpoint)
 
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      !-----------------------------------------------------------------
      ! This subprogram is designed to accept temperature and dewpoint
      ! data and convert them to relative humidity data, using Newton's
      ! iterative Method.
      ! 
      ! rh :relative humidity
      ! new_rh_max :maximum relative humidity based on dewpoint
      !  temperature
	! dewpoint :dewpoint temperature
	! temp :temperature
	! x1 :USED IN OLD PROGRAM; TO BE REMOVED; PASSED BY REFERENCE AND 
      ! MUST ALSO BE REMOVED ONCE IT IS DETERMINED WHERE IT IS PASSED.
      !-----------------------------------------------------------------

      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

!     see Ken's thesis for e equation 4-12

      REAL ::rh,dewpoint,temp,new_rh_max,x1

      ! If the dewpoint is less than 0, then the maximum relative 
      ! humidity has to be adjusted to compensate for lower maximum  
      ! relative humidities at lower temperatures.  Otherwise, set to 
      ! 100%

      IF (dewpoint.LT.0)THEN
         new_rh_max=0.5*dewpoint+100
      ELSE
         new_rh_max=100
      END IF
       
!	rh=((exp(50*(1.31*dewpoint-36.2)/(4.21*dewpoint+1000)))/(/(6.11*
!     &exp((17.3*temp)/(temp+237.3))


	rh=((exp(50*(1.31*dewpoint-36.2)/(4.21*dewpoint+1000)))/(6.11*
     &       exp((17.3*temp)/(temp+237.3))))

      ! If the calculated rh is greater than the maximum rh at that 
      ! temperature, then it is reset to the maximum rh

      IF(rh.GT.new_rh_max)THEN
         rh=new_rh_max
      ! If it is less than 0%, then there is an error and 999.9999 is 
      ! outputted
      ELSE IF(rh.LT.0)then
         rh=999.9999
      END IF

      RETURN
      END SUBROUTINE REL_HUM
      !-----------------------------------------------------------------
      SUBROUTINE rerout(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!DEC$ ATTRIBUTES DLLIMPORT:: rules_MH

!***********************************************************************
!    Copyright (C) 1987-2018 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!     This s/r is meant to be user friendly so operating rules
!     for specific applicatins can be coded.

!***********************************************************************
!   THIS S/R  ROUTES WATER THROUGH A RESERVOIRFq
!   or SIMPLY PASSES ENTERED FLOWS TO THE RIVER
!
!     REV. 7.80   Oct.  29/96 -  SPL7 ADDED YYMMDD.RIN FOR RES INFLOWS
!                             -  UNIT = 39   FLN = 09
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.67  Oct.  06/09  - NK: fixed bug in rerout
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!     rev. 9.8.65  May   28/13  - NK: Dimensioned firstpass_local()in REROUT
!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
!***********************************************************************

      use area_watflood
	implicit none
	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH
	

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: old,hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live
      real*4   :: zp,kkk   ! coefficients for Lake Athabasca routing rule
      real*4   :: fudge,Qfudge,Qlast,WSL   ! coefficients for GSL routing rule
      integer  :: PPx,PPy,PPn    !  needed for Lake Athabasca routing
	integer  :: lcount,day_last
	real*4   :: elvlast,qraw,wollaston_base_store,qtemp
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     for Jenpeg 
      integer  :: jenpeg_grid_no,jenpeg_div_no,jenpeg_gauge_no
!     For the Lake Winnipeg model
      integer  :: FamL_S_grid_no
      integer  :: ivalue
      real(4)  :: xvalue,yvalue,parValue(10)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      logical       :: natural
      
      real*4, dimension(:),   allocatable :: raise,lower,inflow
      real*4, dimension(:),   allocatable :: qo1_temp,qo2_temp

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.true./

!     For the great lakes only:
      DATA retard_factor/0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.,0.,
     * 590.,480.,110.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,110.,
     * 650.,510.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,140.,
     * 110.,140.,80.,140.,0.,60.,230.,140.,80.,60.,0.0,0.0,
     * 170.,300.,150.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10./
!     initial water elevations - now read from a file
!	data sup_init,mhu_init,stc_init,eri_init,ont_init/
!     *      183.2,175.98,174.8,174.01,74.61/

!     lif = lake ice factor

!     WHEN LOCAL IS -VE, RESERVOIR RELEASES ARE NEED IN AND THESE 
!     BECOME THE OUTFLOWS OF THE SQUARE IN WHICH THE DAM OUTLET 
!     STRUCTURE IS LOCATED.  
!     WHEN LOCAL = 0 , THERE ARE NO RESERVOIRS, REROUT IS NOT CALLED.

!     WHEN LOCAL IS +VE, THE INFLOW TO THE SQUARE IN WHICH THE
!     RESERVOIR IS LOCATED IS PRINTED OUT ON FILE 11 FOR USE IN
!     HEC-5 OR OTHER OPERATING PROGRAM.

!     THE OVERALL OPERATING SEQUENCE IS THEN THE FIRST RUN SIMPLE
!     TO CALCULATE THE RUNOFF PRODUCED IN VARIOUS SUB-BASINS THEN
!     TO DETERMINE RELEASES, AND THEN TO ROUTE THE RELEASES AND LOCAL
!     INFLOWS USING HYMO.  THE RELEASES ARE READ IN FROM FILE 12.

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk
      
      if(firstpass_local(98))then
        last_month=month_now
        wrtdiverflg=.false.  !used for writing a new diversion file 
!       if divertflg = 'g' then diversion flows need to be generated 
!       for L. St. Joseph and NOT read in. In this case, qdivert 
!       has not been allocated in read_divert_ef.f so it needs to be 
!       done here for just one location:
        if(.not.allocated(qdivert))then
!         set one diversion location
          nodivert=1
          allocate(qdivert(nodivert,mhtot),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of aqdivert  in rerout @ 109'
        endif
        if(iopt.ge.1)print*,'qdivert allocated as      1,',mhtot
        firstpass_local(98)=.false.
      endif
      
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv),
     *           qo1_temp(noresv),qo2_temp(noresv),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
     
!       For lake Athabasca ONLY:
        natural=.false.
        INQUIRE(FILE='natural.txt',EXIST=exists)
        if(exists)then
          open(unit=99,file='natural.txt',status='old',iostat=ios)
          read(99,*)natural
          IF(NATURAL)THEN
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            PRINT*,'Using naturalized flow for the MRB'
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          endif
        endif
        firstpass_local(99)=.false.
      endif
      
      if(firstpass_local(97))then
!       FIND THE GRID NUMBER FOR pEACE pOINT         
!     REV. 10.1.40 Oct   11/16  - NK: Fixed bug in read_divert for missing u/s DA
        if(resname(l)(1:7).eq.'Athabas'.and.routeflg.ne.'q')then
          PPy=int((59.118-yorigin)/ydelta)+1
          PPx=int((-112.437-xorigin)/xdelta)+1
          PPn=s(ppy,ppx)
          b7(2)=207.0   !  datum
          firstpass_local(97)=.false.
        endif
      endif

!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.53  Jan.  20/09  - NK: undid rev. 9.5.40
!##########################################################################
!     DIVERSIONS
!##########################################################################
!     rev. 9.5.40  Oct.  21/08  - NK: added diversions to rerout
!     A diversion can only be made to another node providing
!     the receiving node is at a lower elevation - i.e. the grid number is 
!     higher in the order = later in the grid loop n=1,naa
!     Makes sense. Can not divert to a higher grid without pumping

!     If in an outlet node of a lake from which diversion is made,
!     add an outflow from this reach to the inflow in another. 

!     Lake St Joseph:
!     outflow grid = 1803    05QB006
!     receiving grid = 1866
c      if(n.eq.1803.and.na.eq.3039)then
c        q_divert=qhyd(34,(jz-1)/ktr*ktr+ktr)        
c        q_divert=amax1(0.0,q_divert)     ! in case there are missing data (-1.00)
c        qi2(1866)=qi2(1866)+q_divert   ! diversion into receiving grid
c        write(53,*)n,jz,(jz-1)/ktr*ktr+ktr,qi2(1866),q_divert
c      else
c        q_divert=0.000
c      endif
!###########################################################################

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
!     Note:
!     b1(l) can be less or more than 1.00 for the polinimial case. So don't change!
      if(b1(l).ne.0.00000)then  
!      Start of rule-based routing
!      If lake name matches name below, coefficients will be ignored
!      and rules used instead.
          
       if(resname(l).eq.'Superior     ')then

!       Lake Superior
!         this means that:
!         1. we are doing the great lakes
!         2. we are initializing lake superior here
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    sup=sup_init
	    sup=b6(1)
	    store1(n)=(sup-181.43)*82.1e+09
c	    store1(n)=(sup-b7(1))*82.1e+09
	    store2(n)=store1(n)
          qo2(n)=824.7*(sup-181.43)**1.5-retard_factor(mo1,1)        
          qo1(n)=qo2(n)
	  endif

        if(b1(1).ne.0.0)then
          qo2(n)=824.7*(sup-181.43)**1.5-retard_factor(mo1,1)        
	  else
	     if(qrel(l,jz).gt.0.0)qo2(n)=qrel(l,jz)
	  endif

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div

        sup=store2(n)/82.1e+09+181.43

        lake_elv(l,jz)=sup
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n) !Superior
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:5).eq.'Huron')then

!       Lake Michigan-Huron
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    mhu=mhu_init
	    mhu=b6(2)
          store1(n)=(mhu-166.98)*117.4e+09
c          store1(n)=(mhu-b7(1))*117.4e+09
	    store2(n)=store1(n)
c	    delta_elv=mhu-stc_init
	    delta_elv=mhu-b6(3)
c	    mean_elv=(mhu_init+stc_init)/2.0
	    mean_elv=(b6(2)+b6(3))/2.0
	  else
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
	    delta_elv=mhu-stc
	    mean_elv=amax1(166.98+0.1,mean_elv)   ! prevent div by 0
	    delta_elv=amax1(0.001,delta_elv)        ! prevent div by 0
	  endif
!       use stc from the previous time step. Slow change anyway.

        qo2(n)=82.2*(mean_elv-166.98)**1.87*(delta_elv)**0.36
     *           -retard_factor(mo1,2)        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        mhu=store1(n)/117.4e+09+166.98

!        print*,n,resname(l),mhu,qo2(n),store1(n),store2(n)
        lake_elv(l,jz)=mhu
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz) !Huron
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'StClair')then

!       Lake St. Clair
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    stc=stc_init
	    stc=b6(3)
	    store1(n)=(stc-164.91)*1.11e+09
c	    store1(n)=(stc-b7(3))*1.11e+09
	    store2(n)=store1(n)
c          delta_elv=stc_init-eri_init
          delta_elv=b6(3)-b6(4)
	  else
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
          delta_elv=stc-eri
	    delta_elv=amax1(0.001,delta_elv)        ! prevent div by 0
	  endif
        stc=amax1(0.1,stc)                    ! prevent div by 0
!       use eri from the previous time step. Slow change anyway.

        qo2(n)=28.8*(stc-164.91)**2.28*(delta_elv)**0.305        
     *           -retard_factor(mo1,3)        

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        stc=store1(n)/1.11e+09+164.91

!        print*,n,resname(l),stc,qo2(n),store1(n),store2(n)
        lake_elv(l,jz)=stc
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz) ! StClair
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:4).eq.'Erie')then

!       Lake Erie
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    eri=eri_init
	    eri=b6(4)
	    store1(n)=(eri-169.86)*25.7e+09
c	    store1(n)=(eri-b7(4))*25.7e+09
	    store2(n)=store1(n)
        endif       

        qo2(n)=558.3*(eri-169.86)**1.60-retard_factor(mo1,4)
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        eri=store1(n)/25.7e+09+169.86  
        lake_elv(l,jz)=eri
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz) ! Erie

c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'Ontario')then

!       Lake Ontario
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    ont=ont_init
	    ont=b6(5)
	    store1(n)=(ont-69.474)*18.96e+09
c	    store1(n)=(ont-b7(5))*18.96e+09
	    store2(n)=store1(n)
	  endif

        qo2(n)=555.823*(ont-0.0014*real(2000-1985)-69.474)**1.5
     *           -retard_factor(mo1,5)        

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        ont=store1(n)/18.96e+09+69.474         
!        print*,n,resname(l),ont,qo2(n),store1(n),store2(n)
!        print*,'year=',year
        lake_elv(l,jz)=ont
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz)  ! Ontario
        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      include '..\ManHydro\lake_rules.fi'       ! users:  remove this
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        
       else   !  resname(l).eq.
       
!       NATURAL RESERVOIR ROUTING:
!       NATURAL RESERVOIR ROUTING:
!       NATURAL RESERVOIR ROUTING:
!       NATURAL RESERVOIR ROUTING:
!       NATURAL RESERVOIR ROUTING:
!       rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout


!       For the Mackenzir River:
!       REV. 10.1.14 Jan.  05/16  - NK: Added ice rules for Great Slave.
        if(resname(l)(1:7).eq.'Gr_Slav')then
!         works way better without ice_factor!!  NK Jul. 02/16        
          lake_ice_factor(l,month_now)=
     *            amax1(lake_ice_factor(l,month_now),0.7)
c          write(777,*)year_now,month_now,day_now,lake_ice_factor(l,month_now)
        endif

!       get initial value:        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
c        if(store2(n).le.0.0)then
c          write(98,9801)time,l,n,store2(n),qi2(n)
c          store2(n)=1.0
c          if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
c        endif
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
c        old=qo1(n)
        qold(n)=qo1(n)
        hold=0.1e+26
        
        if(b3(l).eq.0.0)then
!         using a power function        
!         tried to put this in the iteration loop but got spikes
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          if(store2(n)-store_dead(l).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                if(store2(n)-store_dead(l).gt.0.0)then
!                 have to do at least 3 iterations
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
                  qo2(n)=b1(l)*(store2(n)-store_dead(l))**b2(l)
                  qo2(n)=qo2(n)*lake_ice_factor(l,month_now)
                  wt=amax1(0.5,float(ic)/21.0)
!     rev. 10.2.71 Nov.  18/19  - NK Bug fixes in wetland & reservoir routing
c                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
                  qo2(n)=(1.0-wt)*qo2(n)+wt*qold(n)
c                  old=qo2(n)
                  qold(n)=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                else
                  qo2(n)=0.0
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif
	    lake_inflow(l,jz)=qi2(n)
c        net_lake_inflow(l,jz)=qi2(n)-outflow
        if(nbsflg.eq.'y')then
          net_lake_inflow(l,jz)=qi2(n) ! in rulestl
        else
          net_lake_inflow(l,jz)=qi2(n)-outflow ! in rulestl
        endif

c         lake_elv(l,jz)=-1.0
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
c	    if(b6(l).gt.0.0.and.b7(l).lt.0.000001)then

          lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
        
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!         if there is less than 10 mm of water left in a lake, stop the 
!         evaporation so storage can not go -ve & cause routing problems     
!         used in runoff
!         Needs to be done like this so lake evap can be properly considred
!         for te watbal s/r     
          if(lake_elv(l,jz).lt.b7(l))then
            lakeEflg(l)=.false.
          else
            lakeEflg(l)=.true.
          endif
          
c25        continue   ! sorry about that   

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else       !(b3(l).gt.0.0)
!         using a polinomial        
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation

          if(store2(n).le.0.0)then
            write(98,9801)time,l,n,store2(n),qi2(n)
c            store2(n)=1.0
            if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
          endif

!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          store_live=store2(n)-store_dead(l) 
          if(store_live.gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
!             have to do at least 3 iterations
!             rev  9.1.03  July  24/01  - added polinomial
              qo2(n)=store_live*(b1(l)+store_live*(b2(l)+store_live*
     *                    (b3(l)+store_live*(b4(l)+b5(l)*store_live))))
              qo2(n)=qo2(n)*lake_ice_factor(l,month_now)
              qo2(n)=amax1(0.0,qo2(n))
              wt=amax1(0.5,float(ic)/21.0)
              qo2(n)=(1.0-wt)*qo2(n)+wt*old
c              old=qo2(n)
              qold(n)=qo2(n)
              hold=store2(n)
              store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            end do   ! hold-store
          else     
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

c         if(store2(n).le.0.0)then
c            qo2=0.0
c            store2(n)=1.0
c            write(53,6804)n,l
c          endif
        endif    ! using a polinomial  

	  lake_inflow(l,jz)=qi2(n)
c        net_lake_inflow(l,jz)=qi2(n)-outflow
        if(nbsflg.eq.'y')then
          net_lake_inflow(l,jz)=qi2(n) ! in rulestl
        else
          net_lake_inflow(l,jz)=qi2(n)-outflow ! in rulestl
        endif

c        lake_elv(l,jz)=-1.0
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
c	  if(b6(l).gt.0.0.and.b7(l).lt.0.000001)then

        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
        
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!       if there is less than 10 mm of water left in a lake, stop the 
!       evaporation so storage can not go -ve & cause routing problems     
!       used in runoff
!       Needs to be done like this so lake evap can be properly considred
!       for te watbal s/r     
        if(lake_elv(l,jz).lt.b7(l))then
          lakeEflg(l)=.false.
        else
          lakeEflg(l)=.true.
        endif
          
c        else
c          lake_elv(l,jz)=store2(n)/lake_area(l)
c	  end if

d        if(iopt.ge.2.and.iopt.le.10)then
d          write(53,6004,iostat=ios)n,l,
d    *           qi1(n),qi2(n),store1(n),store2(n),qo1(n),qo2(n)
d          if(ios.ne.0)then
d            print*,'problems for grid #',n,'lake #',l,' @',time
d          endif
d        endif

!       CALCULATE THE DETENTION TIME
!        if(qo1(n).gt.0.001) at=store2(n)/qo1(n)
!         yeah.... fix this:
        if(qo1(n).gt.0.001) at=store2(n)/qo2(n)

!       SELECT MINIMUM TRAVEL TIME FOR THE TIME STEP CALCULATION
c        dtmin=amin1(at,dtmin)
	
!       DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN THE FASTEST
!       EMPTYING ELEMENT              


cccc      endif  ! end of rule based lake/reservoir outflow

       endif  !  resname(l).eq.'Superior 
      
!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      else       !   if(b1(l).eq.0.00000)    FROM RELEASE TABLE:

!       From release table
!       From release table
!       From release table
!       From release table

!       rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!         jm=jz+1        old way see JW's e-mail Oct. 23/01

        jm=jz
        if(jz.gt.nrel)jm=nrel

	  if(jm.lt.1)then
          qo2(n)=qrel(l,1)          !+q_divert
	  else
          qo2(n)=qrel(l,jm)          !+q_divert
	  endif
      
        if(qo2(n).lt.0.0)qo2(n)=0.0

!        this line is for the water balance only
!        it doesn't work for releases

c        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        store2(n)=
     *     store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        if(nbsflg.ne.'y')net_lake_inflow(l,jz)=qi2(n)-qo2(n) ! default Coefficient in rerout

!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels


!     rev. 9.9.20  Jul.  24/14  - NK: Added dead storage for lakes "stroe_dead"
c          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
          
          

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)


!	  if(frcflg.eq.'y')then
	  if(trcflg.eq.'y')then  ! otherwise upsets tracer code
!     rev. 10.1.80 Apr.  26/17  - NK: Fixed tracer turnoff for -ve resv. storage
c          if(store2(n).lt.cap(n))then
          if(lake_elv(l,jz).le.b7(l)-LKdepth(l))then
c              print*,jz,lake_elv(l,jz),b7(l)-LKdepth(l)
!           leave everything unchanged in the reservoir
!     rev. 9.9.20  Jul.  15/14  - NK: Fix -ve lake storage when release data used
            if(b1(l).eq.0.0)then
!             we're run into a problem where the releases in the rel file are
!             greater than the inflows and the reservoir is already below live storage.
!             We can fix this by having extra depth as specifies in the ill.pt2 file
              trcflg='n'
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
              print*,'WARNING: tracer turned off!!!!!!!!!!!!!!!!!'
              print*,'Reason:  lake storage has become -ve'
              print*,'in lake # ',l
              if(warningflg)then      ! added Jan. 08/15  NK
                print*,'Possible fix:'
                print*,'Create a initial lake level file with a datum'
                print*,'low enough so storage will not go -ve. '
                print*,'You may have to experiment until you get a '
                print*,'proper datum. The datum is used as the weir '
                print*,'elv for the lake outflow calculation'
                warningflg=.false.
                print*,'Program won`t pause or beep again'
              if(iopt.ge.1)pause 45678
              endif
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
!             this is fixed by having an yyyymmdd_ill.tb0 file              
            endif

            if(qi2(n).gt.0.0)then
              qo2(n)=(qi1(n)+qi2(n)-qo1(n))/10.0
	        if(qo2(n).lt.0.0) qo2(n)=qi2(n)/2.  ! TS: added to fix -ve outflow problem
	      else
	        qo2(n)=0.0
	      end if
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	    endif

d	    if(store2(n).le.0.0.and.iopt.ge.1)then
d           Print*,'store2(',n,' ) -ve / needs work in rerout @ 345'
d           print*,store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n)
d         endif
	  endif

c        lake_elv(l,jz)=-1.0
c        lake_elv(l,jz)=store2(n)/lake_area(l)

        if(iopt.ge.2)write(53,6803)l,jm,n,ireach(n),qo2(n)

      endif   !        if(b1(l).ne.0.0)

	last_month=month_now

      
  999 RETURN

! FORMATS

  500 format(256f10.3)
  501 format(3i5,4x,a1)
  502 format(' resv flow data extrapolated ',i5,' hours')
  504 format(' noresv,nrel,ktr/',3i5)
 1011 format(' ',3x,'  i  ires(i) jres(i)    b1(i)     b2(i)',
     *	'    b3(i)     b4(i)')
 1013 format(' ',3x,i3,2i8,5f10.5,a12/)
 4901 format(25i1)
 4902 format(3i5)
 4903 format(a12)
 4904 format(256f10.0)
 4905 format(256f10.3)
 5003 format(2i5,4g10.3,5x,a12)
 3704 format(2i5,5g10.3,5x,a12)

!     rev. 9.1.55  Jun.  12/04  - NK: write new files to resrl\newfmt folder.
 5004 format(a20,a10)
 5005 format(a20,i5)
 5006 format(a20,a1)
 5007 format(a20,256i1)
 5008 format(a20,f12.0)
 5009 format(a20,a2,'-',a2,'-nn',a2)
 5010 format(a20,a2,a4)

 5301 format(' ','Reservoir inflow data echoed:')
 5303 format(6(' ',a12))
 5304 format(' ','Error on unit=99,fln=',a30,'(',i2,')'//)
 5310 format(' -ve flow for reservoir #',i3,'zero flow assumed',i3)
 6004 format('n,l,qi,store,qo/',2i5,2f10.3,2e15.6,2f10.3)
 6005 format(f8.2,2f10.3,2e15.6,2f10.3)
 6801 format('   rerout: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',256f8.2)
 6803 format(' rerout: l,m,n,ireach(n),qo2(n)/',4i5,f10.2,f12.0)
 6804 format(' warning: store2(',i5,') set = 0.0 for resv no.',i5) 
 9005 format(' iymin,iymax,jxmin,jxmax/',4i5)
9801  format(f10.1,' resv',i3,' grid',i6,
     *         ' store2=',g12.0,'< 0 1.0 assumed')
99182   format(' Warning: Error opening or reading fln:',a30/
     *  ' Probable cause: missing strfw/yymmdd.str input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
9983  format(256(f12.0,x))
9984  format(256(E12.6,x))
9985  format(256I10)
9986  format(256(a12,x))
9987  format(256(f12.7,x))
9988  format(256(a9,x))

      END SUBROUTINE rerout

      SUBROUTINE rerout(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!DEC$ ATTRIBUTES DLLIMPORT:: rules_MH

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     This s/r is meant to be user friendly so operating rules
!     for specific applicatins can be coded.

!***********************************************************************
!   THIS S/R  ROUTES WATER THROUGH A RESERVOIR
!   or SIMPLY PASSES ENTERED FLOWS TO THE RIVER
!
!     REV. 7.80   Oct.  29/96 -  SPL7 ADDED YYMMDD.RIN FOR RES INFLOWS
!                             -  UNIT = 39   FLN = 09
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.67  Oct.  06/09  - NK: fixed bug in rerout
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!     rev. 9.8.65  May   28/13  - NK: Dimensioned firstpass_local()in REROUT
!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
!***********************************************************************

      use area_watflood
	implicit none

	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH
	

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: old,hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live

	integer  :: lcount,day_last
	real*4   :: elvlast,qraw,aaa
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      
      real*4, dimension(:),   allocatable :: raise,lower,inflow

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.true./

!     For the great lakes only:
      DATA retard_factor/0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.,0.,
     * 590.,480.,110.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,110.,
     * 650.,510.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,140.,
     * 110.,140.,80.,140.,0.,60.,230.,140.,80.,60.,0.0,0.0,
     * 170.,300.,150.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10./
!     initial water elevations - now read from a file
!	data sup_init,mhu_init,stc_init,eri_init,ont_init/
!     *      183.2,175.98,174.8,174.01,74.61/

!     lif = lake ice factor

!     WHEN LOCAL IS -VE, RESERVOIR RELEASES ARE NEED IN AND THESE 
!     BECOME THE OUTFLOWS OF THE SQUARE IN WHICH THE DAM OUTLET 
!     STRUCTURE IS LOCATED.  
!     WHEN LOCAL = 0 , THERE ARE NO RESERVOIRS, REROUT IS NOT CALLED.

!     WHEN LOCAL IS +VE, THE INFLOW TO THE SQUARE IN WHICH THE
!     RESERVOIR IS LOCATED IS PRINTED OUT ON FILE 11 FOR USE IN
!     HEC-5 OR OTHER OPERATING PROGRAM.

!     THE OVERALL OPERATING SEQUENCE IS THEN THE FIRST RUN SIMPLE
!     TO CALCULATE THE RUNOFF PRODUCED IN VARIOUS SUB-BASINS THEN
!     TO DETERMINE RELEASES, AND THEN TO ROUTE THE RELEASES AND LOCAL
!     INFLOWS USING HYMO.  THE RELEASES ARE READ IN FROM FILE 12.

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

      if(firstpass_local(98))then
        last_month=month_now
        wrtdiverflg=.false.  !used for writing a new diversion file 
!       if divertflg = 'g' then diversion flows need to be generated 
!       for L. St. Joseph and NOT read in. In this case, qdivert 
!       has not been allocated in read_divert_ef.f so it needs to be 
!       done here for just one location:
        if(.not.allocated(qdivert))then
!         set one diversion location
          nodivert=1
          allocate(qdivert(nodivert,mhtot),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of aqdivert  in rerout @ 109'
        endif
        if(iopt.ge.1)print*,'qdivert allocated as      1,',mhtot
        firstpass_local(98)=.false.
      endif
      
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        firstpass_local(99)=.false.
      endif


!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.53  Jan.  20/09  - NK: undid rev. 9.5.40
!##########################################################################
!     DIVERSIONS
!##########################################################################
!     rev. 9.5.40  Oct.  21/08  - NK: added diversions to rerout
!     A diversion can only be made to another node providing
!     the receiving node is at a lower elevation - i.e. the grid number is 
!     higher in the order = later in the grid loop n=1,naa
!     Makes sense. Can not divert to a higher grid without pumping

!     If in an outlet node of a lake from which diversion is made,
!     add an outflow from this reach to the inflow in another. 

!     Lake St Joseph:
!     outflow grid = 1803    05QB006
!     receiving grid = 1866
c      if(n.eq.1803.and.na.eq.3039)then
c        q_divert=qhyd(34,(jz-1)/ktr*ktr+ktr)        
c        q_divert=amax1(0.0,q_divert)     ! in case there are missing data (-1.00)
c        qi2(1866)=qi2(1866)+q_divert   ! diversion into receiving grid
c        write(53,*)n,jz,(jz-1)/ktr*ktr+ktr,qi2(1866),q_divert
c      else
c        q_divert=0.000
c      endif
!###########################################################################

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      if(b1(l).ne.0.00000)then  
!     Start of rule-based routing
!     Start of rule-based routing
!     Start of rule-based routing
!     If lake name matches name below, coefficients will be ignored
!     and rules used instead.
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     For the Mackenzir River:
!     REV. 10.1.14 Jan.  05/16  - NK: Added ice rules for Lakes Athabaska & Great Slave.

      if(resname(l)(1:9).eq.'Wollaston')then

!       added Jan. 27/16  NK

!       get initial value:        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
c        if(store2(n).le.0.0)then
c          write(98,9801)time,l,n,store2(n),qi2(n)
c          store2(n)=1.0
c          if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
c        endif
        old=qo1(n)
        hold=0.1e+26
        aaa=0.10   ! ratio mack/(mack+churchill) flows
!         using a power function        
!         tried to put this in the iteration loop but got spikes
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
        if(store2(n)-store_dead(l).gt.0.0)then
          do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
            if(store2(n)-store_dead(l).gt.0.0)then
!             have to do at least 3 iterations
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file

!             added the snow weight at the outlet grid to the 
!             lake dischrge equation
              qo2(n)=b1(l)*(store2(n)-store_dead(l)+
     *            snowc(n,classcount-1)/1000.0*lake_area(l))**b2(l)
              qo2(n)=qo2(n)*lake_ice_factor(l)
              wt=amax1(0.5,float(ic)/21.0)
              qo2(n)=(1.0-wt)*qo2(n)+wt*old
              old=qo2(n)
              hold=store2(n)
              qo2(n)=aaa*qo2(n)
              store2(n)=store1(n)+
     *              (qi1(n)+qi2(n)-qo1(n)-qo2(n)/aaa)*div
            else
              qo2(n)=0.0
              store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            endif
          end do
        else     !(b3(l).gt.0.0)
          qo2(n)=0.0
          store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!         store2(n) is allowed to go -ve     
        endif

      else
!       NATURAL RESERVOIR ROUTING:
!       rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout

!       get initial value:        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
c        if(store2(n).le.0.0)then
c          write(98,9801)time,l,n,store2(n),qi2(n)
c          store2(n)=1.0
c          if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
c        endif
        old=qo1(n)
        hold=0.1e+26
        if(b3(l).eq.0.0)then
!         using a power function        
!         tried to put this in the iteration loop but got spikes
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          if(store2(n)-store_dead(l).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                if(store2(n)-store_dead(l).gt.0.0)then
!                 have to do at least 3 iterations
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file

!                 added the snow weight at the outlet grid to the 
!                 lake dischrge equation
                  qo2(n)=b1(l)*(store2(n)-store_dead(l)+
     *                snowc(n,classcount-1)/1000.0*lake_area(l))**b2(l)
                  qo2(n)=qo2(n)*lake_ice_factor(l)
                  wt=amax1(0.5,float(ic)/21.0)
                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
                  old=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                else
                  qo2(n)=0.0
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif


c25        continue   ! sorry about that   

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else       !(b3(l).gt.0.0)
!         using a polinomial        
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation

          if(store2(n).le.0.0)then
            write(98,9801)time,l,n,store2(n),qi2(n)
c            store2(n)=1.0
            if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
          endif

!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          store_live=store2(n)-store_dead(l) 
          if(store_live.gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
!             have to do at least 3 iterations
!             rev  9.1.03  July  24/01  - added polinomial
              qo2(n)=store_live*(b1(l)+store_live*(b2(l)+store_live*
     *                    (b3(l)+store_live*(b4(l)+b5(l)*store_live))))
              qo2(n)=qo2(n)*lake_ice_factor(l)
              qo2(n)=amax1(0.0,qo2(n))
              wt=amax1(0.5,float(ic)/21.0)
              qo2(n)=(1.0-wt)*qo2(n)+wt*old
              old=qo2(n)
              hold=store2(n)
              store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            end do   ! hold-store
          else     
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

c         if(store2(n).le.0.0)then
c            qo2=0.0
c            store2(n)=1.0
c            write(53,6804)n,l
c          endif
        endif     !if(b3(l).eq.0.0)   

	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

c        lake_elv(l,jz)=-1.0
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
c	  if(b6(l).gt.0.0.and.b7(l).lt.0.000001)then



c        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) !b7()=0.0 if not in rel file
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l) !b7()=0.0 if not in rel file
        
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!       if there is less than 10 mm of water left in a lake, stop the 
!       evaporation so storage can not go -ve & cause routing problems     
!       used in runoff
!       Needs to be done like this so lake evap can be properly considred
!       for te watbal s/r     
        if(lake_elv(l,jz).lt.b7(l))then
          lakeEflg(l)=.false.
        else
          lakeEflg(l)=.true.
        endif
          
c        else
c          lake_elv(l,jz)=store2(n)/lake_area(l)
c	  end if

d        if(iopt.ge.2.and.iopt.le.10)then
d          write(53,6004,iostat=ios)n,l,
d    *           qi1(n),qi2(n),store1(n),store2(n),qo1(n),qo2(n)
d          if(ios.ne.0)then
d            print*,'problems for grid #',n,'lake #',l,' @',time
d          endif
d        endif

!       CALCULATE THE DETENTION TIME
!        if(qo1(n).gt.0.001) at=store2(n)/qo1(n)
!         yeah.... fix this:
        if(qo1(n).gt.0.001) at=store2(n)/qo2(n)

!       SELECT MINIMUM TRAVEL TIME FOR THE TIME STEP CALCULATION
c        dtmin=amin1(at,dtmin)
	
!       DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN THE FASTEST
!       EMPTYING ELEMENT              


cccc      endif  ! end of rule based lake/reservoir outflow

      endif
      
!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      else       !   if(b1(l).eq.0.00000)    FROM RELEASE TABLE:


!       rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!         jm=jz+1        old way see JW's e-mail Oct. 23/01

        jm=jz
        if(jz.gt.nrel)jm=nrel

	  if(jm.lt.1)then
          qo2(n)=qrel(l,1)          !+q_divert
	  else
          qo2(n)=qrel(l,jm)          !+q_divert
	  endif

        if(qo2(n).lt.0.0)qo2(n)=0.0

!        this line is for the water balance only
!        it doesn't work for releases

c        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        store2(n)=
     *     store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels


!     rev. 9.9.20  Jul.  24/14  - NK: Added dead storage for lakes "stroe_dead"
c          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)


!	  if(frcflg.eq.'y')then
	  if(trcflg.eq.'y')then  ! otherwise upsets tracer code
          if(store2(n).lt.cap(n))then
!           leave everything unchanged in the reservoir
!     rev. 9.9.20  Jul.  15/14  - NK: Fix -ve lake storage when release data used
            if(b1(l).eq.0.0)then
!             we're run into a problem where the releases in the rel file are
!             greater than the inflows and the reservoir is already below live storage.
!             Maybe we can fix this by having a datum high enough so the storage does
!             not go -ve.    trcOffFlg
              trcflg='n'
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
              print*,'WARNING: tracer turned off!!!!!!!!!!!!!!!!!'
              print*,'Reason:  lake storage has become -ve'
              print*,'in lake # ',l
              if(warningflg)then      ! added Jan. 08/15  NK
                print*,'Possible fix:'
                print*,'Create a initial lake level file with a datum'
                print*,'low enough so storage will not go -ve. '
                print*,'You may have to experiment until you get a '
                print*,'proper datum. The datum is used as the weir '
                print*,'elv for the lake outflow calculation'
                warningflg=.false.
              endif
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
! fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix              
!             this is fixed by having an yyyymmdd_ill.tb0 file              
            endif   !   if(b1(l).eq.0.0)

            if(qi2(n).gt.0.0)then
              qo2(n)=(qi1(n)+qi2(n)-qo1(n))/10.0
	        if(qo2(n).lt.0.0) qo2(n)=qi2(n)/2.  ! TS: added to fix -ve outflow problem
	      else
	        qo2(n)=0.0
	      end if
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	    endif   !  if(store2(n).lt.cap(n))

d	    if(store2(n).le.0.0.and.iopt.ge.1)then
d           Print*,'store2(',n,' ) -ve / needs work in rerout @ 345'
d           print*,store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n)
d         endif
	  endif  !  if(trcflg.eq.'y')

c        lake_elv(l,jz)=-1.0
c        lake_elv(l,jz)=store2(n)/lake_area(l)

        if(iopt.ge.2)write(53,6803)l,jm,n,ireach(n),qo2(n)

      endif   !        if(b1(l).ne.0.0)

	last_month=month_now

  999 RETURN

! FORMATS

  500 format(256f10.3)
  501 format(3i5,4x,a1)
  502 format(' resv flow data extrapolated ',i5,' hours')
  504 format(' noresv,nrel,ktr/',3i5)
 1011 format(' ',3x,'  i  ires(i) jres(i)    b1(i)     b2(i)',
     *	'    b3(i)     b4(i)')
 1013 format(' ',3x,i3,2i8,5f10.5,a12/)
 4901 format(25i1)
 4902 format(3i5)
 4903 format(a12)
 4904 format(256f10.0)
 4905 format(256f10.3)
 5003 format(2i5,4g10.3,5x,a12)
 3704 format(2i5,5g10.3,5x,a12)

!     rev. 9.1.55  Jun.  12/04  - NK: write new files to resrl\newfmt folder.
 5004 format(a20,a10)
 5005 format(a20,i5)
 5006 format(a20,a1)
 5007 format(a20,256i1)
 5008 format(a20,f12.0)
 5009 format(a20,a2,'-',a2,'-nn',a2)
 5010 format(a20,a2,a4)

 5301 format(' ','Reservoir inflow data echoed:')
 5303 format(6(' ',a12))
 5304 format(' ','Error on unit=99,fln=',a30,'(',i2,')'//)
 5310 format(' -ve flow for reservoir #',i3,'zero flow assumed',i3)
 6004 format('n,l,qi,store,qo/',2i5,2f10.3,2e15.6,2f10.3)
 6005 format(f8.2,2f10.3,2e15.6,2f10.3)
 6801 format('   rerout: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',256f8.2)
 6803 format(' rerout: l,m,n,ireach(n),qo2(n)/',4i5,f10.2,f12.0)
 6804 format(' warning: store2(',i5,') set = 0.0 for resv no.',i5) 
 9005 format(' iymin,iymax,jxmin,jxmax/',4i5)
9801  format(f10.1,' resv',i3,' grid',i6,
     *         ' store2=',g12.0,'< 0 1.0 assumed')
99182   format(' Warning: Error opening or reading fln:',a30/
     *  ' Probable cause: missing strfw/yymmdd.str input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
9983  format(256(f12.0,x))
9984  format(256(E12.6,x))
9985  format(256I10)
9986  format(256(a12,x))
9987  format(256(f12.7,x))
9988  format(256(a9,x))

      END SUBROUTINE rerout

      SUBROUTINE rerout(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!DEC$ ATTRIBUTES DLLIMPORT:: rules_MH

!     copyright (c) by n. kouwen 1987-2012

!     This s/r is meant to be user friendly so operating rules
!     for specific applicatins can be coded.

!***********************************************************************
!   THIS S/R  ROUTES WATER THROUGH A RESERVOIR
!   or SIMPLY PASSES ENTERED FLOWS TO THE RIVER
!
!     REV. 7.80   Oct.  29/96 -  SPL7 ADDED YYMMDD.RIN FOR RES INFLOWS
!                             -  UNIT = 39   FLN = 09
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.67  Oct.  06/09  - NK: fixed bug in rerout
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!     rev. 9.8.65  May   28/13  - NK: Dimensioned firstpass_local()in REROUT
!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
!***********************************************************************

      use area_watflood
	implicit none

	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH
	

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: old,hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live

	integer  :: lcount,day_last
	real*4   :: elvlast,qraw
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      
      real*4, dimension(:),   allocatable :: raise,lower,inflow

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.true./

!     For the great lakes only:
      DATA retard_factor/0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.,0.,
     * 590.,480.,110.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,110.,
     * 650.,510.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,140.,
     * 110.,140.,80.,140.,0.,60.,230.,140.,80.,60.,0.0,0.0,
     * 170.,300.,150.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10./
!     initial water elevations - now read from a file
!	data sup_init,mhu_init,stc_init,eri_init,ont_init/
!     *      183.2,175.98,174.8,174.01,74.61/

!     lif = lake ice factor

!     WHEN LOCAL IS -VE, RESERVOIR RELEASES ARE NEED IN AND THESE 
!     BECOME THE OUTFLOWS OF THE SQUARE IN WHICH THE DAM OUTLET 
!     STRUCTURE IS LOCATED.  
!     WHEN LOCAL = 0 , THERE ARE NO RESERVOIRS, REROUT IS NOT CALLED.

!     WHEN LOCAL IS +VE, THE INFLOW TO THE SQUARE IN WHICH THE
!     RESERVOIR IS LOCATED IS PRINTED OUT ON FILE 11 FOR USE IN
!     HEC-5 OR OTHER OPERATING PROGRAM.

!     THE OVERALL OPERATING SEQUENCE IS THEN THE FIRST RUN SIMPLE
!     TO CALCULATE THE RUNOFF PRODUCED IN VARIOUS SUB-BASINS THEN
!     TO DETERMINE RELEASES, AND THEN TO ROUTE THE RELEASES AND LOCAL
!     INFLOWS USING HYMO.  THE RELEASES ARE READ IN FROM FILE 12.

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

      if(firstpass_local(98))then
        last_month=month_now
        wrtdiverflg=.false.  !used for writing a new diversion file 
!       if divertflg = 'g' then diversion flows need to be generated 
!       for L. St. Joseph and NOT read in. In this case, qdivert 
!       has not been allocated in read_divert_ef.f so it needs to be 
!       done here for just one location:
        if(.not.allocated(qdivert))then
!         set one diversion location
          nodivert=1
          allocate(qdivert(nodivert,mhtot),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of aqdivert  in rerout @ 109'
        endif
        if(iopt.ge.1)print*,'qdivert allocated as      1,',mhtot
        firstpass_local(98)=.false.
      endif
      
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        firstpass_local(99)=.false.
      endif


!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.53  Jan.  20/09  - NK: undid rev. 9.5.40
!##########################################################################
!     DIVERSIONS
!##########################################################################
!     rev. 9.5.40  Oct.  21/08  - NK: added diversions to rerout
!     A diversion can only be made to another node providing
!     the receiving node is at a lower elevation - i.e. the grid number is 
!     higher in the order = later in the grid loop n=1,naa
!     Makes sense. Can not divert to a higher grid without pumping

!     If in an outlet node of a lake from which diversion is made,
!     add an outflow from this reach to the inflow in another. 

!     Lake St Joseph:
!     outflow grid = 1803    05QB006
!     receiving grid = 1866
c      if(n.eq.1803.and.na.eq.3039)then
c        q_divert=qhyd(34,(jz-1)/ktr*ktr+ktr)        
c        q_divert=amax1(0.0,q_divert)     ! in case there are missing data (-1.00)
c        qi2(1866)=qi2(1866)+q_divert   ! diversion into receiving grid
c        write(53,*)n,jz,(jz-1)/ktr*ktr+ktr,qi2(1866),q_divert
c      else
c        q_divert=0.000
c      endif
!###########################################################################

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      if(b1(l).ne.0.00000)then  
!     Start of rule-based routing
!     Start of rule-based routing
!     Start of rule-based routing
!     If lake name matches name below, coefficients will be ignored
!     and rules used instead.
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     lake Katebogama & Namakan
      if(resname(l)(1:7).eq.'Namakan')then
!       Gold Portage & Bear Portage are overflows
!       main outlet is at Kettle Falls  = cell 2469
!       Kabetogama lake l = 33
!       Namakan lake    l = 17
!       The lake time constant is around 16 days so explicit = ok
!       Bear Portage sill = 340.39     Kabetogama lake
!       Gold Portage sill = 338.000
!       Kettle Falls sill ~ 336
c       b1(l)=0.0  ! make sure we don't do this twice
c       b1(33)=0.0
        qbear=0.0
        qgold=0.0
        b7(l)=336.0  ! Kettle Falls sill elv.
        elv=b7(l)+store1(n)/2.7864672E+08
c        hgold=elv-338.00
!       datum is at 338 but flow starts at 339.124 in rating curve. 
!       This should reduce the flows 
        hgold=elv-339.124
        hbear=elv-340.39
!       Kettle Falls
c        qo2(n)=b1(l)*store2(n)**b2(l)
c        qkettle=0.20E-13*store2(n)**1.75
        qkettle=0.30E-13*store2(n)**1.75
        
c        qkettle=1.10*qkettle  ! added to reduce the Gold Portage flow a bit
        
        
        if(hgold.gt.0.0)then              
!         Gold Portage outlet
c         qgold=-0.0288*hgold**6+0.209*hgold**5
c    *               -0.4795*hgold**4+2.0935*hgold**3 
c    *               -2.7188*hgold**2+0.8804*hgold   
!          see Rick Cousin's e-mail June 2010
!          revised Aug. 28, 2013 NK   
           qgold=(((-0.8053*hgold+5.1177)*hgold
     *             -0.9376)*hgold+2.7952)*hgold    

          qgold=amax1(0.0,qgold)     
          if(hbear.gt.0.0)then
!           Bear Portage outlet
            qbear=(((((-12.019*hbear+79.284)*hbear
     *               -193.12)*hbear+202.77)*hbear 
     *               -65.491)*hbear+8.364)*hbear
            qbear=amax1(0.0,qbear)
          endif   
        endif
        qo2(n)=qkettle+qbear  !into Rainy Lake - ungauged
        qo2(2435)=qgold   ! into Black Bay of Rainy Lake - gauged
        qo2(n)=amax1(0.0,qo2(n))
        qo2(2435)=amax1(0.0,qo2(2435))
        store2(n)=store1(n)
     *           +(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
     *           +(-qo1(2435)-qo2(2435))*div
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
c        write(543,54300)totaltime,l,hbear,qbear,hgold,qgold,
c     *            elv,qkettle,qo2(n),qo2(2435)
c54300   format(f10.3,i5,99f10.3)

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'Kabetog')then
!       see above  
!       don't do anything!!
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!    Lake St. Joseph   
      elseif(resname(l)(1:7).eq.'L_St_Jo')then

        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          open(unit=954,file=filename(954),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',filename(954)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in rerout @ 407'
          endif
          if(iopt.ge.1)write(954,*)
     *      '        hour  q_diverted Albany_flow      Lake_elv'
          if(iopt.eq.0)write(954,*)'Set iopt > 0 to get data here'
          ndiv_max=mhtot
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
          include "MH_root_coord.fi"      ! this must be commneted out 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        endif     ! firstpass

!     rev. 9.9.19  Jun.  11/14  - NK: Added a file for lat-long diversion locations for L. St. Jo
!       Albany River outlet:
c        if(lake_elv(l,jz).gt.373.8)then
        if(temp_elv(l).gt.373.8)then
          qo2(n)=300.0
c        elseif(lake_elv(l,jz).gt.374.05)then
        elseif(temp_elv(l).gt.374.05)then
          qo2(n)=1.05*qi2(n)
c          qo2(n)=b1(l)*((temp_elv(l)-374.05)*lake_area(l))**b2(l)
c        elseif(lake_elv(l,jz).gt.371.25.and.year_now.ge.1985)then
        elseif(temp_elv(l).gt.371.25.and.year_now.ge.1985)then
!         OPG maintains a minimum of about 2 m3/s 
!         fishery flow at the Cedars dam for the Albany River           
!         MG's e-mail Jan. 12/13
          qo2(n)=2.0  
        else          ! added Jul. 22/13  NK
          qo2(n)=0.0
        endif
        
        if(divertflg.eq.'g')then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      include "MH_root_diversion.fi"      ! this must be commneted out
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else

!     rev. 9.8.85  Sep.  30/13  - NK: Fixed the water balance for Lake St. Jo so diversion is taken care of
!         qo2() is calculated above
          store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
c     *               -2.0*qdivert(1,jz)*div    already taken out in sub 
          lake_inflow(l,jz)=qi2(n)+qdivert(1,jz)
          net_lake_inflow(l,jz)=qi2(n)-qo2(n)-qdivert(1,jz)
          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          temp_elv(l)=lake_elv(l,jz)
          qdwpr(ireach(n),jz)=qdwpr(ireach(n),jz)+qdivert(1,jz)
          
c       write(954,*)jz,qdivert(1,jz),qo2(n),store2(n),lake_elv(l,jz)
     
        endif
!~~~~~~~~~end generate diversion flow~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

      elseif(resname(l)(1:7).eq.'05QE006')then
!       Lac Seul
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
        endif
        if(temp_elv(l).gt.357.0)then
          qo2(n)=600
        elseif(temp_elv(l).gt.356.8)then
          qo2(n)=500.0
        elseif(mo.lt.3.or.mo.ge.10)then
!         winter rule        
          if(temp_elv(l).gt.354.6)then
            qo2(n)=400.0
          else
            qo2(n)=100.0
          endif
        elseif(jul_day_now.ge.105.and.jul_day_now.lt.181)then
!         between April 15 & June 30 water level should rise
!         steadily to a max = 355.3
          if(temp_elv(l).lt.355.3)then
            qo2(n)=0.25*qi2(n)       ! changed from 0.75 
            if(jul_day_now.ge.135.and.jul_day_now.lt.166)then
!             maintain may-june min flow for walleye spawn            
              qo2(n)=amax1(qo2(n),180.0)
            endif           
          endif
        else  
	    qo2(n)=b1(l)*store2(n)**b2(l)
        endif
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)
        
      elseif(resname(l)(1:7).eq.'LOW_rel')then
!       Lake of the Woods        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.10
          lower(l)=2.5
          inflow(l)=qi2(l)   ! initial seed value for moving average
        endif
c        inflow(l)=0.999*inflow(l)+0.001*qi2(n)
        old=qo2(n)
c        inflow(l)=qi2(n)
        inflow(l)=0.001*qi2(n)+0.999*inflow(l)
c         inflow(l)=0.0
        spill=0.0
!       note that inflow() is used only to determine the outflow
!              - not used for the water balance!!!!!        
c        if(mo.lt.3.or.mo.ge.10)then
c!         winter rule        
c          if(temp_elv(l).gt.322.75)then
c            qo2(n)=400.0
c          else
c            qo2(n)=200.0
c          endif
        if(jul_day_now.le.31.and.temp_elv(l).gt.322.69)then      !Jan
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'01',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.31.and.temp_elv(l).le.322.69)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.59.and.temp_elv(l).gt.322.55)then  !Feb
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'02',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.59.and.temp_elv(l).le.322.55)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.90.and.temp_elv(l).gt.322.38)then  !Mar
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'03',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.90.and.temp_elv(l).le.322.38)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.120.and.temp_elv(l).gt.322.65)then  !Apr
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).le.322.65)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).gt.322.80)then  !May
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).le.322.80)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).gt.323.17)then  !Jun
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).le.323.17)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).gt.323.18)then  !Jul
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).le.323.18)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).gt.323.00)then  !Aug
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).le.323.00)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).gt.322.93)then  !Sep
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).le.322.93)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).gt.322.88)then  !Oct
          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
        elseif(jul_day_now.le.304.and.temp_elv(l).le.322.88)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).gt.322.80)then  !Nov
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'11',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.334.and.temp_elv(l).le.322.80)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.366.and.temp_elv(l).gt.322.75)then  !Dec
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'12',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.366.and.temp_elv(l).le.322.75)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        endif
        qo2(n)=amin1(qo2(n),1400.0)   ! gen=420   spill=200
        qo2(n)=amax1(qo2(n),100.0)    ! min year round flow @ Kenore PH
        qo2(n)=0.999*old+0.001*qo2(n)    ! smoothing
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)
        
      elseif(resname(l)(1:7).eq.'05PC019')then
!       Rainy Lake        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.50   ! was 0.75 but too slow filling
          lower(l)=1.25
        endif
        old=qo2(n)
        inflow(l)=qi2(n)
        if(jul_day_now.le.31.and.temp_elv(l).gt.337.03)then      !Jan
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.31.and.temp_elv(l).le.337.03)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.59.and.temp_elv(l).gt.336.87)then  !Feb
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.59.and.temp_elv(l).le.336.87)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.90.and.temp_elv(l).gt.336.7)then  !Mar
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.90.and.temp_elv(l).le.336.7)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).gt.336.8)then  !Apr
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).le.336.8)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).gt.337.3)then  !May
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).le.337.3)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).gt.337.5)then  !Jun
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).le.337.5)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).gt.337.63)then  !Jul
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).le.337.63)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).gt.337.58)then  !Aug
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).le.337.58)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).gt.337.53)then  !Sep
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).le.337.53)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).gt.337.48)then  !Oct
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).le.337.48)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).gt.337.3)then  !Nov
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).le.337.3)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.366.and.temp_elv(l).gt.337.2)then  !Dec
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.366.and.temp_elv(l).le.337.2)then
          qo2(n)=raise(l)*inflow(l)
        endif
        qo2(n)=amin1(qo2(n),620.0)   ! gen=420   spill=200
        qo2(n)=amax1(qo2(n),100.0)    ! min year round flow @ Kenore PH
        qo2(n)=0.9*old+0.1*qo2(n)     ! smoothing
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)

      elseif(resname(l)(1:6).eq.'FamL_N')then
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!       no iteration needed        n=1562
!       this lake = special case: 2 outlets
        store_live=store2(n)-store_dead(l)
        if(store_live.gt.0.1)then
	    outflow=b1(l)*store_live**b2(l)
	    qo2(n)=0.32*outflow    !this is the outlet in the rel file
c	    qo2(1548)=0.68*outflow
!         for the new shd file with Cedar Lake included
	    qo2(1696)=0.68*outflow
	  else
	    qo2(n)=0.0
c	    qo2(1548)=0.00  ! added here
!         for the new shd file with Cedar Lake included
	    qo2(1696)=0.00  ! added here
        endif
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n)-qo1(1696)-qo2(1696))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:6).eq.'FamL_S')then
!       see above  
!       don't do anything!!

      elseif(resname(l)(1:7).eq.'Cameron')then
!       Cameron Lake        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.90   ! was 0.75 but too slow filling
          lower(l)=1.05
        endif
         
        old=qo2(n)
        inflow(l)=qi2(n)
       
        if(jul_day_now.le.91)then      !Jan-Mar
                 store2(n)=(temp_elv(l)-54.1)*lake_area(l)
        elseif(jul_day_now.le.121)then      !Mar
!                raise level over one month        
                 sill=54.1+float(jul_day_now-91)*0.01667
                 store2(n)=(temp_elv(l)-sill)*lake_area(l)
        elseif(jul_day_now.le.305)then  !May-Oct
                 store2(n)=(temp_elv(l)-54.6)*lake_area(l)
        elseif(jul_day_now.le.335)then  !Nov.
!                lower water slowly        
                 sill=54.6-float(jul_day_now-305)*0.01667
                 store2(n)=(temp_elv(l)-sill)*lake_area(l)
        elseif(jul_day_now.le.366)then  !Dec
                 store2(n)=(temp_elv(l)-54.1)*lake_area(l)
        endif

        if(store2(n).gt.0.0)then
          qo2(n)=b1(l)*store2(n)**b2(l)
        else
          qo2(n)=0.0
        endif
          
        qo2(n)=0.9*old+0.1*qo2(n)     ! smoothing
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
     
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)


!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      include "MH_rules.fi"      ! this must be commneted out
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       

!     For the Mackenzir River:
!     REV. 10.1.14 Jan.  05/16  - NK: Added ice rules for Lakes Athabaska & Great Slave.
      else
!       NATURAL RESERVOIR ROUTING:
!       rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout

!       get initial value:        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
c        if(store2(n).le.0.0)then
c          write(98,9801)time,l,n,store2(n),qi2(n)
c          store2(n)=1.0
c          if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
c        endif
        old=qo1(n)
        hold=0.1e+26
        if(b3(l).eq.0.0)then
!         using a power function        
!         tried to put this in the iteration loop but got spikes
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          if(store2(n)-store_dead(l).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                if(store2(n)-store_dead(l).gt.0.0)then
!                 have to do at least 3 iterations
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file

!                 added the snow weight at the outlet grid to the 
!                 lake dischrge equation
                  qo2(n)=b1(l)*(store2(n)-store_dead(l)+
     *                snowc(n,classcount-1)/1000.0*lake_area(l))**b2(l)
                  qo2(n)=qo2(n)*lake_ice_factor(l)
                  wt=amax1(0.5,float(ic)/21.0)
                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
                  old=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                else
                  qo2(n)=0.0
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif


c25        continue   ! sorry about that   

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else       !(b3(l).gt.0.0)
!         using a polinomial        
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation

          if(store2(n).le.0.0)then
            write(98,9801)time,l,n,store2(n),qi2(n)
c            store2(n)=1.0
            if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
          endif

!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          store_live=store2(n)-store_dead(l) 
          if(store_live.gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
!             have to do at least 3 iterations
!             rev  9.1.03  July  24/01  - added polinomial
              qo2(n)=store_live*(b1(l)+store_live*(b2(l)+store_live*
     *                    (b3(l)+store_live*(b4(l)+b5(l)*store_live))))
              qo2(n)=qo2(n)*lake_ice_factor(l)
              qo2(n)=amax1(0.0,qo2(n))
              wt=amax1(0.5,float(ic)/21.0)
              qo2(n)=(1.0-wt)*qo2(n)+wt*old
              old=qo2(n)
              hold=store2(n)
              store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            end do   ! hold-store
          else     
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

c         if(store2(n).le.0.0)then
c            qo2=0.0
c            store2(n)=1.0
c            write(53,6804)n,l
c          endif
        endif     !if(b3(l).eq.0.0)   

	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

c        lake_elv(l,jz)=-1.0
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
c	  if(b6(l).gt.0.0.and.b7(l).lt.0.000001)then



c        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) !b7()=0.0 if not in rel file
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l) !b7()=0.0 if not in rel file
        
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!       if there is less than 10 mm of water left in a lake, stop the 
!       evaporation so storage can not go -ve & cause routing problems     
!       used in runoff
!       Needs to be done like this so lake evap can be properly considred
!       for te watbal s/r     
        if(lake_elv(l,jz).lt.b7(l))then
          lakeEflg(l)=.false.
        else
          lakeEflg(l)=.true.
        endif
          
c        else
c          lake_elv(l,jz)=store2(n)/lake_area(l)
c	  end if

d        if(iopt.ge.2.and.iopt.le.10)then
d          write(53,6004,iostat=ios)n,l,
d    *           qi1(n),qi2(n),store1(n),store2(n),qo1(n),qo2(n)
d          if(ios.ne.0)then
d            print*,'problems for grid #',n,'lake #',l,' @',time
d          endif
d        endif

!       CALCULATE THE DETENTION TIME
!        if(qo1(n).gt.0.001) at=store2(n)/qo1(n)
!         yeah.... fix this:
        if(qo1(n).gt.0.001) at=store2(n)/qo2(n)

!       SELECT MINIMUM TRAVEL TIME FOR THE TIME STEP CALCULATION
c        dtmin=amin1(at,dtmin)
	
!       DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN THE FASTEST
!       EMPTYING ELEMENT              


cccc      endif  ! end of rule based lake/reservoir outflow

      endif
      
!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      else       !   if(b1(l).eq.0.00000)    FROM RELEASE TABLE:


!       rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!         jm=jz+1        old way see JW's e-mail Oct. 23/01

        jm=jz
        if(jz.gt.nrel)jm=nrel

	  if(jm.lt.1)then
          qo2(n)=qrel(l,1)          !+q_divert
	  else
          qo2(n)=qrel(l,jm)          !+q_divert
	  endif

        if(qo2(n).lt.0.0)qo2(n)=0.0

!        this line is for the water balance only
!        it doesn't work for releases

c        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        store2(n)=
     *     store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels


!     rev. 9.9.20  Jul.  24/14  - NK: Added dead storage for lakes "stroe_dead"
c          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)


!	  if(frcflg.eq.'y')then
	  if(trcflg.eq.'y')then  ! otherwise upsets tracer code
          if(store2(n).lt.cap(n))then
!           leave everything unchanged in the reservoir
!     rev. 9.9.20  Jul.  15/14  - NK: Fix -ve lake storage when release data used
            if(b1(l).eq.0.0)then
!             we're run into a problem where the releases in the rel file are
!             greater than the inflows and the reservoir is already below live storage.
!             Maybe we can fix this by having a datum high enough so the storage does
!             not go -ve.    trcOffFlg
              trcflg='n'
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
              print*,'WARNING: tracer turned off!!!!!!!!!!!!!!!!!'
              print*,'Reason:  lake storage has become -ve'
              print*,'in lake # ',l
              if(warningflg)then      ! added Jan. 08/15  NK
                print*,'Possible fix:'
                print*,'Create a initial lake level file with a datum'
                print*,'low enough so storage will not go -ve. '
                print*,'You may have to experiment until you get a '
                print*,'proper datum. The datum is used as the weir '
                print*,'elv for the lake outflow calculation'
                warningflg=.false.
              endif
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
! fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix              
!             this is fixed by having an yyyymmdd_ill.tb0 file              
            endif   !   if(b1(l).eq.0.0)

            if(qi2(n).gt.0.0)then
              qo2(n)=(qi1(n)+qi2(n)-qo1(n))/10.0
	        if(qo2(n).lt.0.0) qo2(n)=qi2(n)/2.  ! TS: added to fix -ve outflow problem
	      else
	        qo2(n)=0.0
	      end if
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	    endif   !  if(store2(n).lt.cap(n))

d	    if(store2(n).le.0.0.and.iopt.ge.1)then
d           Print*,'store2(',n,' ) -ve / needs work in rerout @ 345'
d           print*,store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n)
d         endif
	  endif  !  if(trcflg.eq.'y')

c        lake_elv(l,jz)=-1.0
c        lake_elv(l,jz)=store2(n)/lake_area(l)

        if(iopt.ge.2)write(53,6803)l,jm,n,ireach(n),qo2(n)

      endif   !        if(b1(l).ne.0.0)

	last_month=month_now

  999 RETURN

! FORMATS

  500 format(256f10.3)
  501 format(3i5,4x,a1)
  502 format(' resv flow data extrapolated ',i5,' hours')
  504 format(' noresv,nrel,ktr/',3i5)
 1011 format(' ',3x,'  i  ires(i) jres(i)    b1(i)     b2(i)',
     *	'    b3(i)     b4(i)')
 1013 format(' ',3x,i3,2i8,5f10.5,a12/)
 4901 format(25i1)
 4902 format(3i5)
 4903 format(a12)
 4904 format(256f10.0)
 4905 format(256f10.3)
 5003 format(2i5,4g10.3,5x,a12)
 3704 format(2i5,5g10.3,5x,a12)

!     rev. 9.1.55  Jun.  12/04  - NK: write new files to resrl\newfmt folder.
 5004 format(a20,a10)
 5005 format(a20,i5)
 5006 format(a20,a1)
 5007 format(a20,256i1)
 5008 format(a20,f12.0)
 5009 format(a20,a2,'-',a2,'-nn',a2)
 5010 format(a20,a2,a4)

 5301 format(' ','Reservoir inflow data echoed:')
 5303 format(6(' ',a12))
 5304 format(' ','Error on unit=99,fln=',a30,'(',i2,')'//)
 5310 format(' -ve flow for reservoir #',i3,'zero flow assumed',i3)
 6004 format('n,l,qi,store,qo/',2i5,2f10.3,2e15.6,2f10.3)
 6005 format(f8.2,2f10.3,2e15.6,2f10.3)
 6801 format('   rerout: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',256f8.2)
 6803 format(' rerout: l,m,n,ireach(n),qo2(n)/',4i5,f10.2,f12.0)
 6804 format(' warning: store2(',i5,') set = 0.0 for resv no.',i5) 
 9005 format(' iymin,iymax,jxmin,jxmax/',4i5)
9801  format(f10.1,' resv',i3,' grid',i6,
     *         ' store2=',g12.0,'< 0 1.0 assumed')
99182   format(' Warning: Error opening or reading fln:',a30/
     *  ' Probable cause: missing strfw/yymmdd.str input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
9983  format(256(f12.0,x))
9984  format(256(E12.6,x))
9985  format(256I10)
9986  format(256(a12,x))
9987  format(256(f12.7,x))
9988  format(256(a9,x))

      END SUBROUTINE rerout

      SUBROUTINE rerout(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!DEC$ ATTRIBUTES DLLIMPORT:: rules_MH

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!     This s/r is meant to be user friendly so operating rules
!     for specific applicatins can be coded.

!***********************************************************************
!   THIS S/R  ROUTES WATER THROUGH A RESERVOIR
!   or SIMPLY PASSES ENTERED FLOWS TO THE RIVER
!
!     REV. 7.80   Oct.  29/96 -  SPL7 ADDED YYMMDD.RIN FOR RES INFLOWS
!                             -  UNIT = 39   FLN = 09
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 
!     rev. 9.1.13  Mar.  23/02  - fixed resv. timing, moved to beginning of dt
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.67  Oct.  06/09  - NK: fixed bug in rerout
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!     rev. 9.8.65  May   28/13  - NK: Dimensioned firstpass_local()in REROUT
!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
!***********************************************************************

      use area_watflood
	implicit none

	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH
	

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: old,hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live

	integer  :: lcount,day_last
	real*4   :: elvlast,qraw
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      
      real*4, dimension(:),   allocatable :: raise,lower,inflow

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.true./

!     For the great lakes only:
      DATA retard_factor/0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.,0.,
     * 590.,480.,110.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,110.,
     * 650.,510.,110.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,140.,
     * 110.,140.,80.,140.,0.,60.,230.,140.,80.,60.,0.0,0.0,
     * 170.,300.,150.,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10./
!     initial water elevations - now read from a file
!	data sup_init,mhu_init,stc_init,eri_init,ont_init/
!     *      183.2,175.98,174.8,174.01,74.61/

!     lif = lake ice factor

!     WHEN LOCAL IS -VE, RESERVOIR RELEASES ARE NEED IN AND THESE 
!     BECOME THE OUTFLOWS OF THE SQUARE IN WHICH THE DAM OUTLET 
!     STRUCTURE IS LOCATED.  
!     WHEN LOCAL = 0 , THERE ARE NO RESERVOIRS, REROUT IS NOT CALLED.

!     WHEN LOCAL IS +VE, THE INFLOW TO THE SQUARE IN WHICH THE
!     RESERVOIR IS LOCATED IS PRINTED OUT ON FILE 11 FOR USE IN
!     HEC-5 OR OTHER OPERATING PROGRAM.

!     THE OVERALL OPERATING SEQUENCE IS THEN THE FIRST RUN SIMPLE
!     TO CALCULATE THE RUNOFF PRODUCED IN VARIOUS SUB-BASINS THEN
!     TO DETERMINE RELEASES, AND THEN TO ROUTE THE RELEASES AND LOCAL
!     INFLOWS USING HYMO.  THE RELEASES ARE READ IN FROM FILE 12.

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

      if(firstpass_local(98))then
        last_month=month_now
        wrtdiverflg=.false.  !used for writing a new diversion file 
!       if divertflg = 'g' then diversion flows need to be generated 
!       for L. St. Joseph and NOT read in. In this case, qdivert 
!       has not been allocated in read_divert_ef.f so it needs to be 
!       done here for just one location:
        if(.not.allocated(qdivert))then
!         set one diversion location
          nodivert=1
          allocate(qdivert(nodivert,mhtot),stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of aqdivert  in rerout @ 109'
        endif
        if(iopt.ge.1)print*,'qdivert allocated as      1,',mhtot
        firstpass_local(98)=.false.
      endif
      
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        firstpass_local(99)=.false.
      endif


!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!     rev. 9.5.53  Jan.  20/09  - NK: undid rev. 9.5.40
!##########################################################################
!     DIVERSIONS
!##########################################################################
!     rev. 9.5.40  Oct.  21/08  - NK: added diversions to rerout
!     A diversion can only be made to another node providing
!     the receiving node is at a lower elevation - i.e. the grid number is 
!     higher in the order = later in the grid loop n=1,naa
!     Makes sense. Can not divert to a higher grid without pumping

!     If in an outlet node of a lake from which diversion is made,
!     add an outflow from this reach to the inflow in another. 

!     Lake St Joseph:
!     outflow grid = 1803    05QB006
!     receiving grid = 1866
c      if(n.eq.1803.and.na.eq.3039)then
c        q_divert=qhyd(34,(jz-1)/ktr*ktr+ktr)        
c        q_divert=amax1(0.0,q_divert)     ! in case there are missing data (-1.00)
c        qi2(1866)=qi2(1866)+q_divert   ! diversion into receiving grid
c        write(53,*)n,jz,(jz-1)/ktr*ktr+ktr,qi2(1866),q_divert
c      else
c        q_divert=0.000
c      endif
!###########################################################################

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      if(b1(l).ne.0.00000)then  
!     Start of rule-based routing
!     Start of rule-based routing
!     Start of rule-based routing
!     If lake name matches name below, coefficients will be ignored
!     and rules used instead.
      if(resname(l).eq.'Superior     ')then

!       Lake Superior
!         this means that:
!         1. we are doing the great lakes
!         2. we are initializing lake superior here
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    sup=sup_init
	    sup=b6(1)
	    store1(n)=(sup-181.43)*82.1e+09
c	    store1(n)=(sup-b7(1))*82.1e+09
	    store2(n)=store1(n)
          qo2(n)=824.7*(sup-181.43)**1.5-retard_factor(mo1,1)        
          qo1(n)=qo2(n)
	  endif

        if(b1(1).ne.0.0)then
          qo2(n)=824.7*(sup-181.43)**1.5-retard_factor(mo1,1)        
	  else
	     if(qrel(l,jz).gt.0.0)qo2(n)=qrel(l,jz)
	  endif

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div

        sup=store2(n)/82.1e+09+181.43

        lake_elv(l,jz)=sup
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:5).eq.'Huron')then

!       Lake Michigan-Huron
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    mhu=mhu_init
	    mhu=b6(2)
          store1(n)=(mhu-166.98)*117.4e+09
c          store1(n)=(mhu-b7(1))*117.4e+09
	    store2(n)=store1(n)
c	    delta_elv=mhu-stc_init
	    delta_elv=mhu-b6(3)
c	    mean_elv=(mhu_init+stc_init)/2.0
	    mean_elv=(b6(2)+b6(3))/2.0
	  else
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
	    delta_elv=mhu-stc
	    mean_elv=amax1(166.98+0.1,mean_elv)   ! prevent div by 0
	    delta_elv=amax1(0.001,delta_elv)        ! prevent div by 0
	  endif
!       use stc from the previous time step. Slow change anyway.

        qo2(n)=82.2*(mean_elv-166.98)**1.87*(delta_elv)**0.36
     *           -retard_factor(mo1,2)        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        mhu=store1(n)/117.4e+09+166.98

!        print*,n,resname(l),mhu,qo2(n),store1(n),store2(n)
        lake_elv(l,jz)=mhu
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz)
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'StClair')then

!       Lake St. Clair
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    stc=stc_init
	    stc=b6(3)
	    store1(n)=(stc-164.91)*1.11e+09
c	    store1(n)=(stc-b7(3))*1.11e+09
	    store2(n)=store1(n)
c          delta_elv=stc_init-eri_init
          delta_elv=b6(3)-b6(4)
	  else
!     rev. 9.4.11  Jun.  22/07  - NK: reordered rerout for glake 
          delta_elv=stc-eri
	    delta_elv=amax1(0.001,delta_elv)        ! prevent div by 0
	  endif
        stc=amax1(0.1,stc)                    ! prevent div by 0
!       use eri from the previous time step. Slow change anyway.

        qo2(n)=28.8*(stc-164.91)**2.28*(delta_elv)**0.305        
     *           -retard_factor(mo1,3)        

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        stc=store1(n)/1.11e+09+164.91

!        print*,n,resname(l),stc,qo2(n),store1(n),store2(n)
        lake_elv(l,jz)=stc
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz)
c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:4).eq.'Erie')then

!       Lake Erie
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    eri=eri_init
	    eri=b6(4)
	    store1(n)=(eri-169.86)*25.7e+09
c	    store1(n)=(eri-b7(4))*25.7e+09
	    store2(n)=store1(n)
        endif       

        qo2(n)=558.3*(eri-169.86)**1.60-retard_factor(mo1,4)
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        eri=store1(n)/25.7e+09+169.86  
        lake_elv(l,jz)=eri
        lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz)

c	print*,sup,mhu,stc,eri,ont
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'Ontario')then

!       Lake Ontario
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
c	    ont=ont_init
	    ont=b6(5)
	    store1(n)=(ont-69.474)*18.96e+09
c	    store1(n)=(ont-b7(5))*18.96e+09
	    store2(n)=store1(n)
	  endif

        qo2(n)=555.823*(ont-0.0014*real(2000-1985)-69.474)**1.5
     *           -retard_factor(mo1,5)        

        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        ont=store1(n)/18.96e+09+69.474         
!        print*,n,resname(l),ont,qo2(n),store1(n),store2(n)
!        print*,'year=',year
        lake_elv(l,jz)=ont
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-lake_outflow(l-1,jz)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     lake Katebogama & Namakan
      elseif(resname(l)(1:7).eq.'Namakan')then
!       Gold Portage & Bear Portage are overflows
!       main outlet is at Kettle Falls  = cell 2469
!       Kabetogama lake l = 33
!       Namakan lake    l = 17
!       The lake time constant is around 16 days so explicit = ok
!       Bear Portage sill = 340.39     Kabetogama lake
!       Gold Portage sill = 338.000
!       Kettle Falls sill ~ 336
c       b1(l)=0.0  ! make sure we don't do this twice
c       b1(33)=0.0
        qbear=0.0
        qgold=0.0
        b7(l)=336.0  ! Kettle Falls sill elv.
        elv=b7(l)+store1(n)/2.7864672E+08
c        hgold=elv-338.00
!       datum is at 338 but flow starts at 339.124 in rating curve. 
!       This should reduce the flows 
        hgold=elv-339.124
        hbear=elv-340.39
!       Kettle Falls
c        qo2(n)=b1(l)*store2(n)**b2(l)
c        qkettle=0.20E-13*store2(n)**1.75
        qkettle=0.30E-13*store2(n)**1.75
        
c        qkettle=1.10*qkettle  ! added to reduce the Gold Portage flow a bit
        
        
        if(hgold.gt.0.0)then              
!         Gold Portage outlet
c         qgold=-0.0288*hgold**6+0.209*hgold**5
c    *               -0.4795*hgold**4+2.0935*hgold**3 
c    *               -2.7188*hgold**2+0.8804*hgold   
!          see Rick Cousin's e-mail June 2010
!          revised Aug. 28, 2013 NK   
           qgold=(((-0.8053*hgold+5.1177)*hgold
     *             -0.9376)*hgold+2.7952)*hgold    

          qgold=amax1(0.0,qgold)     
          if(hbear.gt.0.0)then
!           Bear Portage outlet
            qbear=(((((-12.019*hbear+79.284)*hbear
     *               -193.12)*hbear+202.77)*hbear 
     *               -65.491)*hbear+8.364)*hbear
            qbear=amax1(0.0,qbear)
          endif   
        endif
        qo2(n)=qkettle+qbear  !into Rainy Lake - ungauged
        qo2(2435)=qgold   ! into Black Bay of Rainy Lake - gauged
        qo2(n)=amax1(0.0,qo2(n))
        qo2(2435)=amax1(0.0,qo2(2435))
        store2(n)=store1(n)
     *           +(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
     *           +(-qo1(2435)-qo2(2435))*div
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
c        write(543,54300)totaltime,l,hbear,qbear,hgold,qgold,
c     *            elv,qkettle,qo2(n),qo2(2435)
c54300   format(f10.3,i5,99f10.3)

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:7).eq.'Kabetog')then
!       see above  
!       don't do anything!!
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

!    Lake St. Joseph   
      elseif(resname(l)(1:7).eq.'L_St_Jo')then

        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          open(unit=954,file=filename(954),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',filename(954)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in rerout @ 407'
          endif
          if(iopt.ge.1)write(954,*)
     *      '        hour  q_diverted Albany_flow      Lake_elv'
          if(iopt.eq.0)write(954,*)'Set iopt > 0 to get data here'
          ndiv_max=mhtot
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
          include "MH_root_coord.fi"      ! this must be commneted out 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        endif     ! firstpass

!     rev. 9.9.19  Jun.  11/14  - NK: Added a file for lat-long diversion locations for L. St. Jo
!       Albany River outlet:
c        if(lake_elv(l,jz).gt.373.8)then
        if(temp_elv(l).gt.373.8)then
          qo2(n)=300.0
c        elseif(lake_elv(l,jz).gt.374.05)then
        elseif(temp_elv(l).gt.374.05)then
          qo2(n)=1.05*qi2(n)
c          qo2(n)=b1(l)*((temp_elv(l)-374.05)*lake_area(l))**b2(l)
c        elseif(lake_elv(l,jz).gt.371.25.and.year_now.ge.1985)then
        elseif(temp_elv(l).gt.371.25.and.year_now.ge.1985)then
!         OPG maintains a minimum of about 2 m3/s 
!         fishery flow at the Cedars dam for the Albany River           
!         MG's e-mail Jan. 12/13
          qo2(n)=2.0  
        else          ! added Jul. 22/13  NK
          qo2(n)=0.0
        endif
        
        if(divertflg.eq.'g')then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      include "MH_root_diversion.fi"      ! this must be commneted out
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else

!     rev. 9.8.85  Sep.  30/13  - NK: Fixed the water balance for Lake St. Jo so diversion is taken care of
!         qo2() is calculated above
          store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
c     *               -2.0*qdivert(1,jz)*div    already taken out in sub 
          lake_inflow(l,jz)=qi2(n)+qdivert(1,jz)
          net_lake_inflow(l,jz)=qi2(n)-qo2(n)-qdivert(1,jz)
          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          temp_elv(l)=lake_elv(l,jz)
          qdwpr(ireach(n),jz)=qdwpr(ireach(n),jz)+qdivert(1,jz)
          
c       write(954,*)jz,qdivert(1,jz),qo2(n),store2(n),lake_elv(l,jz)
     
        endif
!~~~~~~~~~end generate diversion flow~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        

      elseif(resname(l)(1:7).eq.'05QE006')then
!       Lac Seul
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
        endif
        if(temp_elv(l).gt.357.0)then
          qo2(n)=600
        elseif(temp_elv(l).gt.356.8)then
          qo2(n)=500.0
        elseif(mo.lt.3.or.mo.ge.10)then
!         winter rule        
          if(temp_elv(l).gt.354.6)then
            qo2(n)=400.0
          else
            qo2(n)=100.0
          endif
        elseif(jul_day_now.ge.105.and.jul_day_now.lt.181)then
!         between April 15 & June 30 water level should rise
!         steadily to a max = 355.3
          if(temp_elv(l).lt.355.3)then
            qo2(n)=0.25*qi2(n)       ! changed from 0.75 
            if(jul_day_now.ge.135.and.jul_day_now.lt.166)then
!             maintain may-june min flow for walleye spawn            
              qo2(n)=amax1(qo2(n),180.0)
            endif           
          endif
        else  
	    qo2(n)=b1(l)*store2(n)**b2(l)
        endif
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)
        
      elseif(resname(l)(1:7).eq.'LOW_rel')then
!       Lake of the Woods        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.10
          lower(l)=2.5
          inflow(l)=qi2(l)   ! initial seed value for moving average
        endif
c        inflow(l)=0.999*inflow(l)+0.001*qi2(n)
        old=qo2(n)
c        inflow(l)=qi2(n)
        inflow(l)=0.001*qi2(n)+0.999*inflow(l)
c         inflow(l)=0.0
        spill=0.0
!       note that inflow() is used only to determine the outflow
!              - not used for the water balance!!!!!        
c        if(mo.lt.3.or.mo.ge.10)then
c!         winter rule        
c          if(temp_elv(l).gt.322.75)then
c            qo2(n)=400.0
c          else
c            qo2(n)=200.0
c          endif
        if(jul_day_now.le.31.and.temp_elv(l).gt.322.69)then      !Jan
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'01',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.31.and.temp_elv(l).le.322.69)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.59.and.temp_elv(l).gt.322.55)then  !Feb
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'02',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.59.and.temp_elv(l).le.322.55)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.90.and.temp_elv(l).gt.322.38)then  !Mar
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'03',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.90.and.temp_elv(l).le.322.38)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.120.and.temp_elv(l).gt.322.65)then  !Apr
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).le.322.65)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).gt.322.80)then  !May
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).le.322.80)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).gt.323.17)then  !Jun
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).le.323.17)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).gt.323.18)then  !Jul
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).le.323.18)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).gt.323.00)then  !Aug
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).le.323.00)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).gt.322.93)then  !Sep
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).le.322.93)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).gt.322.88)then  !Oct
          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
        elseif(jul_day_now.le.304.and.temp_elv(l).le.322.88)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).gt.322.80)then  !Nov
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'11',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.334.and.temp_elv(l).le.322.80)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        elseif(jul_day_now.le.366.and.temp_elv(l).gt.322.75)then  !Dec
c          spill=b1(l)*store2(n)**b2(l)
c          qo2(n)=lower(l)*inflow(l)
            qo2(n)=400.0
            if(temp_elv(l).gt.323.47)qo2(n)=800.0
c            qo2(n)=amax1(lower(l)*inflow(l),400.0)
c        write(711,*)'12',totaltime,lower(l)*inflow(l),400.0+spill,qo2(n)
        elseif(jul_day_now.le.366.and.temp_elv(l).le.322.75)then
          qo2(n)=raise(l)*inflow(l)
            qo2(n)=200.0
        endif
        qo2(n)=amin1(qo2(n),1400.0)   ! gen=420   spill=200
        qo2(n)=amax1(qo2(n),100.0)    ! min year round flow @ Kenore PH
        qo2(n)=0.999*old+0.001*qo2(n)    ! smoothing
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)
        
        
        
        
      elseif(resname(l)(1:7).eq.'05PC019')then
!       Rainy Lake        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.50   ! was 0.75 but too slow filling
          lower(l)=1.25
        endif
        old=qo2(n)
        inflow(l)=qi2(n)
        if(jul_day_now.le.31.and.temp_elv(l).gt.337.03)then      !Jan
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.31.and.temp_elv(l).le.337.03)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.59.and.temp_elv(l).gt.336.87)then  !Feb
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.59.and.temp_elv(l).le.336.87)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.90.and.temp_elv(l).gt.336.7)then  !Mar
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.90.and.temp_elv(l).le.336.7)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).gt.336.8)then  !Apr
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.120.and.temp_elv(l).le.336.8)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).gt.337.3)then  !May
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.151.and.temp_elv(l).le.337.3)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).gt.337.5)then  !Jun
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.181.and.temp_elv(l).le.337.5)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).gt.337.63)then  !Jul
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.212.and.temp_elv(l).le.337.63)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).gt.337.58)then  !Aug
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.243.and.temp_elv(l).le.337.58)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).gt.337.53)then  !Sep
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.273.and.temp_elv(l).le.337.53)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).gt.337.48)then  !Oct
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.304.and.temp_elv(l).le.337.48)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).gt.337.3)then  !Nov
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.334.and.temp_elv(l).le.337.3)then
          qo2(n)=raise(l)*inflow(l)
        elseif(jul_day_now.le.366.and.temp_elv(l).gt.337.2)then  !Dec
          qo2(n)=lower(l)*inflow(l)
        elseif(jul_day_now.le.366.and.temp_elv(l).le.337.2)then
          qo2(n)=raise(l)*inflow(l)
        endif
        qo2(n)=amin1(qo2(n),620.0)   ! gen=420   spill=200
        qo2(n)=amax1(qo2(n),100.0)    ! min year round flow @ Kenore PH
        qo2(n)=0.9*old+0.1*qo2(n)     ! smoothing
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)

      elseif(resname(l)(1:6).eq.'FamL_N')then
!     rev. 9.8.58  Apr.  12/13  - NK: REvised Family Lake (WPEGR) O/R in rerout
!       no iteration needed        n=1562
!       this lake = special case: 2 outlets
        store_live=store2(n)-store_dead(l)
        if(store_live.gt.0.1)then
	    outflow=b1(l)*store_live**b2(l)
	    qo2(n)=0.32*outflow    !this is the outlet in the rel file
c	    qo2(1548)=0.68*outflow
!         for the new shd file with Cedar Lake included
	    qo2(1696)=0.68*outflow
	  else
	    qo2(n)=0.0
c	    qo2(1548)=0.00  ! added here
!         for the new shd file with Cedar Lake included
	    qo2(1696)=0.00  ! added here
        endif
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n)-qo1(1696)-qo2(1696))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      elseif(resname(l)(1:6).eq.'FamL_S')then
!       see above  
!       don't do anything!!

      elseif(resname(l)(1:7).eq.'Cameron')then
!       Cameron Lake        
        if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          raise(l)=0.90   ! was 0.75 but too slow filling
          lower(l)=1.05
        endif
         
        old=qo2(n)
        inflow(l)=qi2(n)
       
        if(jul_day_now.le.91)then      !Jan-Mar
                 store2(n)=(temp_elv(l)-54.1)*lake_area(l)
        elseif(jul_day_now.le.121)then      !Mar
!                raise level over one month        
                 sill=54.1+float(jul_day_now-91)*0.01667
                 store2(n)=(temp_elv(l)-sill)*lake_area(l)
        elseif(jul_day_now.le.305)then  !May-Oct
                 store2(n)=(temp_elv(l)-54.6)*lake_area(l)
        elseif(jul_day_now.le.335)then  !Nov.
!                lower water slowly        
                 sill=54.6-float(jul_day_now-305)*0.01667
                 store2(n)=(temp_elv(l)-sill)*lake_area(l)
        elseif(jul_day_now.le.366)then  !Dec
                 store2(n)=(temp_elv(l)-54.1)*lake_area(l)
        endif

        if(store2(n).gt.0.0)then
          qo2(n)=b1(l)*store2(n)**b2(l)
        else
          qo2(n)=0.0
        endif
          
        qo2(n)=0.9*old+0.1*qo2(n)     ! smoothing
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
     
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) 
        temp_elv(l)=lake_elv(l,jz)


!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
      include "MH_rules.fi"      ! this must be commneted out
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       

!     For the Mackenzir River:
!     REV. 10.1.14 Jan.  05/16  - NK: Added ice rules for Lakes Athabaska & Great Slave.
      else
!       NATURAL RESERVOIR ROUTING:
!       rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout

!       get initial value:        
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation
c        if(store2(n).le.0.0)then
c          write(98,9801)time,l,n,store2(n),qi2(n)
c          store2(n)=1.0
c          if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
c        endif
        old=qo1(n)
        hold=0.1e+26
        if(b3(l).eq.0.0)then
!         using a power function        
!         tried to put this in the iteration loop but got spikes
!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          if(store2(n)-store_dead(l).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                if(store2(n)-store_dead(l).gt.0.0)then
!                 have to do at least 3 iterations
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file

!                 added the snow weight at the outlet grid to the 
!                 lake dischrge equation
                  qo2(n)=b1(l)*(store2(n)-store_dead(l)+
     *                snowc(n,classcount-1)/1000.0*lake_area(l))**b2(l)
                  qo2(n)=qo2(n)*lake_ice_factor(l)
                  wt=amax1(0.5,float(ic)/21.0)
                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
                  old=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                else
                  qo2(n)=0.0
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif


c25        continue   ! sorry about that   

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        else       !(b3(l).gt.0.0)
!         using a polinomial        
!     rev. 9.8.56  Apr.  10/13  - NK: Added check in rerout for -ve storage due to evaporation

          if(store2(n).le.0.0)then
            write(98,9801)time,l,n,store2(n),qi2(n)
c            store2(n)=1.0
            if(qi2(n).lt.0.0)qi2(n)=0.0 !can't evaporate water that is not there
          endif

!     rev. 9.9.44  Nov.  28/14  - NK: Added dead storage to reservoirs 
          store_live=store2(n)-store_dead(l) 
          if(store_live.gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
!             have to do at least 3 iterations
!             rev  9.1.03  July  24/01  - added polinomial
              qo2(n)=store_live*(b1(l)+store_live*(b2(l)+store_live*
     *                    (b3(l)+store_live*(b4(l)+b5(l)*store_live))))
              qo2(n)=qo2(n)*lake_ice_factor(l)
              qo2(n)=amax1(0.0,qo2(n))
              wt=amax1(0.5,float(ic)/21.0)
              qo2(n)=(1.0-wt)*qo2(n)+wt*old
              old=qo2(n)
              hold=store2(n)
              store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            end do   ! hold-store
          else     
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

c         if(store2(n).le.0.0)then
c            qo2=0.0
c            store2(n)=1.0
c            write(53,6804)n,l
c          endif
        endif     !if(b3(l).eq.0.0)   

	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

c        lake_elv(l,jz)=-1.0
!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels
c	  if(b6(l).gt.0.0.and.b7(l).lt.0.000001)then



c        lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l) !b7()=0.0 if not in rel file
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l) !b7()=0.0 if not in rel file
        
!     rev. 9.8.57  Apr.  12/13  - NK: Added lakeEflg to stop lake evaporation whan levels very low
!       if there is less than 10 mm of water left in a lake, stop the 
!       evaporation so storage can not go -ve & cause routing problems     
!       used in runoff
!       Needs to be done like this so lake evap can be properly considred
!       for te watbal s/r     
        if(lake_elv(l,jz).lt.b7(l))then
          lakeEflg(l)=.false.
        else
          lakeEflg(l)=.true.
        endif
          
c        else
c          lake_elv(l,jz)=store2(n)/lake_area(l)
c	  end if

d        if(iopt.ge.2.and.iopt.le.10)then
d          write(53,6004,iostat=ios)n,l,
d    *           qi1(n),qi2(n),store1(n),store2(n),qo1(n),qo2(n)
d          if(ios.ne.0)then
d            print*,'problems for grid #',n,'lake #',l,' @',time
d          endif
d        endif

!       CALCULATE THE DETENTION TIME
!        if(qo1(n).gt.0.001) at=store2(n)/qo1(n)
!         yeah.... fix this:
        if(qo1(n).gt.0.001) at=store2(n)/qo2(n)

!       SELECT MINIMUM TRAVEL TIME FOR THE TIME STEP CALCULATION
c        dtmin=amin1(at,dtmin)
	
!       DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN THE FASTEST
!       EMPTYING ELEMENT              


cccc      endif  ! end of rule based lake/reservoir outflow

      endif
      
!     rev. 9.8.82  Sep.  07/13  - NK: Bypass of hard-coded lake rules when coeff1=0
      else       !   if(b1(l).eq.0.00000)    FROM RELEASE TABLE:


!       rev. 8.99l  Oct.    2001-     fixed reservoir release timing
!         jm=jz+1        old way see JW's e-mail Oct. 23/01

        jm=jz
        if(jz.gt.nrel)jm=nrel

	  if(jm.lt.1)then
          qo2(n)=qrel(l,1)          !+q_divert
	  else
          qo2(n)=qrel(l,jm)          !+q_divert
	  endif

        if(qo2(n).lt.0.0)qo2(n)=0.0

!        this line is for the water balance only
!        it doesn't work for releases

c        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
        store2(n)=
     *     store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-qo2(n)

!     rev. 9.5.32  Jun.  04/08  - NK: compute reservoir levels
!     rev. 9.5.38  Oct.  14/08  - NK: added optional coef6 & 7 to rel file for lake levels


!     rev. 9.9.20  Jul.  24/14  - NK: Added dead storage for lakes "stroe_dead"
c          lake_elv(l,jz)=b7(l)+store2(n)/lake_area(l)
          lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)


!	  if(frcflg.eq.'y')then
	  if(trcflg.eq.'y')then  ! otherwise upsets tracer code
          if(store2(n).lt.cap(n))then
!           leave everything unchanged in the reservoir
!     rev. 9.9.20  Jul.  15/14  - NK: Fix -ve lake storage when release data used
            if(b1(l).eq.0.0)then
!             we're run into a problem where the releases in the rel file are
!             greater than the inflows and the reservoir is already below live storage.
!             Maybe we can fix this by having a datum high enough so the storage does
!             not go -ve.    trcOffFlg
              trcflg='n'
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
              print*,'WARNING: tracer turned off!!!!!!!!!!!!!!!!!'
              print*,'Reason:  lake storage has become -ve'
              print*,'in lake # ',l
              if(warningflg)then      ! added Jan. 08/15  NK
                print*,'Possible fix:'
                print*,'Create a initial lake level file with a datum'
                print*,'low enough so storage will not go -ve. '
                print*,'You may have to experiment until you get a '
                print*,'proper datum. The datum is used as the weir '
                print*,'elv for the lake outflow calculation'
                warningflg=.false.
              endif
              print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
! fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix  fix              
!             this is fixed by having an yyyymmdd_ill.tb0 file              
            endif   !   if(b1(l).eq.0.0)

            if(qi2(n).gt.0.0)then
              qo2(n)=(qi1(n)+qi2(n)-qo1(n))/10.0
	        if(qo2(n).lt.0.0) qo2(n)=qi2(n)/2.  ! TS: added to fix -ve outflow problem
	      else
	        qo2(n)=0.0
	      end if
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	    endif   !  if(store2(n).lt.cap(n))

d	    if(store2(n).le.0.0.and.iopt.ge.1)then
d           Print*,'store2(',n,' ) -ve / needs work in rerout @ 345'
d           print*,store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n)
d         endif
	  endif  !  if(trcflg.eq.'y')

c        lake_elv(l,jz)=-1.0
c        lake_elv(l,jz)=store2(n)/lake_area(l)

        if(iopt.ge.2)write(53,6803)l,jm,n,ireach(n),qo2(n)

      endif   !        if(b1(l).ne.0.0)

	last_month=month_now

  999 RETURN

! FORMATS

  500 format(256f10.3)
  501 format(3i5,4x,a1)
  502 format(' resv flow data extrapolated ',i5,' hours')
  504 format(' noresv,nrel,ktr/',3i5)
 1011 format(' ',3x,'  i  ires(i) jres(i)    b1(i)     b2(i)',
     *	'    b3(i)     b4(i)')
 1013 format(' ',3x,i3,2i8,5f10.5,a12/)
 4901 format(25i1)
 4902 format(3i5)
 4903 format(a12)
 4904 format(256f10.0)
 4905 format(256f10.3)
 5003 format(2i5,4g10.3,5x,a12)
 3704 format(2i5,5g10.3,5x,a12)

!     rev. 9.1.55  Jun.  12/04  - NK: write new files to resrl\newfmt folder.
 5004 format(a20,a10)
 5005 format(a20,i5)
 5006 format(a20,a1)
 5007 format(a20,256i1)
 5008 format(a20,f12.0)
 5009 format(a20,a2,'-',a2,'-nn',a2)
 5010 format(a20,a2,a4)

 5301 format(' ','Reservoir inflow data echoed:')
 5303 format(6(' ',a12))
 5304 format(' ','Error on unit=99,fln=',a30,'(',i2,')'//)
 5310 format(' -ve flow for reservoir #',i3,'zero flow assumed',i3)
 6004 format('n,l,qi,store,qo/',2i5,2f10.3,2e15.6,2f10.3)
 6005 format(f8.2,2f10.3,2e15.6,2f10.3)
 6801 format('   rerout: reservoir no =',i3,' mhtot =',i5)
 6802 format('   ',256f8.2)
 6803 format(' rerout: l,m,n,ireach(n),qo2(n)/',4i5,f10.2,f12.0)
 6804 format(' warning: store2(',i5,') set = 0.0 for resv no.',i5) 
 9005 format(' iymin,iymax,jxmin,jxmax/',4i5)
9801  format(f10.1,' resv',i3,' grid',i6,
     *         ' store2=',g12.0,'< 0 1.0 assumed')
99182   format(' Warning: Error opening or reading fln:',a30/
     *  ' Probable cause: missing strfw/yymmdd.str input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
9983  format(256(f12.0,x))
9984  format(256(E12.6,x))
9985  format(256I10)
9986  format(256(a12,x))
9987  format(256(f12.7,x))
9988  format(256(a9,x))

      END SUBROUTINE rerout

      SUBROUTINE route(div,thr,dtmin,jz,iz,time,date,tdum)

!***********************************************************************
!
!  THE INFLOW INTO THE CHANNEL IN EACH ELEMENT IS THE SUM OF THE
!  OUTFLOW OF THE ELEMENTS WHICH DRAIN INTO IT FROM ABOVE AND THE
!  SURFACE RUNOFF AND SUBSURFACE FLOW FROM THE ELEMENT IN WHICH THE
!  OUTFLOW IS BEING CALCULATED                                 
!
!     REV. 8.23 - Mar.  25/96 -  fixed bug in route - keep qo2 for res
!     rev. 8.99mm Dec. 13/2001-     added check for <= 0 init res flow
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90
!     REV. 9.03    Nov.  2000 - TS: ADDED WATFLOOD SWAMP ROUTING 
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 9.1.10  Jan.  29/02  - flow nudging added for nopt(l)=2
!     rev. 9.1.14  Mar.  24/02  - fixed wetland min time step and outflow
!     rev. 9.1.16  Apr.  03/02  - Added wetland conditional to select river w/wo wetland
!     rev. 9.1.31  Nov.  13/02  - Fixed the wetland Q to account for wetland area
!     rev. 9.1.33  Dec.  05/02  - Fixed instability in wetland flow    
!     rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
!     rev. 9.1.39  Apr.  06/03  - Fixed wetland routing when channel is dry
!     rev. 9.2.11  Sep.  11/05  - NK: added Manning's n  r1n & r2n
!     rev. 9.2.13  Sep.  28/05  - NK: added freeze and break up to route
!     rev. 9.2.23  Nov.  22/05  - NK: Fixed res(n)=0 bug in route 
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.39  May.  09/06  - NK: t added to route & rerout arg listrules
      
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.3.04  Oct.  24/06  - NK: routing parameters dim to na in rte
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!                                 eg: lzf(ii) -> lzf(n) 
!     rev. 9.5     Sep.  07/07  - NK: changed wetland/channel routing 
!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
!     rev. 9.5.02  Oct.  21/07  - NK: set init qdwpr=0.0 in route
!     rev. 9.5.04  Dec.  27/07  - NK: fixed bug in wetland routing
!     rev. 9.5.06  Feb.  05/08  - NK: added pool and pool_o in rdpar & route
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
!     rev. 9.5.39  Oct.  15/08  - NK: fixed bug in reservoit routing
!     rev. 9.5.46  Dec.  23/08  - NK: trying to fix problem with -ve storage. Changed conditional to .lt.
!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!     rev. 9.5.54  Feb.  11/09  - NK: undid rev. 9.2.28
!     rev. 9.5.58  Apr.  16/09  - NK: added nudgeflg for forcing gauge flows
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
!     rev. 9.8.10  Dec.  06/11  - NK: Added message for FP overflow in route
!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
!     rev. 9.8.52  Mar.  20/13  - NK: deleted a pause for dds runs in route
!                                 qwdr = point withdrawals
!                                 taken from store2() in river routing
!                                 taken from lake inflows in lake routing
!
!     changes made to include c&g model stuff  nk  April. 26/07
!
!***********************************************************************


      use area_watflood
      implicit none


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: istate(400,400),rbin,lsta,nnn1,jz,n,lll,l,iz,jjz,
     *             i,j,ii,ic,jj,ios,itracker,unt,ln,n_dt_min,
     *             month_last,ic_max
      integer :: iallocate
      REAL    :: old,oldwet,convert,kfactor,wth,old_at,aaa,tdum
      REAL(4) :: time,newstore,try1,try2,try3,div,thr,at,dtmin,
     *             wt,atemp,ax,xa,at1,dt_min_n,
     *             hold,whold,strlossvol,qtest
      integer :: frame_no1
!        REAL(4), DIMENSION(:) :: att(10000)
      character*1 :: flowsta,firstpass,writeflg,flwinitflg
      character*80 :: junk
!        REAL    :: qdlast(6)
      character(14) :: date
      logical  :: printmsg
      logical, dimension(:), allocatable  :: printwarning
      
!     needs to fixed for dynamic mem
      DATA month_last/0/
      DATA istate /160000*0/
      DATA firstpass/'y'/
      data printmsg/.true./
     
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
      index=2

      if(firstpass.eq.'y')then   !section added Apr. 28/06  nk
!       check that qdwpr memory has been allocated
        do n=1,naa
          if(ireach(n).gt.0.or.res(n).gt.0)then
            if(.not.allocated(qdwpr))then
              print*
              print*,'Memory not allocated for qdwpr'
              print*,'No of reservoirs in the .rel file is 0'
              print*,'but reaches in the map & shed files have been'
              print*,'defined. This is a problem.'
              print*,'Please either set all reach values = 0'
              print*,'or code in the reservoir locations in the rel'
              print*,'files'
              stop 'Program aborted in route @ 279'
            endif      
          endif
        end do

        allocate(printwarning(na),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *     'Error with allocation of printwarning in route @ 114'
        do n=1,naa
          printwarning(n)=.true.
          netoutflow(n)=0.0
        end do
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        if(iopt99)then
          do n=1,naa
            qqlow(n)=10000.0
          end do
        endif
d        print*,'printwarning set to "T"'
        
        
! moved to spl  Jul. 08/13
c!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
c!       wetland_flag(n) replaced multiple logical checks by just 1 in each
c!       time & grid loop - so will save a lot of time
c        allocate(wetland_flag(naa),stat=iAllocate)
c        if(iAllocate.ne.0) STOP
c     *     'Error with allocation of wetland_flag in route @ 112'
c        do n=1,naa
c          if(aclass(n,classcount-2).gt.0.0
c     *            .and.grid_area(n).gt.10.0   ! added Oct. 15/12 NK
c     *            .and.wetflg.eq.'y'
c     *            .and.theta(ibn(n)).gt.0.00001
c     *            .and.glacier_flag(n).ne.'y')then
c            wetland_flag(n)=.true.
c          else
c            wetland_flag(n)=.false.
c          endif
c	  end do  
c	  
	  flwinitflg='n'
	  old_at=dtmin
	  frame_no1=0
        qlow=0.000000
        
	endif

!     CALCULATIONS START IN THE HIGHEST ELEMENT IN THE WATERSHED 
!     AND PROCEED TO THE LOWEST.

!#ifdef TEST
      if(iopt.ge.3)then
        write(55,6002)iz,jz
        write(53,6002)iz,jz
        write(55,6003)
      endif
!#endif
 
!     ROUTING LOOP:

      jjz=jz
      if(jjz.lt.1) jjz=1
      dt_min_n=1.0e32

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

d      if(iopt.eq.2)print*, ' in route before the 1-naa loop'

c!DEC$ NOPARALLEL

      do n=1,naa
!       REV. 8.23 - Mar.  25/96 - FIXED BUG IN ROUTE, KEEP QO2 FOR RES

        store1(n)=store2(n)
        wstore1(n)=wstore2(n)
        hwet1(n)=hwet2(n)
        hcha1(n)=hcha2(n)
        qo1(n)=qo2(n)
        if(res(n).eq.0)qo2(n)=0.0
        qowet1(n)=qowet2(n)
        qi1(n)=qi2(n)
c        qi2(n)=1.0e-10
        qi2(n)=0.0
c        netoutflow(n)=0.0
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        strlossvol=strloss(n)*div*2.0

!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
        qUS1(n)=qUS2(n)
c        qUS1(n)=0.0
        qUS2(n)=0.0
     
        qiwet1(n)=qiwet2(n)
        qiwet2(n)=1.0e-10

!     rev. 9.5.02  Oct.  21/07  - NK: set init qdwpr=0.0 in route
        if(ireach(n).gt.0)then
          rbin=ireach(n)
!          grid is part of a reservoir or lake 
          qdwpr(rbin,jjz)=0.0
        endif
      end do
      writeflg='n'
      
      do n=1,naa
d        if(iopt.eq.2.and.n.eq.1)print*,'In route, passed 101'

        i=yyy(n)
        j=xxx(n)
        l=nhyd(i,j)

c        if(l.eq.0.and.numa.gt.0)then            ! NON-BASIN EXCLUSION
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
c         if(l.eq.0.and.dds_flag.eq.1)then            ! NON-BASIN EXCLUSION
c        if(l.eq.0)then            ! NON-BASIN EXCLUSION


!           DON'T DO ANYTHING - WE'RE NOT IN A GRID THAT COUNTS FOR OPT

c        else                    ! (l.eq.0.and.numa.gt.0)

!         WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASINfat=

!         AND THE ROUTING SEQUENCE IS SKIPPED

          if(slope(n).gt.0.0)then
!           REV. 7.2 Sept. 19/94 - ADDED IREACH() FOR DWOPER INPUT  

! * * * * * * * * * * LAKE or RESERVOIR ROUTING * * * * * * * * * * * * * * * * 
            if(ireach(n).gt.0.or.res(n).gt.0)then   ! res(n).ne.0 outlet
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
!             IF WE ARE ROUTING EXTERNALLY WITH DWOPER OR DOING IT IN A 
!             CONTROLLED RESERVOIR DOWNSTREAM IF THERE IS ONE
!             THE FLOWS ARE ACCUMULATED IN A REACH-BIN FOR DWOPER 
!             SEVERAL ELEMENTS CAN CONTRIBUTE BUT NONE IS ROUTED TO 
!             DOWNSTREAM IN ed :

!             ADD UPSTREAM CONTRIBUTIONS AND LOCAL INFLOW
              
              lll=next(n)
              rbin=ireach(n)
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso model
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
	        resvstore1(n)=store2(n)
              if(res(n).eq.0)then
!               grid is part of a reservoir or lake but is not an outlet 
c                if(trcflg.ne.'y')then
                  qdwpr(rbin,jjz)=qdwpr(rbin,jjz)+qi2(n)+qr(n)
     *                     +qstream(n)-strloss(n)-qwdr(n,month_now)   !+qlz(n): TS - Mar12/08: included in qr(n)
                  
              else     ! res(n).ne.0     = outlet

!               THERE IS A DAM IN THIS GRID AND THE 
!               RESERVOIR ROUTING SUBROUTINE REROUT IS CALLED.

!               * * * FOR RESERVOIR ROUTING:* * *
d                if(iopt.ge.3)write(55,6004)n,res(n),index

!               IT'S ASSUMED THAT THE DAM IS LOCATED IN A DWOPER
!               REACH NUMBER

!     rev. 9.1.43  Jun.  01/03  - Fixed the qdwpr.txt function - re: last grid in lake
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipla & irrigation withdrawals
!               corrected this June 1/03
!               previously, the last grid was not added to the qdwpr.txt file
!               this next line copied from above
                if(rbin.gt.0)then     ! rbin=reach(n)
!                 there may be a dam but the grid may not have been 
!                 designated as part of a lake
!                 i.e. rbin - the lake number
!                 qdwoper collects all the inflow to the reach=lake=reservoir      
                  qdwpr(rbin,jjz)=qdwpr(rbin,jjz)+qi2(n)+qr(n)
     *                         +qstream(n)-strloss(n)-qwdr(n,month_now)  !+qlz(n): TS - Mar12/08: included in qr(n)
!                 qi2(n) is used in rerouta as the lake inflow for routing
                  qi2(n)=qdwpr(rbin,jjz)
                endif

!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!               note: for external routing b1 has to be -ve
!               so when b1 = 0, releases will be used.
c                if(routeflg.eq.'q'.and.b1(res(n)).lt.-0.001)then
                if(routeflg.eq.'q'.and.b1(res(n)).eq.0.00)then
!                 routing will be done by external routing             
!                 no routing in rerout
!                 this way any lakes where b1 <> 0 will be routed in rerout
!                 either by a rule or release table
                  qo2(n)=0.0   
                else
	          
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 10.2.13 Jan.  31/18  - NK: Re-wrote rules.f to mimic stop log operations -> rules_sl.f
                  if(ruleflg.and.resruleflg(res(n)))then
                    if(ruletype(1:7).eq.'StopLog')then  
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call rules_sl(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    elseif(ruletype(1:11).eq.'TargetLevel')then
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call rules_tl(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    else
                      print*,'Error'
                      print*,'StopLog or TargetLevel key words'
                      print*,'not found in the rules.ts5 file'
                      print*,'Keyword found =',ruletype 
                      stop 'Program aborted in route @ 321'
                    endif
                  else
!                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    call rerout(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  endif   ! rules
                  
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_outflow
!                  May   02/05  - TS: revised
!                 for flowsd.csv
                  ln=res(n)
!     rev. 10.1.60 Jan.  03/17  - NK: Fixed conditional in route
                  if(jz.ge.1.and.res(n).gt.0)then      ! added conditional Rev. 9.2.43  nk
                    lake_stor(ln,jz)=store2(n)
                    lake_outflow(ln,jz)=qo2(n)
                    net_lake_outflow(ln,jz)=qo2(n)
!     rev. 10.1.96 Sep   11/17  - NK: Added variable lake depth calculation lake_elv()-LKinvert()
                    LKdepth(ln)=lake_elv(ln,jz)-LKinvert(ln)
                    
                    if(ln.gt.1)net_lake_outflow(ln,jz)=
     *                        qo2(n)-lake_outflow(ln-1,jz)
                    del_stor(ln,jz)=(qi2(n)-qo2(n))*div    !fixed feb. 15/08 -nk- 
!                    div added May 9/06 nk
                  endif    ! jz
                endif    ! routeflg
              endif    ! end reservoir routing
                  
! * * * * * * * * * *  TS - WETLAND ROUTING  * * * * * * * * * * * * * * * * 
! * * * * * * * * * *  TS - WETLAND ROUTING  * * * * * * * * * * * * * * * * 

!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
            elseif(wetland_flag(n))then    ! see conditionals above!!!
                  
              call rt_wetland(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)

            elseif(pondflg(n))then

! * * * * * * * * * * * * * * * POND ROUTING * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * POND ROUTING * * * * * * * * * * * * *

                !     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
!             For grids with large water areas but not included in lakes or reservoirs, 
!             use pond routing   
              call rt_pond(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)
                  
            else     

! * * * * * * * * * * * * * * * CHANNEL ROUTING * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * CHANNEL ROUTING * * * * * * * * * * * * *

!     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!             For grids with large water areas but not included in lakes or reservoirs, 
!             use pond routing   
              call rt_channel(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)
                  
            endif                         ! END OF ROUTING

!     rev. 9.1.10  Jan.  29/02  - flow nudging added for nopt(l)=2
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           for nudgeflg = 2
!           keywords:  nudge  nudgeflg  
            flowsta=' '
            do l=1,no
!             check to see if this grid has a flow station
              if(iflowgrid(l).eq.n.and.nopt(l).eq.2)then
!               we are at a flow station that is to be used for nudging
!               also,nudge only if there is observed flow 
!     REV. 10.1.28 Apr.  26/16  - NK: Fixed first day of output for master_inflows file 
c                if(jz.ge.kt.and.qhyd(l,jz).ge.0.0)then
                if(qhyd(l,jz).ge.0.0)then
                  flowsta='y'
                  lsta=l
                endif
              endif
            end do

!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
            if(lll.gt.0)then   ! added Jan/11 nk
              if(flowsta.eq.'y')then  
!               we are in a grid with a flow station
!               used instead of the computed flow     
!               ADD observed FLOW TO DOWNSTREAM ELEMENT
                qi2(lll)=qi2(lll)+qhyd(lsta,jz)
                
!               Note: qo2(n) is NOT changed so the plots will show the computed 
!                     hydrograph. Also, error is based on computed flow.                
              ELSE
!               ADD computed FLOW TO DOWNSTREAM ELEMENT
!               but only if it is not a lake
                qi2(lll)=qi2(lll)+qo2(n)
              endif
            endif

!#ifdef TEST
            if(iopt.ge.3)then
!             this creates huge files
              at1=at/3600.0
              write(55,6037,iostat=ios)
     *             n,yyy(n),xxx(n),ic,at1,qr(n),qi1(n),qi2(n),
     *        qo1(n),qo2(n),qi2(lll),store1(n),store2(n),cap(n),lll
!              if(ios.ne.0)then
!                print*,'n,lll,na/',n,lll,na
!                stop
!              endif
            endif
!#endif
          endif                            ! SLOPE IF
c        endif           ! NON-BASIN EXCLUSION l.eq.0.and.dds_flag.eq.1 

!#ifdef TEST
d      if(iopt.eq.2.and.n.eq.naa)print*,'In route, passed 901'
!#endif

!       take out
!       print*,time,at,dtmin
        att(n)=at/3600.
!     added for water balance calculations

        if(frac(n).gt.0.0.and.aclass(n,ii_water).gt.0.0)then
           uzs(n,ii_water)=uzs(n,ii_water)
     *          +(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
     *          /frac(n)/aclass(n,ii_water) ! took out convert 14/04/08 nk
!     *          /convert/frac(n)/aclass(n,ii_water) 
        endif

        if(firstpass.eq.'y')then
!         write the header in rte.txt
          IF(iopt.ge.1.and.n.eq.nnprint)then
          write(55,*)'Routing state variables for debug grid # ',nnprint
          write(55,*)'Note time interval may change - i.e. not regular'
          write(55,5551)
5551      format('   id   time     at(hrs)        qi1         qi2'
     *         '         qo1         qo2       store1      store2'
     *         '          qr       qstream     strloss ice_fctr')
          endif
	  endif

!             added Dec. 12/00 nk.
        IF(iopt.ge.1.and.n.eq.nnprint)THEN
          write(55,5550)id,time,at/3600.,qi1(n),qi2(n),
     *                   qo1(n),qo2(n),store1(n),store2(n),
     *                   qr(n),qstream(n),strloss(n),ice_fctr(n)
5550      format(i5,f10.3,11e12.3)
        endif
        
!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
c        qUS2(next(n))=qUS2(next(n))+qo2(n)
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        if(iopt99)then
          if(qo2(n).lt.0.000)then
            if(.not.warning(1))then
                      write(98,*)'mode:  c= channel, w=wetland routing'
                      write(98,*)
     *            'mode     grid#          id       time       outflow'      
            endif
            write(98,*)'C',n,id,time,qo2(n)
            write(98,*)
            if(qo2(n).lt.qlow)then
              qlow=qo2(n)  ! global low flow for warning
              lowtime=time
              lowid=id
              lowgrid=n
              warning(1)=.true.
            endif
          endif
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
          if(ireach(n).eq.0)then
!           for rivers only - not lakes or reservoirs                  
            qqlow(n)=amin1(qqlow(n),qo2(n))
          endif
        endif
        
      end do    ! n=1,naa
        
! END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP        
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
      if(iopt99)then
        if(time.ge.mhtot)then
!         File replaced at the end of each event              
          open(unit=99,file='debug\qlow.xyz',status='unknown')
          do n=1,naa
              i=yyy(n)
              j=xxx(n)
              write(99,*)xorigin+float(j-1)*xdelta+xdelta/2.0,
     *               yorigin+float(i-1)*ydelta+ydelta/2.0,qqlow(n)
          end do
          close(unit=99,status='keep')
        endif
      endif
!####################################################################################      
        
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!     nrules is the number of reservoir with water level target rules

c      if(ruleflg)write(987,98700)totaltime,
c     *             (lower_range(jul_day_now,i),
c     *              upper_range(jul_day_now,i),
c     *              lake_elv(resvNo(i),jz),i=1,nrules)
c98700 format(f10.0,<nrules*3>(',',f10.3)) 

!#ifdef TEST
d      if(iopt.eq.2)print*, ' in route after the 1-naa loop'
!#endif

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

!#ifdef TEST
d      if(iopt.ge.2.and.iopt.le.10) write(55,6006)dtmin
d      if(iopt.ge.3.and.iopt.le.10) write(53,1001)jz
!#endif




!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
c        write(56,*)'time= ',totaltime
        if(iz.ne.jz)then
            do i=1,ycount
c              write(56,56000)(bankfull(i,j),j=1,xcount)
56000         format(<xcount>f8.0)              
            end do
        endif
        
        
        
        

d      if(iopt.eq.2)print*,'finished writing istate'

!     INFORMATION FOR WATBAL.FOR
!     change in volume of the channel or lake
!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
!     qUS1 and qUS2 are the channel inflow from upstream grid(s)
      do n=1,naa
        if(ireach(n).gt.0.and.res(n).eq.0)then
!         in a lake or reservoir        
          netoutflow(n)=0.0
        elseif(ireach(n).gt.0.and.res(n).ne.0)then
!         in the outlet grid of a lake or reservoir
          netoutflow(n)=netoutflow(n)
c     *	     +(qo1(n)+qo2(n)-qUS1(n)-qUS2(n))/tdum/2.0
     *	                +(qo2(n)-qUS2(n))/tdum   !checked out
        else
!         qUS1 & qUS2 is just the inflow from upstream        
          netoutflow(n)=netoutflow(n)
c     *	     +(qo1(n)+qo2(n)-qUS1(n)-qUS2(n))/tdum/2.0
     *	                +(qo2(n)-qUS2(n))/tdum   !checked out
        endif
        end do
        
!     rev. 9.8.80  Aug   09/13  - NK: Added withdraw.r2c output file in route.f
!     write the monthly withdrawals
      if(month_now.ne.month_last)then
        xcount_temp=xcount
        ycount_temp=ycount
        do i=1,ycount
          do j=1,xcount
            outarray(i,j)=0.0
          end do
        end do
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          outarray(i,j)=qwdr(n,month_now)
        end do  
        frame_no1=frame_no1+1
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c          call write_r2c(23,23,2,1,int(totaltime),1,11)    
c          call write_r2c(23,23,2,1,frame_no1,0,11)    
          call write_r2c(23,23,ni*12,0,frame_no1,0,11)    
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  month_last=month_now  

      endif

!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!     rev. 9.8.10  Dec.  06/11  - NK: Added message for FP overflow in route
      if(firstpass.eq.'y'.and.flwinitflg.eq.'y')then
	  print*,'WARNING:'
	  print*,'It looks like your initial flows are too low '
	  print*,'or none were given in the first event.'
	  Print*,'Please enter some appropriate value in the first'
	  print*,'line of the str file for each station.'
	  print*,'If you started the run in mid-winter, '
        print*,'that could be your problem - recorded flows tend to'
	  print*,'very small in cold climates.'
        flwinitflg='n'
c	  pause 'hit enter to continue but please fix 1st str.r2c file'
	endif

      old_at=at
      firstpass='n'

      RETURN

!#ifdef TEST
d      if(iopt.eq.2)print*, ' assigned netflow'
!#endif

! FORMATS


 1000 format(50i3)
 1001 format(3i5)
 6000 format(60i2)
 6001 format(' ',3i5,3f10.2)
 6002 format(' route:iz,jz/',2i5)
 6004 format(' gone to rerout - n,res(n),index/',3i5)
 6005 format(' n,res(n),jz,qo2(n)/',3i5,2f10.2)
 6006 format(' dtmin =',f10.2)
 6007 format(' ','reservoir locations wrt 1-naa')
 6037 format(4i5,7f9.3,3f15.0,i5)
 6003 format('    n    i    j   ic     at       qr      qi1',
     *'     qi2      qo1      qo2  qi2[lll]   store1    store2    cap   
     *lll')
 9801 format(a80)
 9802 format(i5,10g12.3)


      END SUBROUTINE route

      SUBROUTINE route(div,thr,dtmin,jz,iz,time,date,tdum)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!
!  THE INFLOW INTO THE CHANNEL IN EACH ELEMENT IS THE SUM OF THE
!  OUTFLOW OF THE ELEMENTS WHICH DRAIN INTO IT FROM ABOVE AND THE
!  SURFACE RUNOFF AND SUBSURFACE FLOW FROM THE ELEMENT IN WHICH THE
!  OUTFLOW IS BEING CALCULATED                                 
!
!     REV. 8.23 - Mar.  25/96 -  fixed bug in route - keep qo2 for res
!     rev. 8.99mm Dec. 13/2001-     added check for <= 0 init res flow
!     rev. 8.99n  Dec. 31/2001-     fixed nat. res initial flow (JW)
!
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90
!     REV. 9.03    Nov.  2000 - TS: ADDED WATFLOOD SWAMP ROUTING 
!     rev  9.1.03  July  24/01  - added polinomial to reservoir routing
!     rev. 9.1.10  Jan.  29/02  - flow nudging added for nopt(l)=2
!     rev. 9.1.14  Mar.  24/02  - fixed wetland min time step and outflow
!     rev. 9.1.16  Apr.  03/02  - Added wetland conditional to select river w/wo wetland
!     rev. 9.1.31  Nov.  13/02  - Fixed the wetland Q to account for wetland area
!     rev. 9.1.33  Dec.  05/02  - Fixed instability in wetland flow    
!     rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
!     rev. 9.1.39  Apr.  06/03  - Fixed wetland routing when channel is dry
!     rev. 9.2.11  Sep.  11/05  - NK: added Manning's n  r1n & r2n
!     rev. 9.2.13  Sep.  28/05  - NK: added freeze and break up to route
!     rev. 9.2.23  Nov.  22/05  - NK: Fixed res(n)=0 bug in route 
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.39  May.  09/06  - NK: t added to route & rerout arg listrules
      
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.3.04  Oct.  24/06  - NK: routing parameters dim to na in rte
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!                                 eg: lzf(ii) -> lzf(n) 
!     rev. 9.5     Sep.  07/07  - NK: changed wetland/channel routing 
!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
!     rev. 9.5.02  Oct.  21/07  - NK: set init qdwpr=0.0 in route
!     rev. 9.5.04  Dec.  27/07  - NK: fixed bug in wetland routing
!     rev. 9.5.06  Feb.  05/08  - NK: added pool and pool_o in rdpar & route
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
!     rev. 9.5.39  Oct.  15/08  - NK: fixed bug in reservoit routing
!     rev. 9.5.46  Dec.  23/08  - NK: trying to fix problem with -ve storage. Changed conditional to .lt.
!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!     rev. 9.5.54  Feb.  11/09  - NK: undid rev. 9.2.28
!     rev. 9.5.58  Apr.  16/09  - NK: added nudgeflg for forcing gauge flows
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
!     rev. 9.8.10  Dec.  06/11  - NK: Added message for FP overflow in route
!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
!     rev. 9.8.52  Mar.  20/13  - NK: deleted a pause for dds runs in route
!                                 qwdr = point withdrawals
!                                 taken from store2() in river routing
!                                 taken from lake inflows in lake routing
!
!     changes made to include c&g model stuff  nk  April. 26/07
!
!***********************************************************************

      use area_watflood
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: istate(400,400),rbin,lsta,nnn1,jz,n,lll,l,iz,jjz,
     *             i,j,ii,ic,jj,ios,itracker,unt,ln,n_dt_min,
     *             month_last,ic_max
      integer :: iallocate
      REAL    :: old,oldwet,convert,kfactor,wth,old_at,aaa,tdum
      REAL(4) :: time,newstore,try1,try2,try3,div,thr,at,dtmin,
     *             wt,atemp,ax,xa,at1,dt_min_n,
     *             hold,whold,strlossvol,qtest
      integer :: frame_no1
!        REAL(4), DIMENSION(:) :: att(10000)
      character*1 :: flowsta,firstpass,flwinitflg
      character*80 :: junk
!        REAL    :: qdlast(6)
      character(14) :: date
      logical  :: printmsg
!     rev. 10.2.35 Oct.  08/18  - NK: Moved logical def. to area_watflood
c      logical, dimension(:), allocatable  :: printwarning
      
!     needs to fixed for dynamic mem
      DATA month_last/0/
      DATA istate /160000*0/
      DATA firstpass/'y'/
      data printmsg/.true./
     
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
!     rev. 9.5.25  Mar.  20/08  - NK: fixed lake initiation - moved code route -> flowinit
      index=2

      if(firstpass.eq.'y')then   !section added Apr. 28/06  nk
!       check that qdwpr memory has been allocated
!       `firstpass` is passed through all routing routines          
        do n=1,naa
          if(ireach(n).gt.0.or.res(n).gt.0)then
            if(.not.allocated(qdwpr))then
              print*
              print*,'Memory not allocated for qdwpr'
              print*,'No of reservoirs in the .rel file is 0'
              print*,'but reaches in the map & shed files have been'
              print*,'defined. This is a problem.'
              print*,'Please either set all reach values = 0'
              print*,'or code in the reservoir locations in the rel'
              print*,'files'
              stop 'Program aborted in route @ 279'
            endif      
          endif
        end do

        allocate(printwarning(na),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *     'Error with allocation of printwarning in route @ 114'
        do n=1,naa
          printwarning(n)=.true.
          netoutflow(n)=0.0
        end do
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        if(iopt99)then
          do n=1,naa
            qqlow(n)=10000.0
          end do
        endif
d        print*,'printwarning set to "T"'
        
        
! moved to spl  Jul. 08/13
c!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
c!       wetland_flag(n) replaced multiple logical checks by just 1 in each
c!       time & grid loop - so will save a lot of time
c        allocate(wetland_flag(naa),stat=iAllocate)
c        if(iAllocate.ne.0) STOP
c     *     'Error with allocation of wetland_flag in route @ 112'
c        do n=1,naa
c          if(aclass(n,classcount-2).gt.0.0
c     *            .and.grid_area(n).gt.10.0   ! added Oct. 15/12 NK
c     *            .and.wetflg.eq.'y'
c     *            .and.theta(ibn(n)).gt.0.00001
c     *            .and.glacier_flag(n).ne.'y')then
c            wetland_flag(n)=.true.
c          else
c            wetland_flag(n)=.false.
c          endif
c	  end do  
c	  
	  flwinitflg='n'
	  old_at=dtmin
	  frame_no1=0
        qlow=0.000000
        
	endif

!     CALCULATIONS START IN THE HIGHEST ELEMENT IN THE WATERSHED 
!     AND PROCEED TO THE LOWEST.

!#ifdef TEST
      if(iopt.ge.3)then
        write(55,6002)iz,jz
        write(53,6002)iz,jz
        write(55,6003)
      endif
!#endif
 
!     ROUTING LOOP:

      jjz=jz
      if(jjz.lt.1) jjz=1
      dt_min_n=1.0e32
      
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

d      if(iopt.eq.2)print*, ' in route before the 1-naa loop'

c!DEC$ NOPARALLEL

      do n=1,naa
!       REV. 8.23 - Mar.  25/96 - FIXED BUG IN ROUTE, KEEP QO2 FOR RES

        store1(n)=store2(n)
        wstore1(n)=wstore2(n)
        hwet1(n)=hwet2(n)
        hcha1(n)=hcha2(n)
        qo1(n)=qo2(n)
        if(res(n).eq.0)qo2(n)=0.0
        qowet1(n)=qowet2(n)
        qi1(n)=qi2(n)
c        qi2(n)=1.0e-10
        qi2(n)=0.0
c        netoutflow(n)=0.0
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        strlossvol=strloss(n)*div*2.0

!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
        qUS1(n)=qUS2(n)
c        qUS1(n)=0.0
        qUS2(n)=0.0
     
        qiwet1(n)=qiwet2(n)
        qiwet2(n)=1.0e-10

!     rev. 9.5.02  Oct.  21/07  - NK: set init qdwpr=0.0 in route
        if(ireach(n).gt.0)then
          rbin=ireach(n)
!          grid is part of a reservoir or lake 
          qdwpr(rbin,jjz)=0.0
        endif
      end do
      
      do n=1,naa
d        if(iopt.eq.2.and.n.eq.1)print*,'In route, passed 101'

        i=yyy(n)
        j=xxx(n)
        l=nhyd(i,j)

c        if(l.eq.0.and.numa.gt.0)then            ! NON-BASIN EXCLUSION
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
c         if(l.eq.0.and.dds_flag.eq.1)then            ! NON-BASIN EXCLUSION
c        if(l.eq.0)then            ! NON-BASIN EXCLUSION


!           DON'T DO ANYTHING - WE'RE NOT IN A GRID THAT COUNTS FOR OPT

c        else                    ! (l.eq.0.and.numa.gt.0)

!         WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASINfat=

!         AND THE ROUTING SEQUENCE IS SKIPPED

          if(slope(n).gt.0.0)then
!           REV. 7.2 Sept. 19/94 - ADDED IREACH() FOR DWOPER INPUT  

! * * * * * * * * * * LAKE or RESERVOIR ROUTING * * * * * * * * * * * * * * * * 
            if(ireach(n).gt.0.or.res(n).gt.0)then   ! res(n).ne.0 outlet
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
! * * * * * * * * * * RESERVOIR ROUTING * * * * * * * * * * * * * * * * *
!             IF WE ARE ROUTING EXTERNALLY WITH DWOPER OR DOING IT IN A 
!             CONTROLLED RESERVOIR DOWNSTREAM IF THERE IS ONE
!             THE FLOWS ARE ACCUMULATED IN A REACH-BIN FOR DWOPER 
!             SEVERAL ELEMENTS CAN CONTRIBUTE BUT NONE IS ROUTED TO 
!             DOWNSTREAM IN ed :

!             ADD UPSTREAM CONTRIBUTIONS AND LOCAL INFLOW
                
              lll=next(n)
              rbin=ireach(n)
c     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso model
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
	        resvstore1(n)=store2(n)
              
              if(res(n).eq.0)then
!               grid is part of a reservoir or lake but is not an outlet 
c                if(trcflg.ne.'y')then
                  qdwpr(rbin,jjz)=qdwpr(rbin,jjz)+qi2(n)+qr(n)
     *                     +qstream(n)-strloss(n)-qwdr(n,month_now)   !+qlz(n): TS - Mar12/08: included in qr(n)

              else     ! res(n).ne.0     = outlet

!               THERE IS A DAM IN THIS GRID AND THE 
!               RESERVOIR ROUTING SUBROUTINE REROUT IS CALLED.

!               * * * FOR RESERVOIR ROUTING:* * *
d                if(iopt.ge.3)write(55,6004)n,res(n),index

!               IT'S ASSUMED THAT THE DAM IS LOCATED IN A DWOPER
!               REACH NUMBER

!     rev. 9.1.43  Jun.  01/03  - Fixed the qdwpr.txt function - re: last grid in lake
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipla & irrigation withdrawals
!               corrected this June 1/03
!               previously, the last grid was not added to the qdwpr.txt file
!               this next line copied from above
                if(rbin.gt.0)then     ! rbin=reach(n)
!                 there may be a dam but the grid may not have been 
!                 designated as part of a lake
!                 i.e. rbin - the lake number
!                 qdwoper collects all the inflow to the reach=lake=reservoir      
                  qdwpr(rbin,jjz)=qdwpr(rbin,jjz)+qi2(n)+qr(n)
     *                         +qstream(n)-strloss(n)-qwdr(n,month_now)  !+qlz(n): TS - Mar12/08: included in qr(n)
!                 qi2(n) is used in rerouta as the lake inflow for routing
                  qi2(n)=qdwpr(rbin,jjz)
                endif

!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!               note: for external routing b1 has to be -ve
!               so when b1 = 0, releases will be used.
c                if(routeflg.eq.'q'.and.b1(res(n)).lt.-0.001)then
                if(routeflg.eq.'q'.and.b1(res(n)).eq.0.00)then
!                 routing will be done by external routing             
!                 no routing in rerout
!                 this way any lakes where b1 <> 0 will be routed in rerout
!                 either by a rule or release table
                  qo2(n)=0.0   
                else
	          
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 10.2.13 Jan.  31/18  - NK: Re-wrote rules.f to mimic stop log operations -> rules_sl.f
                  if(ruleflg.and.resruleflg(res(n)))then
                    if(ruletype(1:7).eq.'StopLog')then  
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call rules_sl(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    elseif(ruletype(1:11).eq.'TargetLevel')then
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call rules_tl(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    else
                      print*,'Error'
                      print*,'StopLog or TargetLevel key words'
                      print*,'not found in the rules.ts5 file'
                      print*,'Keyword found =',ruletype 
                      stop 'Program aborted in route @ 321'
                    endif
                  else
      
!                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    call rerout(n,div,thr,res(n),
     *                        jz,at,dtmin,date,time,firstpass)
!                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
                  endif   ! rules
                  
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_outflow
!                  May   02/05  - TS: revised
!                 for flowsd.csv
                  ln=res(n)
!     rev. 10.1.60 Jan.  03/17  - NK: Fixed conditional in route
                  if(jz.ge.1.and.res(n).gt.0)then      ! added conditional Rev. 9.2.43  nk
                    lake_stor(ln,jz)=store2(n)
                    lake_outflow(ln,jz)=qo2(n)
                    net_lake_outflow(ln,jz)=qo2(n)
!     rev. 10.1.96 Sep   11/17  - NK: Added variable lake depth calculation lake_elv()-LKinvert()
                    LKdepth(ln)=lake_elv(ln,jz)-LKinvert(ln)
                    del_stor(ln,jz)=(qi2(n)-qo2(n))*div    !fixed feb. 15/08 -nk- 
                    
c                    if(ln.gt.1)net_lake_outflow(ln,jz)=
c     *                        qo2(n)-lake_outflow(ln-1,jz)
                    
!                    div added May 9/06 nk
                  endif    ! jz
                endif    ! routeflg

                  
                  
              endif    ! end reservoir routing
                  
! * * * * * * * * * *  TS - WETLAND ROUTING  * * * * * * * * * * * * * * * * 
! * * * * * * * * * *  TS - WETLAND ROUTING  * * * * * * * * * * * * * * * * 

!     rev. 9.8.29  Oct.  15/12  - NK: added wetland_flag to speed up route.f
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
            elseif(wetland_flag(n))then    ! see conditionals above!!!
                
              call rt_wetland(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)

            elseif(pondflg(n))then

! * * * * * * * * * * * * * * * POND ROUTING * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * POND ROUTING * * * * * * * * * * * * *
                
c              if(.not.netCDFflg)then
c                  IF(iopt.ge.1.and.n.eq.nnprint)THEN
c                      write(554,5550)id,time,at/3600.,qi1(n),qi2(n),
c     *                   qo1(n),qo2(n),store1(n),store2(n),
c     *                   qr(n),qstream(n),strloss(n),ice_fctr(n)
c                  endif
c              endif
                !     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
!             For grids with large water areas but not included in lakes or reservoirs, 
!             use pond routing   
              call rt_pond(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)
c              if(.not.netCDFflg)then
c                  IF(iopt.ge.1.and.n.eq.nnprint)THEN
c                      write(554,5550)id,time,at/3600.,qi1(n),qi2(n),
c     *                   qo1(n),qo2(n),store1(n),store2(n),
c     *                   qr(n),qstream(n),strloss(n),ice_fctr(n)
c                  endif
c              endif
            else     

! * * * * * * * * * * * * * * * CHANNEL ROUTING * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * CHANNEL ROUTING * * * * * * * * * * * * *

                
c        IF(iopt.ge.1.and.n.eq.nnprint)THEN
c          write(555,5550)id,time,at/3600.,qi1(n),qi2(n),
c     *                   qo1(n),qo2(n),store1(n),store2(n),
c     *                   qr(n),qstream(n),strloss(n),ice_fctr(n)
c        endif
                
                
                
                
                
!     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!             For grids with large water areas but not included in lakes or reservoirs, 
!             use pond routing   
              call rt_channel(div,thr,dtmin,jz,iz,time,date,tdum,n) 
              lll=next(n)
                  
            endif                         ! END OF ROUTING

!     rev. 9.1.10  Jan.  29/02  - flow nudging added for nopt(l)=2
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING NUDGING 
!           for nudgeflg = 2
!           keywords:  nudge  nudgeflg  
            flowsta=' '
            do l=1,no
!             check to see if this grid has a flow station
              if(iflowgrid(l).eq.n.and.nopt(l).eq.2)then
!               we are at a flow station that is to be used for nudging
!               also,nudge only if there is observed flow 
!     REV. 10.1.28 Apr.  26/16  - NK: Fixed first day of output for master_inflows file 
c                if(jz.ge.kt.and.qhyd(l,jz).ge.0.0)then
                if(qhyd(l,jz).ge.0.0)then
                  flowsta='y'
                  lsta=l
                endif
              endif
            end do

!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
            if(lll.gt.0)then   ! added Jan/11 nk
              if(flowsta.eq.'y')then  
!               we are in a grid with a flow station
!               used instead of the computed flow     
!               ADD observed FLOW TO DOWNSTREAM ELEMENT
                qi2(lll)=qi2(lll)+qhyd(lsta,jz)
!       if(lsta.eq.21)print*,'xxyyzz',jz,lll,qhyd(lsta,jz),qi2(lll)
!               Note: qo2(n) is NOT changed so the plots will show the computed 
!                     hydrograph. Also, error is based on computed flow.                
              ELSE
!               ADD computed FLOW TO DOWNSTREAM ELEMENT
!               but only if it is not a lake
               if(nbsflg.eq.'n')then
!                  Normal routing = add outflow to downstream grid                    
                   qi2(lll)=qi2(lll)+qo2(n)
               else
!                 nbsflg = y or 0 so don't route downstream if at lake outlet 
!                 nbsflg = 0 no routing AND no data written to NBS output file
                  if(res(n).eq.0)then  ! no reservoir outlet in this grid
!                   nbsflg = y means that the NBS file will be written
!                   nbsflg = 0 means the outflows are set to 0.0 but 
!                   flows will not be written      
                    qi2(lll)=qi2(lll)+qo2(n)
                  endif
                endif
              endif
            endif

!#ifdef TEST
            if(iopt.ge.3)then
!             this creates huge files
              at1=at/3600.0
              write(55,6037,iostat=ios)
     *             n,yyy(n),xxx(n),ic,at1,qr(n),qi1(n),qi2(n),
     *        qo1(n),qo2(n),qi2(lll),store1(n),store2(n),cap(n),lll
!              if(ios.ne.0)then
!                print*,'n,lll,na/',n,lll,na
!                stop
!              endif
            endif
!#endif
          endif                            ! SLOPE IF
c        endif           ! NON-BASIN EXCLUSION l.eq.0.and.dds_flag.eq.1 

!#ifdef TEST
d      if(iopt.eq.2.and.n.eq.naa)print*,'In route, passed 901'
!#endif

!       take out
!       print*,time,at,dtmin
        att(n)=at/3600.
!     added for water balance calculations

        if(frac(n).gt.0.0.and.aclass(n,ii_water).gt.0.0)then
           uzs(n,ii_water)=uzs(n,ii_water)
     *          +(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
     *          /frac(n)/aclass(n,ii_water) ! took out convert 14/04/08 nk
!     *          /convert/frac(n)/aclass(n,ii_water) 
        endif

        if(firstpass.eq.'y')then
!         write the header in rte.txt
          IF(iopt.ge.1.and.n.eq.nnprint)then
          write(55,*)'Routing state variables for debug grid # ',nnprint
          write(55,*)'Note time interval may change - i.e. not regular'
          write(55,5551)
5551      format('   id   time     at(hrs)        qi1         qi2'
     *         '         qo1         qo2       store1      store2'
     *         '          qr       qstream     strloss ice_fctr')
          endif
	  endif

!             added Dec. 12/00 nk.
        IF(iopt.ge.1.and.n.eq.nnprint)THEN
          write(55,5550)id,time,at/3600.,qi1(n),qi2(n),
     *                   qo1(n),qo2(n),store1(n),store2(n),
     *                   qr(n),qstream(n),strloss(n),ice_fctr(n)
5550      format(i5,f10.3,11e12.3)
        endif
        
!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
c        qUS2(next(n))=qUS2(next(n))+qo2(n)
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
        if(iopt99)then
          if(qo2(n).lt.0.000)then
            if(.not.warning(1))then
                 write(63,*)'Reporting flows lower than ',qlow,' = qlow'
                  write(63,*)'mode:  c= channel, w=wetland routing'
                   write(63,*)
     *            'mode     grid#          id       time       outflow'      
            endif
            write(63,*)'C',n,id,time,qo2(n)
            if(qo2(n).lt.qlow)then
              qlow=qo2(n)  ! global low flow for warning
              lowtime=time
              lowid=id
              lowgrid=n
              warning(1)=.true.
            endif
          endif
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
          if(ireach(n).eq.0)then
!           for rivers only - not lakes or reservoirs                  
            qqlow(n)=amin1(qqlow(n),qo2(n))
          endif
        endif
        
      end do    ! n=1,naa
        
! END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP   END NAA LOOP        
        
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
      if(iopt99)then
        if(time.ge.mhtot)then
!         File replaced at the end of each event              
          open(unit=99,file='debug\qlow.xyz',status='unknown')
          do n=1,naa
              i=yyy(n)
              j=xxx(n)
              write(99,*)xorigin+float(j-1)*xdelta+xdelta/2.0,
     *               yorigin+float(i-1)*ydelta+ydelta/2.0,qqlow(n)
          end do
          close(unit=99,status='keep')
          write(98,*)'Info: debug\qlow.xyz written & closed'
        endif
      endif
!####################################################################################      
        
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!     nrules is the number of reservoir with water level target rules

c      if(ruleflg)write(987,98700)totaltime,
c     *             (lower_range(jul_day_now,i),
c     *              upper_range(jul_day_now,i),
c     *              lake_elv(resvNo(i),jz),i=1,nrules)
c98700 format(f10.0,<nrules*3>(',',f10.3)) 

!#ifdef TEST
d      if(iopt.eq.2)print*, ' in route after the 1-naa loop'
!#endif

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

!#ifdef TEST
d      if(iopt.ge.2.and.iopt.le.10) write(55,6006)dtmin
d      if(iopt.ge.3.and.iopt.le.10) write(53,1001)jz
!#endif




!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
c        write(56,*)'time= ',totaltime
c        if(iz.ne.jz)then
c            do i=1,ycount
cc              write(56,56000)(bankfull(i,j),j=1,xcount)
c56000         format(<xcount>f8.0)              
c            end do
c        endif
        
        
        
        

d      if(iopt.eq.2)print*,'finished writing istate'

!     INFORMATION FOR WATBAL.FOR
!     change in volume of the channel or lake
!     REV. 10.1.24 Jan.  30/16  - NK: Added qUS1 & qUS2 for watbal
!     qUS1 and qUS2 are the channel inflow from upstream grid(s)
      do n=1,naa
        if(ireach(n).gt.0.and.res(n).eq.0)then
!         in a lake or reservoir        
          netoutflow(n)=0.0
        elseif(ireach(n).gt.0.and.res(n).ne.0)then
!         in the outlet grid of a lake or reservoir
          netoutflow(n)=netoutflow(n)
c     *	     +(qo1(n)+qo2(n)-qUS1(n)-qUS2(n))/tdum/2.0
     *	                +(qo2(n)-qUS2(n))/tdum   !checked out
        else
!         qUS1 & qUS2 is just the inflow from upstream        
          netoutflow(n)=netoutflow(n)
c     *	     +(qo1(n)+qo2(n)-qUS1(n)-qUS2(n))/tdum/2.0
     *	                +(qo2(n)-qUS2(n))/tdum   !checked out
        endif
        end do
        
!     rev. 9.8.80  Aug   09/13  - NK: Added withdraw.r2c output file in route.f
!     write the monthly withdrawals
      if(month_now.ne.month_last.and.iopt99)then
        xcount_temp=xcount
        ycount_temp=ycount
        do i=1,ycount
          do j=1,xcount
            outarray(i,j)=0.0
          end do
        end do
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          outarray(i,j)=qwdr(n,month_now)
        end do  
        frame_no1=frame_no1+1
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(23,23,ni*12,0,frame_no1,0,11)    
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  month_last=month_now  

      endif

!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!     rev. 9.8.10  Dec.  06/11  - NK: Added message for FP overflow in route
      if(firstpass.eq.'y'.and.flwinitflg.eq.'y')then
	  print*,'WARNING:'
	  print*,'It looks like your initial flows are too low '
	  print*,'or none were given in the first event.'
	  Print*,'Please enter some appropriate value in the first'
	  print*,'line of the str file for each station.'
	  print*,'If you started the run in mid-winter, '
        print*,'that could be your problem - recorded flows tend to'
	  print*,'very small in cold climates.'
        flwinitflg='n'
c	  pause 'hit enter to continue but please fix 1st str.r2c file'
	endif

      old_at=at
      firstpass='n'

      RETURN

!#ifdef TEST
d      if(iopt.eq.2)print*, ' assigned netflow'
!#endif

! FORMATS


 1000 format(50i3)
 1001 format(3i5)
 6000 format(60i2)
 6001 format(' ',3i5,3f10.2)
 6002 format(' route:iz,jz/',2i5)
 6004 format(' gone to rerout - n,res(n),index/',3i5)
 6005 format(' n,res(n),jz,qo2(n)/',3i5,2f10.2)
 6006 format(' dtmin =',f10.2)
 6007 format(' ','reservoir locations wrt 1-naa')
 6037 format(4i5,7f9.3,3f15.0,i5)
 6003 format('    n    i    j   ic     at       qr      qi1',
     *'     qi2      qo1      qo2  qi2[lll]   store1    store2    cap   
     *lll')
 9801 format(a80)
 9802 format(i5,10g12.3)


      END SUBROUTINE route

      subroutine rt_channel(div,thr,dtmin,jz,iz,time,date,tdum,n)
      
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
      
!             CHANNEL ROUTING:
!             ADD UPSTREAM CONTRIBUTIONS AND LOCAL INFLOW:
!              if(aclass(n,classcount-2).gt.0.0)

      use area_watflood
      implicit none

      SAVE          ! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT

      INTEGER :: istate(400,400),rbin,lsta,nnn1,jz,n,lll,l,iz,jjz,&
                  i,j,ii,ic,jj,ios,itracker,unt,ln,n_dt_min,&
                  month_last,ic_max
      integer :: iallocate
      REAL    :: oldwet,convert,kfactor,wth,old_at,aaa,tdum
      REAL(4) :: time,newstore,try1,try2,try3,div,thr,at,dtmin,&
                  wt,atemp,ax,xa,at1,dt_min_n,&
                  hold,whold,strlossvol,qtest
      integer :: frame_no1
!        REAL(4), DIMENSION(:) :: att(10000)
      character*1 :: flowsta,firstpass,flwinitflg
      character*80 :: junk
!        REAL    :: qdlast(6)
      character(14) :: date
      logical  :: printmsg
      
!     needs to fixed for dynamic mem
      DATA month_last/0/
      DATA istate /160000*0/
      DATA firstpass/'y'/
      data printmsg/.true./
      
      
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
                if(strlossvol*2.0.gt.store1(n)+(qi1(n)+qi2(n))*div)then
                    write(98,98000)'Warning:',time,'strloss ',strloss(n),' set = 0.0 for grid ',n
98000               format(a10,i10,a10,f10.3,a20,i10)                    
                    strloss(n)=0.0
                    warning(2)=.true.
                endif
!####################################################################################      

!     rev. 9.9.59  Feb.  18/15  - NK: In route: strloss option fracflg y/n
!     rev. 10.1.62 Jan.  08/17  - NK: Checkup on strloss effect on low flows
      qi2(n)=qi2(n)+qr(n)+qstream(n)-strloss(n)
        
      lll=next(n)
      qold(n)=qo1(n)
      hold=1.0e+25
      do ic=1,20
!       UP TO 20 ITERATIONS ARE ALLOWED
        if(abs(hold-store2(n)).gt.0.0003*hold)then
!         THIS ITERATES TO 3% OR ALLOWS UP TO 15 ITERATIONS
          if(store2(n).le.0.0)then
!           NO OUTFLOW - CHANNEL IS EMPTY
            ax=0.0
            qo2(n)=0.001
          else     ! (store2(n).le.0.0)
            over(n)=(store2(n)-cap(n))/rl(n)
            if(over(n).le.0.0)then
!             CHANNEL FLOW ONLY
              ax=store2(n)/rl(n)

!     rev. 9.2.11  Sep.  15/05  - NK: added Manning's n  r1n & r2n
!     rev. 9.5.06  Feb.  05/08  - NK: added pool and pool_o in rdpar & route
!             pool-riffle storage added
!             pool = % of bankfull area attributed to dead storage
            if(ax/chaxa(n).gt.pool(n))then
                qo2(n)=(ax-pool(n)*chaxa(n))**1.67*slope(n)/chawid(n)**0.667/r2n(n)*ice_fctr(n)
              else
                qo2(n)=0.0
            endif
            hcha2(n)=ax/chawid(n)
              
            else     ! (over(n).le.0.0)

!             CHANNEL + FLOOD PLAIN FLOW
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
              ax=cap(n)/rl(n)   ! added Jun 21/06 nk

!     rev. 9.2.11  Sep.  15/05  - NK: added Manning's n  r1n & r2n
!     rev. 9.8.60  May   14/13  - NK: fixed ice factor for whole x-section
!             0.17 factor is based on 100:1 fp w/d ratio
!             flood plain width/depth assumes as 100
!             use quadratic equation to solve for fp. depth
              hwet2(n)=(-1.0+sqrt(1.+400.0*over(n)))/200.0
!             hcha2(n) is the bankfull depth here
              hcha2(n)=chaxa(n)/chawid(n)
!             xa is the total main channel cross section area
              xa=(hwet2(n)+hcha2(n))*chawid(n)
              if(over(n)-hwet2(n)*chawid(n).gt.0.0)then
                qo2(n)=&
                   (xa**1.67*slope(n)/chawid(n)**0.667/r2n(n)&
                   +(over(n)-hwet2(n)*chawid(n))**1.33&
                            *slope(n)*0.17/r1n(n))*ice_fctr(n)
              else
                qo2(n)=xa**1.67*slope(n)/chawid(n)**0.667/r2n(n)*ice_fctr(n)
              endif     ! (over(n)-hwet2(n)*chawid(n).gt.0.0)
            endif      ! (over(n).le.0.0)
!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
!c            wt=amax1(.5,float(ic)/21.)
            wt=amax1(0.5,0.5+float(ic)/41.)
            wt=amin1(1.0,wt)
            qo2(n)=(1.0-wt)*qo2(n)+wt*qold(n)
            qold(n)=qo2(n)
            endif        ! (store2(n).le.0.0)
            hold=store2(n)
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n)-2.0*qwdr(n,month_now))*div
!                     qwdr multiplied by 2 to offset /2 in div     

!     rev. 9.9.52  Jan.  14/15  - NK: Fixed bug for channel store < 0 for withdrawals
          if(store2(n).le.0.0)then
!           cut off withdrawals                  
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
            if(store2(n).le.0.0)then
!             if store2 still = 0 then reduce calculated outflow
!             but this should not happen as it never did before 
!             withdrawals were added to the code
              store2(n)=0.0
              qo2(n)=store1(n)/div+qi1(n)+qi2(n)-qo1(n)         
            endif
          endif
         else
!          convergence to 3%
           GO TO 16
         endif
      end do    ! ic=1,20
       
  16  continue
       
!     rev. 9.5.46  Dec.  23/08  - NK: trying to fix problem with -ve storage. Changed conditional to .lt.
!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
      if(store2(n).lt.0.0.or.qo2(n).lt.0.0)then
          store_error_flag(n)='true'
          qo2(n)=store1(n)/div+qi1(n)+qi2(n)-qo1(n)
          store2(n)=0.0
          dtmin=a6
!     rev. 9.5.47  Dec.  26/08  - NK: add flwinitflg to warn about initial flows
!         if we are early in the first event,possibly
!         the initial flows are too low.
!         This can happen if run is started in mid-winter
!         and the lowest downstream flow station is not at
!          outlet.
!         Might be fixed by increasing initial flow in the str file
  
          flwinitflg='y'
      endif     ! (store2(n).lt.0.0)
      
      if(qo2(n).gt.0.000001)then
!         CALCULATE THE VELOCITY THROUGH EACH SQUARE
!         CALCULATE TRAVEL TIME FOR MAXIMUM VELOCITY.
          at=store2(n)/qo2(n)
!         SELECT MIN TRAVEL TIME FOR THE TIME STEP CALC
          dtmin=amin1(at,dtmin)
          dtmin=amax1(dtmin,a6)   ! dtmin > a6 no matter what
!     rev. 9.9.49  Jan.  06/14  - NK: Added courantflg
          if(at.lt.a6)then
              courantflg=.false.
          endif
     
!         DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN
!         THE FASTEST EMPTYING ELEMENT

!         CALCULATE THE CHANNEL STATE FOR GRAPHICAL OUTPUT:
          i=yyy(n)
          j=xxx(n)
          atemp=qo2(n)/(0.4*bnkfll(n))+1.0

!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
          bankfull(i,j)=qo2(n)/bnkfll(n)*100.0
          bankfull(i,j)=amax1(0.1,bankfull(i,j))
          bankfull(i,j)=amin1(10000.,bankfull(i,j))

!         TO PREVENT INTEGER UNDERFLOW OR OVEFLOW:  
          atemp=amax1(atemp,1.0)
          atemp=amin1(atemp,99.0)

          istate(i,j)=int(atemp)
!         istate(i,j)=min(istate(i,j),99)
!         istate(i,j)=max(istate(i,j),1)
      endif
              
      if(iopt.ge.4)write(55,1002)i,j,n,istate(i,j),bnkfll(n),qo2(n)
 1002 format(' i,j,n,istate,bnkfull,qo2/',4i5,2f10.3)

      return
      
      end subroutine rt_channel
                    subroutine rt_pond(div,thr,dtmin,jz,iz,time,date,tdum,n)      

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!     Written Nov. 2/17 NK   

      use area_watflood
      implicit none

      SAVE          ! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT

      integer       :: l,ic,n,jz,iz,i,j
      real          :: hold,wt,div,thr,dtmin,time,tdum,at,amin1
      real          :: strlossvol,old
      character*14  :: date

!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
               if(strlossvol*100.0.gt.store1(n)+(qi1(n)+qi2(n))*div)then
                    write(98,*)'Warning:',time,'strloss ',strloss(n),' set = 0.0 for grid ',n
                    strloss(n)=0.0
                    warning(2)=.true.
                endif
!####################################################################################      

!     rev. 9.9.59  Feb.  18/15  - NK: In route: strloss option fracflg y/n
!     rev. 10.1.62 Jan.  08/17  - NK: Checkup on strloss effect on low flows
!       TS preferred way:             
        qi2(n)=qi2(n)+qr(n)+qstream(n)-strloss(n)
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
      
        old=qo1(n)
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
        hold=0.1e+26
        ic=0
!c         using a power function        
          if(store2(n).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                ic=ic+1
                if(store2(n).gt.0.0)then
!                 have to do at least 3 iterations
                  qo2(n)=rlake(n)*store2(n)**1.75
!c                  qo2(n)=qo2(n)*lake_ice_factor(l,month_now)
                  wt=amax1(0.1,float(ic)/21.0)
                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
!c                  qo2(n)=(1.0-wt)*qo2(n)+wt*qold(n)
                  old=qo2(n)
!c                  qold(n)=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
          i=yyy(n)
          j=xxx(n)
          bankfull(i,j)=-1.0
          if(qo2(n).gt.0.000001)then
!             CALCULATE THE VELOCITY THROUGH EACH SQUARE
!             CALCULATE TRAVEL TIME FOR MAXIMUM VELOCITY.
              at=store2(n)/qo2(n)
!             SELECT MIN TRAVEL TIME FOR THE TIME STEP CALC
              dtmin=amin1(at,dtmin)
              dtmin=amax1(dtmin,a6)   ! dtmin > a6 no matter what
              if(at.lt.a6)then
                courantflg=.false.
              endif
!             DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN
!             THE FASTEST EMPTYING ELEMENT

          endif
          
      return
        
      end subroutine rt_pond      subroutine rt_pond(div,thr,dtmin,jz,iz,time,date,tdum,n)      

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.2.07 Nov.  03/17  - NK: New rt_pond subroutine for channel pond routing      
!     Written Nov. 2/17 NK   

      use area_watflood
      implicit none

      SAVE          ! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT

      integer       :: l,ic,n,jz,iz,i,j
      real          :: hold,wt,div,thr,dtmin,time,tdum,at,amin1
      real          :: strlossvol
      character*14  :: date

!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
               if(strlossvol*100.0.gt.store1(n)+(qi1(n)+qi2(n))*div)then
                    write(98,*)time,
     *               'strloss ',strloss(n),' set = 0.0 for grid ',n
                    strloss(n)=0.0
                    warning(2)=.true.
                endif
!####################################################################################      

!     rev. 9.9.59  Feb.  18/15  - NK: In route: strloss option fracflg y/n
!     rev. 10.1.62 Jan.  08/17  - NK: Checkup on strloss effect on low flows
!       TS preferred way:             
        qi2(n)=qi2(n)+qr(n)+qstream(n)-strloss(n)
        store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
      
c        old=qo1(n)
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
        qold(n)=qo2(n)
        hold=0.1e+26
        ic=0
c!         using a power function        
          if(store2(n).gt.0.0)then
            do while(abs(hold-store2(n)).gt.0.003*hold.and.ic.lt.20)
                ic=ic+1
                if(store2(n).gt.0.0)then
!                 have to do at least 3 iterations
c                  qo2(n)=1.0e-12*store2(n)**1.75
                  qo2(n)=rlake(n)*store2(n)**1.75
c                  qo2(n)=qo2(n)*lake_ice_factor(l,month_now)
                  wt=amax1(0.1,float(ic)/21.0)
c                  qo2(n)=(1.0-wt)*qo2(n)+wt*old
!     rev. 10.2.44 Jan.  21/19  - NK: Added qOld() to allow previous weighted outflow on the resume file
                  qo2(n)=(1.0-wt)*qo2(n)+wt*qold(n)
c                  old=qo2(n)
                  qold(n)=qo2(n)
                  hold=store2(n)
                  store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
c                else
c!     rev. 10.2.32 Aug.  23/18  - NK: Changed non-convergence value for qo2 
c                  qo2(n)=qi2(n)*2.0
cc                  qo2(n)=0.0
c                  store2(n)=store1(n)+
c     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
c                  print*,'pond non/converge',totaltime,' cell ',n
                endif
            end do
          else     !(b3(l).gt.0.0)
            qo2(n)=0.0
            store2(n)=store1(n)+
     *                  (qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
!           store2(n) is allowed to go -ve     
          endif

!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
          i=yyy(n)
          j=xxx(n)
          bankfull(i,j)=-1.0
          if(qo2(n).gt.0.000001)then
!             CALCULATE THE VELOCITY THROUGH EACH SQUARE
!             CALCULATE TRAVEL TIME FOR MAXIMUM VELOCITY.
              at=store2(n)/qo2(n)
!             SELECT MIN TRAVEL TIME FOR THE TIME STEP CALC
              dtmin=amin1(at,dtmin)
c             dtmin=amax1(at,a6)   ! dtmin > a6 no matter what
              dtmin=amax1(dtmin,a6)   ! dtmin > a6 no matter what
              if(at.lt.a6)then
                courantflg=.false.
              endif
!             DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN
!             THE FASTEST EMPTYING ELEMENT

          endif
          
      return
        
      end subroutine rt_pond      subroutine rt_wetland(div,thr,dtmin,jz,iz,time,date,tdum,n)
     
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Tricia Stadnyk
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.2.08 Nov.  04/17  - NK: New rt_channel & rt-_wetland subroutines      
!     rev. 10.2.71 Nov.  18/19  - NK Bug fixes in wetland & reservoir routing NaNtest

      use area_watflood
      implicit none

      SAVE          ! SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT

      INTEGER :: istate(400,400),rbin,lsta,nnn1,jz,n,lll,l,iz,jjz,&
                  i,j,ii,ic,jj,ios,itracker,unt,ln,n_dt_min,&
                  month_last,ic_max
      integer :: iallocate
      REAL    :: oldwet,convert,kfactor,wth,old_at,aaa,tdum
      REAL(4) :: time,newstore,try1,try2,try3,div,thr,at,dtmin,&
                  wt,atemp,ax,xa,at1,dt_min_n,&
                  hold,whold,strlossvol,qtest
      integer :: frame_no1
!        REAL(4), DIMENSION(:) :: att(10000)
      character*1 :: flowsta,firstpass,flwinitflg
      character*80 :: junk
!        REAL    :: qdlast(6)
      character(14) :: date
      logical  :: printmsg,NaNtest
      
!     needs to fixed for dynamic mem
      DATA month_last/0/
      DATA istate /160000*0/
      DATA firstpass/'y'/
      data printmsg/.true./

      itracker=-1

!     rev. 9.1.16  Apr.  03/02  - Added wetland conditional to select river w/wo wetland
!     rev. 9.1.31  Nov.  13/02  - Fixed the wetland Q to account for wetland area
!     rev. 9.1.33  Dec.  05/02  - Fixed instability in wetland flow    
!     rev. 9.5     Sep.  07/07  - NK: changed wetland/channel routing 

!             WETLAND+CHANNEL ROUTING:
!             dacheck is just there to be able to do wetlands in headwater watersheds
!             and not do it in the larger rivers. This should be replaced by a
!             rivertype with -ve wetland parameters.
!             CHANNEL ROUTING PORTION OF CODE:
!             ADD UPSTREAM CONTRIBUTIONS AND LOCAL INFLOW:
      
!     rev. 10.1.98 Oct   04/17  - NK: Deal with -ve flows in route
              if(strlossvol.gt.store1(n)+(qi1(n)+qi2(n))*div)then
                    strloss(n)=0.0
              endif

              qi2(n)=qi2(n)+qstream(n)-strloss(n)
              qin(n)=qi2(n)
      
              qiwet2(n)=qr(n)+qswrain(n)-qswevp(n)+qlz(n)    !-qstream(n)+strloss(n)
     
              qiwetsum(n)=qiwetsum(n)+(qiwet1(n)+qiwet2(n))*div
              lll=next(n)
!c              old=qo1(n)
              oldwet=qowet1(n) 
              hold=1.0e+25
              whold=1.0e+25
              ic_max=1
              
!     rev. 9.9.53  Jan.  18/15  - NK: Prevent mode switch during iteration in wetland routing
!             The type of flow is no longer allowed to change
!             while iterating to prenent instabilities
!             The type of flow is based on conditions for the last time step.
              if(store1(n).le.0.0)then
!               NO OUTFLOW - CHANNEL IS EMPTY
!               outflow from the wetland is added to the channel.
                itracker=0
              endif
              hcha1(n)=store1(n)/chaarea(n)
!             determine what condition exists and keep it                   
              if(hcha1(n).le.chadep(n))then
!               CHANNEL FLOW ONLY
                if(wstore1(n).gt.wcap(n))then
!                 WETLAND IS FULL - OVERFLOWS INTO CHANNEL:
!                 WETLAND -> CHANNEL FLOW ONLY
                  itracker=1
                else
!                 WETLAND & CHANNEL DEPTH BELOW BANKFULL
!                 2 WAY  <---> FLOW
                  itracker=2
                endif    ! (wstore2(n).gt.wcap(n))
              else         ! hcha2(n) > chadep(n)     over > 0.0
!               CHANNEL DEPTH ABOVE BANKFUL
                if(wstore1(n).gt.wcap(n))then
!                 WETLAND & CHANNEL ABOVE BANKFULL
!                 2 WAY  <---> FLOW
                  itracker=3
                else       !  wstore < wcap
!                 CHANNEL ABOVE BANKFULL & WETLAND BELOW
!                 CHANNET --> WETLAND FLOW ONLY
                  itracker=4
                endif    
              endif     
              do ic=1,20   ! convergence loop
                if(hwet2(n).le.0.0)hwet2(n)=qlz(n)*div*2/wetarea(n)/theta(n)
              
!     rev. 9.9.48  Jan.  06/14  - NK: Added wetland cond. function for o/b flow
!               UP TO 20 ITERATIONS ARE ALLOWED
!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
!               changed because both the channel routing & the wetland routing
!               to converge.
!c                if(abs(whold-wstore2(n)).gt.0.00001*whold.or.
!c     *                    abs(hold-store2(n)).gt.0.0003*hold)then
                if(abs(whold-wstore2(n)).gt.0.00001*whold.or.abs(hold-store2(n)).gt.0.00001*hold)then
!                 THIS ITERATES TO 3% OR ALLOWS UP TO 20 ITERATIONS
!c                  if(store2(n).le.0.0)then
!     rev. 9.9.53  Jan.  18/15  - NK: Prevent mode switch during iteration in wetland routing
                  if(itracker.eq.0)then
!                   NO OUTFLOW - CHANNEL IS EMPTY
!c                    itracker=0
                    flowxa(n)=0.000
                    hcha2(n)=0.000
                    qo2(n)=0.000
!     rev. 9.1.38  Apr.  06/03  - Fixed wetland routing when channel is dry
!                   Added this section to calculate wetland outflow
!                   even if the channel is empty.
!                   Also, made the convergence check to 1 mm in wetheight.
!     rev. 9.5.04  Dec.  27/07  - NK: fixed bug in wetland routing
                    hwet2(n)=wstore2(n)/wetarea(n)/theta(n)
                    qowet2(n)=kcond(n)*(hwet2(n)**2)*astep
!                   using astep makes it independent of grid size
!                   assumes eq. calculates flow/km
!c                  else    ! (store2(n).le.0.0)
                    hcha2(n)=store2(n)/chaarea(n)
!c                    if(hcha2(n).le.chadep(n))then
                  elseif(itracker.eq.1)then
!                     CHANNEL FLOW ONLY
!c                      itracker=1
!c                      if(wstore2(n).gt.wcap(n))then
!                       WETLAND IS FULL - OVERFLOWS INTO CHANNEL:
                        hwet2(n)=chadep(n)+(wstore2(n)-wcap(n))/wetarea(n)
!     rev. 9.9.61  Mar.  06/15  - NK: In route: restored hcha2(n)=store2(n)/chaarea(n)
                        hcha2(n)=store2(n)/chaarea(n)
                        if(abs(hwet2(n)-hcha2(n)).gt.0.0001)then
                        qowet2(n)=kcond(n)/2*(hwet2(n)**2-hcha2(n)**2)*astep
                        else
                          qowet2(n)=0.0000
                        endif
                 elseif(itracker.eq.2)then
!c                        itracker=2
!                       WETLAND IS NOT FULL - NOTHING OVERFLOWS:
!     rev. 9.9.61  Mar.  06/15  - NK: In route: restored hcha2(n)=store2(n)/chaarea(n)
                        hcha2(n)=store2(n)/chaarea(n)
                        hwet2(n)=wstore2(n)/wetarea(n)/theta(n)
!c                        if(abs(hwet2(n)-hcha2(n)).gt.0.0001.and.
!c     *                                         hwet2(n).gt.0.3)then
                        if(abs(hwet2(n)-hcha2(n)).gt.0.0001)then
                          qowet2(n)=kcond(n)/2*(hwet2(n)**2-hcha2(n)**2)*astep
                        else
                          qowet2(n)=0.0000
                        endif
!c                      endif    ! (wstore2(n).gt.wcap(n))
!c                    else         ! hcha2(n) > chadep(n)     over > 0.0
!                     CHANNEL + FLOOD PLAIN FLOW
!c                      if(wstore2(n).gt.wcap(n))then
                  elseif(itracker.eq.3)then
!c                        itracker=3
!                       WETLAND IS FULL - OVERLAND FLOW
                        hwet2(n)=chadep(n)+(wstore2(n)-wcap(n))/wetarea(n)
!     rev. 9.9.61  Mar.  06/15  - NK: In route: restored hcha2(n)=store2(n)/chaarea(n)
                        hcha2(n)=store2(n)/chaarea(n)
!                       this means that if water deprth on the wetland
!                       is 1 m the conductivity is 26 times kcond
                        if(abs(hwet2(n)-hcha2(n)).gt.0.0001)then
                          qowet2(n)=kcond(n)/2*(hwet2(n)**2-hcha2(n)**2)*astep
                        else
                          qowet2(n)=0.0000
                        endif
                  else       !  wstore < wcap
!c                        itracker=4
!                       CHANNEL OVERFLOWS INTO WETLANd:
                        hwet2(n)=wstore2(n)/wetarea(n)/theta(n)
!     rev. 9.9.61  Mar.  06/15  - NK: In route: restored hcha2(n)=store2(n)/chaarea(n)
                         hcha2(n)=store2(n)/chaarea(n)
                        if(abs(hwet2(n)-hcha2(n)).gt.0.0001)then
                          qowet2(n)=kcond(n)/2*(hwet2(n)**2-hcha2(n)**2)*astep
                        else
                          qowet2(n)=0.0000
                        endif
!c                    endif     ! (hcha2(n).le.chadep(n))
                  endif     ! (store2(n).le.0.0)
              
!     rev. 10.2.71 Nov.  18/19  - NK Bug fixes in wetland & reservoir routing
                  NaNtest=ISNAN(qowet2(n))
                  if(NaNtest)qowet2(n)=0.0
                  if(NaNtest)write(98,*)'Warning: wetland NaN in grid ',n,'at t= ',totaltime

                  flowxa(n)=store2(n)/rl(n)
                  qo2(n)=flowxa(n)**1.67*slope(n)/chawid(n)**0.667/r2n(n)*ice_fctr(n)
                  NaNtest=ISNAN(qo2(n))
                  if(NaNtest)qo2(n)=0.0
                  if(NaNtest)write(98,*)'Warning: flow NaN in grid ',n,'at t= ',totaltime

!     rev. 9.8.12  Dec.  07/11  - NK: removed 30 char limit on find filetype 
                  wt=amax1(.1,float(ic)/21.)
                  wt=amin1(1.00,wt)
                    
!c                  endif     ! (store2(n).le.0.0)
                  qi2(n)=qin(n)+qowet2(n)     ! moved from above
!c                  old=qo2(n)
!c                  qold(n)=qo2(n)                  !  not used really
                  oldwet=qowet2(n)
                  hold=store2(n)
                  whold=wstore2(n)
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals

                  store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n)-2.0*qwdr(n,month_now))*div
                  
!     rev. 9.9.52  Jan.  14/15  - NK: Fixed bug for channel store < 0 for withdrawals
                  if(store2(n).le.0.0)then
!                   cut off withdrawals                  
                    store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
                    if(store2(n).le.0.0)then
!                     if store2 still = 0 then reduce calculated outflow
!                     but this should not happen as it never did before 
!                     withdrawals were added to the code
                        
                      store2(n)=0.0
                      qo2(n)=store1(n)/div+qi1(n)+qi2(n)-qo1(n)         
                      if(qo2(n).lt.0.000.and.iopt99)write(63,*)'W',n,id,time,qo2(n)
                    endif
                  endif
!                            qwdr multiplied by 2 to offset /2 in div     
                  wstore2(n)=wstore1(n)+(qiwet1(n)+qiwet2(n)-qowet1(n)-qowet2(n))*div
                  store2(n)=(1.0-wt)*store2(n)+wt*hold
                  wstore2(n)=(1.0-wt)*wstore2(n)+wt*whold
                  if(wstore2(n).lt.0.0)wstore2(n)=0.0
                  satxa(n)=wstore2(n)/rl(n)/theta(n)
                else
!                 CONVERGENCE TO 3%
                  GO TO 26
                endif   ! (abs(whold-wstore2(n)).gt.0.00001*whold.or.
!     *                    abs(hold-store2(n)).gt.0.0003*hold)
              end do    ! ic=1,20
              ic_max=ic
              
26            continue
              if(dds_flag.eq.0)then            ! changed Nov. 27/14  nk
                if(store2(n).le.0.0)then
                  write(98,*)'Warning: In route @ line 486 msg # 1'
                  write(98,*)'Warning: River class',ibn(n), 'Time =',jz,'row',yyy(n),'col',xxx(n)
                  write(98,*)'Warning: store2(',n,' )-ve / needs work in route @ 603'
                  write(98,*)'Warning:', store1(n),qi1(n),qi2(n),qo1(n)
                  if(qwdr(n,month_now).gt.0.0)qwdr(n,month_now)=0.0
                  write(98,*)'Warning: withdrawals set = zero'
                  qo2(n)=store1(n)/div+qi1(n)+qi2(n)-qo1(n)
                  store2(n)=0.0
                  dtmin=a6
                endif      ! (store2(n).le.0.0)
              endif        ! (dds_flag.eq.0)            
              
      if(qo2(n).lt.0.000)write(98,*)'Warning: W',n,id,time,qo2(n)

! >  >  >     MAYBE NEXT LINE HAS TO BE CHECKED OUT
!             WHY IS IT 0 ANYWAYS ??????
!c              if(qo2(n).le.0.0)qo2(n)=0.0000

              qowetsum(n)=qowetsum(n)+(qowet1(n)+qowet2(n))*div

              if(qowet2(n).gt.1.0e+10)then
!     rev. 9.9.01  Dec.  12/13  - NK: Added `pintwarning' in route added
                if(printwarning(n))then
                  write(98,*)'WARNING: '
                  write(98,*)'WARNING: In route @ line 506 msg # 2'
                  write(98,*)'WARNING: Likely fp overflow: reduce kcond for'
                  write(98,*)'WARNING:  class',ibn(n),'kcond=',kcond(n)
                  write(98,*)'WARNING:  grid #',n,' row/col:',yyy(n),xxx(n)
                  if(ic_max.ge.20)then
                    write(98,*)'WARNING: OR most likely:'
                    write(98,*)'WARNING:  min time step A6 too large - try A6/2'
                  endif
                  write(98,*)'WARNING: Message for this grid is printed only once'
                if(writeflg(51))write(51,*)n,ibn(n),kcond(n),itrace,hwet2(n),hcha2(n),qowet2(n),qlz(n)
!c                writeflg='y'
                printwarning(n)=.false.
              endif     ! (printwarning(n))
              if(printmsg)then
                write(98,*)'WARNING: There are ways to correct this problem'
                write(98,*)'WARNING: Possible problem(s): '
                write(98,*)'WARNING: No initial flows for downstream stations'
                write(98,*)'WARNING:  init flow =',qda(n)
                write(98,*)'WARNING: If that is not it,'
                write(98,*)'WARNING:  Check initial lake levels and'
                write(98,*)'WARNING:  reservoir releases. If all ok,'
                write(98,*)'WARNING: You can increase the width/depth ratio and/or '
                write(98,*)'WARNING:  get rid of the wetland in this grid and/or'
                write(98,*)'WARNING:  you can reduce the conductivity and/or' 
                write(98,*)'WARNING:  increase the width/depth ratio in this '
                write(98,*)'WARNING:  and other grids by making a special river '
                write(98,*)'WARNING:  class for problem grids'
                write(98,*)'WARNING: After fixing one grid, others may show up'
                write(98,*)'WARNING:  you may find these grids by animating the '
                write(98,*)'WARNING:  grid outflow in GreenKenue in the log scale'
                write(98,*)'WARNING:  and noting the grids where the flow'
                write(98,*)'WARNING:  disappears'
                write(98,*)'WARNING: OR'
                write(98,*)'WARNING:  maybe min time step A6 too small - try A6/2'
                write(98,*)'WARNING: This message appears only once'
!     rev. 9.8.52  Mar.  20/13  - NK: deleted a pause for dds runs in route
!                 to skip the pause for dds & sensitivity runs	            
!     rev. 9.8.55  Mar.  20/13  - NK: fixed pause for dds runs in route see 9.8.52
!                 had it backwards  nk
!c	            if(abs(dds_flag).eq.0)pause 'Hit enter to continue the run'
                printmsg=.false.
              endif     ! (printmsg)

              endif       ! (qowet2(n).gt.1.0e+10)

              if(n.eq.naa.and.writeflg(51))write(51,*)'         n,          ibn,       kcond,        itrace,      hwet2,       hcha2,    qowet2       qlz(n)'

!             CALCULATE THE VELOCITY THROUGH EACH SQUARE
!             CALCULATE TRAVEL TIME FOR MAXIMUM VELOCITY.

!     rev. 9.1.14  Mar.  24/02  - fixed wetland min time step and outflow
          if(qo2(n).gt.0.000001.and.qowet2(n).gt.0.000001)then
              at=amin1(store2(n)/qo2(n),abs(wstore2(n)/qowet2(n)))

!             SELECT MIN TRAVEL TIME FOR THE TIME STEP CALC
!              >>>dtmin=amin1(at,dtmin,a6)
!             took out the a6 Mar. 26/01 nk
!             don't know why it was put in. Was not in spl8
!              dtmin=amin1(at,dtmin)
!             >>put it back in Oct. 24/01 because it crashed on tabaco creek
!             o2 and store2 do some weird things.

!c              dtmin=amin1(at,dtmin,a6)

!     rev. 9.9.49  Jan.  06/14  - NK: Added courantflg
              if(at.lt.a6)then
                courantflg=.false.
              endif

              dtmin=amin1(at,dtmin)
              dtmin=amax1(dtmin,a6)   ! dtmin > a6 no matter what
          endif
              
              

!             DTMIN IS THE TIME REQUIRED TO COMPLETELY DRAIN
!             THE FASTEST EMPTYING ELEMENT
!             CALCULATE THE CHANNEL STATE FOR GRAPHICAL OUTPUT:
              i=yyy(n)
              j=xxx(n)
              atemp=qo2(n)/(0.4*bnkfll(n))+1.0

!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
              bankfull(i,j)=qo2(n)/bnkfll(n)*100.0
              bankfull(i,j)=amax1(0.1,bankfull(i,j))
              bankfull(i,j)=amin1(10000.,bankfull(i,j))

!             TO PREVENT INTEGER UNDERFLOW OR OVEFLOW:  
              atemp=amax1(atemp,1.0)
              atemp=amin1(atemp,99.0)
              istate(i,j)=int(atemp)
!#ifdef TEST
              if(iopt.ge.4) write(55,1002)i,j,n,istate(i,j),bnkfll(n),qo2(n)
 1002 format(' i,j,n,istate,bnkfull,qo2/',4i5,2f10.3)
              if(iopt.ge.1)then
!               if(n.eq.nnprint.and.iz.ne.jz)
                if(n.eq.nnprint)then
!c                  if(iz.ne.jz)
                    call write_wetland(itracker,ic,n,totaltime,68)
                endif
                endif
!#endif

      return
      
      end subroutine rt_wetland
!     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
              
              
      subroutine write_wetland(itracker,ic,n,time,unt)

      use area_watflood
      implicit none

        INTEGER :: ii,ic,ios,itracker,unt,n,iz,jz
        REAL(4) :: time
        logical :: firstpass
        
        data firstpass/.true./
        
        if(firstpass)then
          if(writeflg(unt))write(unt,55998)'itracker,ic,totaltime,&
         store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n),&
         wstore1(n),wstore2(n),&
         hcha1(n),hcha2(n),hwet1(n),hwet2(n),&
         flowxa(n),chaxa(n),wetxa(n),satxa(n),&
         qiwet1(n),qiwet2(n),qowet1(n),qowet2(n),&
         qstream(n),qswrain(n),strloss(n),&
         qlz(n),qswevp(n),&
         kcond(n),theta(n),chaxa(n)/chawid(n),over(n)*rl(n)'
55998     format(a340)     
          
        endif

!       write(68 ..... for tracking purposes
        if(writeflg(unt))write(unt,55999)itracker,ic,totaltime,&
         store1(n),store2(n),qi1(n),qi2(n),qo1(n),qo2(n),&
         wstore1(n),wstore2(n),&
         hcha1(n),hcha2(n),hwet1(n),hwet2(n),&
         flowxa(n),chaxa(n),wetxa(n),satxa(n),&
         qiwet1(n),qiwet2(n),qowet1(n),qowet2(n),&
         qstream(n),qswrain(n),strloss(n),&
         qlz(n),qswevp(n),&
         kcond(n),theta(n),chaxa(n)/chawid(n),over(n)*rl(n)

55999 format(2(i5,','),f10.3,',',16(f12.3,','),9(f12.5,','),2(f5.2,','),5x,2(f12.3','))
  
      firstpass=.false.
  
      end subroutine write_wetland
      SUBROUTINE rules_sl(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!***********************************************************************
!   THIS S/R  reads target levels at fixed dates and interpolates the 
!   target levels for each day of the year.
!
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!                                     Fixed for leapyears Jan. 16 NK
!     rev. 10.2.13 Jan.  31/18  - NK: Re-wrote rules.f to mimic stop log operations -> rules_sl.f
!***********************************************************************

      use area_watflood
	implicit none
	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz,iz,ll,nnext,ju_next
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live
      real*4   :: midrange,midrange1,weight
      real*4   :: drawdown,drawdown_rate,fill_rate
      real*4   :: xrule(999),yrule(999),dif
      real*4   :: Qhourly(50,168),Qoutflow(50,169)
      real*4   :: datum_local,store_temp

	integer  :: lcount,day_last,lastres,nlast,rank
	character(10)  :: yyyymmdd(366),hhmmss(365)
	
	real*4   :: elvlast,qraw
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      logical foundEndHeader
      
      real*4, dimension(:),   allocatable :: old,raise,lower,inflow
      logical, dimension(:),  allocatable :: full

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.false./

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

   
!~~~~~~~~~~~~~~~~~~~~~~~~~~START FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        allocate(lower_range(366,noresv),upper_range(366,noresv),
     *           old(noresv),
     *           full(noresv),max_range(noresv),
     *           ruleNo(noresv),resvNo(noresv),stat=iAllocate)
        
        INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)      

        if(exists)then  
          open(unit=99,file='resrl\rules.ts5',
     *                            status='old')
c        read(99,*)
c        do j=1,365
c          read(99,*)(lower_range(j,i),upper_range(j,i),i=1,noresv)
c        end do
          ll=0
          foundEndHeader=.false.
c          print*,'NEW<<<<<'
c          print*,'Coordinates for operating rules:'
          do while(.not.foundEndHeader)
            read(99,99000)line
c            print*,line(1:72)
99000       format(a256)       
            if(line(1:10).eq.':endHeader')foundEndHeader=.true.   
            if(line(1:10).eq.':EndHeader')foundEndHeader=.true.   
            if(line(1:6).eq.':Point')then
              ll=ll+1
              read(line,*)junk,xrule(ll),yrule(ll)
c              print*,junk,ll,xrule(ll),yrule(ll)
            endif
          end do
        endif  
        nrules=ll/2   ! # of reservoirs/lakes with rules
c        print*,'# reservoirs with rules =',nrules
c        print*,'       rule#        row         col   rank        resv#'
          
!       check the locations in the resrl\rules.ts5 file
!       coincide with the reservoir locations in the rel file
!       and mark the lake/resv as having a rule: 
        do ll=1,noresv
!         These were initially set to .true. in read_resv_ef.f   
!         to be sure rules.f is called at least once to look for the rules 
!         if they exist.     
          resRuleFlg(ll)=.false.
          ruleNo(ll)=-1
          resvNo(ll)=-1
        end do     
        
c      print*,
c     *'         ll       rank      res(rank)    resvNo(res(rank))'
        do ll=1,nrules
!         convert to local coordinate unit system for new .res file
          j=int((xrule(ll*2)-xorigin)/xdelta)+1
          i=int((yrule(ll*2)-yorigin)/ydelta)+1
          rank=s(i,j)
!         find the resv # for this rule curve
          if(rank.gt.0)then
!           this reservoir has a rule          
            resRuleFlg(res(rank))=.true.
            ruleNo(res(rank))=ll  !res(rank)
            resvNo(ll)=res(rank)
          else  
            warningflg=.true.
            print*,'Rule coordinates do not match a reservoir location'
            print*,'for rule No.',ll 
          endif
        end do
      print*  
      
        if(warningflg)then
          print*
          print*,'Please check that coordinates in the ts5 file'
          print*,'match those in the rel files'
          stop 'Program aborted in rule @ 165'
        endif         
        
        do j=1,365
          read(99,*)yyyymmdd(j),hhmmss(j),
     *                    (lower_range(j,i),upper_range(j,i),i=1,nrules)
c          print*,yyyymmdd(j),
c     *                    (lower_range(j,i),upper_range(j,i),i=1,noresv)
        end do
          
!       fill in missing values
!       lower range
       
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(lower_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=lower_range(nnext,ll)-lower_range(nlast,ll)
            do j=nlast,nnext
              lower_range(j,ll)=lower_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(99,*)j,nlast,nnext,dif,lower_range(j,l)
            end do
            nlast=nnext
          end do
        end do
!       end lower range        

!       upper range
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(upper_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=upper_range(nnext,ll)-upper_range(nlast,ll)
            do j=nlast,nnext
              upper_range(j,ll)=upper_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(769,*)j,nlast+1,n-1,dif,upper_range(j,ll)
            end do
            nlast=nnext
          end do
        end do
!       end upper range        
        close(unit=99,status='keep')
        
!       write the rules to a file - daily delta t        
        open(unit=99,file='results\rules_echo.txt',
     *                            status='unknown')
        do i=1,ni
          do j=1,365
            write(99,99001)j,
     *            (lower_range(j,ll),upper_range(j,ll),ll=1,nrules)
99001       format(i5,<nrules*2>f10.3)     
          end do
          if(mod(i,4).eq.0)then
!               write and extra line for leap years  (approx)              
                write(99,99001)365,
     *            (lower_range(365,ll),upper_range(365,ll),ll=1,nrules)
          endif  
        end do
        close(unit=99,status='keep')

        do ll=1,nrules
          max_range(l)=-999.0
        end do
        do ll=1,nrules
          do j=1,365
            max_range(ll)=amax1(max_range(ll),upper_range(j,ll))
          end do
        end do
        close(unit=99,status='keep')
        
        outflow=0.0

        firstpass_local(99)=.false.
!       open the output file:        
        open(unit=987,file='results\res_levels.csv',status='unknown')
        
        
d        if(iopt99)then        
d          write(840+l,84001)'jul_day_now','l','res(n)','ruleNo(l)',
d    *          'temp_elv(l)','upper_range','lower_range',
d    *          'midrange','datum_local','store2(n)','qo2(n)',
d    *          'lake_elv(l,jz)','datum_local'  
84001     format(4a10,8a15)          
d        endif
        
      endif   !  end of local first pass to set up the rule table
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     note that this is the global first pass
      if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage
        if(ruleNo(l).gt.0)then 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)    ! initial lake level
c          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
c          store1(n)=store2(n)
          lower_range(366,ruleNo(l))=lower_range(365,ruleNo(l))
          upper_range(366,ruleNo(l))=upper_range(365,ruleNo(l))
!         Get an initial set of flows - use mid-range start elv.          
          midrange=(upper_range(jul_day_now,ruleNo(l))
     *              +lower_range(jul_day_now,ruleNo(l)))/2.0
          store_temp=(temp_elv(l)-midrange)*lake_area(l)
          if(store_temp.gt.0.0)then
            qo2(n)=b1(l)*(store_temp)**b2(l)
          else
            qo2(n)=0.0
          endif
          qo1(n)=qo2(n)
          old(l)=qo2(n)
          weight=.1      ! initial weight on last flow
c          print*,l,ruleNo(l),lake_elv(l,jz)
        endif
      endif
      inflow(l)=qi2(n)
      if(jul_day_now.eq.1)full(l)=.false.

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(ruleNo(l).gt.0)then
!       use only the upper range values to decide if drawdown rate is fast enough
!       drawdown is calculated using the downward slope of the upper range  
        ju_next=jul_day_now+1
c        if(ju_next.gt.366)ju_next=1

!       OK to use 365 as target for 366 - target for 365        
        if(mod(jul_day_now,4).eq.0)then
          if(ju_next.gt.366)ju_next=1
        else
          if(ju_next.gt.365)ju_next=1
        endif
      
!       midrange is used as the target
        midrange=(upper_range(jul_day_now,ruleNo(l))
     *              +lower_range(jul_day_now,ruleNo(l)))/2.0

c        if(temp_elv(l).gt.upper_range(jul_day_now,ruleNo(l)))then
c          datum_local=lower_range(jul_day_now,ruleNo(l))
c        elseif(temp_elv(l).gt.midrange)then
c          datum_local=midrange
c        else
c          datum_local=lower_range(jul_day_now,ruleNo(l))
c        endif

        if(temp_elv(l).gt.upper_range(jul_day_now,ruleNo(l)))then
          datum_local=midrange
        else
          datum_local=lower_range(jul_day_now,ruleNo(l))
        endif
        
        store_temp=(temp_elv(l)-datum_local)*lake_area(l)
          
        old(l)=qo2(n)
        if(store_temp.gt.0.0)then
          qo2(n)=b1(l)*(store_temp)**b2(l)
        else
          qo2(n)=0.0
        endif

        qo2(n)=weight*qo2(n)+(1.0-weight)*old(l)
        
        if(qo2(n).lt.0.)qo2(n)=0.0
        
!       Lower the peak quickly        
c        if(temp_elv(l).ge.safe_max(l))qo2(n)=1.25*qi2(n)
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
c        lake_elv(l,jz)=datum_local+store2(n)/lake_area(l)
        temp_elv(l)=lake_elv(l,jz)
      
        if(temp_elv(l).ge.max_range(l))full(l)=.true.

        if(iopt99.and.res(n).eq.l)then        
          write(840+l,84000)jul_day_now,l,res(n),ruleNo(l),temp_elv(l),
     *          upper_range(jul_day_now,ruleNo(l)),
     *          lower_range(jul_day_now,ruleNo(l)),
     *          midrange,datum_local,store2(n),qo2(n),
     *          lake_elv(l,jz),datum_local     
84000     format(4i10,9f15.3)     
        endif
        
c        if(l.eq.2)then
c            write(611,61100)id,time,
c     *                 store1(n),store2(n),qi1(n),qi2(n)
c     *                ,qo1(n),qo2(n),div,lake_elv(l,jz)
c     *                      
c61100       format(i5,99f15.3)            
c        endif
      endif  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)

c         if(store2(n).le.0.0.and.iopt.ge.1)then
c           Print*,'store2(',n,' ) -ve / needs work in rules @ 345'
c           print*,time,store1(n),store2(n)
c           print*,qi1(n),qi2(n),qo1(n),qo2(n),div
c           print*,inflow(l),raise(l),drawdown_rate,drawdown
cd           pause 'in rules @ 365'
c         endif

	last_month=month_now

  999 RETURN


      END SUBROUTINE rules_sl

      SUBROUTINE rules_sl(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!     copyright (c) by n. kouwen 1987-2018

!***********************************************************************
!   THIS S/R  reads target levels at fixed dates and interpolates the 
!   target levels for each day of the year.
!
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!                                     Fixed for leapyears Jan. 16 NK
!     rev. 10.2.13 Jan.  31/18  - NK: Re-wrote rules.f to mimic stop log operations -> rules_sl.f
!***********************************************************************

      use area_watflood
	implicit none
	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz,iz,ll,nnext,ju_next
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live
      real*4   :: midrange,midrange1,weight
      real*4   :: drawdown,drawdown_rate,fill_rate
      real*4   :: xrule(999),yrule(999),dif
      real*4   :: Qhourly(50,168),Qoutflow(50,169)
      real*4   :: datum_local,store_temp

	integer  :: lcount,day_last,lastres,nlast,rank
	character(10)  :: yyyymmdd(366),hhmmss(365)
	
	real*4   :: elvlast,qraw
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      logical foundEndHeader
      
      real*4, dimension(:),   allocatable :: old,raise,lower,inflow
      logical, dimension(:),  allocatable :: full

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.false./

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

   
!~~~~~~~~~~~~~~~~~~~~~~~~~~START FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        allocate(lower_range(366,noresv),upper_range(366,noresv),
     *           old(noresv),
     *           full(noresv),max_range(noresv),
     *           ruleNo(noresv),resvNo(noresv),stat=iAllocate)
        
        INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)      

        if(exists)then  
          open(unit=99,file='resrl\rules.ts5',
     *                            status='old')
c        read(99,*)
c        do j=1,365
c          read(99,*)(lower_range(j,i),upper_range(j,i),i=1,noresv)
c        end do
          ll=0
          foundEndHeader=.false.
c          print*,'NEW<<<<<'
c          print*,'Coordinates for operating rules:'
          do while(.not.foundEndHeader)
            read(99,99000)line
c            print*,line(1:72)
99000       format(a256)       
            if(line(1:10).eq.':endHeader')foundEndHeader=.true.   
            if(line(1:10).eq.':EndHeader')foundEndHeader=.true.   
            if(line(1:6).eq.':Point')then
              ll=ll+1
              read(line,*)junk,xrule(ll),yrule(ll)
              print*,junk,ll,xrule(ll),yrule(ll)
            endif
          end do
        endif  
        nrules=ll/2   ! # of reservoirs/lakes with rules
c        print*,'# reservoirs with rules =',nrules
c        print*,'       rule#        row         col   rank        resv#'
          
!       check the locations in the resrl\rules.ts5 file
!       coincide with the reservoir locations in the rel file
!       and mark the lake/resv as having a rule: 
        do ll=1,noresv
!         These were initially set to .true. in read_resv_ef.f   
!         to be sure rules.f is called at least once to look for the rules 
!         if they exist.     
          resRuleFlg(ll)=.false.
          ruleNo(ll)=-1
          resvNo(ll)=-1
        end do     
        
c      print*,
c     *'         ll       rank      res(rank)    resvNo(res(rank))'
        do ll=1,nrules
!         convert to local coordinate unit system for new .res file
          j=int((xrule(ll*2)-xorigin)/xdelta)+1
          i=int((yrule(ll*2)-yorigin)/ydelta)+1
          rank=s(i,j)
!         find the resv # for this rule curve
          if(rank.gt.0)then
!           this reservoir has a rule          
            resRuleFlg(res(rank))=.true.
            ruleNo(res(rank))=ll  !res(rank)
            resvNo(ll)=res(rank)
          else  
            warningflg=.true.
            print*,'Rule coordinates do not match a reservoir location'
            print*,'for rule No.',ll 
          endif
        end do
      print*  
      
        if(warningflg)then
          print*
          print*,'Please check that coordinates in the ts5 file'
          print*,'match those in the rel files'
          stop 'Program aborted in rule @ 165'
        endif         
        
        do j=1,365
          read(99,*)yyyymmdd(j),hhmmss(j),
     *                    (lower_range(j,i),upper_range(j,i),i=1,nrules)
          print*,yyyymmdd(j),hhmmss(j),
     *                    (lower_range(j,i),upper_range(j,i),i=1,nrules)
        end do
        pause 44444
          
!       fill in missing values
!       lower range
       
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(lower_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=lower_range(nnext,ll)-lower_range(nlast,ll)
            do j=nlast,nnext
              lower_range(j,ll)=lower_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(99,*)j,nlast,nnext,dif,lower_range(j,l)
            end do
            nlast=nnext
          end do
        end do
!       end lower range        

!       upper range
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(upper_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=upper_range(nnext,ll)-upper_range(nlast,ll)
            do j=nlast,nnext
              upper_range(j,ll)=upper_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(769,*)j,nlast+1,n-1,dif,upper_range(j,ll)
            end do
            nlast=nnext
          end do
        end do
!       end upper range        
        close(unit=99,status='keep')
        
!       write the rules to a file - daily delta t        
        open(unit=99,file='resrl\rules_echo.txt',
     *                            status='unknown')
        do i=1,ni
          do j=1,365
            write(99,99001)j,
     *            (lower_range(j,ll),upper_range(j,ll),ll=1,nrules)
99001       format(i5,<nrules*2>f10.3)     
          end do
          if(mod(i,4).eq.0)then
!               write and extra line for leap years  (approx)              
                write(99,99001)365,
     *            (lower_range(365,ll),upper_range(365,ll),ll=1,nrules)
          endif  
        end do
        close(unit=99,status='keep')

        do ll=1,nrules
          max_range(l)=-999.0
        end do
        do ll=1,nrules
          do j=1,365
            max_range(ll)=amax1(max_range(ll),upper_range(j,ll))
          end do
        end do
        close(unit=99,status='keep')
        
        outflow=0.0

        firstpass_local(99)=.false.
!       open the output file:        
        open(unit=987,file='results\res_levels.csv',status='unknown')
        
        
        if(iopt99)then        
          write(840+l,84001)'jul_day_now','l','res(n)','ruleNo(l)',
     *          'temp_elv(l)','upper_range','lower_range',
     *          'midrange','datum_local','store2(n)','qo2(n)',
     *          'lake_elv(l,jz)','datum_local'  
84001     format(4a10,8a15)          
        endif
        
      endif   !  end of local first pass to set up the rule table
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     note that this is the global first pass
      if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage
        if(ruleNo(l).gt.0)then 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)    ! initial lake level
c          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
c          store1(n)=store2(n)
          lower_range(366,ruleNo(l))=lower_range(365,ruleNo(l))
          upper_range(366,ruleNo(l))=upper_range(365,ruleNo(l))
!         Get an initial set of flows - use mid-range start elv.          
          midrange=(upper_range(jul_day_now,ruleNo(l))
     *              +lower_range(jul_day_now,ruleNo(l)))/2.0
          store_temp=(temp_elv(l)-midrange)*lake_area(l)
!         Note:  store_temp is just a dummy storage to calculate 
!          the outflow given the head above a datum that changes every day 
!         The actual storage is store2 which includes dead storage
!         store2 is continuous, never goes to -ve and should be good for
!         tracer & isotope modelling
          if(store_temp.gt.0.0)then
            qo2(n)=b1(l)*(store_temp)**b2(l)
          else
            qo2(n)=0.0
          endif
          qo1(n)=qo2(n)
          old(l)=qi2(n)
          weight=0.01      ! initial weight on last flow
c          print*,l,ruleNo(l),lake_elv(l,jz)
        endif
      endif
      inflow(l)=qi2(n)
      if(jul_day_now.eq.1)full(l)=.false.

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(ruleNo(l).gt.0)then
!       use only the upper range values to decide if drawdown rate is fast enough
!       drawdown is calculated using the downward slope of the upper range  
        ju_next=jul_day_now+1
c        if(ju_next.gt.366)ju_next=1

!       OK to use 365 as target for 366 - target for 365        
        if(mod(jul_day_now,4).eq.0)then
          if(ju_next.gt.366)ju_next=1
        else
          if(ju_next.gt.365)ju_next=1
        endif
      
!       midrange is used as the target
        midrange=(upper_range(jul_day_now,ruleNo(l))
     *              +lower_range(jul_day_now,ruleNo(l)))/2.0

c        if(mod(hour_now,18).eq.0)then
        if(temp_elv(l).gt.upper_range(jul_day_now,ruleNo(l)))then
          datum_local=lower_range(jul_day_now,ruleNo(l))
        elseif(temp_elv(l).gt.midrange)then
          datum_local=midrange
        else
          datum_local=lower_range(jul_day_now,ruleNo(l))
        endif
c        endif
        
        store_temp=(temp_elv(l)-datum_local)*lake_area(l)
          
        old(l)=qo2(n)
        if(store_temp.gt.0.0)then
          qo2(n)=b1(l)*(store_temp)**b2(l)
        else
          qo2(n)=0.0
        endif

        qo2(n)=weight*qo2(n)+(1.0-weight)*old(l)
        
        if(qo2(n).lt.0.)qo2(n)=0.0
        
!       Lower the peak quickly        
c        if(temp_elv(l).ge.safe_max(l))qo2(n)=1.25*qi2(n)
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
c        lake_elv(l,jz)=datum_local+store2(n)/lake_area(l)
        temp_elv(l)=lake_elv(l,jz)
      
        if(temp_elv(l).ge.max_range(l))full(l)=.true.

        if(iopt99.and.res(n).eq.l)then        
          write(840+l,84000)jul_day_now,l,res(n),ruleNo(l),temp_elv(l),
     *          upper_range(jul_day_now,ruleNo(l)),
     *          lower_range(jul_day_now,ruleNo(l)),
     *          midrange,datum_local,store2(n),qo2(n),
     *          lake_elv(l,jz),datum_local     
84000     format(4i10,9f15.3)     
        endif
        
c        if(l.eq.2)then
c            write(611,61100)id,time,
c     *                 store1(n),store2(n),qi1(n),qi2(n)
c     *                ,qo1(n),qo2(n),div,lake_elv(l,jz)
c     *                      
c61100       format(i5,99f15.3)            
c        endif
      endif  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)

c         if(store2(n).le.0.0.and.iopt.ge.1)then
c           Print*,'store2(',n,' ) -ve / needs work in rules @ 345'
c           print*,time,store1(n),store2(n)
c           print*,qi1(n),qi2(n),qo1(n),qo2(n),div
c           print*,inflow(l),raise(l),drawdown_rate,drawdown
cd           pause 'in rules @ 365'
c         endif

	last_month=month_now

  999 RETURN


      END SUBROUTINE rules_sl

      SUBROUTINE rules_tl(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!     copyright (c) by n. kouwen 1987-2015

!***********************************************************************
!   THIS S/R  reads target levels at fixed dates and interpolates the 
!   target levels for each day of the year.
!
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!                                     Fixed for leapyears Jan. 16 NK
!     rev. 10.2.14 Jan.  31/18  - NK: Renamed rules.f to rules_tl.f - for use with target levels
!***********************************************************************

      use area_watflood
	implicit none
	
c !DEC$ ATTRIBUTES DLLIMPORT :: rules_MH

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz,iz,ll,nnext,ju_next
	integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      real*4   :: hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live
      real*4   :: midrange,midrange1,weight
      real*4   :: drawdown,drawdown_rate,fill_rate
      real*4   :: xrule(999),yrule(999),dif
      real*4   :: Qhourly(50,168),Qoutflow(50,169)
      real*4   :: datum_local,store_temp

	integer  :: lcount,day_last,lastres,nlast,rank
	character(10)  :: yyyymmdd(366),hhmmss(365)
	
	real*4   :: elvlast,qraw
c!     rev. 9.9.16  Jun.  06/14  - NK: Added location file for Root R. diversion
c	integer  :: divX(3),divY(3),divGridNo(3)
c	real*4   :: divlon(3),divlat(3),qtweak
c	character*20 :: cjunk(20)

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      logical foundEndHeader
      
      real*4, dimension(:),   allocatable :: old,raise,lower,inflow
      logical, dimension(:),  allocatable :: full

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.false./

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

c this is already in rerout
c      if(firstpass_local(98))then
c        last_month=month_now
c        wrtdiverflg=.false.  !used for writing a new diversion file 
c!       if divertflg = 'g' then diversion flows need to be generated 
c!       for L. St. Joseph and NOT read in. In this case, qdivert 
c!       has not been allocated in read_divert_ef.f so it needs to be 
c!       done here for just one location:
c        if(.not.allocated(qdivert))then
c!         set one diversion location
c          nodivert=1
c          allocate(qdivert(nodivert,mhtot),stat=iAllocate)
c          if(iAllocate.ne.0)STOP
c     *      'Error with allocation of aqdivert  in rerout @ 109'
c        endif
c        if(iopt.ge.1)print*,'qdivert allocated as      1,',mhtot
c        firstpass_local(98)=.false.
c      endif
      
!~~~~~~~~~~~~~~~~~~~~~~~~~~START FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv)
     *                          ,stat=iAllocate)
          if(iAllocate.ne.0)STOP
     *      'Error with allocation of raise/lower in rerout @ 121'
        allocate(lower_range(366,noresv),upper_range(366,noresv),
     *           old(noresv),
     *           full(noresv),max_range(noresv),
     *           ruleNo(noresv),resvNo(noresv),stat=iAllocate)
        
        INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)      

        if(exists)then  
          open(unit=99,file='resrl\rules.ts5',
     *                            status='old')
c        read(99,*)
c        do j=1,365
c          read(99,*)(lower_range(j,i),upper_range(j,i),i=1,noresv)
c        end do
          ll=0
          foundEndHeader=.false.
          print*,'NEW<<<<<'
          print*,'Coordinates for operating rules:'
          do while(.not.foundEndHeader)
            read(99,99000)line
c            print*,line(1:72)
99000       format(a256)       
            if(line(1:10).eq.':endHeader')foundEndHeader=.true.   
            if(line(1:10).eq.':EndHeader')foundEndHeader=.true.   
            if(line(1:6).eq.':Point')then
              ll=ll+1
              read(line,*)junk,xrule(ll),yrule(ll)
              print*,junk,ll,xrule(ll),yrule(ll)
            endif
          end do
        endif  
        nrules=ll/2   ! # of reservoirs/lakes with rules
        print*,'# reservoirs with rules =',nrules
        print*,'       rule#        row         col   rank        resv#'
          
!       check the locations in the resrl\rules.ts5 file
!       coincide with the reservoir locations in the rel file
!       and mark the lake/resv as having a rule: 
        do ll=1,noresv
!         These were initially set to .true. in read_resv_ef.f   
!         to be sure rules.f is called at least once to look for the rules 
!         if they exist.     
          resRuleFlg(ll)=.false.
          ruleNo(ll)=-1
          resvNo(ll)=-1
        end do     
        
      print*,
     *'         ll       rank      res(rank)    resvNo(res(rank))'
        do ll=1,nrules
!         convert to local coordinate unit system for new .res file
          j=int((xrule(ll*2)-xorigin)/xdelta)+1
          i=int((yrule(ll*2)-yorigin)/ydelta)+1
          rank=s(i,j)
!         find the resv # for this rule curve
          if(rank.gt.0)then
!           this reservoir has a rule          
            resRuleFlg(res(rank))=.true.
            ruleNo(res(rank))=ll  !res(rank)
            resvNo(ll)=res(rank)
          else  
            warningflg=.true.
            print*,'Rule coordinates do not match a reservoir location'
            print*,'for rule No.',ll 
          endif
        end do
      print*  
      
        if(warningflg)then
          print*
          print*,'Please check that coordinates in the ts5 file'
          print*,'match those in the rel files'
          stop 'Program aborted in rule @ 165'
        endif         
        
        do j=1,365
          read(99,*)yyyymmdd(j),hhmmss(j),
     *                    (lower_range(j,i),upper_range(j,i),i=1,nrules)
c          print*,yyyymmdd(j),
c     *                    (lower_range(j,i),upper_range(j,i),i=1,noresv)
        end do
      pause 44444          
!       fill in missing values
!       lower range
       
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(lower_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=lower_range(nnext,ll)-lower_range(nlast,ll)
            do j=nlast,nnext
              lower_range(j,ll)=lower_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(99,*)j,nlast,nnext,dif,lower_range(j,l)
            end do
            nlast=nnext
          end do
        end do
!       end lower range        

!       upper range
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(upper_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=upper_range(nnext,ll)-upper_range(nlast,ll)
            do j=nlast,nnext
              upper_range(j,ll)=upper_range(nlast,ll)+
     *                         dif*float(j-nlast)/(nnext-nlast)
c              write(769,*)j,nlast+1,n-1,dif,upper_range(j,ll)
            end do
            nlast=nnext
          end do
        end do
!       end upper range        
        close(unit=99,status='keep')
        
!       write the rules to a file - daily delta t        
        open(unit=99,file='resrl\rules_echo.txt',
     *                            status='unknown')
        do i=1,ni
          do j=1,365
            write(99,99001)j,
     *            (lower_range(j,ll),upper_range(j,ll),ll=1,nrules)
99001       format(i5,<nrules*2>f10.3)     
          end do
          if(mod(i,4).eq.0)then
!               write and extra line for leap years  (approx)              
                write(99,99001)365,
     *            (lower_range(365,ll),upper_range(365,ll),ll=1,nrules)
          endif  
        end do
        close(unit=99,status='keep')

        do ll=1,nrules
          max_range(l)=-999.0
        end do
        do ll=1,nrules
          do j=1,365
            max_range(ll)=amax1(max_range(ll),upper_range(j,ll))
          end do
        end do
        close(unit=99,status='keep')
        
        outflow=0.0

        firstpass_local(99)=.false.
!       open the output file:        
        open(unit=987,file='results\res_levels.csv',status='unknown')
        
        
        if(iopt99)then        
          write(840+l,84001)'jul_day_now','l','res(n)','ruleNo(l)',
     *          'temp_elv(l)','upper_range','lower_range',
     *          'midrange','datum_local','store2(n)','qo2(n)',
     *          'lake_elv(l,jz)','datum_local'  
84001     format(4a10,8a15)          
        endif
        
        
        
      endif   !  end of local first pass to set up the rule table
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     note that this is the global first pass
      if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage
        if(ruleNo(l).gt.0)then 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)    ! initial lake level
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          store1(n)=store2(n)
          qo2(n)=b1(l)*(store2(n))**b2(l)
          qo1(n)=qo2(n)
          lower_range(366,ruleNo(l))=lower_range(365,ruleNo(l))
          upper_range(366,ruleNo(l))=upper_range(365,ruleNo(l))
          old(l)=qi2(n)
          raise(l)=0.1   ! was 0.75 but too slow filling
          lower(l)=1.25
          weight=.01      ! initial weight on last flow
          print*,l,ruleNo(l),lake_elv(l,jz)
        endif
c        if(Qmin(1).lt.0.0)then
c            print*,'Error:'
c            print*,'Found rules.pt5 file but'
c            print*,'Qmin and safe_max values' 
c            print*,'not found in yyyymmdd_ill.pt2 file'
c            print*,'Please fix'
c            print*
c            stop 'Program abortd in rules @ 277'
c        endif
      endif
      inflow(l)=qi2(n)
      if(jul_day_now.eq.1)full(l)=.false.

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(ruleNo(l).gt.0)then
!       use only the upper range values to decide if drawdown rate is fast enough
!       drawdown is calculated using the downward slope of the upper range  
        ju_next=jul_day_now+1
c        if(ju_next.gt.366)ju_next=1

!       OK to use 365 as target for 366 - target for 365        
        if(mod(jul_day_now,4).eq.0)then
          if(ju_next.gt.366)ju_next=1
        else
          if(ju_next.gt.365)ju_next=1
        endif
      
!       midrange is used as the target
        midrange=(upper_range(jul_day_now,ruleNo(l))
     *              +lower_range(jul_day_now,ruleNo(l)))/2.0

c        if(mod(hour_now,18).eq.0)then
        if(temp_elv(l).gt.upper_range(jul_day_now,ruleNo(l)))then
          datum_local=lower_range(jul_day_now,ruleNo(l))
        elseif(temp_elv(l).gt.midrange)then
          datum_local=midrange
        else
          datum_local=lower_range(jul_day_now,ruleNo(l))
        endif
c        endif
        
        store_temp=(temp_elv(l)-datum_local)*lake_area(l)
          
        old(l)=qo2(n)
        if(store_temp.gt.0.0)then
          qo2(n)=b1(l)*(store_temp)**b2(l)
        else
          qo2(n)=0.0
        endif

        qo2(n)=weight*qo2(n)+(1.0-weight)*old(l)
        
        if(qo2(n).lt.0.)qo2(n)=0.0
        
!       Lower the peak quickly        
c        if(temp_elv(l).ge.safe_max(l))qo2(n)=1.25*qi2(n)
        
        store2(n)=store1(n)+(qi1(n)+qi2(n)     ! moved down
     *                -qo1(n)-qo2(n))*div
	  lake_inflow(l,jz)=qi2(n)
        net_lake_inflow(l,jz)=qi2(n)-outflow
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
        lake_elv(l,jz)=datum_local+store2(n)/lake_area(l)
        temp_elv(l)=lake_elv(l,jz)
      
        if(temp_elv(l).ge.max_range(l))full(l)=.true.

        if(iopt99.and.res(n).eq.l)then        
          write(840+l,84000)jul_day_now,l,res(n),ruleNo(l),temp_elv(l),
     *          upper_range(jul_day_now,ruleNo(l)),
     *          lower_range(jul_day_now,ruleNo(l)),
     *          midrange,datum_local,store2(n),qo2(n),
     *          lake_elv(l,jz),datum_local     
84000     format(4i10,9f15.3)     
        endif
        
c        if(l.eq.2)then
c            write(611,61100)id,time,
c     *                 store1(n),store2(n),qi1(n),qi2(n)
c     *                ,qo1(n),qo2(n),div,lake_elv(l,jz)
c     *                      
c61100       format(i5,99f15.3)            
c        endif
      endif  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)

c         if(store2(n).le.0.0.and.iopt.ge.1)then
c           Print*,'store2(',n,' ) -ve / needs work in rules @ 345'
c           print*,time,store1(n),store2(n)
c           print*,qi1(n),qi2(n),qo1(n),qo2(n),div
c           print*,inflow(l),raise(l),drawdown_rate,drawdown
cd           pause 'in rules @ 365'
c         endif

	last_month=month_now

  999 RETURN


      END SUBROUTINE rules_tl

      SUBROUTINE rules_tl(n,div,thr,l,jz,at,dtmin,date,time,firstpass)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     

!***********************************************************************
!   THIS S/R  reads target levels at fixed dates and interpolates the 
!   target levels for each day of the year.
!
!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
!     rev. 9.9.73  Aug.  31/15  - NK: Finshed rules s/r - ready for beta testing
!                                     Fixed for leapyears Jan. 16 NK
!     rev. 10.2.73 Dec.  14/19  - NK Convert rules_tl.f90 to Fortran 90 & fix drawdown comps.
!***********************************************************************

      use area_watflood
      use area_debug
	  implicit none
      save
	

      Integer  :: ios,nnu,j,k,nrr,i,n,l,ic,jm,jz,ll,nnext,ju_next
	  integer  :: newrel,newrin,iDeallocate,iAllocate
      integer  :: dayrad(12),last_month,ndiv_max,lvl_sta_no
      integer  :: yyyy,mmmm,dddd
      real*4   :: hold,wt,dtmin,at,div,thr,time   !,q_divert,q_fixed
      real*4   :: sup,mhu,stc,eri,ont,mean_elv,delta_elv,temp_elv(100)
      real*4   :: sup_init,mhu_init,stc_init,eri_init,ont_init
      real*4   :: retard_factor(12,5)  ! for great lakes ice-weed retardation
      real*4   :: monthly_evap(12,5),hourly_evap(12,5)    ! for great lakes evap
      real*4   :: qbear,qgold,qkettle,elv,hgold,hbear
      real*4   :: qtake,outflow,last_elv,dlth,ddd,dddlast,ddm,ddmlast
      real*4   :: lif,lif_min_lm,lif_min_lw,log_adj,last_obs,qsum
      real*4   :: datum_LMan,flow,spill,sill,s_factor,store_live
      real*8   :: midrange,midrange1,weight
      real*8   :: drawdown,drawdown_rate,fill_rate
      real*4   :: xrule(999),yrule(999),dif,ua,ub,c,d

      real*4,dimension(:,:),allocatable :: Qhourly,Qoutflow

      
	integer  :: lcount,day_last,lastres,jz_last,nlast,rank,zone
	character(10)  :: yyyymmdd(366),hhmmss(366)
	
	real*4   :: elvlast,qraw

!     rev. 9.1.55  Jun.  12/04  - NK: write new str files to strfw\newfmt folder.
      character(20) :: junk
      character(30) :: newfilename
      character(10) :: fileformat
	character(14) :: date
      character*1   :: firstpass,chtr(10)
      character*256 :: line
      LOGICAL exists,firstpass_local(99),cedar_lvl,warningflg
      logical foundEndHeader
      
      real*4, dimension(:),   allocatable :: old,raise,lower,inflow
      logical, dimension(:),  allocatable :: full

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

	DATA firstpass_local/99*.true./
	DATA day_last/0/
	DATA warningflg/.false./

      nnu=0

!     index = 1 for first pass each new chained event
!     index = 2 for subsequent passes. set in sub

!     rev. 9.1.11  Feb.  07/02  - fixed bug in reservoir routing 

      store1(n)=store2(n)   !  moved from below 'if'  09/11/04 nk

!~~~~~~~~~~~~~~~~~~~~~~~~~~START FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(firstpass_local(99))then
        allocate(raise(noresv),lower(noresv),inflow(noresv),stat=iAllocate)
          if(iAllocate.ne.0)STOP  'Error with allocation of raise/lower in rerout @ 121'
        allocate(lower_range(366,noresv),upper_range(366,noresv),&
                old(noresv),&
                full(noresv),max_range(noresv),&
                ruleNo(noresv),resvNo(noresv),stat=iAllocate)
        INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)      

        if(exists)then  
          open(unit=54,file=filename(54),status='unknown',iostat=ios)
          k=1
          do ll=1,noresv
              k=max(k,int(DecayT(ll)))   ! note: k used in a different way later
          end do
          allocate(Qhourly(noresv,k+1), Qoutflow(noresv,k+1),stat=iAllocate)
        
          open(unit=99,file='resrl\rules.ts5', status='old')
          ll=0
          foundEndHeader=.false.
          print*,'NEW<<<<<'
          print*,'Using Coordinates for operating rules:'
          print*
          do while(.not.foundEndHeader)
            read(99,99000)line
99000       format(a256)       
            if(line(1:10).eq.':endHeader')foundEndHeader=.true.   
            if(line(1:10).eq.':EndHeader')foundEndHeader=.true.   
            if(line(1:6).eq.':Point')then
              ll=ll+1
              read(line,*)junk,xrule(ll),yrule(ll)
!c              print*,junk,ll,xrule(ll),yrule(ll)
            endif
          end do
        endif  
        nrules=ll/2   ! # of reservoirs/lakes with rules
        print*,'# reservoirs with rules =',nrules
!c        print*,'       rule#        row         col   rank        resv#'
          
!       check the locations in the resrl\rules.ts5 file
!       coincide with the reservoir locations in the rel file
!       and mark the lake/resv as having a rule: 
        do ll=1,noresv
!         These were initially set to .true. in read_resv_ef.f   
!         to be sure rules.f is called at least once to look for the rules 
!         if they exist.     
          resRuleFlg(ll)=.false.
          ruleNo(ll)=-1
          resvNo(ll)=-1
          if(DecayT(ll).lt.1.or.DecayT(l).gt.10000)then
              print*
              print*,'Error:'
              print*,'It looks like your level\yyyymmdd_ill.pt2 file'
              print*,'needs to be upgraded to have attribute # 7 '
              print*,'DcayT  as the last column'
              print*
              stop 'Program aborted in rules_tl @ 180'
          endif
        end do     
        
        if(debug_output)write(63,*)'        x             y         ll       rank      res(rank)'
        do ll=1,nrules
!         convert to local coordinate unit system for new .res file
          j=int((xrule(ll*2)-xorigin)/xdelta)+1
          i=int((yrule(ll*2)-yorigin)/ydelta)+1
          rank=s(i,j)
          if(debug_output)write(63,*)xrule(ll*2),yrule(ll*2),ll,rank,res(rank)
!         find the resv # for this rule curve
          if(rank.gt.0)then
!           this reservoir has a rule          
            resRuleFlg(res(rank))=.true.
            ruleNo(res(rank))=ll  !res(rank)
            resvNo(ll)=res(rank)
          else  
            warningflg=.true.
            print*,'Rule coordinates do not match a reservoir location'
            print*,'for rule No.',ll 
          endif
        end do
        
        open(unit=987,file='rule_locations.csv',status='unknown')
        do ll=1,noresv
            rank=s(ires(ll),jres(ll))
            if(resruleFlg(res(rank)))then
                write(987,*)xres(ll),yres(ll),ll,resname(ll)
            endif
        end do
        close(unit=987,status='keep',iostat=ios)
        open(unit=987,file='rule_no_locations.csv',status='unknown')
        do ll=1,noresv
            rank=s(ires(ll),jres(ll))
            if(.not.resruleFlg(res(rank)))then
                write(987,*)xres(ll),yres(ll),ll,resname(ll)
            endif
        end do
        close(unit=987,status='keep',iostat=ios)
      
        if(warningflg)then
          print*
          print*,'Please check that coordinates in the ts5 file'
          print*,'match those in the rel files'
!c          stop 'Program aborted in rule @ 165'
        endif         
        
        do j=1,365
          read(99,*,iostat=ios)yyyymmdd(j),hhmmss(j),(lower_range(j,i),upper_range(j,i),i=1,nrules)
          if(ios.ne.0)then
              print*,'Failed reading the resrl\rules.ts5 file'
              print*,'last read data line j'
              print*,yyyymmdd(j)
          print*,j,yyyymmdd(j),(lower_range(j,i),upper_range(j,i),i=1,noresv)
              stop 'Program aborted in read_tl.f @ 224'
          endif
        end do

!c          read(yyyymmdd(1),*)(chtr(j),j=1,10)  
          print*,yyyymmdd(1)
          if(yyyymmdd(1)(5:5).ne.'-')then
              print*,'Wrong date format'
              print*,'You can edit the rules.ts5 file in Exel but it '
              print*,'must be opened as a tab & space delimited file'
              Print*,'Before saving, change the date format to'
              print*,'2015-01-01'
              print*,'The program will read / as a space and give'
              print*,'an error later as the data is not read'
              stop 'Program aborted in rules.f @ 234'
          endif
!       fill in missing values
!       lower range
       
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(lower_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=lower_range(nnext,ll)-lower_range(nlast,ll)
            do j=nlast,nnext
              lower_range(j,ll)=lower_range(nlast,ll)+dif*float(j-nlast)/(nnext-nlast)
            end do
            nlast=nnext
            end do
        end do
!       end lower range        

!       upper range
        Do ll=1,nrules
          nlast=1
!         find 1st >0 value
          j=2
          do while(nlast.lt.365)
            do while(upper_range(j,ll).lt.0.0)                
              j=j+1            
            end do
            nnext=j
!           found a +ve value so interpolate missing for days          
            dif=upper_range(nnext,ll)-upper_range(nlast,ll)
            do j=nlast,nnext
              upper_range(j,ll)=upper_range(nlast,ll)+dif*float(j-nlast)/(nnext-nlast)
!c              write(769,*)j,nlast+1,n-1,dif,upper_range(j,ll)
            end do
            nlast=nnext
          end do
        end do
!       end upper range        
        close(unit=99,status='keep')
        
!       write the rules to a file - daily delta t        
        open(unit=99,file='results\rules_echo.txt',status='unknown')
        do i=1,ni
          do j=1,365
            write(99,99001)j,(lower_range(j,ll),upper_range(j,ll),ll=1,nrules)
99001       format(i5,<nrules*2>f10.3)     
          end do
!     rev. 10.2.43 Jan.  17/19  - NK: Fixed bug in leapyear extra day in rules_echo.txt
          if(mod(year_now+i-1,4).eq.0)then
!               write and extra line for leap years  (approx)              
                write(99,99001)366,(lower_range(365,ll),upper_range(365,ll),ll=1,nrules)
          endif  
        end do
        close(unit=99,status='keep')

        do ll=1,nrules
          max_range(ll)=-999.0
        end do
        do ll=1,nrules
          do j=1,366
            max_range(ll)=max(max_range(ll),upper_range(j,ll))
          end do
        end do
        close(unit=99,status='keep')
        
        outflow=0.0

        firstpass_local(99)=.false.
        jz_last=-999
!        do l=1,noresv
!            old(l)=qo2(n)
!        end do
      endif   !  end of local first pass to set up the rule table
!~~~~~~~~~~~~~~~~~~~~~~~~~~END FIRST PASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
!     note that this is the global first pass
      if(firstpass.eq.'y')then
!         initialize storage	   
!         storage = live storage
        if(ruleNo(l).gt.0)then 
          temp_elv(l)=b6(l)
          lake_elv(l,jz)=b6(l)    ! initial lake level
          store2(n)=(lake_elv(l,jz)-b7(l))*lake_area(l)
          lower_range(366,l)=lower_range(365,ruleNo(l))
          upper_range(366,l)=upper_range(365,ruleNo(l))
!         ********************************************************weight
!         ********************************************************weight
!         ********************************************************weight
          raise(l)=0.5   ! was 0.75 but too slow filling
          lower(l)=1.5
          weight=1.0/decayT(l)      ! initial weight on last flow
!         ********************************************************weight
!         ********************************************************weight
!         ********************************************************weight
        endif
        if(Qmin(1).lt.0.0)then
            print*,'Error:'
            print*,'Found *_ill.pt2 file but'
            print*,'Qmin and safe_max values' 
            print*,'not found in yyyymmdd_ill.pt2 file'
            print*,'Please fix'
            print*
            stop 'Program abortd in rules @ 277'
        endif
      endif
      
!c      if(jul_day_now.lt.122.or.jul_day_now.gt.288)then
!c                call rerout(n,div,thr,l,jz,at,dtmin,date,time,firstpass)
!c               return
!      endif
!      if(jul_day_now.eq.123)print*,'Switched to rules'
!      if(jul_day_now.eq.289)print*,'Switched to power functions'
      
    
      inflow(l)=qi2(n)
      if(jul_day_now.eq.1)full(l)=.false.

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(ruleNo(l).gt.0)then
!       use only the upper range values to decide if drawdown rate is fast enough
!       drawdown is calculated using the downward slope of the upper range  
        ju_next=jul_day_now+1
!       OK to use 365 as target for 366 - target for 365        
        if(ju_next.ge.365)ju_next=1
!       drawdawn is for the midrange trendline        
!     rev. 10.2.37 Oct.  18/18  - NK: Changed target levels to real*8 
        if(jul_day_now.le.365)then
!         for 366 just leave as is            
          drawdown=upper_range(jul_day_now,ruleNo(l))&
                     -upper_range(ju_next,ruleNo(l))&
                     +lower_range(jul_day_now,ruleNo(l))&
                     -lower_range(ju_next,ruleNo(l))
          drawdown_rate=drawdown*lake_area(l)/43200.        ! 86400.0)/2.0 = 43200
          fill_rate=-drawdown_rate
        endif
      
!       midrange is used as the target
        midrange=(upper_range(jul_day_now,ruleNo(l))&
                   +lower_range(jul_day_now,ruleNo(l)))/2.0
!          write(840+l,84000)jul_day_now,l,ruleNo(l),
!     *          upper_range(jul_day_now,ruleNo(l)),
!     *          lower_range(jul_day_now,ruleNo(l)),
!     *          midrange,drawdown,qmin(l),safe_max(l)
84000 format(3i10,7f12.3)     

      ua=upper_range(jul_day_now,ruleNo(l))-midrange
      ub=TEMP_ELV(L)-midrange
      c=abs(midrange-TEMP_ELV(L))
      d=upper_range(jul_day_now,ruleNo(l))-midrange
        
      if(TEMP_ELV(L).gt.safe_max(l))then
          qo2(n)=1.05*qi2(n)
          weight=1/decayT(l)
          qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)
      elseif(abs(fill_rate).le.0.0100)then
!         keep level constant          
          IF(TEMP_ELV(L).gt.upper_range(jul_day_now,ruleNo(l)))then
!             above upper target level so lower regardless 
              if(drawdown.gt.0.0)then
!                  qo2(n)=amax1(1.25*qi2(n),1.25*drawdown_rate)  
                  qo2(n)=max(1.1*qi2(n),1.1*drawdown_rate) 
              else
!                  qo2(n)=1.25*qi2(n)  
                  qo2(n)=1.05*qi2(n)  
              endif
              zone=1
          elseIF(TEMP_ELV(L).gt.midrange)then  

              qo2(n)=(c/d+1)*qi2(n)
!              if(zone.lt.2)qold(n)=qo2(n)   ! kill memory
!              zone=2
        
          elseIF(TEMP_ELV(L).gt.lower_range(jul_day_now,ruleNo(l)))then
        
              qo2(n)=(1.0-c/d)*qi2(n)
!              if(zone.lt.3)qold(n)=qo2(n)   ! kill memory
!              zone=3
              
          elseIF(TEMP_ELV(L).le.lower_range(jul_day_now,ruleNo(l)))then
!             below the lower target level                  
              if(temp_elv(l).le.b7(l))then
!                 below the sill                  
                  qo2(n)=0.0
              else
!                  qo2(n)=0.1*qi2(n)
                  qo2(n)=0.01*qi2(n)
              endif
              zone=4
          endif
          weight=1/decayT(l)
          qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)
      elseif(fill_rate.gt.0.100)then
!         Filling
          IF(TEMP_ELV(L).gt.upper_range(jul_day_now,ruleNo(l)))then
!             above upper target level so lower regardless 
              qo2(n)=1.1*qi2(n)  
              zone=1
           elseIF(TEMP_ELV(L).gt.midrange)then  
        
              qo2(n)=(c/d+1)*qi2(n)-fill_rate
!               if(zone.lt.2)qold(n)=qo2(n)   ! kill memory
             zone=2
        
           elseIF(TEMP_ELV(L).gt.lower_range(jul_day_now,ruleNo(l)))then
        
              qo2(n)=(1.0-c/d)*qi2(n)-fill_rate
!              if(zone.lt.3)qold(n)=qo2(n)   ! kill memory
!              zone=3
              
        
          elseIF(TEMP_ELV(L).le.lower_range(jul_day_now,ruleNo(l)))then
!             below the lower target level                  
              if(temp_elv(l).le.b7(l))then
!                 below the sill                  
                  qo2(n)=0.0
              else
                  qo2(n)=0.1*qi2(n)
              endif
              zone=4
          endif
          weight=1/decayT(l)
          qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)
      elseif(drawdown_rate.gt.0.0100)then
!         lowering
        !             above upper target level so lower regardless 
          IF(TEMP_ELV(L).gt.upper_range(jul_day_now,ruleNo(l)))then
              if(drawdown.gt.0.0)then
                  qo2(n)=max(1.25*qi2(n),1.25*drawdown_rate)  
              else
                  qo2(n)=1.25*qi2(n)  
              endif
              zone=1
           elseIF(TEMP_ELV(L).gt.midrange)then  
        
              qo2(n)=(1.0+c/d)*drawdown_rate+qi2(n)    !<<<<<<<<<<<<<<<<<<<<<<<<<
              if(zone.lt.2)qold(n)=qo2(n)   ! kill memory
              zone=2
        
           elseIF(TEMP_ELV(L).gt.lower_range(jul_day_now,ruleNo(l)))then
        
              qo2(n)=(c/d-1.0)*drawdown_rate+qi2(n)
              if(zone.lt.3)qold(n)=qo2(n)   ! kill memory
              zone=3
              
           elseIF(TEMP_ELV(L).le.lower_range(jul_day_now,ruleNo(l)))then
!             below the lower target level                  
              if(temp_elv(l).le.b7(l))then
!                 below the sill                  
                  qo2(n)=0.0
              else
                  qo2(n)=0.1*qi2(n)
              endif
              zone=4
          endif
          weight=1/decayT(l)
          qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)
      else
          
          qo2(n)=qi2(n)    
          
        weight=1/decayT(l)
        qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)
      endif

!      weight=1/decayT(l)
!      qo2(n)=weight*qo2(n)+(1.0-weight)*qold(n)

      
      if(l.eq.1.and.iopt99)then
          write(666,66600)jul_day_now,jz,&
          drawdown,drawdown_rate,fill_rate,qi2(n),qo2(n),&
          upper_range(jul_day_now,ruleNo(l)),&
                     upper_range(ju_next,ruleNo(l)),&
                     lower_range(jul_day_now,ruleNo(l)),&
                     lower_range(ju_next,ruleNo(l)),midrange     
66600     format(2i5,f15.8,99f10.3)          
      endif
        
        if(qo2(n).lt.0.)qo2(n)=0.0
        
        if(lake_release(l,day_now).gt.0.0)then
              qo2(n)=lake_release(l,day_now)
        endif
        
        qold(n)=qo2(n)
        store2(n)=store1(n)+(qi1(n)+qi2(n)-qo1(n)-qo2(n))*div
	    lake_inflow(l,jz)=qi2(n)
        
        
        if(nbsflg.eq.'y')then
          net_lake_inflow(l,jz)=qi2(n) ! in rulestl
        else
          net_lake_inflow(l,jz)=qi2(n)-outflow ! in rulestl
        endif
        
        
        lake_elv(l,jz)=b7(l)+(store2(n)-store_dead(l))/lake_area(l)
        temp_elv(l)=lake_elv(l,jz)
      
        if(temp_elv(l).ge.max_range(l))full(l)=.true.
        
      endif
        
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
      jz_last=jz    

!     rev. 9.5.11  Feb.  12/08  - NK: added -ve storage check for reservoirs
!     Fixed for -ve outflow Mar. 4/08 -nk-
!     rev. 9.5.20  Mar.  06/08  - NK: added resvstore for iso mosed
        resvstore2(n)=store2(n)

         if(store2(n).le.0.0.and.iopt.ge.1)then
           Print*,'store2(',n,' ) -ve / needs work in rules @ 345'
           write(54,54000)year_now,time,l,store1(n),store2(n),qold(n),&
                qi1(n),qi2(n),qo1(n),qo2(n),div,&
                inflow(l),raise(l),drawdown_rate,drawdown
54000      format(i5,f8.0,i5,3E15.6,10f10.3)           
!c           print*,'Try increasing lake depth '
!c           print*,'check debug\debug\lake_error.txt'
!c           pause 'in rules @ 365'
         endif

	last_month=month_now

  999 RETURN


      END SUBROUTINE rules_tl

      SUBROUTINE runof6(jan,time,t,thr,mon,e1,mz,ju)

!***********************************************************************
!    Copyright (C) 1987-2018 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!     runof4 - snowmelt added
!     runof5 - seperate sca and bare areas added
!     runof6 - wetland runoff and routing added
!
!  THIS SUBROUTINE CALCULATES THE SURFACE RUNOFF AND SUBSURFACE
!  FLOW FOR EACH ELEMENT OF THE WATERSHED =qr(n)
!
!     modified for phillips formula ~ 1974
!     modified for multiple classes in each element 1986
!     modified for jd's snow runof4
!     REV. 7.5 seperate snow covered and bare ground
!     modified for separation of snowcovered ground and bare
!              ground by Frank Seglenieks  Feb/1995   runof5
!     REV. 7.75 added ak2fs   - drainage under snow covered ground
!     REV. 7.76   jun.  11/96 - # classes increased to 16 + urban
!     REV. 7.9    dec 18/96   - Added Todd's evaporation
!     REV. 8.1  - Feb.  15/96 - TBC & RSM (to be continued & resume) 
!     REV. 8.5  - Oct.  09/97 - deleted the old interseption stuff
!     REV. 8.51 - Oct.  09/97 - fixed -ve qr() problem in runof5
!     REV. 8.52 - Nov.  14/97 - replaced x4()= in runof
!     REV. 8.60 - Nov.  14/97 - added sl1 to the interflow calculation
!     REV. 8.85 - Oct.  12/98 - fixed rain & snow on water class
!     REV. 8.89 - Nov.  30/98 - simplified uzs parameters
!     REV. 8.99b  Sept. 27/00 - divvy up interflow & drainae
!
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 
!     REV. 9.03    Nov.  2000 - TS: ADDED WATFLOOD SWAMP ROUTING
!     rev. 9.1     May    7/01  - updated Luis's sed & nutrient stuff
!                                 in runof6 calculate rf(), hsed(), qs()
!     rev  9.1.20  Jun.  25/02  - Added A10 as the power on the UZ discharge function
!     rev. 9.1.37  Mar.  22/03  - Option to turn off leakage by setting LZF < 0.0
!     rev. 9.1.38  Aug.  18/03  - TS: Add qstrm(n) to save value of qstream(n) for Tracer
!     rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
!     rev. 9.2.07  Jul.  29/05  - NK: soilinit moved from runoff to sub 
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.37  Mar.  31/06  - NK: Removed impervious area as special class
!     rev. 9.2.42  Jun.  20/06  - NK: water class included in the water balance
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!     rev. 9.4.06  May.  09/07  - NK: replaced por with spore(n,ii) in runof6
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!     rev. 9.5.61  Sep.  03/09  - NK: bug/eloss - added water class for wfo weighted et
!     rev. 9.5.83  Feb.  17/10  - NK: non_basin exclusion for dds_flag=1
!     rev. 9.7.13  Nov.  22/10  - NK: Changed the outfiles.txt for more rff classes
!     rev. 9.8.59  May   14/13  - NK: REmoved psmear & punused from the program
!     rev. 9.8.61  May   22/13  - NK: Introduced flag1 to speed up runof6
!     rev. 9.8.62  May   22/13  - NK: Fixed bug in runof6: (classcount-3) to (classcount-2) 
!     rev. 9.8.67  Jun   06/13  - NK: Added allocation for flag1
!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
!     rev. 10.1.51 Nov.  08/16  - NK: removed unused isotope related calculations, merged two 
!     rev. 10.1.51                NK: isotope related calc sections to reduce if statements
!
!     changes made to include c&g model stuff  nk  April. 26/07
!
!          * * * all depths in mm * * *
!  unit 74 is for evt stuff written in aet.for
!  the value for qr (n) is calculeted in this subroutine
!  h is the height of the crop in m.
!  permeability coefficient=ak mm/hr
!  void ratio=vol.voids/vol.solids=e
!  porosity=vol.voids/tot.vol.=por   << no longer use e1

!  aclass(n,classcount) - % of impervious area in element n
!  aclass(n,ii)      - % of class ii in element n
!  p(i,j)            - rainfall in mm.
!  jj : ibn(n)      - basin number (5=max) - used to be iak(ii)
!  intcap(n,ii)      - max. amount of water that can be held as 
!                      intercepted initially v=0.  intcap is satisfied 
!                      before any water reaches the excess then becomes
!                      net precipitation.
!  oldsca(n,ii)      - snow covered area from the previous time step
!                       (calculated)
!  uzsfs(n,ii)       - upper zone storage for snow covered ground
!                       (calculated)
!  d1fs(n,ii)        - d1 for snow covered ground (calculated)
!  r3fs(ii)          - ground roughness for snow covered ground (read
!                      in from parameter file)
!  akfs(ii)          - permeability for snow covered ground (read
!                      in from parameter file)
!  fakefs(ii)        - infiltration capacity for snow covered ground
!                       (calculated)
!  fexcess(n,ii)     - amount of runoff from the snowpack     
!                       (calculated in melt.f)

!  p    - net prec. available for runoff.when we enter this subroutine
!         the rainfall
!  v    - depth of water intercepted
!  thr  - time in hours
!  fake - infiltration in the time step
!  t    - time in seconds
!  rec  - interflow depletion coefficient
!  qlz  - baseflow recession parameter
!  pwr  - is the lz outflow exponent
!  ds   - depression storage maximum value
!  pen  - depth of water penetration into soil
!         see philip paper 1954 #368
!  x2   - a parameter for interception - see linsley
!  step2- is grid length in km squared
!  t    - time step in seconds
!  tdum - converts mm of water depth to cms for the time step
!         so depth in mm is multiplied by tdum, flow is divided by tdum
!  uzs  - depth of water stored below the soil surface (mm)
!  lzs  - depth of water in the saturated zone (mm)
!  fake - infiltration capacity in the current time interval
!  ak   - sat. cond. in mm/sec
!
!***********************************************************************

      use areacg
      use area_watflood
c      use omp_lib
      implicit none


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      character*8  :: tempflg      ! just a dummy variable
      real*4   :: power1,thr,xdum,t,tdum,e1,qlzfrac,a51,zj,time,
     *            dend,duz,demand,supply,fraction,evaptemp,q2,dcheck,
     *            dlz,sdlz,aju,amon,loss,tempv1,tempvmin1,rh1,
     *            eff_bare_area,eff_sc_area,temp_junk

      integer  :: i,jan,classcount_9,ii,ios,n,j,
     *     mon,ju,jj,l,iiwater,mzz,mz,iAllocate

      data tempv1,tempvmin1,rh1/-999.0,-999.0,-999.0/
c      logical  :: firstpass
c      data firstpass/.true./

!     THE GROUNDWATER DEPLETION FUNCTION:
      do n=1,naa
         if(flz(n).le.0.0)then
            print*,'flz for grid river class no',ibn(n),' =',flz(n)
            print*,'In grid #',n
            print*,'in row #',yyy(n)
            print*,'in column #',xxx(n)
            print*,'Value must be larger than 0.0'
            STOP 'Program aborted in runof6 @ 139'
         endif
      end do

!     XDUM CONVERTS 1 mm depth to cu. m. for the centre grid
      xdum=1000.*step2
!     tdum converts 1 mm/hour depth to cms for the centre grid
      tdum=1000.*step2/t

!     note:  jan can't really be replaced by first pass because of various restarts
!            in options: sensitivity, pattern search etc.
      if(jan.eq.1)then
!       firstpass through this routine
        classcount_9=min0(9,classcount)
!       Append to existing rff files
!       FOR THE RESUME CASE, GO TO THE END OF THE output FILEs: 
        if(resumflg.eq.'y'.and.contflg.eq.'y'.and.id.eq.1)then
          if(iopt.ge.1)then
c            do ii=1,classcount_9
            do ii=1,classcount
              ios=0
              do while(ios.eq.0)
                read(80+ii,6040,iostat=ios)tempflg  ! simout\rffii.txt
              end do
            end do
          endif
        endif
!       rev. 9.4.06  May.  09/07  - NK: replaced por with spore(n,ii) in runof6
!       use of por discontinued 
!       rev. 9.8.61  May   22/13  - NK: Introduced flag1 to speed up runof6


c!      rev. 9.8.67  Jun   06/13  - NK: Added allocation for flag1
c	   if(.not.allocated(flag1))then
c	     allocate(flag1(na),stat=iAllocate)
c	     if(iAllocate.ne.0)stop
c     *     'Error with allocation of flag1 array in runof6'
c	    endif
c         do n=1,naa
c           if(wetflg.eq.'y'
c     *         .and.theta(n).gt.0.00001
c     *         .and.nclass(classcount-3)(1:7).ne.'glacier'
c     *         .and.nclass(classcount-4)(1:7).ne.'glacier')then
c!              both of these could be glaciers as we can have 1 or 2 wetland classes     
c             flag1(n)=.true.
c           else
c             flag1(n)=.false.
c           endif
c         end do

c      In flowinit now
c!     REV. 10.1.19 Jan.  15/16  - NK: Fixed initialization of ice_factr - moved from lake_ice > runof6
c!       default ice_fctr        
c        do n=1,naa
c          ice_fctr(n)=1.0
c        end do

!     rev. 10.1.97 Sep   11/17  - NK: Moved hdrflg action in runof6.f
        if(id.eq.1.and.contflg.eq.'n')then 
           if(frcflg.eq.'y')write(95,7402)
!          write the headers in the rff**.txt & resin.csv files           
           if(iopt99)then     ! added Oct. 18/17 NK
             do ii=1,classcount
               if(aclass(nnprint,ii).gt.0.0)write(900+ii,6002)
             end do
           endif  
        endif
      endif

!     * * * * INITIAL VALUES * * * *
!
d     if(iopt.eq.3)print*,' checkpoint 1 in runoff. JAN=',jan

      GO TO(1001,1002,1003)jan

 1001 CONTINUE

!     FIRST TIME THROUGH THE PROGRAM

      sdlz=0.0
      qlzfrac=1.00
      if(numa.eq.0)write(51,5190)qlzfrac

d      if(iopt.eq.3)print*,' checkpoint 1a in runoff - after soilinit'

!     UPDATE THE UNSATURATED ZONE SOIL MOISTURE
!     SO FAR, THERE IS ONLY ONE SOIL MOISTURE FOR ALL CLASSES
!     ALTHOUGH GRANTED, IT'S A WEIRD IDEA FOR SWAMPS, WHERE MAYBE
!     WE OUGHT TO SET IT FOR 100%

! TS: added e-separation file header Apr.5/06
!     rev. 9.8.33  Oct.  23/12  - NK: Deleted header for rff files with resumflg = y
      if(resumflg.eq.'n')then
        if(iopt99)then
c           if(frcflg.eq.'y')write(95,7402)
c           do ii=1,classcount
c             if(aclass(nnprint,ii).gt.0.0)write(900+ii,6002)
c           end do
!       this section added to write state variables at time=0.0
          n=nnprint
            mzz=mz-24*(mz/24)
             classcount_9=min0(9,classcount)
c             amon=float(mon)
             amon=float(mo1)   !  changed jan22/11 nk for sensitivity repeated runs
             aju=float(ju)
!            this section repeated below
             if(snwflg.eq.'y'.or.vapflg.eq.'y')then
!              this is needed because memory is allocated 
!              only for these cases
               tempv1=tempv(n)
               tempvmin1=tempvmin(n)
               rh1=rh(n)
             else
               tempv1=-999.
               tempvmin1=-999.
               rh1=-999.
             endif
c             do ii=1,classcount_9
             do ii=1,classcount
               if(aclass(n,ii).gt.0.0)  
     *                write(900+ii,6000)0.000,intevt(n,ii),evt(n,ii),
     *         p(ipr,jpr),sump(n),ssumr(n,ii),
     *         amin1(fake(ii),1000.),amin1(fakefs(ii),1000.),
!     rev. 10.2.39 Nov.  15/18  - NK: changed snowc(n,ii) to snowc(n,ii)*sca(n,ii) in runof6
     *         sca(n,ii),snowc(n,ii)*sca(n,ii),d1(n,ii),d1fs(n,ii),
     *         sumf(n,ii),sumffs(n,ii),uzs(n,ii),uzsfs(n,ii),lzs(n),
     *         q1(n,ii),q1fs(n,ii),qint(n,ii),qintfs(n,ii),qlz(n),
     *         drng(n,ii),drngfs(n,ii),qr(n),qstream(n),strloss(n),
     *         sumrff(n),fexcess(n,ii),glmelt(n),fmadj(n),
     *         sq1(ii),sq1fs(ii),sqint(ii),sqintfs(ii),
     *         sdrng(ii),sdrngfs(ii),slzinflw,sdlz,amon,aju,def(n,ii),
     *         tempv1,tempvmin1,rh1,      !psmear(n),punused(n),
     *         api(n,ii)*100.0,sublim(n,ii),sum_sublim(n,ii),
     *         v(n,ii),wcl(n,ii),sum_pet(n,ii),sum_et(n,ii),pet(n,ii),
     *         tto(n),ttomin(n)
             end do
        endif
      endif   

      if(numa.eq.0.and.resumflg.eq.'n'.and.iopt99)call watbal(1)

cd      if(iopt.eq.3)print*,' checkpoint 1b in runoff- after WATBAL'

1002  CONTINUE                         ! PRODUCTION MODE

cd      if(iopt.eq.3)print*,' checkpoint 2 in runoff'

      a51=a5**thr
      zj=p(ipr,jpr)

!     CALC RUNOFF FOR EACH SQUARE

      do n=nastart,naend
        i=yyy(n)
        j=xxx(n)
        qr(n)=0.0
        qstream(n)=0.0
        qstrm(n)=0.0
        strloss(n)=0.0
        sump(n)=sump(n)+p(i,j)
        rechrg(n)=0.0
        qdrng(n)=0.0
        qdrngfs(n)=0.0
            
        sumq1(n)=0.0
        sumq1fs(n)=0.0
        sumqint(n)=0.0
        sumqintfs(n)=0.0
!        sumrechrg(n)=0.0
        glmelt(n)=0.0   !added Jun. 3/02  nk
      end do

      if(frcflg.eq.'y')then !   added for iso
        do n=nastart,naend            
          storeGW2(n)=0.0         
        end do
      endif

c????????????????????????????????????????????????????????????
      if(jan.eq.1)then
      do ii=1,classcount
        sr(ii)=0.0
        sqint(ii)=0.0
        sqintfs(ii)=0.0
        sdrng(ii)=0.0
        sdrngfs(ii)=0.0
        sq1(ii)=0.0
        sq1fs(ii)=0.0           
        uzsinit(ii)=0.0
        sexcess(ii)=0.0
      end do
      endif

      leakage=0.0

cd      if(iopt.eq.3)print*,' checkpoint 2a in runoff'

!     FOR FLGEVP2.GE.1.0 EVAPORATION IS FROM PLANTS AND SOIL USING 
!     CLIMATIC DATA USING THE EVAP.DAT TABLE AS THE POTENTIAL RATE

!     FOR FLGEVP2 = 0.0, EVAPORATION IS FROM THE SOIL ONLY AND EQUAL TO 
!     THE VALUES IN THE EVAP.DAT TABLE AS LONG AS MOISTURE IS 
!     AVAILABLE IN THE UZS
cd      if(iopt.eq.2)print*,vapflg,'in runof6'

      if(vapflg.eq.'y'.and.flgevp2.ge.1.0)then
cd         if(iopt.eq.2)print*,' gone to etina'
         call etin(mon,jan,ju)
cd         if(iopt.eq.2)print*,' back from etina & gone to intcept'
         call intcept(mon)
cd         if(iopt.eq.2)print*,' back from intcept & gone to aet'
         call aet(time,t,mon,ju)
cd         if(iopt.eq.2)    print*,' back from aet'
      else
         do n=nastart,naend
            do ii=1,classcount
               i=yyy(n)
               j=xxx(n)
               r(n,ii)=p(i,j)
               ssumr(n,ii)=ssumr(n,ii)+r(n,ii)
            end do
         end do
      endif

cd      if(iopt.eq.3)print*,' checkpoint 2b in runoff'

!     CALL THE SNOWMELT SUBROUTINE IF THERE IS ANY SNOE ON THE GROUND
!     SNOW MELT IS CALCULATED FOR ALL CLASSES FOR ALL ELEMENTS
!           WITH ONE CALL TO THE SNOW MELT S/R.
!     THE S/R IS CALLED AT LEASR ONCE TO SEE IF THERE IS SNOW

      if(snwflg.eq.'y')then
         call melt(time,jan,ju)
      endif

cd      if(iopt.eq.3)print*,' checkpoint 2c in runoff'

!     * * * * * * CALC RUNOFF FOR EACH GRID * * * * * * 
!     Grid loop

c      CALL OMP_SET_NUM_THREADS(4)
!$OMP PARALLEL DO NUM_THREADS(2)
c!$OMP DO

      do n=1,naa
      
c        print*,'grid ',n 
      
        jj=ibn(n)

cd     if(iopt.eq.3)print*,'In runof6, passed 101'

      if(slope(n).gt.0.0)then
        i=yyy(n)
        j=xxx(n)
        l=nhyd(i,j)

cd     if(iopt.eq.3)print*,'In runof5, passed 201'

        qlz(n)=0.0
        
        do ii=1,classcount   ! changed Mar. 31/06 nk

cd     if(iopt.eq.3)print*,'In runof5, passed 301'

!         these variables added Jul. 7/06  nk
          eff_bare_area=frac(n)*aclass(n,ii)*(1.0-sca(n,ii))
          eff_sc_area=frac(n)*aclass(n,ii)*sca(n,ii)

!     rev. 9.5.15  Feb.  28/08  - NK: fixed tdum & xdum for proper grid area in lat-long
  
! * * * * * * * *  TS  - WETLAND ROUTING OPTION * * * * * * * * * * * * * 

c!     rev. 9.8.61  May   22/13  - NK: Introduced flag1 to speed up runof6
c          if(ii.eq.classcount-2.and.flag1(n))then


!         rev. 9.8.77  Jul   08/13  - NK: Made universal the use of wetland_flag(n)
          if(ii.eq.classcount-2.and.wetland_flag(n))then
!           rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!                we have to assume that if there is a glacier, 
!                there is no wetland in that grid
!                i.e. we run this code only when NOT in a glacier grid
!                only glacier flow bypasses the wetland
            
            if(sca(n,ii).le.0.001)then
!              NO SCA - ALL PRECIP ON BARE GROUND
               qswrain(n)=r(n,ii)*wetwid(n)*rl(n)/1000.0/t
         
            else
!              THERE IS A FRACTION OF SCA AND BARE GROUND
!              melt is added from the sca and
!              rain is added from the bare area
               qswrain(n)=
     *              (fexcess(n,ii)*sca(n,ii)+r(n,ii)*(1.0-sca(n,ii)))
     *               *wetwid(n)*rl(n)/1000.0/t
            endif

!           TS - NOT USED IN WETLANDS, SET TO ZERO TO AVOID NaN
!           TS - ADDED DRNG(FS) PARAMS (22/08/2006)
!           TS - ADDED DF(FS) PARAMS (02/10/2006)
            d1(n,ii)=0.0
            d1fs(n,ii)=0.0
            uzs(n,ii)=0.0
            uzsfs(n,ii)=0.0
            df(n,ii)=0.0
            dffs(n,ii)=0.0
            drng(n,ii)=0.0
            drngfs(n,ii)=0.0
!           NK - set to zero to prevent write errors fro wetland class.
            q1(n,ii)=0.0
            q1fs(n,ii)=0.0
            qint(n,ii)=0.0
            qintfs(n,ii)=0.0
            qdf(n,ii)=0.0
            qdffs(n,ii)=0.0
            qdrng2(n,ii)=0.0               
            qdrngfs2(n,ii)=0.0
            drng(n,ii)=0.0
            drngfs(n,ii)=0.0
            dprecip(n,ii)=0.0

! * * * * * * * *  TS  - END WETLAND ROUTING OPTION * * * * * * * * * * * * * 

          else   ! non-wetland classes

!     *       PAUSE 'channel runof5 loop for wetland class'

cd     if(iopt.eq.3)print*,'In runof5, passed 401'

            q1(n,ii)=0.0
            q1fs(n,ii)=0.0
            qint(n,ii)=0.0
            qintfs(n,ii)=0.0
            qdf(n,ii)=0.0
            qdffs(n,ii)=0.0
            qdrng2(n,ii)=0.0               
            qdrngfs2(n,ii)=0.0
            drng(n,ii)=0.0
            drngfs(n,ii)=0.0
            dprecip(n,ii)=0.0

          if(frcflg.eq.'y')then
!           TS - ADDED storeSW1(FS) PARAMS (22/08/2006)
!           TS - ADDED storeIF1(FS) PARAMS (02/10/2006)
              storeSW1(n,ii)=storeSW2(n,ii)
              storeSW2(n,ii)=0.0
              storeIF2(n,ii)=0.0
          endif

          if(aclass(n,ii).gt.0.0)then   ! skip if class area = 0.0
          
!           REV. 7.5 SEPERATE SNOW COVERED AND BARE GROUND

!           THE PRECIPITATION NOT INTERCEPTED NOW REACHES THE GROUND
!           WFILE SNOWMELT IS KEPT SEPARATE IN FEXCESS
!           d1(n) IS THE WATER IN SURFACE RETENTION NOW ON PERMEABLE 
!           GROUND
!           sumf(n,ii), sumffs(n,ii) IS THE SUM OF THE INFILTRATION UP 
!           TO THE PRESENT TIME
!           df(n), dffs(n) IS THE NON-CUMMULATIVE INFILTRATION

!   ++++++++++  THIS IS THE MAIN SECTION TO DEAL WITH ++++++++++
!   ++++++++++             BARE GROUND                ++++++++++

cd     if(iopt.eq.3)print*,'In runof5, passed 501'

            if(ak(ii).gt.0.0)then
!             i.e. water is bypassed            
!      +++++++++++++++++++++++++++++++++++++++++++++++++ fs begin
!      ++++++++   RUNOFF FOR BARE GROUND   +++++++++++++
!      +++++++++++++++++++++++++++++++++++++++++++++++++
d     if(iopt.eq.3)print*,'In runof5, passed 600'
              if(sca(n,ii).lt.1.0)then
                d1(n,ii)=d1(n,ii)+r(n,ii)
                dprecip(n,ii)=r(n,ii) 
              endif
              if(nclass(ii)(1:7).eq.'glacier')then
!               NOTE: AUTOMATICALLY ON BARE ICE ONLY
                d1(n,ii)=d1(n,ii)+glmelt(n)
!               ADD GLACIER MELT TO PRECIP FOR WATER BALANCE:
                sump(n)=sump(n)
     *               +glmelt(n)*aclass(n,ii)*(1.0-sca(n,ii))
              endif
cd             if(iopt.eq.3)print*,'In runof5, passed 601'
!             REV. 7.42 CHECK FOR DIVISION BY 0  MAY/95
!              if(uzs(n,ii).gt.0.01)then    !caused discontinuities nk jul 10/06
              if(uzs(n,ii).gt.1.0E-10)then
                fake(ii)=ak(ii)*thr*
     *          (1.+effpor(n,ii)*(d1(n,ii)+pot(ii))/(uzs(n,ii)+0.00001))
!               limit added Dec. 11/00 nk
                fake(ii)=amin1(fake(ii),1000.1)
!               limit added April 19, 2002 AB
                fake(ii)=amax1(fake(ii),0.001)
              else
                fake(ii)=1000.0
              endif
cd             if(iopt.eq.3)print*,'In runof5, passed 701'
              if(fake(ii).eq.0.0)print*,'ii,fake',ii,fake

!             INFILTRATION:
              if(d1(n,ii).le.fake(ii))then
!               SURFACE STORAGE < INFILTRATION CAPACITY 
!               AND ALL THE WATER IS INFILTRATED-NO RUNOFF

                uzs(n,ii)=uzs(n,ii)+d1(n,ii)
                sumf(n,ii)=sumf(n,ii)+d1(n,ii)*eff_bare_area
                if(frcflg.eq.'y')then
                  qdf(n,ii)=qdf(n,ii)+d1(n,ii)*eff_bare_area*tdum
                endif
!                 prorated for sca Jul. 7/06 nk
                d1(n,ii)=0.0
              else
!               SURFACE STORAGE > INFILTRATION CAPACITY
                uzs(n,ii)=uzs(n,ii)+fake(ii)
!     rev. 10.1.55 Nov.  30/16  - NK: Fixed sumf & sumffs in runof6
c                sumf(n,ii)=sumf(n,ii)+fake(ii)
                sumf(n,ii)=sumf(n,ii)+fake(ii)*eff_bare_area
!               prorated for sca Jul. 7/06 nk
                d1(n,ii)=d1(n,ii)-fake(ii)
                if(frcflg.eq.'y')then
                  qdf(n,ii)=qdf(n,ii)+fake(ii)*eff_bare_area*tdum
                endif
              endif

cd     if(iopt.eq.3)print*,'In runof5, passed 801'

!             OVERLAND FLOW (DIRECT RUNOFF)
              if(over(n)*type1.le.0)then
!               WE HAVE A FLOODPLAIN AND THERE CAN BE RIVER INFLOW
                if(d1(n,ii).le.ds(ii))then
!                 WATER DEPTH IS LESS THAN DEPRESSION STORAGE
!                 AND THERE IS NO SURFACE FLOW
                  q1(n,ii)=0.0
!                 AND D1 REMAINS UNCHANGED BY SURFACE RUNOFF
                else
!                 THE CONVERSE - THE MAX POSSIBLE FLOW IS: 
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
                  q1(n,ii)=(d1(n,ii)-ds(ii))**1.66*sl2(n)*step2/r3(ii)
!                 UNITS: d1,ds IN MM; step2 IN KM^2 
!                 SO R3 HAS DIMENSIONS ACCORDING AS IN MANNING
!                 THE WATER REMAINING AT END OF TIME STEP 
                  dend=d1(n,ii)-q1(n,ii)/tdum
!                 SURFACE FLOW CAN NOT TAKE WATER BELOW DEPRESSION 
!                 STORAGE
d                 if(iopt.eq.3)print*,'In runof5, passed 901'
                  if(dend.ge.ds(ii))then
!                   THERE IS ENOUGH WATER FOR MAX RUNOFF AND        
                    d1(n,ii)=dend
                  else
!                   ALL WATER ABOVE DEP. STOR. IS DRAINED IN THIS DT.
!                   (AND PROBABLY THE SURFACE ROUGHNESS IS TOO LOW!!
                    q1(n,ii)=(d1(n,ii)-ds(ii))*tdum
                    d1(n,ii)=ds(ii)
                  endif
                endif
!               RF() (IN M) IS RUNOFF IN MM FOR THIS DT NEEDED BY SED
                rf(n,ii)=q1(n,ii)/tdum
!               ADJUST FOR PROPER CONTRIBUTING AREA:
                q1(n,ii)=q1(n,ii)*eff_bare_area
cd               if(iopt.eq.3)print*,'In runof5, passed 1001'

!               INTERFLOW AND DRAINAGE:
!               WHERE UZS IS IN MM AND QINT IS CUBIC METER PER SECOND
!     REV. 8.60 - Nov.  14/97 -   ADDED SL1 TO THE INTERFLOW CALCULATION
!     REV. 8.99b  Sept. 27/00 -   DIVVY UP INTERFLOW & DRAINAGE
!               Added check - AB, April 19, 2002
                if(uzs(n,ii).gt.retn(ii))then
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
!                  duz=x4(ii)*((uzs(n,ii)-retn(ii))**A10)*sl1(n)
                  duz=rec(ii)*((uzs(n,ii)-retn(ii))**A10)*sl1(n)
                else
                  duz=0.00000
!                 duz=1.0e-10
                endif
cd     if(iopt.eq.3)print*,'In runof5, passed 1001-2'

!               DRAINAGE OF UZS TO GROUND WATER:
!               THRESHOLD FOR DRAINAGE 
!               IF VOL. WATER CONTENT LESS THAN RETN THEN NO
!               DRAINAGE OCCURS
!               AK2 MUST BE LT 1 - CHECKED IN PARAM.FOR
                if(uzs(n,ii).gt.retn(ii))then
!                 Added check - AB, April 19, 2002
                  drng(n,ii)=ak2(ii)*(uzs(n,ii)-retn(ii))    !**power1
                else
                  drng(n,ii)=0.0000
!                 drng(ii)=1.0e-10
                endif
                drng(n,ii)=amax1(0.000,drng(n,ii))

!               DIVVY UP THE OUTFLOW
                demand=duz+drng(n,ii)
                if(demand.gt.0.0)then
                  if(uzs(n,ii)-retn(ii).ge.demand)then
!                   THERE IS ENOUGH WATER TO SATISFY BOTH
                    uzs(n,ii)=uzs(n,ii)-duz-drng(n,ii)
                  else
!                   DIVVY UP THE WATER
                    supply=uzs(n,ii)-retn(ii)
                    fraction=supply/demand
                    duz=duz*fraction
!     rev. 10.1.84 May   09/17  - NK: Put drng(n,ii)=drng(n,ii)*fraction back into runof6
                    drng(n,ii)=drng(n,ii)*fraction
                    drng(n,ii)=amax1(0.000,drng(n,ii))  ! TS: ADDED ERROR CHECK
                    uzs(n,ii)=retn(ii)
                  endif
                  qint(n,ii)=duz*eff_bare_area*tdum
                  if(n.eq.nnprint)then
                    sq1(ii)=sq1(ii)+rf(n,ii)*eff_bare_area*tdum
                    sqint(ii)=sqint(ii)+duz*eff_bare_area*tdum
                  endif
                  if(n.eq.nnprint)then
                    sdrng(ii)=sdrng(ii)+drng(n,ii)*eff_bare_area  
!                   TS: added *tdum b/c lower zone inflow: Nov 1/07
                    slzinflw=slzinflw  ! FLOW
     *                     +drng(n,ii)*eff_bare_area*tdum 
                  endif
!                 DRAINAGE IS WEIGHTED HERE TO ACOCUNT FOR 
!                 LAND COVER AREA OF EACH CLASS        ! lzs is depth
                  lzs(n)=lzs(n)+drng(n,ii)*aclass(n,ii)*(1-sca(n,ii))
                endif
cd     if(iopt.eq.3)print*,'In runof5, passed 1301'

!               rechrg() is the incremental recharge for output to MODFLOW
!               This could be for instance in 24 hour increments (hard coded now) 
!               The recharge is adjusted for a grid with frac=1.0 !!!
                rechrg(n)=rechrg(n)                  ! adjusted depth
     *                   +drng(n,ii)*eff_bare_area

!     rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!               sumrechrg() is the cummulative recharge for the whole run
!               and is for information wrt doing a water balance AND
!               to see what the recharge is on each grid.
                sumrechrg(n)=sumrechrg(n)+drng(n,ii)*eff_bare_area
                qdrng(n)=qdrng(n)+drng(n,ii)*eff_bare_area*tdum
                if(frcflg.eq.'y') qdrng2(n,ii)=
     *                       qdrng2(n,ii)+drng(n,ii)*eff_bare_area*tdum
!               STREAMFLOW CONTRIBUTION: OVERLAND & INTERFLOW
!               WEIGHTED ACCORDING TO LAND COVER AMOUNT
                qr(n)=qr(n)+qint(n,ii)+q1(n,ii)
              else
!               NO FLOOD PLAIN : TYPE1 = 1.0 IN MAIN PROGRAM
!               WHEN OVER*TYPE1 .GE. 0, CHANNEL INFLOW CALCS ARE
!               BYPASSED 
!               CHANNELS ARE FULL AND THERE IS NO DIRECT RUNOFF OR
!               INTERFLOW
                qr(n)=0.0
                qbase(n)=0.0
              endif
cd     if(iopt.eq.3)print*,'In runof5, passed 1401'

!             EVAPORATION:
!             WATER IS ONLY LOST TO EVAPORATION IF WATER IS AVAILABLE
!             SINCE THE HOURLY AMOUNTS ARE SMALL, WE'RE NOT BOTHERING 
!             TO BRING THE UZS TO 0.0
!       REV 7.9  PROVISION TO ALLOW THE USE OF ORIGINAL AET TABLE DATA
              if(flgevp2.lt.1.0)then
!               alternative method - aet NOT called
                evaptemp=amin1(uzs(n,ii),evap(ii,mon))
                if(evaptemp.gt.0.0)then
!                 WATER AVAILABLE AND PET >0.0, TAKE OFF EVAPORATION:
                  uzs(n,ii)=uzs(n,ii)-evaptemp
                  evt(n,ii)=evt(n,ii)+evaptemp*(1-sca(n,ii))
                  eloss(n)=eloss(n)+evaptemp*aclass(n,ii)*(1-sca(n,ii))
                  if(frcflg.eq.'y')then
                    evloss(n,ii)=evaptemp
                  endif
                endif
!               RETN MAY HAVE TO BE CONSIDERED <<<<<<      ???
                pet(n,ii)=0.0
              endif
!             END OF REV 7.9


c            else
c!             SURFACE WATER:
c!             PERMEABILITY IS -VE FOR WATER
c!             RAIN FALLS ON WATER SURFACE AND IS DIRECTLY ADDED TO 
c!             RIVER FLOW. SET AK(ii) TO 0.0 OR LESS FOR THIS OPTION
c!             REV 7.9 NEW CALCULATION BASED ON NEW EVAPORATION
c!             REV. 8.85 - Oct. 12/98 - FIXED RAIN & SNOW ON WATER CLASS
c              d1(n,ii)=0.0
c              df(n,ii)=0.0
c              uzs(n,ii)=0.0
cd             if(iopt.eq.3)print*,'In runof5, passed 1501'
c!             qstream(n) is added to channel inflow in route
c!             qstream(n) = net precip in mm converted to cms
c              qstream(n)=r(n,ii)*eff_bare_area*tdum        
c!              qstream(n)=amax1(0.1e-10,qstream(n))
c              iiwater=ii
c              if(.not.rd_evp_flg)then
c!               if the water evaporation is read in, skip this part
c!               strloss is computed in sub
c!               EVAPORATION IN THE WATER CLASS IS EQUAL TO
c!               POTENTIAL EVAPORATION AND HAS TO BE TAKEN FROM
c!               RIVER STORAGE AS A FLOW
c!     rev. 9.1.66  Oct.  17/04  - NK; pet*fpet for loss from water instead of pet
c!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!change  nov 25/09 nk
c                if(r(n,ii).gt.0.0)then
c                  ev(n,ii)=0.0    ! ev calculated in AET
c                endif
c                
c!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f
c                if(ice_fctr(n).lt.0.0)then
c                  strloss(n)=0.0
c                  ev(n,ii)=0.0
c                else
c!     rev. 9.5.61  Sep.  03/09  - NK: bug/eloss - added water class for wfo weighted et
c!                   for the wfo file:
c                  strloss(n)=ev(n,ii)*eff_bare_area*tdum
c!                 strloss is taken from channel storage in route
c                  if(ireach(n).eq.0)then
c                    if(store2(n).gt.strloss(n)*3600.0)then
c                      evt(n,ii)=evt(n,ii)+ev(n,ii)         ! for rffxx.txt
c!                     for ensim: prorated for sca 
c!                     100% snow cover - no et
c!                       0% snow cover - no reduction
c                      sum_et(n,ii)=sum_et(n,ii)+ev(n,ii)*(1.0-sca(n,ii))   
c                      eloss(n)=eloss(n)+
c     *                              ev(n,ii)*aclass(n,ii)*(1-sca(n,ii))
c
c!     REV. 10.1.17 Jan.  11/16  - NK: Added fpetLakeOverride factor
c!                     Temporary fix for dealing with rogue lakes - i.e. where fpet
c!                     just doesn't fit all the lakes
c!                     Maybve the lake evaporation model will fix this - maybe not.
c!                     It has to be done here so the tracer & isotope stuff 
c!                     is not affected
c                    else
c                      strloss(n)=0.0
c                    endif     !  store2(n).gt.............
c                  endif     !  ireach(n).eq.0
c                endif     !  ice_fctr(n).lt.0.0
c              endif     !  .not.rd_evp_flg
            endif   ! :end SURFACE WATER:  

!           SEDIMENT COMPONENT - REMOVE IF NOT USED
!           EROSION ON BARE GROUND ONLY
            if(sedflg.eq.'y'.or.sedflg.eq.'Y')then
              qs(n,ii)=q1(n,ii)
              hsed(n,ii)=d1(n,ii)-ds(ii)
            endif
d     if(iopt.eq.3)print*,'In runof5, passed 1601'

!  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!  ++++++++++++++   RUNOFF FOR SNOWCOVERED GROUND   +++++++++++++
!  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!           BYPASS SNOW COVERED GROUND WHEN THERE IS NO SNOW !!!!
            if(snwflg.eq.'y')then
            if(sca(n,ii).gt.0.001)then
            if(akfs(ii).gt.0.0)then
!             NON-water classes
              d1fs(n,ii)=d1fs(n,ii)+fexcess(n,ii)
                fakefs(ii)=akfs(ii)*thr*(1.+effpor(n,ii)
     *                  *(d1fs(n,ii)+potfs(ii))/(uzsfs(n,ii)+0.00001))
cd               if(iopt.eq.3)print*,'In runof5, passed 1701'
!             INFILTRATION: 
              if(d1fs(n,ii).le.fakefs(ii))then
!               SURFACE STORAGE LT INFILTRATION CAPACITY 
!               AND ALL THE WATER IS INFILTRATED-NO RUNOFF
                uzsfs(n,ii)=uzsfs(n,ii)+d1fs(n,ii)
!     rev. 10.1.55 Nov.  30/16  - NK: Fixed sumf & sumffs in runof6
c                sumffs(n,ii)=sumffs(n,ii)+d1fs(n,ii)
                sumffs(n,ii)=sumffs(n,ii)+d1fs(n,ii)*eff_sc_area
                if(frcflg.eq.'y')then
                  qdffs(n,ii)=qdffs(n,ii)+d1fs(n,ii)*eff_sc_area*tdum  ! fixed nk
                endif
!                prorated for sca Jul. 7/06 nk
                d1fs(n,ii)=0.0
              else
!               SURFACE STORAGE > INFILTRATION CAPACITY
                uzsfs(n,ii)=uzsfs(n,ii)+fakefs(ii)
!     rev. 10.1.55 Nov.  30/16  - NK: Fixed sumf & sumffs in runof6
c                sumffs(n,ii)=sumffs(n,ii)+fakefs(ii)
                sumffs(n,ii)=sumffs(n,ii)+fakefs(ii)*eff_sc_area
!                prorated for sca Jul. 7/06 nk
                d1fs(n,ii)=d1fs(n,ii)-fakefs(ii)
                if(frcflg.eq.'y')then
                  qdffs(n,ii)=qdffs(n,ii)+fakefs(ii)*eff_sc_area*tdum
                endif
              endif

cd     if(iopt.eq.3)print*,'In runof5, passed 1801'

!             OVERLAND FLOW (DIRECT RUNOFF):
              if(over(n)*type1.le.0)then
!               WE HAVE A FLOOD PLAIN AND THERE CAN BE INFLOW
!               TO THE RIVER
                if(d1fs(n,ii).le.dsfs(ii))then
!                 WATER DEPTH IS LESS THAN DEPRESSION STORAGE
!                 AND THERE IS NO SURFACE FLOW
                  q1fs(n,ii)=0.0
!                 AND D1 REMAINS UNCHANGED BY SURFACE RUNOFF
                else
!                 THE CONVERSE - THE MAX POSSIBLE FLOW IS
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
                  q1fs(n,ii)=(d1fs(n,ii)-dsfs(ii))**1.66
     *                         *sl2(n)*step2/r3fs(ii)

!                 AND THE WATER REMAINING AT END OF TIME STEP
                  dend=d1fs(n,ii)-q1fs(n,ii)/tdum
!                 SURFACE FLOW CAN NOT TAKE WATER BELOW DEPRESSION
!                 STORAGE
                  if(dend.ge.dsfs(ii)) then
!                   THERE IS ENOUGH WATER FOR MAX RUNOFF AND
                    d1fs(n,ii)=dend
                  else
!                   ALL WARER ABOVE DEP. STOR. IS DRAINED IN THIS DT.
!                   (AND PROBABLE THE SURFACE ROUGHNESS IS TOO LOW !!)
                    q1fs(n,ii)=(d1fs(n,ii)-dsfs(ii))*tdum
                    d1fs(n,ii)=dsfs(ii)
                  endif
                endif
cd              if(iopt.eq.3)print*,'In runof5, passed 1901'
!               RFFS() IS RUNOFF IN MM FOR THIS DT NEEDED BY SED
                rffs(n,ii)=q1fs(n,ii)/tdum
!               adjust for contributing area
                q1fs(n,ii)=q1fs(n,ii)*eff_sc_area

!               INTERFLOW:
!               WHERE UZS IS IN MM AND QINT IS CUBIC METER PER SECOND
!   REV. 8.60 - Nov.  14/97 -     ADDED SL1 TO THE INTERFLOW CALC
!   REV. 8.99b  Sept. 27/00 -     DIVVY UP INTERFLOW & DRAINAGE
!               Added check - AB, April 19, 2002  added here Apr. 08/03 nk
                if(uzsfs(n,ii).gt.retn(ii))then
!                if(uzs(n,ii)-retn(ii).gt.1.0e-10)then   
                              ! changed Jun. 3/02 nk
!     rev. 9.1.60  Jul.  27/04  - NK: reversed definitions for sl1 & sl2 Int. Slope
!                  duz=x4(ii)*((uzsfs(n,ii)-retn(ii))**a10)*sl1(n)
                  duz=rec(ii)*((uzsfs(n,ii)-retn(ii))**a10)*sl1(n)
                else
                  duz=0.00000
!                 duz=1.0e-10
                endif

!               DRAINAGE OF UZS TO GROUND WATER:
!               THRESHOLD FOR DRAINAGE - IF VOL. WATER CONTENT LESS 
!               THAN RETN THEN NO DRAINAGE OCCURS 
!               ak2fs must be lt 1 - checked in param.for
                if(uzsfs(n,ii).gt.retn(ii))then
!                if(uzs(n,ii)-retn(ii).gt.1.0e-10)then   ! changed Jun. 3/02 nk
!               Added check - AB, April 19, 2002
                  drngfs(n,ii)=ak2fs(ii)*(uzsfs(n,ii)-retn(ii))    !**power1
                else
                  drngfs(n,ii)=0.0000
!                 drngfs(ii)=1.0e-10
                endif
                drngfs(n,ii)=amax1(0.000,drngfs(n,ii))  ! TS: ADDED ERROR CHECK

!               DIVVY UP THE UZ OUTFLOW 
cd               if(iopt.eq.3)print*,'In runof5, passed 2001'
                demand=duz+drngfs(n,ii)
                if(demand.gt.0.0)then
                  if(uzsfs(n,ii)-retn(ii).ge.demand)then
!                   THERE IS ENOUGH WATER TO SATISFY BOTH
                    uzsfs(n,ii)=uzsfs(n,ii)-duz-drngfs(n,ii)
                  else
!                   DIVVY UP THE WATER
                    supply=uzsfs(n,ii)-retn(ii)
                    fraction=supply/demand
                    duz=duz*fraction
!     rev. 10.1.84 May   09/17  - NK: Put drng(n,ii)=drng(n,ii)*fraction back into runof6
                    drngfs(n,ii)=drngfs(n,ii)*fraction
                    drngfs(n,ii)=amax1(0.000,drngfs(n,ii))  ! TS: ERROR CHECK
                    uzsfs(n,ii)=retn(ii)
                  endif
                  qintfs(n,ii)=duz*eff_sc_area*tdum
                  if(n.eq.nnprint)then
                    sq1fs(ii)=sq1fs(ii)+rffs(n,ii)*eff_sc_area*tdum
                    sqintfs(ii)=sqintfs(ii)+duz*eff_sc_area*tdum
                  endif
                  if(n.eq.nnprint)then
                    sdrngfs(ii)=sdrngfs(ii)+drngfs(n,ii)*eff_sc_area
                    slzinflw=slzinflw  !FLOW
     *                      +drngfs(n,ii)*eff_sc_area*tdum
                  endif
!               DRAINAGE IS WEIGHTED HERE TO ACCOUNT FOR 
!               LAND COVER AREA OF EACH CLASS
                lzs(n)=lzs(n)+drngfs(n,ii)*aclass(n,ii)*sca(n,ii)  ! depth
              endif
cd             if(iopt.eq.3)print*,'In runof5, passed 2101'
!             The recharge is adjusted for a grid with frac=1.0 !!!
              rechrg(n)=rechrg(n)               ! adjusted depth
     *                 +drngfs(n,ii)*eff_sc_area
!     rev. 9.1.48  Dec.  08/03  - NK: sumrechrge() added to get total recharge
!             see note above
              sumrechrg(n)=sumrechrg(n)+drngfs(n,ii)*eff_sc_area
!                               found mistake here 30/06/00
!             TS: MADE THIS DRNG FROM SNOWMELT FOR TRACER S/R (08/27/03)
              qdrngfs(n)=qdrngfs(n)+drngfs(n,ii)*eff_sc_area*tdum
              if(frcflg.eq.'y') qdrngfs2(n,ii)=
     *                     qdrngfs2(n,ii)+drngfs(n,ii)*eff_sc_area*tdum
!             STREAMFLOW CONTRIBUTION: OVERLAND & INTERFLOW
!             WEIGHTED ACCORDING TO LAND COVER AMOUNT
              qr(n)=qr(n)+qintfs(n,ii)+q1fs(n,ii)
            else
!             NO FLOOD PLAIN: TYPE1 = 1.0  IN MAIN PROGRAM
!             WHEN OVER*TYPE1.GE.0, CHANNEL INFLOW CALCS ARE BYPASSED
!             CHANNELS ARE FULL AND THERE IS NO DIRECT RUNOFF OR
!             INTERFLOW
              qr(n)=0.0
              qbase(n)=0.0
            endif
cd           if(iopt.eq.3)print*,'In runof5, passed 2201'
   

c            else                    !IF(akfs(ii).gt.0.0)THEN
c!             SURFACE WATER:
c!             PERMEABILITY IS -VE FOR WATER
c!             FEXCESS FALLS ON WATER SURFACE AND IS DIRECTLY ADDED TO 
c!             RIVER FLOW. SET AK(ii) TO 0.0 OR LESS FOR THIS OPTION
c!             REV 7.9 UPDATED EVAPORATION    
c!                BUT THERE IS NO EVAP FOR MELTED SNOW
c!             REV. 8.85 - Oct. 12/98 - FIXED RAIN & SNOW ON WATER CLASS
c              d1fs(n,ii)=0.0
c              dffs(n,ii)=0.0
c              uzs(n,ii)=0.0
c              iiwater=ii
c!             qstream(n) is added to channel inflow in route
c!             qstream(n) = net melt+rain in mm converted to cms
c              qstream(n)=qstream(n)+fexcess(n,ii)*eff_sc_area*tdum
c              
c              strloss(n)=0.0
c              
c!             NO EVAPORATION WHEN WATER IS COVERED BY SNOW!
c!                 this is in the last version of SPL8
c               
c             
            endif           !IF(akfs(ii).gt.0.0)THEN
            endif           !IF(sca(n,ii).gt.0.001)THEN
            endif           !IF(snwflg.eq.'y')THEN
!           END OF SNOW COVERED AREA COMPUTATIONS

          endif                         ! IF(aclass().gt.0.0)THEN
cd     if(iopt.eq.3)print*,'In runof5, passed 2301'
!  ++++++++++++++++++++++++++++++++++++++++++++++++++++++   fs end 

          endif                     ! if(ii.NE.classcount-2)

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
!       TS:ADDED SUMS HERE FOR TRACER S/R (08/27/03)
!       INCLUDES impervious, wetland classes and water class
!          LOOPING FROM ii=1,classcount
          sumq1(n)=sumq1(n)+q1(n,ii)
          sumq1fs(n)=sumq1fs(n)+q1fs(n,ii)
          sumqint(n)=sumqint(n)+qint(n,ii)
          sumqintfs(n)=sumqintfs(n)+qintfs(n,ii)
          if(frcflg.eq.'y')then 
            storeSW2(n,ii)=storeSW2(n,ii)+(d1(n,ii)*eff_bare_area 
     *                 +d1fs(n,ii)*eff_sc_area)*xdum
            storeIF2(n,ii)=storeIF2(n,ii)+(uzs(n,ii)*eff_bare_area
     *                     +uzsfs(n,ii)*eff_sc_area)*xdum   
          endif
          

        end do                ! classcount loop
        
!      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

!        if(frcflg.eq.'y')then   ! TS: moved to below "call baseflow" where lzs is defined
!          storeGW2(n)=lzs(n)*xdum*frac(n)
!        endif
cd       if(iopt.eq.3)print*,' checkpoint 5 in runoff'
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call baseflow(n,dlz,sdlz,tdum)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cd     if(iopt.eq.3)print*,' checkpoint 6 in runoff'
        if(frcflg.eq.'y')then
          storeGW2(n)=lzs(n)*xdum*frac(n)
        endif

! TS - ADDED ROUTING PROVISION FOR WETLANDS - NOV 2000
! * * * * * * * * * * * * * * * * * * * * * * * * * *
!      rev. 9.8.61  May   22/13  - NK: Introduced flag1 to speed up runof6
!      rev. 9.8.62  May   22/13  - NK: Fixed bug in runof6: (classcount-3) to (classcount-2) 
c        if(aclass(n,classcount-2).gt.0.0.and.flag1(n))then
!      rev. 9.8.77  Jul   08/13  - NK: Made universal the use of wetland_flag(n)
!      rev. 9.8.79  Jul   19/13  - NK: Fixed wetland conditional screwed up with rev 9.8.77 in runof6
        if(wetland_flag(n))then
!         for wetlands, qlz(n) is added to qiwet2(n) in route
!      rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!                we have to assume that if there is a glacier, 
!                there is no wetland in that grid
!                i.e. we run this code only when NOT in a glacier grid
!                only glacier flow bypasses the wetland
          qr(n)=amax1(qr(n),0.1e-10)
        else
!         not in a wetland so qlz        
!         water is added directly to the stream in route
          qr(n)=qr(n)+qlz(n)
          qr(n)=amax1(qr(n),0.1e-10)
        endif
! * * * * * * * * * * * * * * * * * * * * * * * * * 
!       HAVE TO DIVIDE BY FRAC TO NORMALIZE TO FULL GRID 
!       THE WATER AREA IS INCLUDED in the water class above
!     rev. 9.2.42  Jun.  20/06  - NK: water class included in the water balance
        sumrff(n)=sumrff(n)+qr(n)/tdum/frac(n)
!       ADD RAIN & SNOWMELT ON WATER AREA TO RUNOFF TOTAL
!       THIS IS NOT INCLUDED IN THE WATERBALANCE CHECK
!       WRITE ALL THE STUFF FOR THE RFF*.TXT FILES
!       FOR DEBUGGING AND PROCESS PLOTS
cd        if(iopt.eq.3)print*,' checkpoint 7 in runoff'
c        if(iopt.ge.1)then
        if(iopt99)then
          if (n.eq.nnprint)then
            mzz=mz-24*(mz/24)
!           if(mzz.eq.1)then
             classcount_9=min0(9,classcount)
             amon=float(mon)
             aju=float(ju)
!            this section repeated below
             if(snwflg.eq.'y'.or.vapflg.eq.'y')then
!              this is needed because memory is allocated 
!              only for these cases
               tempv1=tempv(n)
               tempvmin1=tempvmin(n)
               rh1=rh(n)
             else
               tempv1=-999.
               tempvmin1=-999.
               rh1=-999.
             endif

!     rev. 9.7.13  Nov.  22/10  - NK: Changed the outfiles.txt for more 50 rff classes
!     rev. 9.9.69  Jun.  10/15  - NK: prevent write ro rff if there is no class area
             do ii=1,classcount
               if(aclass(n,ii).gt.0.0)then
                 write(900+ii,6000)time,intevt(n,ii),evt(n,ii),
     *           p(ipr,jpr),sump(n),ssumr(n,ii),
     *           amin1(fake(ii),1000.),amin1(fakefs(ii),1000.),
!     rev. 10.2.39 Nov.  15/18  - NK: changed snowc(n,ii) to snowc(n,ii)*sca(n,ii) in runof6
     *           sca(n,ii),snowc(n,ii)*sca(n,ii),d1(n,ii),d1fs(n,ii),
     *           sumf(n,ii),sumffs(n,ii),uzs(n,ii),uzsfs(n,ii),lzs(n),
     *           q1(n,ii),q1fs(n,ii),qint(n,ii),qintfs(n,ii),qlz(n),
     *           drng(n,ii),drngfs(n,ii),qr(n),qstream(n),strloss(n),
     *           sumrff(n),fexcess(n,ii),glmelt(n),fmadj(n),
     *           sq1(ii),sq1fs(ii),sqint(ii),sqintfs(ii),
     *           sdrng(ii),sdrngfs(ii),slzinflw,sdlz,amon,aju,def(n,ii),
     *           tempv1,tempvmin1,rh1,           !psmear(n),punused(n),
     *           api(n,ii)*100.0,sublim(n,ii),sum_sublim(n,ii),
     *           v(n,ii),wcl(n,ii),sum_pet(n,ii),sum_et(n,ii),pet(n,ii),
     *           tto(n),ttomin(n)
               endif
             end do
!           endif
          endif
        endif
        
        
        
        
        qstrm(n)=qstream(n)
!     TRISH:  this means that qstream never got added to the lakes ?????????????
cccccccccccccccccccccccccc        qstream(n)=0.0                   
cd        if(iopt.eq.3)print*,' checkpoint 8 in runoff'

!       MODIFY THE UNSATURATED ZONE SOIL MOISTURE
!       THIS USED TO BE AT THE START OF THE LOOP - NO GOOD
!       ADJUST SOIL MOISTURE AFTER ALL CALCS 
!       THIS SHOULD BE DONE SEPERATELY FOR SCA - USE FEXCESS
!       INSTEAD OF RAIN
!       REV 7.9 EVAPORATION    
!       MODIFY THE UNSATURATES ZONE SOIL MOISTURE

!       SOIL MOISTURE IS ADJUSTED FOR DRYING OR NEW PRECIP
!       IF IT IS BELOW FREEZING, NO ADJUSTMENTS ARE MADE
!       THIS IS A KLUDGE
!       AND may HAVE TO BE FIXED SOMEDAY  <<<<<<<
        do ii=1,classcount
          if(snwflg.eq.'y'.or.vapflg.eq.'y')then
            if(ttemp(i,j).gt.0.0)then
              api(n,ii)=api(n,ii)*a51+p(i,j)/100.0          
!              effpor(n,ii)=por-api(n,ii)
!     rev. 9.4.06  May.  09/07  - NK: replaced por with spore(n,ii) in runof6
              effpor(n,ii)=spore(ii)-api(n,ii)
              effpor(n,ii)=amax1(0.0001,effpor(n,ii)) 
              effpor(n,ii)=amin1(por   ,effpor(n,ii))
            endif
          else
!           this bit of code has to be repeated because ttemp() 
!           has not been allocated memory for this case so
!           can't be used in a conditional
            api(n,ii)=api(n,ii)*a51+p(i,j)/100.0          
!            effpor(n,ii)=por-api(n,ii)
!     rev. 9.4.06  May.  09/07  - NK: replaced por with spore(n,ii) in runof6
            effpor(n,ii)=spore(ii)-api(n,ii)
            effpor(n,ii)=amax1(0.0001,effpor(n,ii)) 
            effpor(n,ii)=amin1(por   ,effpor(n,ii))
          endif
        end do     !  ii=
      endif            ! IF(slope(n).gt.0.0)THEN
cd      if(iopt.eq.3)print*,n,ii,time,' checkpoint 9 in runoff'
      end do                !  n=1,naa loop
      
c!$OMP END DO 
!$OMP END PARALLEL    

 
!     * * * * * * *   END OF MAIN LOOP   * * * * * * * * 

!     QR(n)=TOTAL STREAM INFLOW FROM grid(N) AND IS ROUTED
!     INTO THE DOWNSTREAM ELEMENT.
d      if(iopt.eq.3)print*,' checkpoint 10 in runoff'
      RETURN

1003  CONTINUE
!     END OF RUN
!     WRITE THE WATER BALANCE INFORMATION
d      if(iopt.eq.3)print*,' checkpoint 11 in runoff'

      if(numa.eq.0.and.resumflg.eq.'n'.and.iopt99)call watbal(3)
d      if(iopt.ge.3)write(*,5101)time
d      if(iopt.eq.3)print*,' checkpoint 12 in runoff'

      RETURN

! FORMATS
 5101 format(' at RETURN 6007 time=',f10.2)
 5102 format(/' por = ',f10.3/)
 5190 format(/,' qlzfrac =',f10.2,'  in runof5 <<<<<<<'/)

 6007 format(' n,ipr,jpr,aclass,frac/',3i5,17f8.2)
c 6000 format(' ',16(g8.2,','),1(g8.0,','),50(g8.3,','))
c 6000 format(' ',f8.0,999(',',g10.3))
      
 6000 format(' ',f8.0,3(',',g10.3),f10.1,999(',',g10.3))
     
 6001 format('     time',7x,'v',2x,'intcap',7x,'p',4x,'sump',7x,'r',
     *6x,'d2',6x,'q2',6x,'qr')
 6002 format(    '       time,    intevt,      evt,        p,',
     *  '      sump,      ssumr,     fake,    fakefs,',
     *  '       sca,     snowc,        d1,      d1fs,',
     *  '         sumf,    sumffs,',
     *  '     uzs,     uzsfs,       lzs,        q1,      q1fs,',
     *  '      qint,    qintfs,       qlz,      drng,    drngfs,',
     *  '       qr,    qstream,   strloss,    sumrff,',
     *  '   fexcess,    glmelt,  fmadjust,       sq1,     sq1fs,',
     *  '      sqint,  sqintfs,     sdrng,   sdrngfs,   slzinfl,',
     *  '      sdlz,     month,   jul_day,  heat_def,     tempv,',
     *  '     tempvmin,     rh,    API,',
     *  '     sublm,   sumsublm,       v,        wcl,',
     *  '     sumpet,     sumet,     pet,        tto,     ttomin')
 6003 format(9i8,f8.3)
 6004 format(5f12.5)
 6005 format(' n=',i5,' ii=',i5,' uzs=',f10.5) 
 6006 format(' ipr,jpr/=',2i5)
 6027 format(' ii=',i2,' smc=',f5.2,' effpor=',f5.2,
     * ' -> lower limit is set <-')
 6040 format(8a)
 6100 format
     *('0','    n    i    j        da       lzs     qbase in runof5'/)
 6201 format(i10,7f10.1)
 7010 format(' sump       ',f8.1/)
 7011 format(' ssumr       ',16f8.1/)
 7012 format(' d1         ',16f8.1/)
 7013 format(' sq1        ',16f8.1/)
 7014 format(' sumf       ',16f8.1/)
 7015 format(' usz        ',16f8.1/)
 7016 format(' sqint      ',16f8.1/)
 7017 format(' sdrng      ',16f8.1/)
 7021 format(' sexcess    ',16f8.1/)
 7022 format(' d1fs       ',16f8.1/)
 7023 format(' sq1fs      ',16f8.1/)
 7024 format(' sumffs     ',16f8.1/)
 7025 format(' uzsfs      ',16f8.1/)
 7026 format(' sqintfs    ',16f8.1/)
 7027 format(' sdrngfs    ',16f8.1/)
 7030 format(' aclass     ',16f8.2/)
 7031 format(' slzinflw   ',16f8.1/)
 7032 format(' lzs        ',16f8.1/)
 7033 format(' sdlz       ',f8.1/)
 7034 format(' sumrff     ',16f8.1/)
 7050 format('     ')
! 7401 format('    time fpet2(n)   uzsi'
!     * ,' tto(n)   intev ev(n.ii) pet(n.ii)'
!     * ,'uzs(n.ii)')
 7402 format('    time',<classcount>('   ET   ','   E    '))

! 8429 format(//' in runof5,flz/',5f10.6/
!     * ' wrong parameter value - change flz(',i2,') to +ve value'/)
59999 format(i5,4f12.5,'runof6 //')


      RETURN

      END SUBROUTINE runof6
       SUBROUTINE sed(jan,time,al)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      integer  :: jan
      real*4  :: time,al

!        this is a dummy subroutine

        RETURN

        END SUBROUTINE sed        SUBROUTINE sedfl(step)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     


!         SEDFLG IS IN AREA2A
c          USE area2

      use area_watflood
	implicit none


      real*4  :: step
          sedflg='n'
!         THIS IS A DUMMY SUBROUTINE

        RETURN

        END SUBROUTINE sedfl
        SUBROUTINE sedroute(div,t,jz,iz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      integer :: jz,iz
      real*4  :: div,y,t

!         this is a dummy subroutine

        RETURN
        END
      subroutine sensitivity
     *    (jan,smc5,conv,scale,icase,smok,optlow,igrdshft)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis

!     This subroutine carries out a sensitivity analysis of all
!     optimizable parameters


      use area_watflood
      USE EF_module
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(128):: qstr
      CHARACTER(72) :: junk
!      CHARACTER(14) :: date
      CHARACTER(1)  :: smok,rvrflg,cvrflg,debug_flag 
      character(20) :: rvrname(12),classname(24)
      CHARACTER*14    :: date
      INTEGER    :: iallcnt,icnt(5),ndir(5),nchr,ix,ios,icase,
     *              iallocate,igrdshft,iyshiftmin,iyshiftmax,
     *              jxshiftmin,jxshiftmax,ishift,jshift,inum,jnum,
     *              l,iw1,iw2,iv,iflg,i,n,ii,j,nhr,nhf,jan
      REAL(4)    ::   smc5(16),errold(5),err(5),chng(5),best(5),hmax
      REAL(4)    :: optlow,e1,scale,ddtemp,cc1,cc2,crit,conv,best1
      real(4)    :: opt_base,up_factor,down_factor,delta_factor
      integer*2  :: result1,ntest

!      DATA ntest/-1358/qstr/'options'/nchr/7/
      DATA ntest/43814/qstr/'optionsss'/nchr/9/
      DATA iallcnt/0/


      allocate(nrvr_array(nrvr,12),class_array(classcount,24),
     *            stat=iAllocate)
      if(iAllocate.ne.0) STOP
     *      'Error with allocation of area8a arrays in optionsa'

!     initialize array values:
      do ii=1,nrvr
        do i=1,12
          nrvr_array(ii,i)=0.0
        end do
      end do
      do ii=1,classcount
        do i=1,24
          class_array(ii,i)=0.0
        end do
      end do
      optim=0.0

      ensimflg='n'
      sensitivityflg=.true.  ! default = false - set in options

      print*
      print*,'Do you want sensitivities on the routing parameters? y/n'
      read*,rvrflg
      print*
      print*,'Do you wnat sensitivities on the hydrol. parameters? y/n'
      read*,cvrflg
      print*
	Print*,'Please enter the % delta you would like to use:'
	print*,'10% is not a bad value'
      read*,delta_factor
	print*

	if(rvrflg.eq.'y'.or.rvrflg.eq.'n')then
	  continue
	else
	  print*,'rvrflg=',rvrflg
	  print*,'Improper response given for routing question'
	  stop 'Program aborted in sensitivities @ 73'
	endif
	if(cvrflg.eq.'y'.or.cvrflg.eq.'n')then
	  continue
	else
	  print*,'cvrflg=',cvrflg
	  print*,'Improper response given for hydrol. question'
	  stop 'Program aborted in sensitivities @ 80'
	endif
	if(delta_factor.lt.0.0.or.delta_factor.gt.50)then
	  print*,'WARNING: delta_factor not between 0 & 50'
	  print*,'Enter your domain at your peril'
	  pause 'Hit enter to continue ^C to quit'
	endif
	
	debug_flag='n'
	if(iopt.ge.1)then
	  print*,'iopt = ',iopt,' is debug mode'
	  print*,'Do you want to run in this way y/n ?'
	  read*,debug_flag
	  if(debug_flag.eq.'n')then
	    debugflg=.false.
	    print*,'iopt set to 0'
	  else
	    print*,'OK. It will be messy!'
	  endif
	else
	  debugflg=.false.
	endif

      print*,'OK, thank you'

      rvrname(1)='flz'
      rvrname(3)='pwr'
      rvrname(5)='r2n'
      rvrname(7)='theta'
      rvrname(9)='kcond'
      rvrname(11)='rlake'
      classname(1)='rec'
      classname(3)='ak'
      classname(5)='akfs'
      classname(7)='retn'
      classname(9)='ak2'
      classname(11)='ak2fs'
      classname(13)='r3'
      classname(15)='mf'
      classname(17)='base'
      classname(19)='fratio'
      classname(21)='not_used'
      classname(23)='sublim_rate'

       
      id=1
      fln(99)='event/event.evt'
      call read_evt(date,conv,scale,smc5,nhr,nhf)
      ensimflg='n'
	call read_shed_ef(31,1)	
      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
      opt_base=optim
      optim=0.0
      print*,'base value =',opt_base
      print*,'errflg=',errflg
      print*,'-----------------------'

c      id=1
c      fln(99)='event/event.evt'
c      call read_evt(date,conv,scale,smc5,nhr,nhf)
c      ensimflg='n'
c	call read_shed_ef(31,1)	
c      call read_par_parser(32,2)    
c      call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
c      opt_base=optim
c      optim=0.0
c      print*,'base value =',opt_base
c      print*,'-----------------------'
      
      up_factor=1.0+(delta_factor/100.)
      down_factor=1.0-(delta_factor/100.)

      if(rvrflg.eq.'y')then
      print*,'flz:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        flz_o(ii)=flz_o(ii)*down_factor
        do n=1,naa
          flz(n)=flz_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
90111   format(a13,i3,a2,i3,a2,2f15.5)     
        nrvr_array(ii,1)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
	  if(debug_flag.eq.'n')iopt=0
        do n=1,naa
          flz(n)=flz_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,2)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'pwr:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        pwr_o(ii)=pwr_o(ii)*down_factor
         do n=1,naa
          pwr(n)=pwr_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
     
        nrvr_array(ii,3)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        pwr_o(ii)=pwr_o(ii)*up_factor
         do n=1,naa
          pwr(n)=pwr_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,4)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'r2n:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        r2n_o(ii)=r2n_o(ii)*down_factor
        do n=1,naa
          r2n(n)=r2n_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,5)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        r2n_o(ii)=r2n_o(ii)*up_factor
         do n=1,naa
          r2n(n)=r2n_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,6)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'theta:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        theta_o(ii)=theta_o(ii)*down_factor
        do n=1,naa
          theta(n)=theta_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,7)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        theta_o(ii)=theta_o(ii)*up_factor
        do n=1,naa
          theta(n)=theta_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,8)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'kcond:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        kcond_o(ii)=kcond_o(ii)*down_factor
        do n=1,naa
          kcond(n)=kcond_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,9)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        kcond_o(ii)=kcond_o(ii)*up_factor
        do n=1,naa
          kcond(n)=kcond_o(ibn(n))
        end do
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        nrvr_array(ii,10)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'rlake:'
      do ii=1,nrvr
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
	  if(rlake_o(ii).gt.0.0)then
          rlake_o(ii)=rlake_o(ii)*down_factor
          do n=1,naa
            rlake(n)=rlake_o(ibn(n))
          end do
          call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
          write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
          nrvr_array(ii,11)=(opt_base-optim)/opt_base*100.0
        else
          nrvr_array(ii,11)=-9.999
        endif
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
        ensimflg='n'
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)   
	  if(rlake_o(ii).gt.0.0)then
          rlake_o(ii)=rlake_o(ii)*up_factor
          do n=1,naa
            rlake(n)=rlake_o(ibn(n))
          end do
          call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
          write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
          nrvr_array(ii,12)=(opt_base-optim)/opt_base*100.0
        else
          nrvr_array(ii,12)=-9.999
        endif
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)
      endif


!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(cvrflg.eq.'y')then

      print*,'rec:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        rec(ii)=rec(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,1)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        rec(ii)=rec(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,2)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'ak:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak(ii)=ak(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,3)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak(ii)=ak(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,4)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'akfs:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        akfs(ii)=akfs(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,5)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        akfs(ii)=akfs(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,6)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'retn:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        retn(ii)=retn(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,7)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        retn(ii)=retn(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,8)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'ak2:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak2(ii)=ak2(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,9)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak2(ii)=ak2(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,10)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'ak2fs:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak2fs(ii)=ak2fs(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,11)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        ak2fs(ii)=ak2fs(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,12)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

      print*,'r3:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        r3(ii)=r3(ii)*down_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,13)=(opt_base-optim)/opt_base*100.0
        optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        r3(ii)=r3(ii)*up_factor
        call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *      (opt_base-optim)/opt_base*100.0,optim
        class_array(ii,14)=(opt_base-optim)/opt_base*100.0
        optim=0.0
      end do
      call write_sens_result(rvrname,classname,delta_factor)

	print*,'fm:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        fm(ii)=fm(ii)*down_factor
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,15)=(opt_base-optim)/opt_base*100.0
	  optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        fm(ii)=fm(ii)*up_factor
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,16)=(opt_base-optim)/opt_base*100.0
	  optim=0.0
	end do
	call write_sens_result(rvrname,classname,delta_factor)

	print*,'base:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        base(ii)=base(ii)-1
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,17)=(opt_base-optim)/opt_base*100.0
	  optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        base(ii)=base(ii)+1
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,18)=(opt_base-optim)/opt_base*100.0
	  optim=0.0
	end do
	call write_sens_result(rvrname,classname,delta_factor)

	print*,'fratio:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        fratio(ii)=fratio(ii)*down_factor
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,19)=(opt_base-optim)/opt_base*100.0
	  optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
        fratio(ii)=fratio(ii)*up_factor
	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	  class_array(ii,20)=(opt_base-optim)/opt_base*100.0
	  optim=0.0
	end do
	call write_sens_result(rvrname,classname,delta_factor)

	print*,'not_used:'
c      do ii=1,classcount
c        id=1
c        fln(99)='event/event.evt'
c        call read_evt(date,conv,scale,smc5,nhr,nhf)
c	  call read_shed_ef(31,1)	
c        call read_par_parser(32,2)    
c        ensimflg='n'
c!       fpetmo is calculated in read_par and is prop'l to ftall
c!       so we can't operated on ftall here
c        do i=1,12
c          fpetmo(i,ii)=fpetmo(i,ii)*down_factor
c        end do
c	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
c        write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
c     *	  (opt_base-optim)/opt_base*100.0,optim
c	  class_array(ii,21)=(opt_base-optim)/opt_base*100.0
c	  optim=0.0
c
c        id=1
c        fln(99)='event/event.evt'
c        call read_evt(date,conv,scale,smc5,nhr,nhf)
c	  call read_shed_ef(31,1)	
c        call read_par_parser(32,2)    
c        ensimflg='n'
c!       fpetmo is calculated in read_par and is prop'l to ftall
c!       so we can't operated on ftall here
c        do i=1,12
c          fpetmo(i,ii)=fpetmo(i,ii)*up_factor
c        end do
c	  call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
c        write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
c     *	  (opt_base-optim)/opt_base*100.0,optim
c	  class_array(ii,22)=(opt_base-optim)/opt_base*100.0
c	  optim=0.0
c	end do
	call write_sens_result(rvrname,classname,delta_factor)

	print*,'sublim_rate:'
      do ii=1,classcount
        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
	  if(sublim_rate(ii).gt.0.0)then
          sublim_rate(ii)=sublim_rate(ii)*down_factor
	    call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
          write(*,90111)'sensitivity -',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	    class_array(ii,23)=(opt_base-optim)/opt_base*100.0
        else
          class_array(ii,23)=-9.999
	  endif
	  optim=0.0

        id=1
        fln(99)='event/event.evt'
        call read_evt(date,conv,scale,smc5,nhr,nhf)
	  call read_shed_ef(31,1)	
        call read_par_parser(32,2)    
        ensimflg='n'
	  if(sublim_rate(ii).gt.0.0)then
          sublim_rate(ii)=sublim_rate(ii)*up_factor
	    call sub(jan,1.0,smc5,conv,scale,icase,smok,optlow,igrdshft)
          write(*,90111)'sensitivity +',int(delta_factor),'%(',ii,')=',
     *	  (opt_base-optim)/opt_base*100.0,optim
	    class_array(ii,24)=(opt_base-optim)/opt_base*100.0
        else
          class_array(ii,24)=-9.999
        endif
	  optim=0.0
	end do
	call write_sens_result(rvrname,classname,delta_factor)
	endif

	return

	end subroutine sensitivity

!******************************************************************

      SUBROUTINE soilinit

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!
!     REV. 8.31  - June   3/97 -  added initial uzs values in evap.par
!     REV. 8.96  - Apr.  26/99 -  lower zone function related to nbsn
!     REV. 8.99f - Jan. 7/2000 -  changed uzs calcs re: shari's data
!
!     REV. 9.00  - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90
!     REV. 9.03    Nov.  2000  -  TS: ADDED WATFLOOD SWAMP ROUTING 
!     rev. 9.2.42  Jun.  20/06  - NK: water class included in the water balance
!
!***********************************************************************

      use area_watflood
	implicit none

      integer       :: nflag,jj,ios,i,j,n,ii
      real (4)      :: ff1                    !,xxx1
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

d      if(iopt.eq.2)print*,' checkpoint 1 in soilinit'

	do i=1,ycount
         do j=1,xcount
            sn1(i,j)=0.0
         end do
      end do


!     Initialize these - unknown values so set = 0.0
      do n=1,naa
	  eloss(n)=0.0
        do ii=1,classcount
          wcl(n,ii)=0.0
	    v(n,ii)=0.0
        end do
      end do

      write(98,*)'Info: Free water in snowpack set = 0.0'
	write(98,*)'Info: Interceptions storage  set = 0.0'

      sqlz=0.0
      slzinflw=0.0

d      if(iopt.eq.2)print*,' checkpoint 2 in soilinit'


      do n=1,naa
            i=yyy(n)
            j=xxx(n)
            d2(n)=0.000001
            nflag=1
!           A VALUE OF NFLAG > 0 INDICATES THERE IS SNOW ON THE GROUND
    

!           REV. 7.5 SEPERATE SNOW COVERED AND BARE GROUND
!           SET INITIAL VALUES FOR EACH SOIL & EACH ELEMENT:
            do ii=1,classcount
              if(nclass(ii).ne.'water     ')then ! added Jul.11/06 nk
!               aclass(n,ii)=amax1(aclass(n,ii),0.0)
!               aclass(n,ii)=amin1(aclass(n,ii),1.0)
                v(n,ii)=0.0
!               the next two were added Jun. 3/02  nk
	          ev(n,ii)=0.0
	          evt(n,ii)=0.0
	          intevt(n,ii)=0.0
                d1(n,ii)=0.000001
                d1fs(n,ii)=0.000001
!     rev. 8.99f - Jan. 7/2000-     changed uzs calcs re: shari's data
                uzs(n,ii)=retn(ii)*api(n,ii)/spore(ii)
                uzsfs(n,ii)=retn(ii)*api(n,ii)/spore(ii)
	          uzs(n,ii)=amin1(retn(ii),uzs(n,ii))
	          uzsfs(n,ii)=amin1(retn(ii),uzsfs(n,ii))
                sumf(n,ii)=0.0
                sumffs(n,ii)=0.0
              else
!     rev. 9.2.42  Jun.  20/06  - NK: water class included in the water balance
!               this line added Sep. 13/06 nk
	          evt(n,ii)=0.0
	          intevt(n,ii)=0.0
                uzs(n,ii)=0.0       !used for the water class water balance only
                uzsfs(n,ii)=0.0     !used for the water class water balance only
                d1(n,ii)=0.0        !just so rff files don't have junk
                d1fs(n,ii)=0.0      !just so rff files don't have junk
	        endif

!             SET INITIAL UNSATURATED ZONE EFFECTIVE POROSITY:
!             THE EFFECTIVE POROSITY DEPENDS ON SOIL MOISTURE
!             WHICH IS ENTERED FOR EACH GRID
!             effpor is for the intermediate zone so same for bare & sca
              effpor(n,ii)=spore(ii)-api(n,ii)
              effpor(n,ii)=amax1(0.0001,effpor(n,ii))
              effpor(n,ii)=amin1(spore(ii),effpor(n,ii))
              if(api(n,ii).lt.0.0)then
!                write(*,6027)n,ssmc(i,j),effpor(n)
                api(n,ii)=0.0
              endif
            end do
      end do

d      if(iopt.eq.2)print*,' checkpoint 3 in soilinit'

d      if(iopt.eq.2)print*,' checkpoint 4 in soilinit'


!     These valuse may be reset in etin.for
!     but are initialized here to have values in the soil_init.r2c file
!     if this file is written only at start of spl run nk Nov. 13/06
      do n=1,naa   
        tto(n)=tton            ! tton set in the par file
        ttomin(n)=1.0e+32
        ttomax(n)=-1.0e+32
        fpet2(n)=1.0
      end do

d      if(iopt.eq.2)print*,' checkpoint 4a in soilinit'


!     * * * * END OF THE INITIALIZATION (JAN) * * * *

! FORMATS

 6008 format(/' Error: DA <= 0.0 in el. n=',i5/)
 6100 format
     *('0','    n    i    j        da       lzs     qbase in runof5'/)
 6102 format(' ',3i5,3e10.3)

      if(iopt.ge.1)then
        print*
        print*,'Soil initialization completed'
        print*
      endif  


      RETURN

      END SUBROUTINE soilinit

!****************************************************************************
!
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!  PROGRAM: Stats
!
!  PURPOSE:  To calculate Nash, r^2, RMS, RMS/avg and %Dv using watflood output files
!
!  WRITEN BY: Angela MacLean, September 2005
!
!  Revised  NK Sept. 6/06
!
!****************************************************************************

!     rev. 9.6.01  Mar.  01/10  - NK: DDS capability added
!     rev. 9.8.47  Feb.  04/13  - NK: Headers added for spl & resin csv files
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
!     rev. 9.8.66  Jun   03/13  - NK: Added error_Dv.txt output in stats.f
!     rev. 9.9.54  Jan.  19/15  - NK: Put par & shd file names for 1st event in the headers

c      implicit none

      subroutine Stats(unitNum,flnNum)
      
	use area_watflood
      use areacg
	implicit none


	save

      real*4, dimension(:),   allocatable :: 
     *    sumAct,sumSA,sumSAsqr,ActAvg,
     *    sumAAsqr,SimAvg,SumSSsqr,sumSim,
     *    sumSimsqr, sumActsqr, stdAct, stdSim,
     *    Correl,Dv,RMS,rNr,RMS2,
     *    APB,sumAbsSA,aMAE,bias,garAvg,
     *    sumGar,Garrick,sumAA,sumSS,sumAASS
	integer nash_count,unitNum,flnNum
         
      real*4, dimension(:,:),allocatable :: Act,Sim     
	real*4  nash_mean,r2_mean,dv_mean,count
      real*4  mean_18O,mean_2H,count_18O,count_2H

      real nsum,nash_sum,Dv_Sum,rms_sum,sumR2,sumRMS2,sumRMS

      integer, dimension(:), allocatable :: junk,numValues
      integer iflag, intValues, daily, intdays, intRemain, intTotal,
     *      intGar,anallines,hourly
	integer  iAllocate,nstations,ii,jj,kk,ios,i,j
      logical*1 exists,firstpass,printflg
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday
	character(1)   :: yn
	character(80) :: line

      data firstpass/.true./

      print*
      print*,'Calculating the statistics instats:'

      nstations = no + noresvi
!     no = # flow stations
!     noresvi = # reservoir inflows      
	anallines=int(totaltime)/kt

      if(firstpass)then
      allocate(junk(anallines),numValues(nstations),
     *  Act(nstations,anallines),Sim(nstations,anallines),
     *  sumAct(nstations),sumSA(nstations),
     *  sumSAsqr(nstations),ActAvg(nstations),
     *  sumAAsqr(nstations),SimAvg(nstations),
     *  SumSSsqr(nstations),sumSim(nstations),
     *  sumSimsqr(nstations), sumActsqr(nstations), 
     *  stdAct(nstations), stdSim(nstations),
     *  Correl(nstations),Dv(nstations),RMS(nstations),
     *  rNr(nstations),RMS2(nstations),
     *  APB(nstations),sumAbsSA(nstations),aMAE(nstations),
     *  bias(nstations),garAvg(anallines),
     *  sumGar(nstations),Garrick(nstations),
     *  sumAA(nstations),sumSS(nstations),
     *  sumAASS(nstations),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *         'Error with allocations  in stats @ 76'
          
      endif

      if(.NOT.allocated(R2))then 
        allocate(r2(nstations),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *         'Error with allocation of R2 in stats @ 30'
      endif

      OPEN(UNIT=unitNum,FILE=filename(flnNum), status='unknown')
!     rev. 10.2.05 Oct   28/17  - NK: Killed off stats_info.txt for iopt.ge.1
      if(iopt99)OPEN(UNIT=99,FILE='debug\stats_info.txt',
     *                          status='unknown')

      write(unitNum,*)'***************************************'
      write(unitNum,*)'*                                     *'
      write(unitNum,*)'*          WATFLOOD (R)               *'
      write(unitNum,*)'*          CHARM    (TM)              *'
      write(unitNum,*)'*                                     *'
      write(unitNum,*)'*      Version ',program_version,'             *'
      write(unitNum,*)'*      Compile date ',program_date,'        *'
      write(unitNum,*)'*                                     *'
      write(unitNum,*)'*       User conditions stated        *'
      write(unitNum,*)'*    in the WATFLOOD manual apply     *'
      write(unitNum,*)'*                                     *'
      write(unitNum,*)'*      (c) N. Kouwen, 1972-2018       *'
      write(unitNum,*)'*                                     *'
      write(unitNum,*)'***************************************'
      write(unitNum,*)

      call date_and_time(cday,time)
      write(unitNum,5026)time(1:2),time(3:4),time(5:6),
     *              cday(7:8),cday(5:6),cday(1:4)
5026  format(' Created     :      ',
     *        2(a2,':'),a2,2x,a2,'-',a2,'-',a4/)

	if(kt.eq.1)daily=2
	if(kt.eq.24)daily=1
c	skiplines=0

      if(iopt99)then
      write(99,*)'kt=',kt
	write(99,*)'no=',no
      write(99,*)'noresvi=',noresvi
      write(99,*)'daily=',daily
      write(99,*)'skiplines=',skiplines
	write(99,*)'anallines=',anallines
      endif

d     print*,'In stats'

11111 continue

	rewind 60
	rewind 73

!     rev. 9.8.47  Feb.  04/13  - NK: Headers added for spl & resin csv files
      if(hdrflg0)read(60,*,iostat=ios)(line,ii=1,no*2+1)
  
!     skip over the specified no of  record
      if(skiplines.gt.0)then
        do jj=1,skiplines
          read(60,9002,iostat=ios)junk(jj)
        end do
      endif
!      pause 11

      ios=0
      jj=1
	do ii=1,no
	  numvalues(ii)=0.0
	end do

      if(iopt99)write(99,*)'obs & computed streamflows:'
      do jj=(skiplines+1),anallines
        read(60,*,iostat=ios)
     *      kk,(Act(ii,jj),Sim(ii,jj),ii=1,no)
97001   format(i10,999f10.3)
        if(ios.ne.0)then
          print*,'end of data in line(1)',skiplines+jj
        else
          if(iopt99)write(99,97001)
     *        kk,(Act(ii,jj),Sim(ii,jj),ii=1,no)
        endif 
      end do
       
!     skip over the specified no of  record
!     the same as for the str file
      if(skiplines.gt.0)then
        do jj=1,skiplines
          read(73,*,iostat=ios)junk(jj)
        end do
      endif
      print*,'in stats - # lines in resin.txt =',anallines
!     read the lake inflow values: actual,computed
      if(noresvi.gt.0)then
        do jj=(skiplines+1),anallines
          read(73,*,iostat=ios)
     *    junk(jj),(Act(ii,jj),Sim(ii,jj),ii=no+1,nstations)
97002     format(i10,999f10.3)
          if(ios.ne.0)then
            print*,'end of data in line(1)',skiplines+jj
          else
            if(iopt99)write(99,97001)
     *        jj,(Act(ii,jj),Sim(ii,jj),ii=no+1,nstations)
          endif 
c          if(ios.ne.0)then
c            print*,'end of data in line(2)',skiplines+jj
c            go to 15
c          endif 
        end do
      endif

15    continue

c      pause 2

!     Next step is to preform the calclations to do this we need to sum 
!     the values to preform the necessary calculations 
      
c      intValues = jj-1
      intValues=anallines

      do ii=1,nstations
	  numvalues(ii)=0
!       Initialize the data for the calculationsc
c        do jj=1,intValues
          sumAct(ii) = 0.0
          sumSim(ii) = 0.0
          sumActsqr(ii) = 0.0
          sumSimsqr(ii) = 0.0
          sumSA(ii) = 0.0
          sumSAsqr(ii) = 0.0
          sumAbsSA(ii) = 0.0
	    sumAASS(ii)=0.0
          sumAA(ii) = 0.0
          sumSS(ii) =0.0
          sumAAsqr(ii) = 0.0
          sumSSsqr(ii) =0.0
          Correl(ii) = 0.0
          sumGar(ii) = 0.0
c        end do
      end do

c      pause 3

      if(iopt99)then
          write(99,*)
          write(99,*)'Sums:'
      endif
      
      do ii=1,nstations
!     Use only values if both actual & computed are > 0.0
!     Sum the data for the calculations
        do jj=1,intValues
c          if(Act(ii,jj).gt.0.0000.or.ii.gt.no)then
c          if(Act(ii,jj).gt.0.0000)then
!     rev. 10.2.64 Sep.  09/26  - NK added min_flow_cutoff for error calculations
          if(Act(ii,jj).gt.min_flow_cutoff)then
            numValues(ii) = numValues(ii) + 1
            sumAct(ii) = sumAct(ii) + Act(ii,jj)
            sumSim(ii) = sumSim(ii) + Sim(ii,jj)
            sumActsqr(ii) = sumActsqr(ii) + (Act(ii,jj))**2
            sumSimsqr(ii) = sumSimsqr(ii) + (Sim(ii,jj))**2
            sumSA(ii) = sumSA(ii) + (Sim(ii,jj)-Act(ii,jj))
            sumSAsqr(ii) = sumSAsqr(ii) + (Sim(ii,jj)-Act(ii,jj))**2
            sumAbsSA(ii) = sumAbsSA(ii) + abs(Sim(ii,jj)-Act(ii,jj))
	    endif
        end do
        if(iopt99)write(99,9901)ii,numvalues(ii),sumAct(ii),sumSim(ii),
     *   sumActsqr(ii),sumSimsqr(ii),sumSA(ii),sumSAsqr(ii),sumAbsSA(ii)
9901   format(2i10,999g15.3)
      end do

!      pause 4
      if(iopt99)then
      write(99,*)
      write(99,*)'Averages:'
      write(99,*)'  location no observations  sum_actual  sum_computed'
     *          ,'actual mean  computed mean'
      endif     
      do ii=1,nstations
!     Calclate the averages
        if(numValues(ii).gt.0)then
          ActAvg(ii)= sumAct(ii)/numValues(ii)   ! mean observed
          SimAvg(ii)= sumSim(ii)/numValues(ii)   ! mean computed
        else
          ActAvg(ii)=0.0   
          SimAvg(ii)=0.0   
	  endif
	  if(iopt99)write(99,9902)ii,numValues(ii),sumAct(ii),sumSim(ii),
     *	  ActAvg(ii),SimAvg(ii)
9902   format(2i10,999f15.3)
      end do
      
!     Finish summing the values
      do ii=1,nstations
        do jj=1,intValues
          if(Act(ii,jj).gt.0.0000)then
            sumAA(ii) = sumAA(ii) + (Act(ii,jj)-ActAvg(ii))
            sumSS(ii) = sumSS(ii) + (Sim(ii,jj)-SimAvg(ii))
	      sumAASS(ii)  = sumAASS(ii)+
     *              (Act(ii,jj)-ActAvg(ii))*(Sim(ii,jj)-SimAvg(ii))
            sumAAsqr(ii) = sumAAsqr(ii) + (Act(ii,jj)-ActAvg(ii))**2
            sumSSsqr(ii) = sumSSsqr(ii) + (Sim(ii,jj)-SimAvg(ii))**2

	      if(sumAAsqr(ii).gt.0.0.and.sumSSsqr(ii).gt.0.0)then
              R2(ii)=
     *        (sumAASS(ii)/(sqrt(sumAAsqr(ii))*sqrt(sumSSsqr(ii))))**2
	      else
	        r2(ii)=-9.99
            endif
	    endif
c          Correl(ii) = Correl(ii) + 
c     *             (Act(ii,jj)-ActAvg(ii))*(Sim(ii,jj)-SimAvg(ii))
        end do
      end do

!     Garrick requiers a special procedure.  Garrick will only be callculated if the spl.csv
!     file contains hourly values.  from the hourly values the mean for each day will be calculated.
 
!      pause 9

      If(daily.eq.2)then
        Do ii=1,nstations
            
          intTotal=1

!     find the number of days
          intdays = numValues(ii)/24
          if(mod(numValues(ii),24).eq.0)then
            intRemain = 24
          Else
            intRemain = mod(intdays,24)
            intdays = intdays + 1
          Endif

!     Calculate the daily avgerages
          do jj=1,intdays
            if(jj.eq.intdays)then
              do kk=1,intRemain
                nsum = nsum + Act(ii,intTotal)
                intTotal = intTotal + 1                   
              enddo
                garAvg(jj) = nsum/intRemain               
                nsum = 0
              else
                do kk=1,24 
                  nsum = nsum + Act(ii,intTotal)
                  intTotal = intTotal + 1
              enddo
            garAvg(jj) = nsum/24
            nsum=0
          Endif
        enddo

!     Sum the vaules subtracting the approate avgerage 
        intGar = 1
        do jj = 1,numValues(ii)
          sumGar(ii)= sumGar(ii) + (Act(ii,jj) - garAvg(intGar))**2         
          intGar = (jj/24)+1
        enddo

!     Calculate Garrick
        Garrick(ii) = 1 - (sumSAsqr(ii)/sumGar(ii))                 
      
        enddo
	else
        Do ii=1,nstations
          Garrick(ii)=0.0
	  end do
      endif

!      pause 15

!     Now that the sums for all the values have been calculated the stats can be calculated
!     Deviation of Runoff volumes(Dv%)
!     Root mean squared Error (RMS)
!     Nash-Sutcliffe Coefficient (rNr)
!     Correlation Coefficient squared (R2)
!     RMS/qbar(avg observed flows) (RMS2)
!     Absolute percent bias (APB)
!     Mean Absolute Error (aMAE)
!     Bias (bias)
      
      do ii=1,nstations
        if(sumact(ii).gt.0.0)then
          Dv(ii) = (sumSA(ii)/sumAct(ii))*100
        else
          Dv(ii)=-999.99
        endif
        if(numValues(ii).gt.0)then
          RMS(ii) = SQRT(sumSAsqr(ii)/numValues(ii))
	  else
          RMS(ii) = -999.0
        endif
        
!     rev. 10.2.26 Jul.  03/18  - NK: Fixed nash e calculation for denominator = 0
        if(sumAAsqr(ii).ne.0.0)then
          rNr(ii) = 1.0 - (sumSAsqr(ii)/sumAAsqr(ii))
        else
          rNr(ii) = 0.0  
        endif  
        
c          R2(ii)=((Correl(ii)/numValues(ii))/(stdAct(ii)*stdSim(ii)))**2
        RMS2(ii) = RMS(ii)/ActAvg(ii)
        APB(ii) = (sumAbsSA(ii)/sumAct(ii))*100
        aMAE(ii) = sumAbsSA(ii)/numValues(ii)
        bias(ii) = sumSA(ii)/numValues(ii)
        if(iopt99)write(99,*)
     *        ii,numValues(ii),sumSAsqr(ii),sumAAsqr(ii),ActAvg(ii)
      end do

!     Print out on Screen  
      print*,'Nash-Sutcliffe Coefficient (rNr)'
      print*,'Correlation Coefficient squared (R2)'
      print*,'Root mean squared Error (RMS)'
      print*,'RMS/qbar(avg observed flows) (RMS2)'
      print*,'Deviation of Runoff volumes(Dv%)'
      print*,'Absolute percent bias (APB)'
      print*,'Bias (bias)'
      print*,'Mean Absolute Error (MAE)'
      print*,'Weight w = abs(Dv)'
      write(*,*)
      write(*,*)'No of streamflow data points ',anallines
      write(*,*)'Min flow cutoff  ',min_flow_cutoff
      write(*,*)'No of skipped data points ',skiplines
      write(*,*)'Parameter file: ',par_fln(1:60)
	write(*,*)'Precipitation scale factor =',scaleall
      write(*,*)
      write(*,6002)

 !    Print to File
      write(unitNum,*)'Deviation of Runoff volumes(Dv%)'
      write(unitNum,*)'Root mean squared Error (RMS)'
      write(unitNum,*)'Nash-Sutcliffe Coefficient (rNr)'
      write(unitNum,*)'Correlation Coefficient squared (R2)'
      write(unitNum,*)'RMS/qbar(avg observed flows) (RMS2)'
      write(unitNum,*)'Absolute percent bias (APB)'
      write(unitNum,*)'Bias (bias)'
      write(unitNum,*)'Mean Absolute Error (aMAE)'
      write(unitNum,*)'Weight w = abs(Dv)'
      write(unitNum,*)
      write(unitNum,*)'No of streamflow data points ',jj-1
      write(unitNum,*)'Min flow cutoff  ',min_flow_cutoff
      write(unitNum,*)'No of skipped data points ',skiplines
      write(unitNum,*)'Parameter file: ',par_fln(1:60)
	write(unitNum,*)'Precipitation scale factor =',scaleall
      write(unitNum,*)
      write(unitNum,6003)

      do ii=1,no
!       add error check iostat Feb. 6/13 NK          
	  if(numValues(ii).gt.0.and.SimAvg(ii).gt.0.001.and.nopt(ii).eq.1)then
          write(*,6004,iostat=ios)
     *       ii,rNr(ii),-1.0,R2(ii),RMS(ii),RMS2(ii),
     *                 Dv(ii),APB(ii),bias(ii),aMAE(ii)
        else
          write(*,6006,iostat=ios)ii,'no data or not selected'
	  endif
      end do

      printflg=.true.
      do ii=no+1,nstations
	  if(ii.gt.no.and.printflg)then
	    print*,'Lake/Reservoir inflows'
	    printflg=.false.
	  endif    
!       add error check iostat Feb. 6/13 NK          
	  if(numValues(ii).gt.0.and.SimAvg(ii).gt.0.001.
     *                            and.nopt(no+ii).eq.1)then
          write(*,6004,iostat=ios)
     *       ii,rNr(ii),-1.0,R2(ii),RMS(ii),RMS2(ii),
     *                 Dv(ii),APB(ii),bias(ii),aMAE(ii)
        else
          write(*,6006,iostat=ios)ii,'no data or not selected'
	  endif
      end do
	print*
	print*,'Please see stats.txt file for copy of above stats'
	print*

!      pause 17

	nash_count=0
	nash_sum=0.0
	rms_sum=0.0
	sumR2=0.0


!     Print to File
      do ii=1,nstations
c      do ii=1,no
	  if(numValues(ii).gt.0.and.SimAvg(ii).gt.0.001)then
	    if(ii.eq.no+1)write(unitNum,*)'Lakes/Reservoir inflows'
          write(unitNum,6004,iostat=ios),ii,rNr(ii),-1.0,R2(ii),
     *      RMS(ii),RMS2(ii),Dv(ii),APB(ii),bias(ii),aMAE(ii),ActAvg(ii)
     *      ,R2(ii)*abs(Dv(ii))/100.0,numValues(ii)
!         no point trying to fit hydrographs with N-S efficiency less than -1
!     rev. 9.6.01  Mar.  01/10  - NK: DDS capability added
!         calculate the modified Nash-Sutcliffe coefficient
c          if(nopt(ii).gt.0)then
            if(rNr(ii).gt.-1.0.and.rNr(ii).le.1.0)then
              nash_count=nash_count+1
              if(abs(Dv(ii)).gt.a4)then
                nash_sum=nash_sum+rNr(ii)-a3*(Dv(ii)-a4)*(Dv(ii)-a4)
	        else
!               no penalty for small Dv error
	          nash_sum=nash_sum+rNr(ii)
	        endif
              Dv_Sum=Dv_Sum+Dv(ii)*Dv(ii)
	        rms_sum=rms_sum+RMS2(ii)
	        sumR2=sumR2+R2(ii)
	        sumRMS=sumRMS+RMS(ii)
	        sumRMS2=sumRMS2+RMS2(ii)
c	        print*,nash_count,a3,a4,rNr(ii),Dv(ii)
c	        print*,nash_sum
	      endif
c	    endif
        else
          write(unitNum,6004,iostat=ios)ii
	  endif
      end do

!     This sectin added May 24, 2011  NK
      nash_mean=0.0
	r2_mean=0.0
	dv_mean=0.0
	count=0.0

	do ii=1,int(nstations)
!     rev. 10.2.25 May   27/18  - NK: Fixed nash e calculation for value1=nopt=0
        if(numValues(ii).gt.0.and.nopt(ii).eq.1)then
	    count=count+1.0
	    nash_mean=nash_mean+rNr(ii)
	    r2_mean=r2_mean+R2(ii)
	    dv_mean=dv_mean+abs(dv(ii))
	  endif
	end do

	nash_mean=nash_mean/count
	r2_mean=r2_mean/count
	dv_mean=dv_mean/count

	write(*,*)
	write(*,*)'Mean Nash   = ',nash_mean
	write(*,*)'Mean R^2    = ',r2_mean
	write(*,*)'Mean abs(Dv)= ',dv_mean
	write(unitnum,*)
	write(unitnum,*)'Mean Nash   = ',nash_mean
	write(unitnum,*)'Mean R^2    = ',r2_mean
	write(unitnum,*)'Mean abs(Dv)= ',dv_mean
      

!     rev. 10.1.89 May   25/17  - NK: Added errflg = 11 for isotope DDS
      if(frcflg.eq.'y')then
        mean_18O=0.0
        count_18O=0.0
        do j=1,n18O
          if(iso_rms_18O(j).gt.0.0)then
              mean_18O=mean_18O+iso_rms_18O(j)
              count_18O=count_18O+1.0
          endif
        end do
        mean_18O=mean_18O/count_18O
        
        mean_2H=0.0
        count_2H=0.0
        do j=1,n2H
          if(iso_rms_2H(j).gt.0.0)then
              mean_2H=mean_2H+iso_rms_2H(j)
              count_2H=count_2H+1.0
          endif
        end do
        mean_2H=mean_2H/count_2H
        
        write(*,*)
        write(*,*)'Isotope RMS error       '
        write(*,*)
     * 'Location  # readings   error 18O    # readings   error 2H'
        do j=1,n18O
          write(*,90100)j,
     *     iso_n_18O(j),iso_rms_18O(j),iso_n_2H(j),iso_rms_2H(j)
90100     format(i8,i12,f12.2,i12,f12.2)          
        end do
        write(*,*)
      
        write(unitnum,*)  
        write(unitnum,*)'Isotope RMS error      '
        write(unitnum,*)
     * 'Location   # readings   error 18O   # readings   error 2H'
        do j=1,n18O
          write(unitnum,90100)j,
     *     iso_n_18O(j),iso_rms_18O(j),iso_n_2H(j),iso_rms_2H(j)
        end do
        write(unitnum,*)
      
	  write(*,*)'Mean_18O    = ',mean_18O
	  write(*,*)'Mean 2H     = ',mean_2H
	  write(unitnum,*)'Mean_18O    = ',mean_18O
	  write(unitnum,*)'Mean 2H     = ',mean_2H
      endif


	open(unit=99,file='debug\stats_means.csv',status='unknown')
	write(*,99999)
c	write(*,99999)nash_mean,r2_mean,dv_mean
c	write(99,99999)nash_mean,r2_mean,dv_mean
	if(iopt99)write(99,*)nash_mean,r2_mean,dv_mean
99999	format(f7.3,',',f7.3,',',f7.2)
      close(unit=99,status='keep')
      close(unit=unitNum,status='keep')
      firstpass=.false.
      
!     rev. 9.8.66  Jun   03/13  - NK: Added error_Dv.txt output in stats.f
      open(unit=99,file='error_Dv.txt',status='unknown',iostat=ios)
      if(ios.ne.0)then
        print*,'Error opening error_Dv.txt in working directory'
        print*,'File not written'
        print*
        return
      endif
      if(iopt99)then
      do ii=1,nstations
        write(99,99001)ii,dv(ii)
99001   format(i5,f10.1)        
      end do
      close(unit=99,status='keep')  
      endif
          
      
	return

6002  format(' locn  Nash   Garrick   r^2     rms   rms/qbar  %Dv'
     +     '     APB     Bias     MAE')
6003  format(' locn  Nash   Garrick   r^2     rms   rms/qbar  %Dv'
     +     '     APB     Bias     MAE   Qbar  w*r^2   # observed')
6004  format(i4,11f8.2,i10)
c6004  format(i4,2f7.2,2f10.2,8f7.2)
6005  format(a18,a60)
6006  format(i4,a60)
    
7001  format(i5,30f10.3)
9001  format(5X,100(f7.0,1X))
9002  format(i4,1X,100(f9.0,1X))
9003  format(10f10.0)
      
      
      end subroutine Stats

      suBROUTINE sub(jan,e1,smc5,conv,scale,icase,smok,optlow,igrdshft)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

!  THIS SUBROUTINE ORGANIZES ALL THE CALCULATIONS.

!     REV. 7.51 oct.  08/95   -   revise init channel flow in SUB
!     REV.        aug   07/96 - to read in mica inflow file and
!                       use mica data for optimization when
!                       maxn=2002
!     REV. 7.80 Oct.  29/96   - spl7 added yymmdd.rin for res inflows
!                     - unit = 49   fln = 19
!     REV. 7.9  Dec   18/96   - Todd's Evaporation, changed above
!                       res inflows to unit=99  fln=21
!     REV. 8.1  - Feb.    15/96 - TBC & RSM (to be continued & resume) 
!     REV. 8.61 - Dec.    12/97 - added contflg for statistics cont'n
!     REV. 8.75 - Apr.    27/89 - took da out of the resume file
!     REV. 8.90 - Dec.    04/98 - input to memory for opt runs
!     REV. 8.91 - Dec.    07/98 - read rdevt in sub as well as spl!
!     REV. 8.94 - Feb.    01/99 - crseflg to read resume & snow course
!     REV. 8.82 - July    10/98 - added runoff output option: routeflg
!     REV. 8.82 - July    10/98 - added runoff output option: routeflg
!     REV. 8.83 - Oct.    23/98 - added step to the lst argument list
!     REV. 8.86 - Nov.    02/98 - fixed opt problem found by ted.
!     REV. 8.96.1 May 12/99 - added ireport for reporting interval
!     REV. 8.98   July    15/99 - met grid increased
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 
!     rev. 9.1.18  Jun.  03/02  - Added sub-watershed modelling capability
!     rev. 9.1.21  Jun.  28/02  - Added wetland storage & outflow to the wfo file
!     rev. 9.1.23  Jul.  23/02  - Added control for nudging in event #1
!     rev. 9.1.28  Sept. 19/02  - Added shedlfg to replace the bsnm.shd file
!     rev  9.1.29  Oct.  24/02  - Added q1, qint & drng to wfo file
!     rev. 9.1.35  Dec.  26/02  - Added wetland & channel heights to the wfo file
!     rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
!     rev. 9.1.42  May     31/03  - Tracer module added - first try
!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!     rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added
!     rev. 9.1.47  July  11/03  - TS: Tracer s/r call line modified 
!     rev. 9.1.50  Jan.  14/04  - NK: version number added to the wfo_spec.txt file
!     rev. 9.1.51  Jan.  28/04  - NK: added iz.ne.jz conditional to ENSIM output  
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_flow
!     rev. 9.1.81  Apr.  04/05  - NK: added sublimation,et and etfs to wfo file
!     rev. 9.2.05  Jul.  15/05  - NK: reversed order of reading resume file 
!     rev. 9.2.07  Jul.  29/05  - NK: soilinit moved from runoff to sub 
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 
!     rev. 9.2.25  Dec.  13/05  - NK: ENSIM r2c gridded soil moisture 
!     rev. 9.2.28  Jan.  30/06  - NK: Added low slope a4 for grids with water
!     rev. 9.2.30  Feb.  07/06  - NK: Added class_distribution.txt to output
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.3.02  Jul.  18/06  - NK: converted runof, rchrg & lkage to r2c
!     rev. 9.3.08  Jan.  15/07  - NK: added lzs_init_new.r2c output to sub.for
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!     rev. 9.4.14  Jul.  09/07  - NK: added lake loss file 
!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
!     rev. 9.5.18  Mar.  03/08  - NK: added conv to options & sub argument list
!     rev. 9.5.19  Mar.  05/08  - NK: prevented use of tracer * iso models with nudging
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!     rev. 9.5.31  May.  27/08  - NK: moved totsnw(n) computation in sub
!     rev. 9.5.33  Sep.  12/08  - NK: added column labels for grapher in flow_station_location.xyz
!     rev. 9.5.35  Sep.  22/08  - NK: moved flow_sta_location to flowinit
!     rev. 9.5.45  Dec.  16/08  - NK: added various error calculations - user's choice with errflg
!     rev. 9.5.48  Dec.  26/08  - NK: added event_fln() to allow unlimited events
!     rev. 9.5.50  Jan.  05/09  - NK: read evap data for reaches only
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
!     rev. 9.5.57  Apr.  13/09  - NK: added ntrlflg for natural lake flows
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
!     rev. 9.5.73  Oct.  12/09  - NK: bypass using lake levels when optimizing
!     rev. 9.5.75  Oct.  26/09  - NK: commented "deallocate in sub for watroute reads
!     rev. 9.5.77  Oct.  26/09  - NK: fixed some inits for out of basin gauges
!     rev. 9.5.80  Dec.  20/09  - NK: added swe_locations.txt file for swe input
!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.03  Jun.  24/10  - NK: normalized SSE with station Qmean**2
!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
!     rev. 9.7.17  Jan.  05/11  - NK: Fixed diversions outside sub-basin
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.7.27  May.  26/11  - NK: Add lake_ice_factor
!     rev. 9.8.03  Aug.  08/11  - NK: chech no of mean observed flows in file are ok
!     rev. 9.8.09  Nov.  22/11  - NK: nopt(l)=0 for area_error(l) > 10%
!     rev. 9.8.14  Jan.  27/11  - NK: dds_penalty added for swe not to zero in summer
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
!     rev. 9.8.44  Jan.  31/13  - NK: fixed bug in sub.f : uninitialized course_calc(n,j)
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!     rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
!     rev. 9.8.93  Nov.  12/13  - NK: Added the routing initialization with yyyymmdd_fli.r2c
!     rev. 9.9.06  Jan.  08/14  - NK: Add daily differences to Harfreaves ETHarg.f
!     rev. 9.9.09  Feb.  24/14  - NK: Fixed reading the time stame in r2c frame headers
!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!     rev. 9.9.21  Jul.  27/14  - NK: Added allocation for outarray in sub
!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!     rev. 9.9.36  Nov.  03/14  - NK: Revised error message for daily diff choices
!     rev. 9.9.64  Apr.  08/15  - NK: DDS bypass in sub for single runs
!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!
!  id     - storm id number
!  l      - station number
!  ni     - total # of storms
!  nl     - forecast period = total length of the streamflow file
!  no     - total # of stations
!  nr     - the # of hours rainfall is available
!  mhrd   - length of streamflow record = time elapsed since start
!  mhtot  - the simulation length in hours or is the length of rainfall
!         input for simulated forecasts
!  aintvl - precip interval in hours
!  sintvl - precip. interval in seconds
!  tot2   - the total average precipitation over the watershed


!***********************************************************************

      use areacg
      use area_watflood

C///////////////////////// 
C// Added by Dave
      USE EF_module
C// End Dave addition
C/////////////////////////

      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        DIMENSION     :: smc5(16)
        CHARACTER(14) :: date
        CHARACTER(3)  :: eofmark
        CHARACTER(1)  :: lineflg,smok,answer
        character(20) :: junk
        REAL(4)       :: optlow,time,time2,tot1,qwert,conv,scale,
     *           smc5,tj1,clock,t,thr,dtmin,dtmax,div,aintvl,sintvl,
     *           tot2,e1,tdum,tdum1,qtemp,diff2,sdlz,dlz,
     *           wfo_spec_version_number,
     *           route_dt,sec_div,hr_div
      integer         :: frame_no1,frame_no2,frame_no3,frame_no4
      integer         :: frame_no5,frame_no6,frame_no7,frame_no8

      real*4          ::  input,runoff,router,output,last,now
      real*4          ::  hhhhh,mmmmm,sssss
      integer         ::  yyyyy,moooo,ddddd
      
  
      INTEGER*4       :: rbin,inta,block,no1,classcount1,na1,
     *             ycount1,xcount1,
     *             iallcnt1,iallcnt2,n1,ii1,jan,m,ios,n,iallocate,
     *             l,ii,juold,julast,jj,kk,lun,nhr,nhf,nfg,
     *             i,j,icase,iz,jz,nchr,mz,ju,mon,
     *             iwest,ieast,isouth,inorth,nocolumns,nno,k,
     *             nu,igrdshft,minsnwflg,oldjan,flgevp22,
     *             noresv1,nj,npick,n_trick,no_frames,
     *             no_dt,iDeallocate,id_last,nd,MC_id
      integer       :: swe_l(99),no_swe_l,no_swe_obs
      integer       :: nrows,ncols
      integer       :: flnNum
      integer       :: n_max,nold,nlines_old,nlines

      CHARACTER(10) :: ctime
      CHARACTER(8)  :: cday
      CHARACTER(12) :: outlet_type
      logical   :: exists,newpafflg,firstpass,errflg_store,msgflg
      logical   :: dataflg,newDataFlag

        CHARACTER(10) :: coordsys
!        INTEGER      :: xcount,ycount
!        REAL     :: xorigin,yorigin,xdelta,ydelta,
      real     :: a66,sum_mean_flow,class_sum
      real :: swe_error,swe_penalty
      real :: ha,fpw,kdn,nratio,xtemp,ytemp,ztemp
      real :: domain_precip,domain_area
      real :: store_live

      data firstpass/.true./
      data id_last/0/
      data no_swe_l/0/
      DATA iallcnt1/0/
      DATA iallcnt2/0/
c      DATA col1/'b','d','f','h','j','l','n','p','r','t','v','x','z'/
c      DATA col0/'c','e','g','i','k','m','o','q','s','u','w','y','a'/
c      DATA col2/' ','a','b','c','d','e','f','g','h','i','j','k','l'
c     *       ,'m','n','o','p','q','r','s','t','v','u','w','x','y'/


!     NOTE: FOR MONTHLY RUNS, DIMENSIONS CAN BE CHANGED FROM 
!         3,8784,500  TO  12,366,3000

!>>>>>>>>>>>>>  AB: STUFF FOR ENSIM
      INTEGER(4) :: wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss,
     *             wfo_ms
      INTEGER(4) :: wfo_seq
      real*4     :: dds_penalty

      character(256) line,tmpLine
      CHARACTER(100) sys_command ! Command line input string

!      replaced by areawfo
!      REAL*4, DIMENSION(:,:), ALLOCATABLE :: outwfo

!     DDS error functions
     	real*4    :: log_qhyd,log_qinfl,log_mean_obs           
      real*4    ::  sum_swe
      real*4    ::   score
      real*4    ::   temp_value,sum_sq_error,
     *               temp_value_sum,dds_error

!     WFO IO FUNCTIONS
      INTEGER :: wfo_write_attribute_data
      INTEGER :: wfo_write_timestamp
      
!>>>>>>>>>>>>>

      if(iopt.eq.2)print*,' In sub after definitions'

!     RESET SETS ALL INITIAL VARIABLES

!     CHECK FILES MODE    iopt=99
!     FOR IOPT=99 NL AND MHRD ARE SET TO KT AND THE PROGRAM WILL RUN
!     FOR ONE TIME STEP ONLY - THIS WILL CHECK AND ECHO ALL INPUT FILES
!     >> VERY HANDY FOR CHECKING DATA FILE PRIOR TO LONG RUNS

      id=1  ! just so it's not some value from before

      if(firstpass)then
      
        input=0.0
        runoff=0.0
        router=0.0
        output=0.0
        min_flow_cutoff=0.01    ! error not calculated below this flow

      
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
        tdum1=1000.*step2/3600.

!       rev. 9.8.21  Jun.  18/12  - NK: Assed swe observed date & report
        if(iopt99)open(unit=951,file=filename(951),iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',filename(951)(1:40)
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in sub.f @ 236'
        endif

!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
        if(lakeflg.eq.'y')then
          allocate(WindSpd(na),WindDir(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating wind arrays in sub' 
        endif
          
c        if(netCDFflg)then
             allocate(QQsum(na),stat=iAll)
	       if(iAll.ne.0) STOP 'Error allocating QQsum in sub' 
             do n=1,na
                  QQsum(n)=0.0
             end do 
c        endif

!     rev. 9.8.80  Aug   09/13  - NK: Added withdraw.r2c output file in route.f
!       write the header for the withdraw.r2c file 
      if(iopt99)then
        author='watflood                    '
        name='Irrigation withdrawals             '
        coordsys_temp=coordsys1
!       GreenKenue uses LatLong - code below uses LATLONG
        if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
        if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
        zone_temp=zone1
        datum_temp=datum1
        xorigin_temp=xorigin
        yorigin_temp=yorigin
        xcount_temp=xcount
        ycount_temp=ycount
        xdelta_temp=xdelta
        ydelta_temp=ydelta
        attribute_name='withdrawalslow                    '
        attribute_units='cms                           ' 
        attribute_type='Flow                          '
        unit_conversion=1.0   
	    startdate='unknown   '
	    starttime='unknown   '
        source_file_name='various rff,rch,lkg files'     
        no_frames=2      
        frame_no1=0       ! write the header
!       no_frames=2 tricks write_r2c to write frame .....
!       write the header for gridded withdrawal flows
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        fln(23)='results\withdraw.r2c'
        print*,fln(23)(1:40)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(23,23,ni*12,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif
!       added for BC Hydro
        if(iopt99)then
        open(unit=29,file=filename(29),status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',filename(29)(1:40)
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in sub.f @ 293'
        else
          write(29,*)'       ID domain_precip'     
        endif
        
        domain_area=0.0 
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          domain_area=domain_area+grid_area(n)
        end do
        domain_precip=0.0
        endif
        
!       rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
!       This will only happen is the user has created a folder & file: 'radcl\new_grid\junk'
        open(unit=99,file='radcl\new_grid\junk',
     *             status='unknown',iostat=ios)
        if(ios.eq.0)then
          new_precip_grid_flg=.true.
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          print*,'re-gridded met file will be written in radcl\new_grid'
	    print*,'delete the \new_grid folder to stop this message'
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        else
          new_precip_grid_flg=.false.
        endif
        close(unit=99,status='delete')
        open(unit=99,file='tempr\new_grid\junk',
     *             status='unknown',iostat=ios)
c        inquire(FILE='radcl\new_grid\junk',EXIST=exists)
        if(ios.eq.0)then
          new_temp_grid_flg=.true.
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          print*,'re-gridded tem file will be written in tempr\new_grid'
	    print*,'delete the \new_grid folder to stop this message'
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        else
          new_temp_grid_flg=.false.
        endif
        close(unit=99,status='delete')
!       end rev. 9.7.15  Dec.  14/10  

!       assume we do a swe report untuil we do not find the swe.tb0 files
        courseflg=.true.

!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
        skiplines=0
        


!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!       this needs to be read along with the event file; include with read_evt()?
!       ? ... or flow_init -- either has correct scope and occurs at start of event
!       these declarations are in area_watflood.f
!       logical :: fcst_exists,fcst_mode ! declare  in header of 
!       integer :: fcst_yr, fcst_hr0, fcst_days2avg
!       real*4 :: fsct_snow_adj, fcst_rain_adj
! --    the rest of this located in main scope; could add to separate sub

        fcst_mode=.false.
        INQUIRE(FILE='fcst_params.txt',EXIST=fcst_exists)
        IF(fcst_exists)THEN
          open(unit=99,file='fcst_params.txt',iostat=ios)    ! 99 is a scratch file #
!           -- unit number selected randomly (fix!);
!           -- can't figure out filename convention
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  fcst_params.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            stop 'Program aborted in sub.f @ 358'
          endif
          read(99,*)fcst_yr ! read each line and assign to forecast parameter variables
          read(99,*)fcst_hr0
          read(99,*)fcst_days2avg
          read(99,*)fcst_snow_adj
          read(99,*)fcst_rain_adj
          close(unit=99,status='keep')
!         check if this is the current year
          if(fcst_yr.eq.year_now)then          ! Trish believes 'year1' is the current year; might be 'year' or 'yearnow'?
!                                                 look in timer.f
            fcst_mode=.true.
          end if
        END IF    
!       end rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg

!     rev. 10.2.01 Oct   08/17  - NK: Moved ruleflg from sub.f to spl.f
c!     rev. 9.9.65  Apr.  `3/15  - NK: Added rule s/r; resrl\rules.txt & ruleflg
c        INQUIRE(FILE='resrl\rules.ts5',EXIST=exists)
c        if(exists)then
c!         this means there are rules for some or all of the lakes & reservoirs
c!         Note:  not necessarily all        
c          ruleflg=.true.
c        else
c!         this means there are no rules at all.        
c          ruleflg=.false.
c        endif      




!     rev. 10.1.08 Dec.  04/15  - NK: Added msg re: replacing "mean_observed_flows.txt"' 
        if(dds_flag.eq.0.and.id.eq.ni)then
          inquire(FILE='mean_observed_flows.txt',EXIST=exists)
          if(exists)then
            print*
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            print*,'found the file mean_observed_flows.txt'
            print*
            print*,'If you wish to replace this file with the current'
            print*,'the old file must be deleted'
            print*
            print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          endif
        endif
        
        if(iopt99)then
          open(unit=1000,file='debug\benchmark_time.txt',iostat=ios)
          if(ios.ne.0)then
            print*,'Problems opening benchmark_time.txt'
            print*,'needs debug\ directory in the working dir'
            pause 'paused in sub @ 427'
          endif
        endif
        
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!       New here        
        if(.not.allocated(p).and.FLtype(10)(1:2).eq.'nc')then
           allocate(p(ycount,xcount),stat=iAllocate)
           if(iAllocate.ne.0) 
     *       STOP 'Error with allocation of p in sub @ 117'
        endif
        
!       Stuff for FEWS & netCDF files
        deltaT2 = 1  ! Will be reset as soom as we read the first precip file
        deltaT3 = 1  ! Will be reset as soom as we read the first temp file
        
      endif   ! firstpass
 
      if(numa.ne.0)then
c        iopt=0
        trcflg='n'
        ensimflg='n'
        initflg='n'
        modelflg='n'
      endif

!     JAN=2 SUBSEQUENT PASSES
!     JAN=3 LAST PASS  - SET BELOW

c      jan=1

      m=1
      tot1=0.0
      totaltime=0.0       ! used for ensim time series
	mo=mo1              ! added jan 22/11 nk for repeated runs
      wfo_open_flg='n'
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
      dtmin=a6

!     Write the header in rte.txt
      IF(iopt.ge.1.and.n.eq.nnprint)write(55,5551)
5551  format('   id   time         at     qi1     qi2'
     *          '     qo1     qo2   store1     store2')

d      if(iopt.eq.2)print*,' In sub - gone to rdflow @ 147'

!     get no and nopt for allocations etc.  nk Apr. 8/03 
!     read the str header for allocation and initialization purposes

!      call rdflow('0',date)     
 
      if(IsFileTypeTB0(fln(6)).or.FLtype(6)(1:2).eq.'nc') then
d       print*,'reading flow header'      
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_flow_ef('0',date)  !EnSim compatible tb0 file
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      else
         print*,'Old format .str files not accepted'
         print*,'Please create yyyymmdd_str.tb0 files & rerun'
         stop 'Program aborted in sub @ 192'
      endif

!     rev. 9.5.19  Mar.  05/08  - NK: prevented use of tracer * iso models with nudging
      msgflg=.false.
      do l=1,no
        if(nopt(l).eq.2)then
          frcflg='n'
c          trcflg='n'
          if(msgflg)then
            print*,'Flow nudging is turned on in flow station ',l
          else
            print*,'also at station',l
          endif
          msgflg=.true.
        endif
      end do
      if(msgflg)then
        print*
        print*,'WARNING:'
        print*,'Tracer and isotope model data may have issues at'
        print*,'locations downstream from stations with nudging'
        print*,'due to a possible lack of continuity'
c        print*,'trcflg and frcflg set to `n`'
        print*,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      endif
 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     Section added to allow for lengthened routing time step for large grids
      if(irdt.gt.kt)then
        a6=float(irdt)*3600.0
        write(51,*)' Warning'
        write(51,*)' Min time step a6 changed to ',a6
        write(51,*)
        write(*,*)
        write(*,*)'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
        write(*,*)' WARNING'
        write(*,*)' deltaT (str file) irdt=',irdt
        write(*,*)' Min time step a6 changed to ',a6
        write(*,*)'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
        write(*,*)
d        pause 'hit enter to continue - in sub @167'
      endif
d     if(iopt.eq.2)print*,' In sub - back from rdflow @ 152'

      if(iallcnt1.eq.0)then
        iallcnt1=1
      endif   ! iallcnt1=0
      if(iallcnt2.eq.0)then
        iallcnt2=1
      endif   ! iallcnt2=0

d     if(iopt.eq.2)print*,' In sub after allocations 1'

      if(snwflg.eq.'y')then
         do n=1,naa
          do ii=1,classcount
!            will print warning if snow never disappears
             snowcmin(n,ii)=1.0e+32
          end do
         end do
      endif
d      if(iopt.eq.2)print*,' In sub after allocations 2'

!     SINGLE RUN USING SOIL MOISTURE GRID IS THE DEFAULT.
!     NO SOIL MOISTURE OPTIMIZATION - THIS CAN BE CHANGED WITH 
!     SETTING ICASE=-1 IN THE PARAMETER FILE & SM GRID WILL BE IGNORED

!     SAVE THE ORIGINAL VALUE:

      flgevp22=flgevp2

d     if(iopt.eq.2)print*,' In sub after allocations 3'

      do n=1,naa
        rechrg(n)=0.0
!       qstream & strloss need to be initialized for watroute
        qstream(n)=0.0
        strloss(n)=0.0
!        rh(n)=.50   ! moved to rdtemp 28/12/04 nk
        
      end do
      juold=0

c!     added mar 28/06  nk
c!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
c      if(glacier_class_number.ne.0)then
c!       glacier_class_number is assigned in the rdpar file
c        do n=1,naa
c          if(aclass(n,glacier_class_number).gt.0.0)then
c!         there is a glacier in this grid
c          glacier_flag(n)='y'
c          else
c!         there is no glacier in this grid
c          glacier_flag(n)='n'
c          endif
c        end do
c      endif

c      open(873,file='aet.out',status='unknown')

d     if(iopt.eq.2)print*,' In sub before user check'

!     rev. 9.1.46  Jul.  17/03  - WATFLOOD LITE incorporated 
c      if(ichsm.eq.4)then
c!       it's ok to go thru here for ichsm=3 for the first event
c        if(ni.gt.1)then
c          print*,' For WATFLOOD LT, no of events allowed is 1'
c          print*,' Program will abort after first event.'
c          print*
c          ni=1
c!          pause ' Hit enter to continue - in SUB @ 349'
c        endif
c      endif

!     call decread(ha,fpw,kdn,nratio)

 !     NK - ALLOCATION OF AREAwfo ARRAYS
      if(iallcnt1.eq.1)then
        allocate(outwfo(xcount,ycount),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *    'Error with allocation of ensim arrays in sub'    
          iallcnt1=2
      endif
!
!      if(routeflg.eq.'y')then
      if(iallcnt2.eq.1)then
        allocate(outarray(ycount,xcount),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *    'Error with allocation of ensim arrays in sub'    
          iallcnt2=2
      endif
!     endif

!     Initialize all grids for write_r2c
!      if(routeflg.eq.'y')then
        do i=1,ycount
          do j=1,xcount
          outarray(i,j)=0.0
          end do
        end do
!      endif

      if(iopt.eq.2)print*,'In sub before writing header / gridflow.r2c'

      if(iopt99)then
      if(numa.eq.0.and.dds_flag.eq.0)then
        author='watflood                    '
        name='Gridded Channel Flow (SPL)          '
        coordsys_temp=coordsys1
!       GreenKenue uses LatLong - code below uses LATLONG
        if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
        if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
        zone_temp=zone1
        datum_temp=datum1
        xorigin_temp=xorigin
        yorigin_temp=yorigin
        xcount_temp=xcount
        ycount_temp=ycount
        xdelta_temp=xdelta
        ydelta_temp=ydelta
        attribute_name='channel_inflow                    '
        attribute_units='mm                            ' 
        attribute_type='Runoff                        '
        unit_conversion=1.0   
        source_file_name='various rff,rch,lkg files'     
        frame_no2=0
!       write the header for gridded channel flow (gridflow.r2c)
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(72,72,no_frames,1,frame_no2,1,1) 
!       use mhtot+1 so the file statys open until the end of the last event.  
        call write_r2c(72,72,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          print*
          print*
          print*,'disabled output to',fln(72)(1:30)
          write(72,*)'to write this file, set ensimflg= y or a'
        endif

        name='Snow Water Equivalent - weighted        '
        attribute_name='Weighted swe                  '
        attribute_type='SWE                           '
        source_file_name=fln(10)   ! met file
        frame_no4=0      
!       write the header for weighted swe
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(61,61,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          print*,'disabled output to',fln(61)(1:30)
          write(*,*)'to write these files, set ensimflg= y or a'
          write(61,*)'to write this file, set ensimflg= y or a'
          print*
          print*
        endif

!     rev. 9.5.09  Feb.  12/08  - NK: added evap.r2c to the output files
        name='Total evaporation - weighted        '
        attribute_name='Weighted evaporation              '
        attribute_type='EVAP                          '
        source_file_name=fln(10)   ! met file
        frame_no5=0
!       write the header for weighted gridded et
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(100,100,no_frames,1,frame_no5,1,1)   
        call write_r2c(100,100,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          print*,'disabled output to',fln(100)(1:30)
          write(*,*)'to write these files, set ensimflg= y or a'
          write(100,*)'to write this file, set ensimflg= y or a'
        endif

        name='isostrcon2                  '
        attribute_name='Iso_concentration_stream          '
        attribute_type='Concentration                 '
        source_file_name=fln(10)   ! met file
        fln(200)='results\isostrconc2.r2c'
        frame_no6=0
!       write the header        
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c       call write_r2c(200,200,no_frames,1,frame_no6,1,1)   
c        call write_r2c(200,200,mhtot+8784,1,frame_no6,0,1)   
        call write_r2c(200,200,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif
      endif   ! iopt99


!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
      if(dds_flag.eq.1)then
!       pre-emption 
        inquire(FILE='dds\pre-emption_value.txt',EXIST=exists)
        if(exists)then
!         read the pre-emption value which is the best solution so far
          open(unit=99,file='dds\pre-emption_value.txt',
     *          status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  dds\pre-emption_value.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 667'
          endif
          read(99,*)pre_emption_value
          print*,'from dds\pre-emption_value.txt'
          print*,'pre_emption_value read=',pre_emption_value
          close(unit=99,status='keep')
        else
!         first evaluation - set the pre-emption value to a large number
          open(unit=99,file='dds\pre-emption_value.txt',
     *          status='unknown',iostat=ios)
          if(ios.ne.0)then
            print*
            print*,'Unable to open file  dds\pre-emption_value.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
c            pause 'hit ctrl C to abort in sub @ 677'
!     rev. 9.9.64  Apr.  08/15  - NK: DDS bypass in sub for single runs
            print*,'It looks like you are making a single run with'
            print*,'a par file generated by DDS or the PS'
            print*,'You can avoid this interruption by changing'
            print*,'ddsflg = 0 in the par file'
            print*
            pause 'For single run, to continue - hit Enter'
            dds_flag=0
          endif
          pre_emption_value=1.0E+35
          write(99,*)pre_emption_value
          close(unit=99,status='keep')
          print*,'first pre_emption_value written=',1.0E+35  ! changed 35 > 32 nk Jan. 22/11
        endif

      endif


!     rev. 9.7.11  Nov.  22/10  - NK: added monthly_climate_deltas.txt file
	climate_delta_flg=.false.     !default
      inquire(FILE='basin\monthly_climate_deltas.txt',EXIST=exists)
	if(exists)then
        open(unit=99,file='basin\monthly_climate_deltas.txt',
     *	  status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file  basin\monthly_climate_deltas.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in sub.f @ 700'
        endif
	  read(99,*)(monthly_temperature_delta(j),j=1,12)
	  read(99,*)(monthly_precipitation_delta(j),j=1,12)
	  close(unit=99,status='keep')
	  print*
	  print*,'Montly climate deltas found in file'
	  print*,'basin\monthly_climate_deltas.txt'
	  print*,'All temperatures will be adjusted by dC:'
	  print*,monthly_temperature_delta
	  print*,'All precipition will be adjusted by %:'
	  print*,monthly_precipitation_delta
	  print*
	  do j=1,12
	    monthly_precipitation_delta(j)=
     *               1.0+monthly_precipitation_delta(j)/100.0
	  end do
	  print*,'Do you want to continue with these adjustments?  y/n'
	  read*,answer
	  if(answer.eq.'y')then
	    climate_delta_flg=.true.
	    print*,'All temperatures will be adjusted as per table'
	    print*
	    print*
	  else
	    do j=1,12
	      monthly_temperature_delta(j)=0.0
	      monthly_precipitation_delta(j)=1.0
         end do
	  endif
	endif

!     rev. 9.8.08  Nov.  18/11  - NK: added fratio for interception hight optimization
!     correct the interception capacity by the multiplier fratio
      fratioflg=.false.  ! i.e. it's equal to 1.0
      do i=1,12
        do ii=1,classcount
          h(i,ii)=h(i,ii)*fratio(ii)
          if(fratio(ii).gt.1.00001.or.fratio(ii).lt.0.99999)
     *                                     fratioflg=.true.
        end do
      end do
      
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
      swe_update=.false.
      inquire(file='snow1\swe_update.xml',EXIST=exists)
      if(exists)then
          call read_swe_update(yy_swe,mm_swe,dd_swe,hh_swe,
     *                                         swe_add,swe_mult)
          if(swe_add.gt.-999.or.swe_mult.gt.-999.0)swe_update=.true.
          if(swe_add.lt.-998.and.swe_mult.lt.-998.0)then
              write(98,*)
     *         'Warning: Both the swe adjustment factors are < -999'
              swe_update=.false.
          endif
          if(swe_update)then
              write(98,*)'INFO: swe update'
              write(98,*)'INFO: swe update for ',yy_swe,mm_swe,dd_swe,hh_swe
              write(98,*)'INFO: swe_add/swe_mult',swe_add,swe_mult
              write(98,*)
          endif
      endif
      
!     rev. 10.2.62 Sep.  09/19  - NK Added read_sm_update.f90 for read in sm adjustment factors
      uzs_update=.false.
      inquire(file='moist\uzs_update.xml',EXIST=exists)
      if(exists)then
          call read_uzs_update(yy_uzs,mm_uzs,dd_uzs,hh_uzs,
     *                                         uzs_add,uzs_mult)
          if(uzs_add.gt.-999.or.uzs_mult.gt.-999.0)uzs_update=.true.
          if(uzs_add.lt.-998.and.uzs_mult.lt.-998.0)then
              write(98,*)
     *         'Warning: Both the uzs adjustment factors are < -999'
              uzs_update=.false.
          endif
          if(uzs_update)then
              write(98,*)'INFO:uzs update for ',
     *                        yy_uzs,mm_uzs,dd_uzs,hh_uzs
              write(98,*)'INFO:uzs_add/uzs_mult',uzs_add,uzs_mult
          endif
      endif

      if(iopt.eq.2)print*,'Before event loop start'

!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *


      do id=1,ni
     
!         TIMER SETS ALL THE CLOCKS i.e. SUM HOURS, SUM SECONDS, ETC.
!     rev. 10.1.74 Apr.  01/17  - NK: Changed timer to fix 1 day-off problem 
!       This hasd to be moved here so the read_rain, read_temp, read_r2c etc files
!       have a proper initisl clock time        
        time=0.0
        jz=0 
        if(netCDFflg)jz=1         
c        if(netCDFflg)then
c          nnprint=s(ycount/2,xcount/2)         
c          ipr=yyy(nnprint)   
c          jpr=xxx(nnprint)
c          iopt=1
c          iopt99=.true.
c        endif
c        if(.not.iopt99)ensimflg='n'
        
          
!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\      
!\\\\\added by Dave Newson
!      rev. 9.9.72  Jul.  21/15  - NK: Dave Newson additions to sub & process_rain
!       DN addition of forecast mode code
        fcst_mode=.false.
        !print *, '*** looking for fcst_params.txt in . ...'
        inquire(FILE="fcst_params.txt",EXIST=exists)
        !inquire(FILE='fcst_params.txt',EXIST=exists)
        
	  !print *,"cwd=",getcwd()
	  
        IF(exists)THEN
          print *, 'FOUND fcst_params.txt! checking forecast year...'
          open(unit=99,file='fcst_params.txt',iostat=ios)    ! 99 is a scratch file #
!           -- unit number selected randomly (fix!);
!           -- can't figure out filename convention
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  fcst_params.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            stop 'Program aborted in sub.f @ 358'
          endif
          read(99,*)fcst_yr ! read each line and assign to forecast parameter variables
          read(99,*)fcst_hr0
          read(99,*)fcst_days2avg
          read(99,*)fcst_snow_adj
          read(99,*)fcst_rain_adj
          close(unit=99,status='keep')
!         check if this is the current year
          print *, 'forecast year, current year: ', fcst_yr, year1
          if(fcst_yr.eq.year1)then          ! Trish believes 'year1' is the current year; might be 'year' or 'yearnow'?
!                                                look in timer.f
          fcst_mode=.true.
!         DN 2015-02-07 -- these are temporary debug statements
          !print *, 'in sub at 372, forecast parameters:'
          !print *, fcst_yr,fcst_hr0,fcst_snow_adj,fcst_rain_adj
          print *, 'forecast mode enabled?: ', fcst_mode
          end if
        ELSE 
          if(dds_flag.eq.0)then
            print*
            print*, '!WARNING fcst_params.txt not found!'
            print*
          endif
        END IF
!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\      
!\\\\\end Dave Newson addition

d        if(iopt.eq.2)print*,' In sub, passed location  201'
        julast=0
!     rev. 9.9.49  Jan.  06/14  - NK: Added courantflg
        courantflg=.true.    ! All's well Courant criteria not violated
!       
CHECK FOR STOP COMMAND:
        open(unit=99,file='stop.txt',form='formatted',
     *          status='unknown',iostat=ios)
        if(ios.ne.0)print*,'Problems opening stop.txt file ignored'
        read(99,99001,iostat=ios)qwert
        if(ios.ne.0)print*,'Problems reading stop.txt file ignored'
        close(unit=99,status='keep')

d       if(iopt.eq.2)print*,' In sub, passed location  2011'
        if(qwert.gt.0.0)go to 83

!       RESET TO THE ORIGINAL VALUE -  WILL BE CHANGED IF NO DATA
        flgevp2=flgevp22

!     rev. 10.1.79 Apr.  18/17  - NK: Set trcflg=0 for all dds except errflg=10
        if(numa.ne.0.or.dds_flag.ne.0)then
          iopt=0
          trcflg='n'
          ensimflg='n'
          initflg='n'
          modelflg='n'
!         but GW flows are needd to run this dds criteria          
          if(errflg.eq.10)trcflg='y'
        endif

        index=1
!       INDEX = 1 FOR FIRST PASS REROUT ONLY
!       INDEX = 2 FOR SUBSEQUENT PASSES
!       SET   = 1 FOR EACH NEW LINKED EVENT TO READ IN NEXT SET OF 
!              RESERVOIR RELEASES

!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout

d       if(iopt.eq.2)print*,' In sub, passed location  2012'

!       REV. 8.91 - Dec.  07/98 - READ rdevt IN SUB AS WELL AS SPL 
!       READ THE EVENT FILE - HAS TO BE DONE FOR EACH ID
        if(id.le.1)then
!         event file used to be read here as well but no longer needed
!         it is read in spl9 at the beginning
!         except for optimization when it has to be re-read
!         for each new iteration           apr. 30/08 nk
c          if(numa.gt.0)then
c            fln(99)='event\event.evt'
cd           print*,'reading event file  id = 1'    
c            call read_evt(date,conv,scale,smc5,nhr,nhf)
c          endif
c
c          month1=mo1

        else

!     rev. 9.5.48  Dec.  26/08  - NK: added event_fln() to allow unlimited events
          fln(99)=event_fln(id)

!         rdevt WAS CALLED IN SPL9 FOR THE FIRST EVENT
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!          call rdevt(date,conv,scale,smc5,nhr,nhf)
d         print*,'reading event file id > 1'      
          call read_evt(date,conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        endif

!       needed of precip fitting: scale is set in options
        if(icase.eq.2)scale=a(1)

        if(numa.eq.0.or.id.eq.1.and.nnn.eq.0)then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c          if(abs(dds_flag).ne.1)call header()
          call header()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(abs(dds_flag).eq.1)ensimflg='n'

        endif

!     Changed the order: has to be after opening the next event!!
!     Nov. 24/02 nk

!     make sure we don't write the wfo file when optimizing
!     has to be her because flag is read with each new event
        if(ensimflg.eq.'y'.and.wfo_open_flg.eq.'n')then
!         read the wfo_spec file & do allocations
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d         print*,'reading wfo_spec file'
          call rd_wfo_spec()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AB:  ENSIM HEADERS
!         WRITE THE HEADER FOR ENSIM FILES:

!         NK - ALLOCATIONS FOR AREA2 arrays
!         rev  9.1.29  Oct.  24/02    - Added q1, qint & drng to wfo file

!         added nj to the arg lst to allocate attname ...nk  30/01/03
          if(llflg.ne.'y')then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_both_headers('UTM       ',jan)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_both_headers('LATLONG ',jan)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif

          wfo_open_flg='y'

!         NOTE: IF YOU CHANGE WHICH DATA YOU OUTPUT YOU WILL HAVE TO EDIT
!           THE ABOVE SUBROUTINE
!           YOU CAN REPLACE 'UTM' WITH 'LATLONG' WHERE NECESSARY
!         ALSO, MAKE THE ARRAY FOR OUTPUTTING
!          xcount     ! number of columns
!          ycount     ! number of rows
           if(iopt.eq.2)print*,' In sub before initializing outwfo()'
          do j=1,xcount
            do i=1,ycount
              outwfo(j,i)=0.0
            end do
          end do
          do n=1,na
            wfo_sum_p(n)=0.0
          end do
          wfo_seq=0
!         LUN IS THE UNIT NUMBER for the watflood.wfo file
          lun=65
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>....>!
        endif ! if(ensimflg.eq......

!       rev. 9.1.28  Sept. 19/02  - Added shdlfg to replace the bsnm_shd.r2c file
        if(shdflg.eq.'y')then      
!         basin/bsnm.shd
          open(unit=31 ,file=fln(1) ,status='old',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(1)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            print*,'or wrong # of events listed in event file'
            stop 'Program aborted in sub.f @ 896'
          endif

          if(IsFileTypeR2C(fln(1))) then
d             print*,'reading shd file'      
              call read_shed_ef(31,1) !EnSim compatible r2c file
c	!       **********************************************************************
c	        call read_par_parser(32,2)
c!             **********************************************************************

          else
!             call rdshed()
               print*,'Old format shd files not accepted'
               print*,'Please create EF ????_shd.r2c files & rerun'
               stop 'Program aborted in sub @ 528'
          endif

          write(51,5101)
          write(51,5102)id,fln(1) 
          print*,' New watershed file ',fln(1)
          print*,' read in'
          print*
!          pause 'In sub - read in new shd file'
          close(unit= 31)

        endif     !  if(shdflg.eq......

!     rev. 9.8.93  Nov.  12/13  - NK: Added the routing initialization with yyyymmdd_fli.r2c
        if(fliflg.eq.'y')then
          flnNum=99
          fln(99)=fln(55)
!         There are 2 flowinit possibilities:
!         One with a resume: the flow_init.r2c file will be in the working directory
!         the other when is it done on the fly as an updating tool with
!                    strfw\yyyymmdd_fli.r2c
!             This is on the fly with the file name from the event file
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_flowinit(flnNum)
!             ~~~~~~~~~~~~~~~~~~~~~
        endif
d       if(iopt.eq.2)print*,' In sub, passed location  202'

!     rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!     wqual/yymmdd.wqd
        if(sedflg.eq.'y')then
          close(unit=256,status='keep',iostat=ios)
          if(ios.ne.0)then
          print*,'Problem closing unit 256 fln=',fln(26)
          print*
          stop ' program aborted in sub @ 645'
          endif
        endif
d       if(iopt.eq.2)print*,' In sub, passed location  2026a'

!       REV 7.9  ADDED GRIDDED RADIATION FILE
        if(ver.ge.7.9)then
          if(flgevp2.eq.3.0)then 
d         if(iopt.eq.2)print*,' In sub, passed location  2044'
          close(unit=49,status='keep')
d         if(iopt.eq.2)print*,' In sub, passed location  2045'
          close(unit=50,status='keep')
          endif
        endif

!       if(resinflg.eq.'y') close(unit=99,status='keep')

d      if(iopt.eq.2)print*,' In sub, passed location  203'

!       INPUT FILES

!       unit    32 = fln(2)  - parameter data file .par
!       unit    36 = fln(6)  - flow file .str
!       unit    37 = fln(7)  - reservoir releases file .rel
!       unit    38 = fln(8)  - snow file .snw
!       unit    40 = fln(10) - precip file .met

!       AND OPEN THE FILES FOR THE NEXT ONE:

d        if(iopt.eq.2)print*,' In sub, passed location  205'

!       rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!       wqual/yymmdd.wqd
        if(sedflg.eq.'y')then
          open(unit=256,file=fln(40),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(40)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            print*
            print*,'This file is optional - used for nutrient loading'
            print*,'needed only if sedflg=y in yymmdd.evt'
            stop 'Program aborted in sub.f @ 990'
          endif
        endif

!       unit 261 = fln(31) - gridded runoff files for watroute .rff
!       unit 262 = fln(32) - gridded recharge for modflow .rch
!       unit 263 = fln(33) - gridded leakage for watroute

!       rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added 
!       WRITING FILES FOR WATROUTE
        if(modelflg.eq.'l')then
!         route surface  flow & leakage
!         these 2 are added together and then routed
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1011'
          endif
!         open lkage\yyyymmdd_lkg.r2c
          open(unit=263,file=fln(33),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(33)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1021'
          endif
        endif

        if(modelflg.eq.'r')then
!         route surface flow to stream and rchrg thru the lzs
!         leakage is computed using the watflood LZ routing module
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1036'
          endif
!         open rchrg\yyyymmdd_rch.r2c
          open(unit=262,file=fln(32),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(32)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1046'
          endif
        endif

        if(modelflg.eq.'i')then
!         surface flow only to the stream for routing
!         leakage is not included in the routing
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1061'
          endif
        endif

!       WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE

!       rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added 
!       Writing FILES FOR WATROUTE
        if(routeflg.eq.'y'.and.numa.eq.0)then
          mhtot=2   ! <<<<<<<<<<<< just to get the right header - reset later
          author='spl.exe                     '    
          name='Gridded Channel Inflow              '
          coordsys_temp=coordsys1
!         GreenKenue uses LatLong - code below uses LATLONG
          if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
          if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
          zone_temp=zone1
          datum_temp=datum1
          xorigin_temp=xorigin
          yorigin_temp=yorigin
          xcount_temp=xcount
          ycount_temp=ycount
          xdelta_temp=xdelta
          ydelta_temp=ydelta
          attribute_name='channel_inflow                  '
          attribute_units='mm                          ' 
          unit_conversion=1.0
          attribute_type='Runoff                      '  
          source_file_name=fln(10)
          frame_no3=0            ! write the headers               
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c         call write_r2c(261,31,mhtot,1,frame_no3,1,1)     
          call write_r2c(261,31,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          name='Gridded Recharge                '
          attribute_name='recharge                        '
          attribute_units='mm                          ' 
          attribute_type='recharge                        '  
          source_file_name=fln(10)                           
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c         call write_r2c(262,32,mhtot,1,frame_no3,1,1)     
          call write_r2c(262,32,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          name='Gridded Leakage                 '
          attribute_name='leakage                     '
          attribute_units='mm                          ' 
          attribute_type='leakage                         '  
          source_file_name=fln(10)                           
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c         call write_r2c(263,33,mhtot,1,frame_no3,1,1)     
          call write_r2c(263,33,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        endif

d       if(iopt.eq.2)print*,' In sub, passed location  206'

        if(ver.ge.7.9)then
          if(flgevp2.eq.3.0)then
!         RADIATION FILE
          open(unit=49,file=fln(19),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(19)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1131'
          endif
          open(unit=50,file=fln(20),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(20)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1140'
          endif
          endif
        endif

d       if(iopt.eq.2)print*,' In sub, passed location  207'

!       RESET THE CLOCK:   >>>>>>>>>>>> CHECK THIS OUT
        m=1
        tot1=0.0

d       if(iopt.eq.2)print*,' In sub, passed location  209'

! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!       FROM THE STREAMFLOW FILE:

!       REV. 7.32   feb.  07/95 - ADDED NOPT TO SELECT OPT FLOW STA 
!       NOPT IS A VECTOR SIZE = # OF STREAMFLOW STATIONS
!       IF = 0 STATION NOT USED FOR OPTIMIZATION
!       IF = 1 STATION USED FOR OPTIMIZATION
!       if = 2 station is used to "correct" flows for that event only
!       if = 3 in 1st event, station nudges in all events

!       rev. 9.1.23  Jul.  23/02  - Added control for nudging in event #1
        if(id.eq.1)then
!         the first event is the master event for settings    
!         if nopt=3
          do l=1,no
            nopt1(l)=nopt(l)
            if(nopt(l).eq.3)nopt(l)=2   ! set to nudge first event
          end do
        else
!         subsequent events are nudged if nopt1(?)=3
          do l=1,no
            if(nopt1(l).eq.3)then
              nopt(l)=2     ! set to nudge following events
            endif
          end do
        endif

d        if(iopt.eq.2)print*,' In sub, passed location  214'

        if(iopt.eq.99)then
!         THIS OPTION IS TO CHECK ALL INPUT FILES
!          kt=1
!          nl=1
          mhrd=kt
          if(id.le.1)then
          write(*,6300)iopt
          write(98,6300)iopt
          write(*,'(A)',advance='no') 
     *         'In sub: hit any key to continue checking files'
          read(*,*)
          endif
        endif

d        if(iopt.eq.2)print*,' In sub, passed location  722'

!       MHRD CAN BE ENTERED WHEN SAVING THE STR FILE.
!       MHRD DEFAULT VALUE IS THE END OF THE STREAMFLOW DATA.

!*******************
! RAIN (MET FILE)
!*******************
!//////////////////////////////////////////////
!///////////////////////// 
!// Added by Dave
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list

c        if(IsFileTypeR2C(fln(10))) then
!         changed argument list  nov. 9/06 nk
!         read the header:
d          if(iopt.eq.2)then
d			print*,'In sub, passed location  904 before read_rain'
d             print*,'If program dies here, check the met file'
d		 endif 

        if(modelflg.eq.'n')then
!       rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
          inquire(FILE=fln(10),EXIST=exists)
          if(.not.exists)then
            print*
            print*,'Fatal error'
            print*,'radcl\yyyymmdd_met.r2c file not found'
            print*,'Please check the event\event.evt file'
            print*,'for correct keyword nad/or file name'
            print*
            stop 'Program aborted in sub @ 1185'
          endif

          
          call find_filetype(10)
          if(filetype.eq.'r2c')then
!         read the header:
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c            call read_rain_ef('1',conv,jz,jan) !EnSim compatible r2c file
            call read_rain_ef('1',conv,0,jan) !EnSim compatible r2c file
c          elseif(filetype(1:3).eq.'bin')then
c            call read_rain_bin('1',conv,jz,jan) 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(filetype.eq.'nc ')then
              continue
!             no header to read
          else
            print*,'Error:'
            print*,'File type for met file =',filetype
            print*,'Old format met files not accepted'
            print*,'Please create EF _met.r2c files & rerun'
            print*
            print*,'Forward slashes / in the event files not'
            print*,'accepted on the PC (it`s ok in unix)'
            print*
            stop 'Program aborted in sub @ 830'
          endif
        endif
        
!// End Dave addition
!/////////////////////////
!//////////////////////////////////////////////

d        if(iopt.eq.2)print*,' In sub, passed location  769'
d        write(98,*)'met file header read'

!*******************
! TEMP (TEM FILE)
!*******************




        if(modelflg.eq.'n')then
          
          
          
          

        if(snwflg.eq.'y'.or.vapflg.eq.'y')then    ! added nk Jun. 28/06
!//////////////////////////////////////////////
!///////////////////////// 
!// Added by Dave
d         if(iopt.eq.2)print*,' In sub, passed location  936'
!         rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
          inquire(FILE=fln(15),EXIST=exists)
          if(.not.exists)then
            print*
            print*,'Fatal error <<<<<'
            print*,fln(15)(1:72)
            print*,' not found'
            print*,'Please check the event\event.evt file'
            print*,'for correct keyword and/or file name'
            print*
!           THE TEMP FILE IS MISSING WHEN IT SHOULD BE THERE -> TERMINATE
            write(*,99111)
99111     format(' This file is optional - used to input gridded temps'/
     *  ' needed if snwflg=y or vapflg=y in yymmdd.evt'/
     *  ' not needed if flgevp2 .le. 1.0'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
            stop 'Program aborted in sub @ 1259'
          endif

          if(IsFileTypeR2C(fln(15)).and.
     *                  .not.FLtype(15)(1:2).eq.'nc')then
d          if(iopt.eq.2)then
d			print*,'In sub, passed location  796 before read_temp'
d             print*,'If program dies here, check the tem file'
d		 endif 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_temp_ef('1',jan,jz) !EnSim  r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d          if(iopt.eq.2)print*,' In sub, passed location  798'
          elseif(.not.FLtype(15)(1:2).eq.'nc')then   !  i.e. nc is ok so go on
!           call rdtemp('1',jan,jz)
            print*,'Old format tem files not accepted'
            print*,'Please create EF _tem.r2c files & rerun'
            print*
            stop 'Program aborted in runof6 @ 857'
          endif
!// End Dave addition
!/////////////////////////
!//////////////////////////////////////////////

!     rev. 9.9.06  Jan.08/14  - NK: Add daily differences to Harfreaves ETHarg.f
          if(flgevp2.eq.4)then
            INQUIRE(FILE=fln(62),EXIST=exists)
            if(exists)then
              dlyflg=.true.
!             read the header of tempr\yyyymmdd_dif.r2c
              if(iopt99)then
                print*
                print*,'NEW  <<<<<'
                print*,'Reading the header on unit 292 ',fln(62)(1:40)
              endif
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_r2c(292,62,'1',jz,newDataFlag) !EnSim  r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              if(iopt99)then
                print*,'Back from reading the header ',fln(62)(1:40)
                print*,'SPL will use the daily temperature differences'
                print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                print*   
              endif           
            else
!             in this case, monthly_climate_normals or
!             mean_dly_diff will be used depending on availability
!     rev. 9.9.36  Nov.  03/14  - NK: Revised error message for daily diff choices
              print*
              print*,'WARNING'
              print*,'flgevp is read having a value of 4'
              print*,'expecting file: ',fln(62)(1:40)
              print*,'but is is not found'
              print*,'Are you using a current evt file?????'
              print*,'If the temp data was not produced by tmp.exe,'
              print*,'the *dif.r2c file was not created.' 
              print*,'Please use diff.exe to create the *dif.r2c files.'

              stop 'Program aborted in sub @ 1455'

              print*,'You can continue using the values in the'
              print*,'basin\monthly_climate_normals.txt  file'
              print*,'for the Hargreaves & Samani (1985) equation'
              print*,'This is not ideal as daily diff`s are expected'
              print*,'You may continue by hitting Enter'
              print*,'if not running DDS'
              if(dds_flag.eq.1)then
                pause 'program will abort'
                stop  'Program aborted in sub @ 1291'
              else    
                dlyflg=.false.
                print*,'program continues with monthly_climate_normals'
                print*,'if the file is found in the basin directory'
                if(id.eq.1)pause  'Hit enter to continue'
              endif
            endif
          endif
        endif  ! added nk Jun. 28/06
        endif    !modelflg='n'

!       ***********************
!       EVAPORATION (EVP FILE) for lakes
!       ***********************

C//////////////////////////////////////////////
C///////////////////////// 
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
d          if(iopt.eq.2)print*,' In sub, passed location  922'
        inquire(FILE=fln(51),EXIST=exists)  !gridded evaporation
        if(exists)then
          rd_evp_flg=.true.
!         if the evp file exists, it will be used for lake evaporation. 
!         there's no way not to use it if it is not there
!         it also means that we can switch during a run

          if(IsFileTypeR2C(fln(51))) then
d           if(iopt.eq.2)then
d			  print*,'In sub, passed location  929 before read_r2c'
d             print*,'If program dies here, check the evaporation file'
d	 	    endif 
!           read the header
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d           print*,'reading evaporaton r2c file'     
            call read_r2c(281,51,'1',jz,newDataFlag) !EnSim  r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(id.eq.1)then
              if(.NOT.allocated(evap_convert))then      
              allocate(evap_convert(na),lake_evaporation(na),
     *                stat=iAllocate)
              if(iAllocate.ne.0) STOP
     *           'Error with allocation of evap_convert in sub @ 941'
                print*
              endif
!             conversion factor for m evaporation on a grid to m**3
              do n=1,naa
              evap_convert(n)=grid_area(n)*aclass(n,classcount)/1000.0
                end do
              print*,'read header fln='
              print*,fln(51)
              print*,'Time step other than 1hr to be fixed'
              print*

            endif
           
d            if(iopt.eq.2)print*,' In sub, passed location  929'
          else
            print*
            print*,'Fatal error:'
            print*,'r2c file expected'
            print*,'Wrong file type found for file fln(51)'
            print*,fln(51)(1:60)
            print*,'Delete this file if not needed or just junk'
            print*,'and try again'
            print*
            stop 'Program aborted in sub @ 942'
          endif
        else
          rd_evp_flg=.false.
        endif

!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes

        if(frcflg.eq.'y') then

!         Check for REMIiso input files. If all of the 4 required files are present, use them, otherwise check for other inputs.            
          frc_file_flg='y'
            inquire(FILE=fln(21),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(47),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(48),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(49),EXIST=exists)
          if(.not.exists)frc_file_flg='n'

!         If all REMOiso inputs are present, then skip the next section of code (because frac_file_flg='y' will be written over).         
         if(frc_file_flg.eq.'y') GOTO 1221 
         
!         Check if the time series delta rain input is present.            
          frc_file_flg='c'  
          inquire(FILE=fln(48),EXIST=exists)
          if(.not.exists)then
            frc_file_flg='n'
            if(dds_flag.eq.0)then
              print*,'WARNING:'
              print*,'Looking for :',fln(48)(1:60)
              print*,'but file not found'
              print*,'Program continues without time series dRain data'
            endif
          else
            if(dds_flag.eq.0)then
              print*
              print*,'frc_file_flg =',frc_file_flg
              print*,'Program continues with time series dRain data'
            endif
          endif
          print*

!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
c          this section removed by TH:
c!         if one of the needed REMOiso files is missing, or if there is no time series delta rain, use the defaults (values from isotope.par file).
c          print*,'frc_file_flg =',frc_file_flg
c          if(frc_file_flg.eq.'n')then
c            print*,'do you want to continue to run isoWATFLOOD without
c     *     time series input data?'
c            print*
c           pause 'enter to continue; cntl C to abort'
c          endif

 1221     CONTINUE
          
          if(frc_file_flg.eq.'y')then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d         print*,'reading humidity file'      
c          call read_hum(251,21,'1',jan,jz)   ! humidity  removed by TH:
d         print*,'reading gridded snow precip'      
          call read_gsn(277,47,'1',jan,jz)   ! snow_precip
d         print*,'reading REMOiso delta rain'      
          call read_drn(278,48,'1',jan,jz)   ! delta rain
d         print*,'reading REMOiso delta snow'      
          call read_dsn(279,49,'1',jan,jz)   ! delta snow
          
          elseif(frc_file_flg.eq.'c')then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         print*    
         print*,'reading time series delta rain'      
          call read_r2c(278,48,'1',jz,newDataFlag)   ! delta rain
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d      print*,'after reading ddrain time=',time

          endif 
          
          !TH: relative humidity from EC data based r2c
          inquire(FILE=fln(21),EXIST=exists)
          if(exists)then
            call read_r2c(251,21,'1',jz,newDataFlag)
            RH_flg=.true.
          else
            RH_flg=.false.
          endif

!         read in isotope parameter file from \basin
          inquire(FILE='basin\isotope.init',EXIST=exists)
          if(exists)then
          open(99,file='basin\isotope.init',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  basin\isotope.init'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1593'
          endif
          
          read(99,9990)flg2H        ! deutirium flag 1=18O, 2=18O and 2H
          read(99,9990)ninit    ! number of initializations
          read(99,9990)h2oflg    ! classcount for isotope output

          if(.NOT.allocated(deltar))then
!         ALLOCATE ISOTOPE INPUT PARAMETERS
          allocate(isoyear(ninit),deltar(ninit),deltas(ninit),
     *    rfoffset(ninit),smoffset(ninit),
     *    deltar2H(ninit),deltas2H(ninit),
     *    rfoffset2H(ninit),smoffset2H(ninit),stat=iall)
          if(iall.ne.0) STOP 'Error allocating isotope inputs'
          
          
          read(99,9991)delta1                    ! riverwater
          read(99,9991)delta2                    ! soil water
          read(99,9991)delta3                    ! groundwater
          read(99,9991)delta4                    ! snow
          read(99,9992)(isoyear(ii),ii=1,ninit)  ! data year 
          read(99,9993)(deltar(ii),ii=1,ninit)   ! rain
          read(99,9993)(deltas(ii),ii=1,ninit)   ! snow
          read(99,9993)(rfoffset(ii),ii=1,ninit)  ! per mil depletion for refreezing
          read(99,9993)(smoffset(ii),ii=1,ninit)  ! per mil enrichment for snowmelt
          if(flg2H==2)then
           read(99,9991)delta2H1                    ! riverwater 2H
           read(99,9991)delta2H2                    ! soil water 2H
           read(99,9991)delta2H3                    ! groundwater 2H
           read(99,9991)delta2H4                    ! snow 2H
           read(99,9993)(deltar2H(ii),ii=1,ninit)   ! 2H rain
           read(99,9993)(deltas2H(ii),ii=1,ninit)   ! 2H snow
           read(99,9993)(rfoffset2H(ii),ii=1,ninit)  ! 2H per mil depletion for refreezing
           read(99,9993)(smoffset2H(ii),ii=1,ninit)  ! 2H per mil enrichment for snowmelt
           read(99,9990)isoframeflg                 ! This doohickey is to set up the framework calcs: 1: whole basin avg framework, 2: 1 framework per gauge, 3: multiple frameworks, but with gauges aggregated-> read another file

           if(isoframeflg.eq.1)then 
           nisoframe=1
           else if(isoframeflg.eq.3)then
            
            inquire(FILE='basin\isobasin_combine.txt',EXIST=exists)
            if(exists)then
             open(98,file='basin\isobasin_combine.txt',iostat=ios)
             if(ios.ne.0)    
     *         print*,'Unable to open file  basin\isobasin_combine.txt'
             allocate (isoframecom(no),stat=iall)
             if(iall.ne.0) STOP 'Error allocating isotope frame combine'
             nisoframe=1
             do n=1,no
              read(98,9994)isoframecom(n)
              if(isoframecom(n).gt.nisoframe)nisoframe=isoframecom(n)
             end do
             close(98)
            else
             STOP 
     *        'Error reading \basin\isobasin_combine.txt 
     *          - create or do not use option 3'
            endif
            
           else 
           nisoframe=no
           end if
           
          end if
          close(99)
          endif

!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
          !TH: NEW ET split pars
          inquire(FILE='basin\ET.par',EXIST=exists)
            if(exists)then
             open(98,file='basin\ET.par',iostat=ios)
             if(ios.ne.0)    
     *         print*,'Unable to open file  basin\ET.par'
             do ii=1,classcount
              read(98,9995)acg(ii)
              read(98,9995)bcg(ii)
             end do
             close(98)
            else
             do ii=1,classcount
              acg(ii)=0.3
              bcg(ii)=4.
             end do
          end if
          
          else
          STOP 
     *     'Error reading \basin\isotope.init - create file & re-run'
          
          endif  !if par exists

!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
          !TH: if 18O is coming from gridded frc file, 2H should be checked too
           !TH: added 2H flg to allow for 18O runs only with CD gridded data
          if(frc_file_flg.eq.'c'.and.flg2H==2)then
           inquire(FILE=fln(49),EXIST=exists)
              if(.not.exists)STOP 
     *     'Error reading time series 2H data. Either added gridded 2H, 
     *turn off 2H flg, or turn off gridded 18O'
           print*,'reading time series delta 2H rain'
           call read_r2c(279,49,'1',jz,newDataFlag) !TH: I stole the gridded snow file for 2H (hopefully temp)
          endif
                   
        endif

d        if(iopt.eq.2)print*, '4 in rain'
d        write(98,*)'tem file header read'

!     rev. 9.1.75  Feb.  08/05  - NK: added rdgsm (gridded soil moisture)
!     rev. 9.2.25  Dec.  13/05  - NK: ENSIM r2c gridded soil moisture 

        if(id.eq.1)then 
          INQUIRE(FILE=fln(37),EXIST=exists)  ! gridded initial soil moisture
          IF(exists)THEN
            if(IsFileTypeR2C(fln(37)))then 
!             note: gsm is read again later to overwrite soil_init.r2c
!                 when present
d             if(iopt.eq.2)then
d		  	  print*,'In sub, passed location 1083 before read_gsm'
d               print*,'If program dies here, check the gsm file'
d		    endif 
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d             print*,'reading gridded soil moisture'      
              call read_gsm_ef    !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            else
              print*,'Old format gsm files not accepted'
              print*,'Please create EF _gsm.r2c files & rerun'
              print*
              stop 'Program aborted in sub @ 841'
            endif
d            write(98,*)'gridded soil moistures read'
          else
c            if(resumflg.eq.'y')then
            if(resumflg.ne.'n')then  ! could be y of s
c             print*,'Soil moisture from soil_init.r2c file used'
            else
              print*
              print*,'WARNING:'
              print*, fln(37)
              print*, 'not found'
              print*
              print*,'Please see manual on how to create a '
              print*,'gridded soil moisture file'
              print*
              pause 'Hit enter to use the event file values'
            endif
            ssmc_firstpass='n'    
            if(.NOT.allocated(ssmc))then      
!             suggested modification by D. Watson  mar 21/06 
              allocate(ssmc(ycount,xcount),stat=iAllocate)
              if(iAllocate.ne.0) STOP
     *         'Error with allocation of ssmc in sub @ 919'
              if(iopt.eq.2)print*,
     *          'allocation done in sub',ycount,xcount
              print*
            endif
            if(.NOT.allocated(api))then  
!             suggested modification by D. Watson  mar 21/06 
              allocate(api(na,classcount),stat=iAllocate)
              if(iAllocate.ne.0) STOP
     *         'Error with allocation of api in sub @ 927'
              if(iopt.eq.2)print*,
     *         'allocation done in sub',ycount,xcount
              print*
            endif
          endif
        endif

d        if(iopt.eq.2)print*,' In sub, passed location  934'

!       THIS SIMPLIFIES THE RAINFALL INPUT SO AN ENTIRE RAINFALL 
!       SEQUENCE CAN BE INPUTTED AT ONCE BUT ONLY THE DATA FOR THE 
!       CALIBRATION PERIOD WILL BE USED FOR THE FORECAST.

d          if(iopt.eq.2)print*,' In sub - gone to read_flow_ef'

           if(IsFileTypeTB0(fln(6))) then
c!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_flow_ef('1',date)  !EnSim compatible tb0 file
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           endif
            
d          if(iopt.eq.2)print*,' In sub - back from read_flow_ef'
d          write(98,*)'flows read'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        endif

!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout

d          if(iopt.eq.2)print*,' In sub - gone to read_resv_ef'
c          if(IsFileTypeTB0(fln(7))) then

!     rev. 9.5.57  Apr.  13/09  - NK: added ntrlflg for natural lake flows
!     rev. 9.9.40  Nov.  19/14  - NK: Modified the 'a' option for ntrlflg
c           if(id.eq.1.and.ntrlflg.eq.'y'.or.ntrlflg.ne.'y')then
           if(id.eq.1.and.ntrlflg.eq.'a')then
!             read the rel file - running natural flows
!             For natural flows, read the rel file only once for 1st event
!             then keep the same coefficients throughout the run
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_resv_ef()  !EnSim compatible tb0 file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           elseif(ntrlflg.eq.'a')then
!            in this case we are using the coefficients from event #1           
             continue
           else
!            for ntrlflg y or n in any event file except if ntrlflg = a in event #1  
!            read the release file           
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_resv_ef()  !EnSim compatible tb0 file
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif
            if(id.eq.1.and.noresv.ge.1)then
!             no need to do this if there are no reservoirs or lakes

!             fist event - read the rel file no matter what.
!             to run natural flows, make sure all locations have coefficients. 
!             you can rename the rel file resrl\yyyymmdd_ntrl.tb0
!             write an xyz file flow reservoir location plotting in GK
!             Added this here for FEWS  NK Jul.                
              if(iopt99.or.FLtype(6).eq.'nc')then
                if(FLtype(6).eq.'nc')then
                  open(unit=99,file='debug\reservoir_location.xyz',
     *                                           status='unknown')
                else
                  open(unit=99,file='reservoir_location.xyz',
     *                                           status='unknown')
                endif
                if(ios.ne.0)then    ! added Nov. 10/14  nk
                  print*
                  print*,'Unable to open file  reservoir_location.xyz'
                  print*,'Possible cause(s):'
                  print*,'file in use by another application'
                  stop 'Program aborted in sub.f @ 1637'
                endif
                do i=1,noresv
                  if(b1(i).gt.0.0)then
                    outlet_type='weir       '
                  else
                    outlet_type='regulated   '
                  endif
!     rev. 10.1.87 May   18/17  - NK: Added DA to reservoir_location.xyz
!     rev. 10.2.18 Mar.  12/18  - NK: Fixed array fault in read_resv_ef and sub
                  if(ires(i).le.ycount.and.jres(i).le.xcount.and.
     *                        ires(i).gt.0.and.jres(i).gt.0)then
                    n=s(ires(i),jres(i))
                    if(n.gt.0)write(99,99002)xres(i),yres(i),i,
     *                           resname(i),outlet_type,da(n)
                  endif
                end do
                close (unit=99,status='keep')
              endif   ! iopt99
              
              
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!             initialize    
              do l=1,noresv
                b6(l)=100.0     ! changed from 0.0  Dec. 3/14 nk
                b7(l)=100.0
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
                LKdepth(l)=1.0  !default value if not assigned in yyyymmdd_ill.pt2
                fpet_lake(l)=-1.0
              end do 
              

!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!             read the initial lake elevations for all lakes:
!             read the initial lake levels for all lakes:
!             test if yyyymmdd_ill.pt2 file exists. if yes, read it
!               Initial lake levels
!               read ill.pt2 file               ill   ill   ill   ill   ill   ill   ill
                INQUIRE(FILE=fln(50),EXIST=exists)
                if(exists)then
!                 read the initial lake level & datum  yyyymmdd_ill.pt2                 
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_pt2(280,50,nrows,ncols)
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  print*
                  if(nrows.ne.noresv)then
                    write(98,*)
     *              'Warning: Number of initial lake levels does not ',
     *               'match the number of lakes & reservoirs'
c                    print*,'Check for extra blank lines in the file'
                    write(98,*)'No of reservoirs & lakes =',noresv
                    write(98,*)'No init lake levels =',nrows
                    write(98,*)'Warning: program aborted!'
                    if(dds_flag.eq.1)pause 'Pause in sub - please fix'
                    stop 'Aborted in sub @ 1347 -SEE debug\warnings.txt'
                  endif
                  write(53,*)'in sub - init lake levels & datums'
                  print*,'Finished reading ',fln(50)(1:40),nrows,ncols      

!                 Qmin set as a flag to check that qmin & safe_max
!                 are entered in the ill file
                  qmin(1)=-999.0  
                  do l=1,noresv
                    b6(l)=inarray(l,1)           ! init lake level
!     rev. 10.1.95 Sep   11/17  - NK: Fixed LKdepth bug in sub
                    lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned
                    b7(l)=inarray(l,2)           ! datum
c                    if(ncols.eq.4)then           ! 4 att's incl. name
                    if(ncols.ge.4)then
                        
                        ! 4 attributes incl. name
!                     default value = 1.0 set above                    
                      LKdepth(l)=inarray(l,3)
                      if(LKdepth(l).lt.b6(l)-b7(l))then
                          print*,
     *                 'WARNING: Lake Depth',l,' lower than Datum'
                      endif    
!                     LKdepth in the ill file is the initial lake depth below the invert
!                     like the hight of a weir - and is dead storage usually 
!                     But here it is redefined as tha actual depth of water in the lake
!                     and becomes a variable and is used in the evaporation routine
                      LKinvert(l)=b7(l)-inarray(l,3)
                      LKdepth(l)=lake_elv(l,1)-LKinvert(l)

                      write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),
     *                       'LKdepth=',LKdepth(l),'LKinve=',LKinvert(l)
                    endif  
                    if(ncols.ge.6)then
                      safe_max(l)=inarray(l,4)
                      qmin(l)=inarray(l,5)
                      DecayT(l)=inarray(l,6)
                      write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),
     *                    'LKdepth=',LKdepth(l),'LKinvert=',LKinvert(l),
     *                      'Qmin=',qmin(l),'safe_max=',safe_max(l),
     *                      'DecayT=',DecayT(l)
                    endif
c                    fpet_lake(l)=inarray(l,3)    ! fpet for lake l
c                    if(iopt.eq.1)then
c                    endif                      
                  end do
                  deallocate(inarray)
!                 NOTE:
!                 initial lake storage & outflows are calculated in flowinit.f below
                  
!                 write a file that has the datum for lakes & reservoirs
!                 so the datum can be plotted
                  if(iopt99)then
                    open(unit=99,file='results\datum.txt',
     *                               status='unknown',iostat=ios)
                    write(99,99005)0,(b7(l),l=1,noresv)
                    do i=1,ni
                      write(99,99005)i*365,(b7(l),l=1,noresv)  
                    end do
                    close(unit=99,status='keep')
                  endif
                else
                  if(dds_flag.eq.0)then
                    write(53,*)
                    write(53,*)'WARNING'
                    write(53,*)'No initial lake levels file found.'
                    write(53,*)'Looking for file:' 
                    write(53,*)fln(50)(1:40)
                    write(53,*)
     *                'Default values for datum & initial level = 0.0'
                    write(53,*)
                    print*
                    print*,'WARNING'
                    print*,'No initial lake levels file found.'
                    print*,'Looking for file:' 
                    print*,fln(50)(1:40)
                    print*,
     *                'Default values for datum & initial level = 0.0'
                    print*
                    if(lakeflg.eq.'y')then 
                      print*,'NOTE: for lake evap model, ill file with'
                      print*,'lake depths are required'
                      stop 'program aborted in sub @ 1714'
                    endif
                  endif
                endif  ! (exist)

!     rev. 9.7.27  May.  26/11  - NK: Add lake_ice_factor
!     Commented out for MRBM in 2014
!     REV. 10.1.42 Oct   20/16  - NK: Reinstated read_ice_factor.f as default if present
              icefactorfile=.false.   ! change to true if file exists
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_ice_factor()    !!for lakes only!!
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            endif    ! id=1

c          else
c!           need this just in case there is an old format rel file 15/04/08 nk
c!           call rdresv()   
c            inquire(FILE=fln(7),EXIST=exists)
c            if(exists)then
c              print*,'Old format .rel files not accepted'
c              print*,'Please create yyyymmdd_rel.tb0 files & rerun'
c              stop 'Program aborted in sub @ 1052'
c            endif
c          endif
d          if(iopt.eq.2)print*,' In sub - back from read_resv_ef'
d          write(98,*)'releases read'

!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
          if(resinflg.eq.'y')then
!         call rdresvin() 
          if(IsFileTypeTB0(fln(8))) then
d            if(iopt.eq.2)print*,' In sub - gone to read_resvin_ef'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_resvin_ef()  !EnSim compatible tb0 file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
!            call rdresvin()   
             print*,'Old format .tin files not accepted'
             print*,'Please create yyyymmdd_rin.tb0 files & rerun'
             stop 'Program aborted in sub @ 979'
          endif
d          if(iopt.eq.2)print*,' In sub - back from read_resvin_ef'
d          write(98,*)'reservoir inflows read'
          endif        

 
!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.tb0 for diversions
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!                                 This added the divertflg to see whether to read the 
!                                 diversion data or generate it.
!         Diversions    Diversions    Diversions    Diversions    Diversions
          diversion=.false.
          if(divertflg.eq.'y')then
            INQUIRE(FILE=fln(52),EXIST=exists)
            if(exists)then
              diversion=.true.
                call read_divert(282,52)
              if(iopt.ge.1)print*,'Diversion file read:',fln(52)(1:40)
              if(iopt.ge.3)pause 'after read_divert in sub'
            else
!     rev. 9.9.42  Nov.  26/14  - NK: Added errer check if diversion does not exist 
              print*,'Error:'
              print*,'divertflg in the event file = `y`'
              print*,'but',fln(52)(1:40)
              print*,'i.e.  diver\yyyymmdd_div.tb0'
              print*,'is not found'
              stop 'Program aborted in sub @ 1827'
            endif
          else
           nodivert=0    ! used as a flag in rerout
          endif

!     rev. 9.8.24  Aug.  07/12  - NK: Added reading yyyymmdd_lvl.tb0 for lake levels
          lvlflg=.false.
            if(dds_flag.eq.0)then     !added Feb. 20/14 nk
c             INQUIRE(FILE=fln(53),EXIST=exists)
c             if(exists)then
                
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          
              call read_level(283,53)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     
              
              print*,'Lake levels read:',fln(53)(1:40)
c              lvlflg=.true.
!             open levels output file results\levels.txt
              if(id.eq.1.and.lvlflg)then  
!               open 'results\levels.csv'    !lake level comparison                  
                open(unit=953,file=filename(953),status='unknown',
     *                    iostat=ios)
                if(ios.ne.0)then    ! added Nov. 10/14  nk
                  print*
                  print*,'Unable to open file',filename(953)(1:40)
                  print*,'Possible cause(s):'
                  print*,'file in use by another application'
                  print*,'or target directory does not exist'
                  stop 'Program aborted in sub.f @ 1792'
                else
                  print*,'Opened file ',filename(953)(1:50)
                endif
              endif
              print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
c            endif   
          endif   ! dds_flag.eq.0

        if(icase.le.-10)then

!         TO RUN A FORECAST SIMULATION (BEYOND REAL TIME DATA)
!         AND USE ALL ENTERED (INCLUDING FORECAST) RAINFALL 
!         THE SOIL MOISTURE COMES FROM THE EVENT FILE, NOT    
!         FROM THE MET FILE.

!         WE HAVE OPTIMIZED SOIL MOISTURE OR SCALED THE RADAR
!         NOW WE WANT TO FORECAST WITH THE RAIN UP TO THE FORECAST
!         TIME.

          mhtot=nl
          nr=min(nr,mhrd)

        elseif(icase.eq.-2)then

!         FOR SCALING THE ENTIRE RAINFALL FIELD BY THE SAME AMOUNT
!         CALIBRATE TO RECORDED FLOWS ONLY UNTIL MHRD
!         SEE ALSO THE CALL TO RAIN BELOW.  

          if(nnn.le.0)write(51,6004)nr,mhrd

!         ACTIVATE THIS IF YOU WANT TO READ IN THE OPT PERIOD 
!         WITH THE STREAMFLOW INPUT MENU

!!!!!!    scale=a(1)
          mhtot=mhrd

        elseif(icase.eq.-1)then

!         FOR SMC FITTING ONLY
!         CALIBRATE TO RECORDED FLOWS ONLY FOR SMC FITTING
!         USES STREAMFLOW AND RAINFALL UNTIL MHRD
!         BUT RUNS SPL FOR THE ENTIRE PERIOD NL

          if(nnn.le.0)write(51,6004)nr,mhrd

!         ACTIVATE THIS IF YOU WANT TO READ IN THE OPT PERIOD 
!         WITH THE STREAMFLOW INPUT MENU

          mhtot=mhrd

        elseif(icase.eq.0)then

!         DO A SINGLE RUN WITH ALL AVAILABLE RAINFALL 
!         TO THE END OF THE RAINFALL RECORD
!         FOR THIS OPTION, THE AP's AT THE GAUGES WILL BE USED
!         IF AVAILABLE, OTHERWISE THE NUMBERS IN THE EVENT FILE
!         ALSO, THE SCALING FACTOR IS SET eq. TO CONV
  
          mhrd=nl
          mhtot=nl

        elseif(icase.gt.0)then

!         OR DO A PARAMETER CALIBRATION ON WHOLE HYDROGRAPH, 
!         WHERE NUMA IS THE NUMBER OF PARAMETERS TO BE OPTIMIZED
!         ALL AVAILABLE RAINFALL WILL BE USED.
!         AND FOR PARAMETER CALIBRATION USE THE SAME FOR ALL
!         ELEMENTS.

          mhtot=nl    

        endif

        if(iopt.ge.1)then
          if(id.eq.1.and.ni.gt.3.and.mhtot.gt.8000)then
          print*
          print*
          print*,' It looks like you are running more '
          print*,' than 3 years of simulation in the debug'
          print*,' mode (iopt>0) You may run out of disk space.'
          print*
          print*
c         print*,' Hit Ctrl^C to abort'
c         print*
c         pause ' Hit enter to continue with this run.'
          endif
        endif

!       VER. 9.1 - SEDIMENT/NUTRIENT COMPONENT 
!       TO CALL wqread, SEDFLG MUST BE READ IN AS 'Y' IN rdevtA
!       Read water quality data (sediments and nutrients)

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(sedflg.eq.'y')call wqread
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        if(iopt.ge.1)write(51,5002)nr,smc5(1),mo,conv

d        if(iopt.eq.2)print*,' In sub, passed location  234'
  
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        if(id.eq.1)then

d          if(iopt.eq.2)print*,'in sub, gone to flowinit'
!         make sure this call is after reading initial lake levels
!         read_pt2(280,50)....      

!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call flowinit()
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

          if(routeflg.eq.'y')then
!           write a new flow_init file only if creating files for watroute  
!           first delete the old file if one exists:      
            inquire(FILE='flow_init.r2c',EXIST=exists)
            if(exists)then
              fln(99)='flow_init.r2c'
              open(99,file=fln(99),status='unknown',iostat=ios)
              close(unit=99,status='delete')
              print*
              print*,'Old ***',fln(99)(1:60),'*** deleted'
            endif
          endif

          if(initflg.eq.'y')then
            author='spl.exe (flowinit)    '
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_flowinit()
c            call write_lzsinit()
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            print*,'flowinit.r2c '
            print*,' written in working directory'
          endif

c          if(resumflg.ne.'y'.and.snwflg.eq.'y') then
          if(resumflg.eq.'n'.and.snwflg.eq.'y') then
!           READ THE SNOW COURSE DATA FOR INIT SNOW
!           but not if there is aresume file
!           If swe needs to be read in, set the crseflg='y'
!           read swe in the first event if snwflg = y
!           but it would be overridden by the resume file
!           values if resumflg = y
            if(IsFileTypeR2C(fln(36))) then
d             if(iopt.eq.2)then
d		   	    print*,'In sub, passed location 1430 before read_swe'
d               print*,'If program dies here, check the swe file'
d		      endif 
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d             print*,'reading swe r2c file'      
              call read_sweinit(266,36)  !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            else
              print*,'Found SWE file ',fln(36)
              print*,'Old format swe files not accepted'
              print*,'Please create EF ????_swe.r2c files & rerun'
              stop 'Program aborted in sub @ 1216'
              if(iopt.eq.2)print*,'in sub, passed location 1114'
            endif
d            write(98,*)'swe file read'
d            if(iopt.eq.2)print*,'in sub, back from read_sweinit'
          else
!           ADDED DEC. 13/98  NK
!           default swe = 0.0 - replaced be rdresume or rdswe 
!           if files are present & read.
            do n=1,naa
              do ii=1,classcount
              snowc(n,ii)=0.0
              end do
            end do
          endif

d          if(iopt.eq.2)print*,'in sub, passed location 237'
          do n=1,naa
            if(slope(n).gt.0.0)then  
              sump(n)=0.0
              sumrff(n)=0.0
              do ii=1,classcount
                ssumr(n,ii)=0.0
                intev(n,ii)=0.0
                ev(n,ii)=0.0
              end do
            endif
          end do
d          if(iopt.eq.2)print*,'in sub, passed location 238'

!     rev. 9.2.30  Feb.  07/06  - NK: Added class_distribution.txt to output

          if(.NOT.allocated(areaclass))then     
c           allocate(areaclass(no,classcount),stat=iAllocate)

!            fixed april 1/10 - has to be max # gauges  # grids  nk
c            allocate(areaclass(na,classcount),areasum(na),stat=iAllocate)

            n=max(no,na)
            allocate(areaclass(n,classcount),areasum(n),stat=iAllocate)
            if(iAllocate.ne.0) STOP
     *         'Error with allocation of areaclass in sub @ 1351'
            print*
          endif

!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
c          if(numa.eq.0.and.iopt.ge.1)then
          if(numa.eq.0)then
            open(unit=99,file='class_distribution.txt',
     *            status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file  class_distribution.txt'
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              stop 'Program aborted in sub.f @ 2004'
            endif
            write(51,6016)
            write(51,6017)classcount
            write(99,6017)classcount

            do n=1,na
!             initialize values
              areasum(n)=0.0
              do ii=1,classcount
                areaclass(n,ii)=0.0
              end do
            end do

            do n=1,naa
c             write(51,6014)yyy(n),xxx(n),
c    *             frac(n),(aclass(n,ii),ii=1,classcount)
c             write(*,6014)yyy(n),xxx(n),
c     *            frac(n),(aclass(n,ii),ii=1,classcount)
     *            
              if(n.gt.0.and.next(n).gt.0)then        ! ??????????????????????
                areasum(next(n))=areasum(next(n))+areasum(n)+frac(n)
                areasum(n)=areasum(n)+frac(n)
                do ii=1,classcount
                  areaclass(next(n),ii)=areaclass(next(n),ii)+
     *              areaclass(n,ii)+frac(n)*aclass(n,ii)
                  areaclass(n,ii)=areaclass(n,ii)+frac(n)*aclass(n,ii)
                end do
c               write(*,6018)n,areasum(n),(areaclass(n,ii),ii=1,classcount)
              endif
            end do

            do l=1,no
!     rev. 9.5.77  Oct.  26/09  - NK: fixed some inits for out of basin gauges
              if(inbsnflg(l).eq.1)then
                i=(ystr(l)-yorigin)/ydelta+1
                j=(xstr(l)-xorigin)/xdelta+1
                n=s(i,j)
                write(99,6013)xstr(l),ystr(l),l,gage(l),
     *            areasum(l),
     *            ((areaclass(n,ii)/areasum(n)),ii=1,classcount)
                write(51,6014)
              endif
            end do
            close(unit=99,status='keep')
          endif
c
c!     rev. 9.2.07  Jul.  29/05  - NK: soilinit moved from runoff to sub 
c!         tdum converts mm/hour to m^3/sec for a grid with frac=1.0
c           tdum=1000.*step2/3600.

          if(modelflg.eq.'r'.or.modelflg.eq.'l'
     *          .or.modelflg.eq.'i')then
!           skip soilinit for watroute
            continue
          else

!           ~~~~~~~~~~~~~~~~~~~
            call soilinit()
!           ~~~~~~~~~~~~~~~~~~~
            

            if(initflg.eq.'y')then
!             ~~~~~~~~~~~~~~~~~~~~~
              call write_soilinit()
!             ~~~~~~~~~~~~~~~~~~~~~
            endif

            endif
            
            
            
            
            
            
            
            
!     rev. 9.2.05  Jul.  15/05  - NK: reversed order of reading resume file 
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
          if(resumflg.ne.'n')then   !NOTE THE .NE. 
!         .NE. IS USED BECAuSE IT CAN BE OTHER THAN 'n' OR 'y'
!         THIS SECTION IS USED TO READ IN ALL STATE VARIABLES
!         SO PROGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!         IN RUNOF6, SOILINIT.F IS not SKIPPED but over written
!         ~~~~~~~~~~~~~~~~~~~~~~~~

!         NOTE: these 3 calls go together for a resumed run:
!     rev. 9.5.79  Nov.  04/09  - NK: added resumflg='s' for read_soilinit ONLY
            if(resumflg.ne.'s')then
!             these are skipped for the special case when we want to 
!             read the soilinit file (below) but not the flow init and other stuff
!             i.e. we skip this is the resumflg='s'
!             ~~~~~~~~~~~~~~~~~~~~~
              call rdresume()
!             ~~~~~~~~~~~~~~~~~~~~~
              flnNum=99
              fln(99)='flow_init.r2c'
!             There are 2 flowinit possibilities:
!             One with a resume: the flow_init.r2c file will be in the working directory
!             the other when is it done on the fly as an updating tool with
!                       strfw\yyyymmdd_fli.r2c
!             This is with a resume:
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_flowinit(flnNum)
!             ~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!             This data is in the flow_init.r2c file so it's not needed 
c              read the gridded lzs  -- but why bother?????
c              call read_r2c(268,38,'1',jz,newDataFlag)
!             ~~~~~~~~~~~~~~~~~~~~~
            endif
!           For resumflg = s, only the soil_init.r2c file will be read 
!           but the lzs and all flow variables will be initialized with 
!           streamflow.
!           Soilinit is read every time we use the resume files
            fln(99)='soil_init.r2c'
d           print*,'reading soil_init.r2c file'     
!           ~~~~~~~~~~~~~~~~~~~~~
            call read_soilinit()
!           ~~~~~~~~~~~~~~~~~~~~~
!           NOTE: if the _gsm.r2c and _swe.r2c files exist, values therein
!           will replace values from the soil_init.r2c file 
            if(resumflg.ne.'s')then           
!             i.e. we skip this if the resumflg='s'
d             print*,'reading gridded soil moisture file'      
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_gsm_ef()
!             ~~~~~~~~~~~~~~~~~~~~~
d             print*,'reading swe r2c file' 
!     rev. 9.9.10  Mar.  20/14  - NK: Update swe anytime a file is found
!             but don't call if the resumflg = 'y' 
!             It will update later if the sweflag = 'u'
              if(.not.resumflg.eq.'y')then     
!               ~~~~~~~~~~~~~~~~~~~~~
                call read_sweinit(266,36)  
!               ~~~~~~~~~~~~~~~~~~~
              endif
              endif
            
!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!           >>>>>resume with updated lake storage
!           No matter what, we need coefficients (safe max etc.) from this file
            fln(99)='lake_level_init.pt2'   ! for resume only - generic name
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_pt2(99,99,nrows,ncols)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d           print*
d           print*,'Back from read_pt2 to read initial lake levels'
d           print*
            if(nrows.ne.noresv)then
              print*
              print*,'Number of initial lake levels does not'
              print*,'match the number of lakes & reservoirs'
              print*,'No of reservoirs & lakes =',noresv
              print*,'No init lake levels =',nrows
              print*
              if(dds_flag.eq.1)pause 'Pause in sub - please fix'
              stop 'Program aborted in sub @ 1966'
            endif
            write(53,*)'in sub @ 1951 - init lake levels & datums'
            print*,'Finished reading ',fln(99)(1:40)


            
            
c take this out - it's all in the resume files <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<            
            
            
            do l=1,noresv                                                            
               b6(l)=inarray(l,1)           ! init lake level                         
!         rev. 10.1.95 Sep   11/17  - NK: Fixed LKdepth bug in sub                    
               lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned              
               b7(l)=inarray(l,2)           ! datum                                   
c               if(ncols.eq.4)then           ! 4 att's incl. name                     
               if(ncols.ge.4)then                                                     
                                                                                      
                   ! 4 attributes incl. name                                          
!                default value = 1.0 set above                                        
                 LKdepth(l)=inarray(l,3)                                              
                 if(LKdepth(l).lt.b6(l)-b7(l))then                                    
                     print*,                                                          
     *            'WARNING: Lake Depth',l,' lower than Datum'                         
                 endif                                                                
                 LKinvert(l)=b7(l)-inarray(l,3)                                       
                 LKdepth(l)=lake_elv(l,1)-LKinvert(l)                                 
                                                                                      
                 write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),                     
     *                  'LKdepth=',LKdepth(l),'LKinve=',LKinvert(l)                   
               endif                                                                  
               if(ncols.ge.6)then                                                     
                 safe_max(l)=inarray(l,4)                                             
                 qmin(l)=inarray(l,5)                                                 
                 DecayT(l)=inarray(l,6)                                               
                 write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),                     
     *               'LKdepth=',LKdepth(l),'LKinvert=',LKinvert(l),                   
     *                 'Qmin=',qmin(l),'safe_max=',safe_max(l)                        
               endif                                                                  
c               fpet_lake(l)=inarray(l,3)    ! fpet for lake l                        
c               if(iopt.eq.1)then                                                     
c               endif                                                                 
            end do                                                                  

               
            do l=1,noresv
c              b6(l)=inarray(l,1)           ! init lake level
c              b7(l)=inarray(l,2)           ! datum
              LKinvert(l)=b7(l)-inarray(l,3)
              lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned
c             fpet_lake(l)=inarray(l,3)    ! fpet for lake l
c             if(iopt.eq.1)then
c                write(53,*)'l=',l,'b6=',b6(l),'b7=',b7(l),
c     *                              'fpet=',fpet_lake(l)
c             endif        
!             lake storage must be recalculated 
!             as lake levels could be reset
!             this will overwrite the storaged read from flow_init.r2c

!     rev. 9.9.34  Oct.  17/14  - NK: Added re-compute of lake storage re: new lake levels
	        if(b6(l).ne.0.0.or.b7(l).ne.0.0)then
!               initial lake levels can be lower than the datum	        
c	          if(b7(l).lt.b6(l))then
                write(53,*)
                write(53,*)'Override flow based initial storage:'
c                store1(n)=(b6(l)-b7(l))*lake_area(l)
!               store1 & store2 are now total lake storage
 !     rev. 10.2.45 Jan.  21/19  - NK: Fixed bug in reservoir initialization in sub - n was undefined
                i=ires(l)
                j=jres(l)
                n=s(i,j)
                store1(n)=(b6(l)-b7(l))*lake_area(l)+store_dead(l)
                store2(n)=store1(n)
                if(store2(n).ge.0.0)then
                  if(b3(l).eq.0.0)then
c                    qo2(n)=b1(l)*store2(n)**b2(l)
                    qo2(n)=b1(l)*(store2(n)-store_dead(l))**b2(l)
                  else
c                    qo1(n)=store2(n)*(b1(l)+store2(n)*(b2(l)+store2(n)*
c     *                (b3(l)+store2(n)*(b4(l)+b5(l)*store2(n)))))
                    store_live=store2(l)-store_dead(l)
                    qo1(n)=store_live*
     *                (b1(l)+store_live*
     *                (b2(l)+store_live*
     *                (b3(l)+store_live*
     *                (b4(l)+b5(l)*store_live))))
                  endif   
                  qo2(n)=qo1(n)
                else
                  qo2(n)=0.0
                endif
              endif
!     end rev. 9.9.34  Oct.  17/14  - NK: Added re-compute of lake storage re: new lake levels
            end do


                
                
                
                
            print*
            print*,'NEW        Rev. 9.9.34        Oct.  17/14'
            print*,'Recalculated lake storage & outflow based'
            print*,'on the file lake_level_init.pt2'
            print*,'in the working directory'
            print*
            deallocate(inarray)
              endif   ! resume
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME            


          if(iopt.ge.1)print*,'In SUB: initialization completed '
          
!     rev. 9.8.69  Jun   17/13  - NK: Fixed bug in allocating clumnunits in SUB.f
!         moved from below to make it general
          if(allocated(column_type))then
            deallocate(column_type,column_units,stat=iDeallocate)
            if(iDeallocate.ne.0)then
              print*,'Error with deallocation of resv stuff'
              print*
              stop 'Program aborted in subf @ 1575'
            endif
          endif
!         allocate for the largest number needed              
          n=max(noresv,2*no)
          allocate(column_type(n),column_units(n),stat=iAllocate)
          if(iAllocate.ne.0) STOP
     *          'Allocation Error:  arrays in sub @1558'

!         Net Basin Supply header for Great Lakes and Mackenzie
          if(noresv.gt.0.and.dds_flag.eq.0)then
!           write the header for the nbs.tb0 file
            if(resname(1).eq.'Superior     '.or.
     *        routeflg.eq.'q'     )then
!             create a nbs.tb0 file for 1D
              author='watflood                                '
              if(resname(1).eq.'Superior     ')then
                name='Net_Basin_Supply_GLAKE                  '
              elseif(routeflg.eq.'q')then                                
                name='MRBB_MASTER_INFLOWS                     '
              else
                name='Net_Basin_Supply                        '
              endif
              coordsys_temp=coordsys1
!             GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
              zone_temp=zone1
              datum_temp=datum1
              xorigin_temp=xorigin
              yorigin_temp=yorigin
              author='WATROUTE'

              if(mo1.lt.10.and.day1.lt.10)then
                write(line,77661)year1,mo1,day1
77661           format(i4,'/',i1'/',i1)
              elseif(mo1.lt.10.and.day1.ge.10)then
                write(line,77662)year1,mo1,day1
77662           format(i4,'/',i1'/',i2)
              elseif(mo1.ge.10.and.day1.lt.10)then
                write(line,77663)year1,mo1,day1
77663           format(i4,'/',i2'/',i1)
              else
                write(line,77664)year1,mo1,day1
77664           format(i4,'/',i2'/',i2)
              endif
              startdate=line
              write(line,77665)hour1
77665         format(i2,':00:00')
              starttime=line
c              startdate='0000/01/01'
c              starttime='0:00      '
              unit_conversion=1.0
!             attribute_name='sum precipitation                       '
              attribute_units='m3/s' 
!              attribute_type='Runoff                                  '  
              source_file_name='last spl run' 
  
              if(allocated(column_type))then
                deallocate(column_type,stat=iDeallocate)
                deallocate(column_units,stat=iDeallocate)
                if(iDeallocate.ne.0)then
                  print*,'Error with deallocation of resv stuff'
                 print*
                  stop 'Program aborted in subf @ 1575'
                endif
              endif
!             allocate for the largest number needed              
              n=MAX0(noresv,2*no)
              allocate(column_type(n),stat=iAllocate)
              allocate(column_units(n),stat=iAllocate)
              if(iAllocate.ne.0) STOP
     *         'Allocation Error:  arrays in sub @1558'
              do l=1,n
                column_type(l)='float' 
                column_units(l)='m**3/s'   
              end do
!             write the header for the nbs.tb0 file
!             
!     REV. 10.1.15 Jan.  08/16  - NK: Custom coding for Mackenzie River Basin Hydraulic Model
!             write the header for the mrb_master_inflows.tb0 file
!             the last 20 lakes are not to be writted to this file but 
!             passed through rerout for natural lake routing
!                                   un,fn,nfg,ng,no_signf
!             # of MRBHM nodes = 126
              call write_flow1d_tb0(70,70,nfg,126,-1)
            endif
          endif

        endif    !id.eq.1
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        
!     rev. 9.8.09  Nov.  22/11  - NK: nopt(l)=0 for area_error(l) > 10%
c          if(dds_flag.eq.1)then
c            i=0
c            do l=1,no
c              if(abs(area_error(l)).gt.10.0)then
c                nopt(l)=0
c                i=i+1
c              endif
c            end do
c            if(i.gt.0)then
c              print*,'no error calcs for',i,'stations w/area errors'
c            endif
c          endif  


!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!       this section of code needs to stay here because we need to
!       know the no of flow & reservoir locations
!       pre-emption
        if(id.eq.1)then
        
          sum_sq_error=0.0
          dds_error=0.0

          if(.not.allocated(mean_observed))then
            allocate(mean_observed(no+noresvi),pre_sse(no+noresvi),
     *           stat=iAllocate)
            if(iAllocate.ne.0) STOP 
     *       'Error with allocation in sub @ 1598'
	      allocate(qhyd_sum(no+noresvi),qsyn_sum(no+noresvi),
     *           qhyd_mean(no+noresvi),qsyn_mean(no+noresvi),
     *           qhyd_mean_evt(no+noresvi,ni),
     *           qsyn_mean_evt(no+noresvi,ni),
     *           sum_den(no+noresvi),sum_num(no+noresvi),
     *           num_obs(no+noresvi),
     *           stat=iAllocate)
            if(iAllocate.ne.0) STOP 'Problem allocating qhyd_sum etc'
	    endif

!         initialize the sums
          do l=1,no+noresvi
            qhyd_sum(l)=0.0
            qsyn_sum(l)=0.0
            num_obs(l)=0
	      sum_num(l)=0.0
	      sum_den(l)=0.0
	      do i=1,ni
              qhyd_mean_evt(l,i)=0.0
              qsyn_mean_evt(l,i)=0.0
            end do
          end do

          if(dds_flag.eq.1)then
!           open the dds_log.txt file:
            open(unit=30,file=filename(30),status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file',filename(30)(1:40)
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              print*,'or target directory does not exist'
              print*
              pause 'For single run, to continue - hit Enter'
              dds_flag=0
c              stop 'Program aborted in sub.f @ 2351'
            endif
!           go to the end of the file so new data is appended  
            DO WHILE(.NOT.EOF(30))
              read(30,*,iostat=ios)
            end do
          endif

!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
          if(.not.allocated(sta_weight))then
	      allocate(sta_weight(no+noresvi),mse(no+noresvi),
     *		 stat=iAllocate)
            if(iAllocate.ne.0) STOP
     *      'Error with allocation of sta_weight in sub @491'   
          endif 

!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
c          if(abs(dds_flag).eq.1.or.dds_flag.eq.3.or.
c     *           dds_flag.eq.6.or.dds_flag.eq.7.or.dds_flag.eq.8)then
          if(abs(dds_flag).eq.1)then
          inquire(FILE='mean_observed_flows.txt',EXIST=exists)
          if(exists)then
            open(unit=99,file='mean_observed_flows.txt',
     *                    status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file  mean_observed_flows.txt'
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              pause 'Program will abort with hit enter'
              stop 'Program aborted in sub.f @ 2380'
            endif
d            print*,'reading the mean flows in sub'

!     rev. 9.8.03  Aug.  08/11  - NK: check no of mean observed flows in file are ok
!     rev. 10.1.71 Mar.  14/17  - NK: Revised reading mean_observed_flows in sub 
              i=0
              ios=0
              read(99,*,iostat=ios)
              DO WHILE(.NOT.EOF(99))
                read(99,*,iostat=ios)i,mean_observed(i)
d               write(*,*)i,mean_observed(i)
              end do
              ios=0
              if(iopt.ge.1)then
                print*,'no of entries in mean_observed_flows.txt =',i
                print*
              endif
              if(errflg.eq.1.or.errflg.eq.3.or.errflg.eq.5.or.
     *           errflg.eq.6.or.errflg.eq.7.or.errflg.eq.8.or.
     *           errflg.eq.100)then

                if(i.ne.no+noresvi)then
                  print*,'no of mean_observed_flows.txt =',i
                  print*,'no of flow & resv inflow statns =',no+noresvi
                  print*,'These numbers must be equal'
                  print*,'Remove file & run splx to get a new file'
                  print*,'It is needed only for DDS'
                  print*,'program paused in sub @ 1830'
                  if(dds_flag.eq.1)pause 'Hit enter to abort splx'
                  stop 'Program aborted in sub @ 1904'
                endif
              endif
c             rewind(unit=99)
            close(unit=99,status='keep')
!     rev. 9.8.03 -- end              

!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
c              read(99,*,iostat=ios)
c            if(resinflg.ne.'y')noresvi=0
c            do l=1,no+noresvi
c              read(99,*,iostat=ios)i,mean_observed(l)
cd             write(*,*)i,mean_observed(l)
c            end do
            if(i.ne.no+noresvi)then
                print*,'File found but'
                print*,'Problems reading mean_observed_flows.txt'
                print*,'# entries found =',i
                print*,'# entries needed =',no+noresvi
                print*,'for # flow stations =',no
                print*,'and # reservoir inflows =',noresvi
                print*,'Have you changed the number of stations?'
                print*,'Do you have a reservoir or lake inflow file?'
                print*,'Please fix or remove the file'
                print*,'Remove file & run splx to get a new file'
                print*,'It is needed only for DDS'
                stop 'Program aborted in sub @ 1792'
            endif
c            close(unit=99,status='keep')
!     rev. 9.7.08  Sep.  21/10  - NK: revised error weighting for DDS
            if(errflg.eq.1.and.dds_flag.ge.0)then
              print*
              print*,'mean_observed_flows.txt file  found'
              print*,'station mean squared errors will be weighted'
              print*,'with station weights based on'
              Print*,'Weight(i)=sta_MSE(i)/sum(sta_MSE(n))'
	        print*,'where n is the number of stations used for'
	        print*,'calibration'
              print*
	        print*,'Calculating station weights for DDS'
	        print*,'Table in spl.txt'
	        print*
            endif

!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
            i=0
	      sum_mean_flow=0.0
            do l=1,no
              if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                sum_mean_flow=sum_mean_flow+mean_observed(l)
	          i=i+1
	        endif
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            do l=1,noresvi
              if(nopti(l).eq.1.and.mean_observed(no+l).gt.0.0)then
                sum_mean_flow=sum_mean_flow+mean_observed(no+l)
	          i=i+1
	        endif
	      end do

	      write(51,*)
	      write(51,*)'Station weights for DDS error calculation:'
	      do l=1,no
	        if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
	          sta_weight(l)=mean_observed(l)/sum_mean_flow
	        else
	          sta_weight(l)=0.0
	        endif
	        if(nopt(l).eq.1)then
	          write(51,*)l,mean_observed(l),sum_mean_flow,sta_weight(l)
	        endif
	        num_obs(l)=0          !initialize number of observations
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
	      do l=1,noresvi
	        if(nopti(l).eq.1.and.mean_observed(no+l).gt.0.0)then
	          sta_weight(no+l)=mean_observed(no+l)/sum_mean_flow
	        else
	          sta_weight(no+l)=0.0
	        endif
	        if(nopti(l).eq.1)then
	          write(51,*)l,mean_observed(no+l),
     *	                	  sum_mean_flow,sta_weight(no+l)
	        endif
	        num_obs(no+l)=0          !initialize number of observations
	      end do

          else
d            print*,'no=',no
            do l=1,no+noresvi
              mean_observed(l)=1.0
            end do

            i=0
	      do l=1,no
	        if(nopt(l).eq.1)then
	          i=i+1
	        endif
	      end do
	      do l=1,no
	        if(nopt(l).eq.1)then
	          sta_weight(l)=1.0/float(i)
	        else
	          sta_weight(l)=0.0
	        endif
	        if(nopt(l).eq.1)then
	          write(51,*)l,mean_observed(l),sum_mean_flow,sta_weight(l)
	        endif
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
	      do l=1,noresvi
	        if(nopti(l).eq.1)then
	          i=i+1
	        endif
	      end do
	      do l=1,noresvi
	        if(nopt(no+l).eq.1)then
	          sta_weight(no+l)=1.0/float(i)
	        else
	          sta_weight(no+l)=0.0
	        endif
	        if(nopti(no+l).eq.1)then
	          write(51,*)l,mean_observed(no+l),
     *			  sum_mean_flow,sta_weight(no+l)
	        endif
	      end do
            print*,'WARNING:'
            print*,'mean_observed_flows.txt file not found'
            print*,'all flagged stations will be equally weighted'
	      print*,'--including stations without any flows if flagged--'
            print*
            if(errflg.eq.1.or.errflg.eq.7.or.
     *         errflg.eq.8.or.errflg.eq.100)then
              print*,'For errflg=',errflg,' mean flow file is required'
              print*
            endif
          endif
        endif
        endif  ! dds_flag.eq.1

!       read in new snow course data and replace computed swe
!       moved  April 12/01  nk
!       moved here June 09/06  nk
!       moved here so swe can be read in even if run starts with
!       a resume file. SWE from here overrides the resume file values
!       I.e. to use swe from the swe file, it has to be explicitly 
!       asked for with the crseflg. Just the snwflg is not enough!

        if(crseflg.eq.'y'.and.snwflg.eq.'y')then
!         this is where swe is updated at the start of an new event        
!         in a sequence to update the swe
          if(IsFileTypeR2C(fln(36))) then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d           print*,'reading swe r2c file @ 1905'      
            call read_sweinit(266,36)    !EnSim compatible r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
            print*,'Old format swe files not accepted'
            print*,'Please create EF ????_swe.r2c files & rerun'
            stop 'Program aborted in sub @ 1321'
          endif
          write(98,*)'swe file read'
        endif
        
        if(resumflg.eq.'y'.and.crseflg.eq.'y')then
          print*
          print*,'WARNING  WARNING    WARNING  WARNING    WARNING  '
          print*,'Snow course swe used - not swe in the resume file'
          print*
          write(51,*)
          write(51,*)'WARNING'
          write(51,*)'Snow course swe used - not swe in the resume file'
          write(51,*)
        endif

!       END OF INITIALIZATION SECTION

! ^^^^^^^^^^^^^^^^^^^^^^^^^



!       WATROUTE START    WATROUTE START  WATROUTE START  WATROUTE START

        if(modelflg.ne.'n')then
          if(id.gt.1)close(unit=261,status='keep')
!         read the header in the runoff file:
d         print*,'reading runoff file'      
          call read_r2c(261,31,'1',jz,newDataFlag)
          if(modelflg.eq.'l')then
          if(id.gt.1)close(unit=263,status='keep')
!           read the header in the leakage (baseflow) file:
d           print*,'reading leakage file'      
            call read_r2c(263,33,'1',jz,newDataFlag)
          elseif(modelflg.eq.'r')then
            if(id.gt.1)close(unit=262,status='keep')
!           read the header in the recharge file:
d           print*,'reading recharge file'      
            call read_r2c(262,32,'1',jz,newDataFlag)
          endif
        endif

!       WATROUTE END   WATROUTE END    WATROUTE END    WATROUTE END 



        if(iopt.eq.2)print*,' In sub, passed location  244'

        a66=a6

c!         TIMER SETS ALL THE CLOCKS i.e. SUM HOURS, SUM SECONDS, ETC.
c
c        time=0.0

        if(iopt.eq.99)then
!         THIS OPTION IS TO CHECK ALL INPUT FILES
!         see above for more
          mhtot=kt*2
        endif

!       rev. 9.8.21  Jun.  18/12  - NK: Assed swe observed date & report
!       check & see if there is time series snow course data
!       this subroutine will check if the file yyyymmdd_swe.tb0 exists
!       If it exists, compute swe will be compared with observed values
!       unit number is 951 & filename(951) is used
!     rev. 10.2.63 Sep.  09/19  - NK Fixed check for file exists for fln(54) - swe time series
        call find_filetype(54)  
        inquire(file=fln(54),EXIST=exists)
        if(.not.exists)courseflg=.false.
        if(courseflg)then
          if(filetype(1:3).eq.'tb0')then
d           if(iopt.eq.2)print*,' Gone to read_swe'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_swe()
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(filetype(1:3).eq.'ts5')then
!     rev. 10.2.51 Apr.  03/19  - NK: New section to read ts5 format file for swe
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_ts5(284,54)        !( not an .nc read)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            print*,'Finished reading ',fln(54)(1:30)
		if(id.eq.1)then
			n_max=xcount_temp
			nold=xcount_temp
			nlines=ycount_temp
			nlines_old=ycount_temp
              nswe=xcount_temp
d              print*,'nswe',nswe
	      allocate(course_obs(nswe,max0(366,nlines)),
     *              course_calc(nswe,max0(366,nlines)),
     *             	      indomainflg(nswe),stat=iAllocate)
!           corrected bug above - replaced na by nswe   Nov. 19/14  nk     
            If(iopt.ge.1)print*,'course_obs dimensioned for:',
     *                        max0(366,nlines)
			if(iAllocate.ne.0) STOP
     *		'Error with allocation of  arrays in read_swe @ 147'
		else                    !  firstpass
!         check to see memory allocated is adequate      

			if(n.ne.nold)then
				print*,'No of swe stations has been changed in'
				print*,'nold=',nold,' n=',n
				print*,'in file ',fln(99)(1:60)
				print*,'This is not permitted'
				print*
				stop 'Program aborted in read_swe @ 156'
			endif
			if(nlines.gt.nlines_old)then
				print*,'No of data lines have changed in'
				print*,'nlines_old=',nlines_old,' nlines=',nlines
				print*,'in file ',fln(99)(1:60)
				print*
c			if(n.gt.n_max)then
				n_max=n

!           the file length is longer than any of the previous events so 
!           more memory has to be allocated

!           DEALLOCATION OF ARRAYS FROM AREA10A:
				deallocate(course_obs,course_calc,stat=iDeallocate)
				if(iDeallocate.ne.0)then
					print*,'Error with deallocation ofswe)obs'
					print*
					stop 'Program aborted in read_swe @ 170'
				endif

                print*,'reallocation for more swe locations',nswe

				allocate(course_obs(nswe,max(366,nlines)),
     *                    course_calc(nswe,max(366,nlines)),
     *         				stat=iAllocate)
				if(iAllocate.ne.0) STOP
     *			'Allocation Error: arrays in read_swe @177'
                nlines_old=nlines
d               print*,'course_obs re-dimensioned for:',max(366,nlines)
			endif
		endif                   !  firstpass
		
          if(.not.allocated(xswe))then
              allocate(xswe(nswe),yswe(nswe),gname_swe(nswe),
     *                   ewg_swe(nswe),sng_swe(nswe),stat=iAllocate)
              if(iAllocate.ne.0)then
                  print*,'Error with allocation of station descripters'
                  print*,' in read_swe'
                  STOP 'Program aborted in read_swe @ 213'
              endif
          endif
!     rev. 9.1.68  Dec.  19/04  - NK: rewrote read_tbo c/w memory allocation 
!       turn into local coordinates
          do n=1,nswe
            ewg_swe(n)=int((x_temp(n)-xorigin)/xdelta+1.0)
            sng_swe(n)=int((y_temp(n)-yorigin)/ydelta+1.0)
            gname_swe(n)=gname_temp(n)
          end do
d          print*,(ewg_swe(n),n=1,nswe)
d          print*,(sng_swe(n),n=1,nswe)
d          print*,(gname_swe(n),n=1,nswe)
            
          do l=1,xcount_temp
!           convert to local coordinate unit system 
!           and check that the stations are in the watershed
            j=int((x_temp(l)-xorigin)/xdelta)+1
            i=int((y_temp(l)-yorigin)/ydelta)+1
!           find the rank for this data point
            if(s(i,j).le.0)then
              print*,'coordinates are outside watershed'
              print*,'for location No.',i,j 
            endif
          end do
          do j=1,ycount_temp
            do i=1,xcount_temp
              course_obs(i,j)=inarray(j,i)
            end do
d           print*,(course_obs(i,j),i=1,xcount_temp)
          end do  

!         Write the header in the results\swe.csv file          
          write(951,91101)(gname_swe(n),gname_swe(n),n=1,nswe)
91101   format(<2*nswe>(a9,','))      

!         check to see if stations are in the model domain
          do n=1,nswe
            if(ewg_swe(n).ge.1.and.ewg_swe(n).le.xcount.and.
     *        sng_swe(n).ge.1.and.sng_swe(n).le.ycount)then
              if(s(sng_swe(n),ewg_swe(n)).gt.0)then
              indomainflg(n)=.true.
d             print*,n,xswe(n),yswe(n),s(sng_swe(n),ewg_swe(n)),
d    *         indomainflg(n)
              else
                  indomainflg(n)=.false.
              endif
            else
              indomainflg(n)=.false.
            endif
          end do
!     END rev. 10.2.51 Apr.  03/19  - NK: New section to read ts5 format file for swe
          
          
            open(unit=99,file='swe_location.xyz',status='unknown')
            do l=1,xcount_temp
                write(99,*)x_temp(l),y_temp(l),l,gname_swe(l)
                write(*,*)x_temp(l),y_temp(l),l,gname_swe(l)
            end do
            close(unit=99,status='keep')
            
          else
            if(dds_flag.eq.0)then
              print*,fln(54)(1:60),'not found'
	        print*,'program continues without swe analysis'
	      endif
	      courseflg=.false.
          endif
        endif
        
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipla & irrigation withdrawals
d       if(iopt.eq.2)print*,' Gone to withdraw'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call withdraw()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!       re-initialize ice factors Jan 1 each year.
c        if(jul_day_now.eq.1)then
c          do n=1,naa
c            ice_fctr_min(n)=0.5
c            ice_fctr_max(n)=0.5
c          end do
c        end if

        if(numa.eq.0.and.dds_flag.eq.0)print*

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
!         THIS IS THE MAIN TIME LOOP, EXECUTED FOR EACH TIME STEP
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
!       start time loop
!       start time loop
!       start time loop
!       start time loop
!       start time loop

        if(.NOT.allocated(inarray))then    
!         inarray not previously allocated
          allocate(inarray(ycount,xcount),stat=iAllocate)
          if(iAllocate.ne.0)then
            STOP 'Error with allocation of inarray in read_sub @ 1623'      
          end if
        endif

!        do while(time.le.float(mhtot-1))
!        do while(time.le.float(mhtot))
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!        do while(time.lt.float(mhtot+kt))

!      cant do this when running opt
cd     mhtot=2
c      print*,'in sub @ 1553 mhtot set to 24 hours'

        do while(time.lt.float(mhtot))
          time=time+1.000
          totaltime=totaltime+1.0

          if(iopt99)then
            call date_and_time(cday,ctime)
            read(ctime,11111)hhhhh
            read(ctime,11112)mmmmm
            read(ctime,11113)sssss
11111       format(f2.0)
11112       format(2x,f2.0)
11113       format(4x,f6.0)      
          endif

d          if(iopt.eq.2)print*,' Gone to timer'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call timer(iz,jz,mz,clock,time,t,thr,dtmin,dtmax,div,m,
     *              ju,a66)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d          if(iopt.eq.2)print*,' Back from timer'

!     rev. 10.1.54 Nov.  25/16  - NK: Moved tdum under call timer in sub
      tdum=1000.*step2/t

!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
        if(resetflg)then
          if(jul_day_now.gt.265.and.jul_day_now.lt.275)then !Oct. 1 approx
            do n=1,naa
              sump(n)=0.0
              wfo_cum_p(n)=0.0
              do ii=1,classcount
                intevt(n,ii)=0.0
                evt(n,ii)=0.0
                ssumr(n,ii)=0.0
                sum_sublim(n,ii)=0.0
              end do
            end do
          endif
        endif
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
        if(resetflg)then
!         reset the cummulative precip to 0 at the beginning of Sept.        
          do n=1,naa
            if(jul_day_now.gt.265.and.jul_day_now.lt.275)wfo_cum_p(n)=0.0
          end do
        endif


        if(iz.lt.jz)then 
!         STATUS LINE:
          if(iopt.lt.99.and.abs(dds_flag).ne.1)then
!           THIS IS TO PREVENT DIV BY 0
            if(mhtot.gt.10)then       ! added Mar. 15/14 NK to prevent div/0
              if(mod(jz,mhtot/10).eq.0.and.mhtot.gt.10)then
                if(icase.le.0)then
                  if(icase.eq.-1.or.icase.eq.-11)then
                    write(6,5001)id,ni,jz,mhtot,nnn,maxn,smc5,
     *                        optlow
                  elseif(numa.eq.0.and.na.gt.100)then 
                    write(6,5003)id,ni,jz,mhtot,nnn,maxn,scale,
     *                    optlow
                  endif
                endif
              endif
            endif
          endif
!         FIRST AND SUBSEQUENT PASSES  
!         IF FLGEVP = 'n' IN THE EVENT FILE, FLGEVP2 IS SET TO 0
!         IN SPL
!         DON'T NEED TEMPERATURES FOR EVAP OPTION .LE. 1.0

!     rev. 9.9.10  Mar.  20/14  - NK: Update swe anytime a file is found
!         create a file name for today's snow course
!         use the 'u' for update - this will do the first event also
!         for crseflg = 'y', swe will only be used at the beginning of an event
!         and an error will result if the file is not there.
          if(crseflg.eq.'u')then
            if(hour_now.eq.12)then
              if(month_now.lt.10.and.day_now.lt.10)then
                write(line,77671)year_now,month_now,day_now
77671           format('snow1\',i4,'0'i1,'0',i1,'_swe.r2c')
              elseif(month_now.lt.10.and.day_now.ge.10)then
                write(line,77672)year_now,month_now,day_now
77672           format('snow1\',i4,'0',i1,i2,'_swe.r2c')
              elseif(month.ge.10.and.day_now.lt.10)then
                write(line,77673)year_now,month_now,day_now
77673           format('snow1\',i4,i2,'0',i1,'_swe.r2c')
              else
                write(line,77674)year_now,month_now,day_now
77674           format('snow1\'i4,i2,i2,'_swe.r2c')
              endif
              fln(99)=line
              INQUIRE(FILE=fln(99),EXIST=exists)
              if(exists)then
                print*,'Updating the swe with fln',fln(99)(1:40)
                call read_sweinit(99,99)
                print*,'NEW <<<<<'
                print*,'swe updated with file:'
                print*,fln(99)(1:72)
              endif
            endif
          endif
          
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
          if(swe_update)then 
!             This order is with the least # checks - but fix so we find hour from sart so there needs to be just one check              
              if(year_now.eq.yy_swe)then
              if(month_now.eq.mm_swe)then
              if(day_now.eq.dd_swe)then
              if(hour_now.eq.hh_swe)then
              if(swe_mult.gt.-998.)then
                  do n=1,naa
                      do ii=1,classcount
                          snowc(n,ii)=snowc(n,ii)*swe_mult
                      end do
                  end do
                  if(swe_mult.gt.-998..and.swe_add.gt.-998.)then
                      write(98,*)'Warning:'
                      write(98,*)'Both swe mult & add factors > -999'
                      write(98,*)'Mult applied on '
                      write(98,*)year_now,month_now,day_now,hour_now
                      write(98,*)
                  endif
             elseif(swe_add.gt.-998.)then
                  do n=1,naa
                      do ii=1,classcount
                          snowc(n,ii)=snowc(n,ii)+swe_add
                          snowc(n,ii)=amax1(0.0,snowc(n,ii))
                      end do
                  end do
              endif
              endif
              endif
              endif
              endif
          endif

!     rev. 10.2.62 Sep.  09/19  - NK Added read_sm_update.f90 for read in sm adjustment factors
          if(uzs_update)then 
!             This order is with the least # checks - but fix so we find hour from sart so there needs to be just one check              
              if(day_now.eq.dd_uzs)then            ! check once a day
              if(hour_now.eq.hh_uzs)then           ! then check once an hour
              if(year_now.eq.yy_uzs)then
              if(month_now.eq.mm_uzs)then
              if(uzs_mult.gt.-998.)then
!                  print*,uzs_mult
                  do n=1,naa
                      do ii=1,classcount
!                         set upper limit for uzs adjustment                          
                          uzs(n,ii)=amin1(retn(ii),uzs(n,ii)*uzs_mult)
                      end do
                  end do
                  if(uzs_mult.gt.-998..and.uzs_add.gt.-998.)then
                      write(98,*)
     *                     'Warning: Both uzs mult & add factors > -999'
                      write(98,*)'INFO: Mult applied on '
     *                      ,year_now,month_now,day_now,hour_now
                      write(98,*)
                  endif
             elseif(uzs_add.gt.-998.)then
                  do n=1,naa
                      do ii=1,classcount
!                         set limits for uzs adjustment                          
                          uzs(n,ii)=amin1(retn(ii),uzs(n,ii)+uzs_add)
                          uzs(n,ii)=amax1(0.0,uzs(n,ii))
                      write(98,*)'INFO: UZS addition applied on '
     *                      ,year_now,month_now,day_now,hour_now
                      end do
                  end do
              endif
              endif
              endif
              endif
              endif
          endif

!     rev. 10.2.21 Apr.  14/18  - NK: Added Lake Level update 
          if(ruleflg)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call lake_lvl_update(jz,date,time)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
          
!       WATROUTE START    WATROUTE START  WATROUTE START  WATROUTE START

          if(modelflg.ne.'n')then     ! i.e. modelflg.eq.i or l or r

!           WATROUTE only <<<<<< !!!!!!
!           the headers have been read above.
            newDataFlag=.false.
            call read_r2c(261,31,'0',jz,newDataFlag)
            if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow

      
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              qr(n)=inarray(i,j)*tdum1*frac(n)
              end do
            else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 1406'
            endif
            if(modelflg.eq.'r')then
!             read the recharge and route through the lz
              call read_r2c(262,32,'0',jz,newDataFlag)
              if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow
              do n=1,naa
                i=yyy(n)
                j=xxx(n)
                lzs(n)=lzs(n)+inarray(i,j)
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!               call baseflow(n,ibn(n),dlz,sdlz,tdum)
                call baseflow(n,dlz,sdlz,tdum)
                qr(n)=qr(n)+qlz(n)
              end do
              else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 11420'
              endif
            endif
            if(modelflg.eq.'l')then
!             read qlz = groundwater flow (leakage/baseflow)       
              call read_r2c(263,33,'0',jz,newDataFlag)
              if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow
              do n=1,naa
                i=yyy(n)
                j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!               need tdum1 here for hour time step conversion              
                qr(n)=qr(n)+inarray(i,j)*tdum1
              end do
              else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 1434'
              endif
            endif

!     rev. 9.5.75  Oct.  26/09  - NK: commented "deallocate in sub for watroute reads
!     this deallocate killed the watroute run. Used only for watroute 
!     so we can probably leave it out at theis point as we need to use 
!     inarray to read the files for each following time step.
c               deallocate(inarray)

!       WATROUTE END   WATROUTE END    WATROUTE END    WATROUTE END 

          else         ! modelflg.eq.........

!           DO THE MODELLING!!!!!!!!!

!           REV. 8.90 - Dec.  04/98 - INPUT TO MEMORY FOR OPT RUNS
!           RAIN PUTS PROPER AMOUNT OF PRECIPITATION ON EACH SQUARE, 
!           ONCE, ONLY AT THE BEGINNING OF EACH HOUR
!           AVERP IS THE AVERAGE OF THE PRECIP READ IN AT THE 
!           PRECIP STATIONS.      


!           Add the binary file option here - unit 91
d            if(iopt.eq.2)print*,' Gone to rain'
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

d     if(iopt.eq.4)pause 5000

!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
          if(.not.netCDFflg)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_rain_ef('0',conv,jz,jan) !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(FLtype(10)(1:2).eq.'nc')then
              do i = 1,ycount
                  do j=1,xcount
                      p(i,j)=0.0
                  end do    
              end do
              if(mod(jz+5,6).eq.0)then
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_2D_pcp_nc((jz+5)/6,10,1)                ! netCDF
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  endif
!              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call disaggregate(jz)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
d     if(iopt.eq.4)pause 5100

c            else
c              call read_rain_bin('0',conv,jz,jan) !EnSim compatible r2c file
c            endif
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call process_rain(conv,scale)
!          call process_rain_gcm(conv,scale)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins

            if(new_precip_grid_flg)then
            if(xcount.ne.xcount2.or.ycount.ne.ycount2)then
!             create a new name for the met file       
              if(jz.eq.1)then
                write(line,66001)fln(10)(1:6),'new_grid\',fln(10)(7:73)
c                write(*,66001)fln(10)(1:6),'new_grid\',fln(10)(7:73)
66001           format(a6,a9,a66)
                read(line,*)fln(12)
c                print*,fln(12)              
!               write the header for the new condensed met file    
                author='watflood                    '
                name='Precipitation                       '
                coordsys_temp=coordsys1
!               GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
                zone_temp=zone1
                datum_temp=datum1
                xorigin_temp=xorigin
                yorigin_temp=yorigin
                xcount_temp=xcount
                ycount_temp=ycount
                xdelta_temp=xdelta
                ydelta_temp=ydelta
                attribute_name='Precipitation                     '
                attribute_units='mm                            ' 
                attribute_type='                              '
                unit_conversion=1.0   
                source_file_name=fln(10)     
                no_frames=mhtot*ni+1
!               write the header for new precipitation file
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call write_r2c(42,12,no_frames,1,0,1,1)   
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              endif
              if(new_precip_flg)then
                dataflg=.false.
                do i=1,ycount
                  do j=1,xcount
                    if(p(i,j).gt.0.0)dataflg=.true.
                  end do
                end do
                if(dataflg)then      
                  write(42,66003)precip_frame_header
66003             format(a60)                
                  do i=1,ycount
                    write(42,66002)(p(i,j),j=1,xcount)
66002               format(9999f6.1)                  
                  end do
                endif
              endif  
            endif
            endif
        
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
c              print*,p(i,j)
c              domain_precip=domain_precip+p(i,j)*grid_area(n)
            end do

!           adjust the precip
d            if(iopt.eq.2)print*,' Back from rain, gone to rdtemp'

!            if(flgevp2.ge.2.0.or.snwflg.eq.'y')then
            if(vapflg.eq.'y'.or.snwflg.eq.'y')then
              if(time.le.float(mhtot))then

c              if(snwflg.eq.'y'.or.vapflg.eq.'y')then  ! added nk Jun. 28/06
c                if(IsFileTypeR2C(fln(15))) then

                if(netCDFflg)then
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
c              if(mod(jz,deltaT3).eq.0)then
                  if(mod(jz+5,6).eq.0)then
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call read_2D_tmp_nc((jz+5)/6,15,1)    
 !                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  endif
c             endif
c                  endif
                 else
 !                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_temp_ef('0',jan,jz)     !EnSim compatible r2c file
  !                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                endif

!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call process_temp(jz)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                 call process_temp_gcm(jz)
                  if(new_temp_grid_flg)then
                    if(xcount.ne.xcount3.or.ycount.ne.ycount3)then
!                     create a new name for the met file       
                      if(jz.eq.1)then
                        write(line,66001)fln(15)(1:6),
     *                             'new_grid\',fln(15)(7:73)
c                        write(*,66011)fln(15)(1:6),
c     *                             'new_grid\',fln(15)(7:73)
66011                   format(a6,a9,a66)
                        read(line,*)fln(9)
c                        print*,fln(9)              
!                       write the header for the new condensed met file    
                        author='watflood                    '
                        name='temperature                         '
                        coordsys_temp=coordsys1
!            GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
                        zone_temp=zone1
                        datum_temp=datum1
                        xorigin_temp=xorigin
                        yorigin_temp=yorigin
                        xcount_temp=xcount
                        ycount_temp=ycount
                        xdelta_temp=xdelta
                        ydelta_temp=ydelta
                        attribute_name='Temperature                    '
                        attribute_units='dC                            ' 
                        attribute_type='                              '
                        unit_conversion=0.0   
                        source_file_name=fln(10)     
                        no_frames=mhtot*ni+1
!                       write the header for new precipitation file
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        call write_r2c(39,9,no_frames,1,0,1,1)   
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      endif
                      if(new_temp_flg)then
                        dataflg=.false.
                        do i=1,ycount
                          do j=1,xcount
                            if(ttemp(i,j).gt.-99.0)dataflg=.true.
                          end do
                        end do
                        if(dataflg)then      
                          write(39,66013)temp_frame_header
66013                     format(a60)                
                          do i=1,ycount
                            write(39,66012)(ttemp(i,j),j=1,xcount)
66012                       format(9999f7.1)                  
                          end do
                        endif
                      endif  
                    endif
                  endif
c                else
c                  print*,'Old format .tem files not accepted'
c                  print*,'Create yyyymmdd_tem.r2c files & rerun'
c                  stop 'Program aborted in sub @ 192'
c                endif
               
c              endif  ! added nk Jun. 28/06

              endif  
            end if

d            if(iopt.eq.2)print*,' Back from rdtemp'





c!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
c            if(lakeflg.eq.'y')then
c!             read the data          
cd              print*,'reading wind speed on unit',288,'hour',jz
c                newDataFlag=.false.
cc              call read_r2c(288,58,'0',jz,newDataFlag) !EnSim compatible r2c file
cd              print*,'back from reading',fln(58)(1:40)
c              if(newDataFlag)then
c!               if the hdrflg = 'y' there is new data              
c!               vectorize 
c                do n=1,naa
c                  i=yyy(n)
c                  j=xxx(n)
cc                  windspd(n)=inarray(i,j)
c                end do
c              endif
cd                print*
c              
cd              print*,'reading wind direction on unit',289,'hour',jz
c              newDataFlag=.false.
cc              call read_r2c(289,59,'0',jz,newDataFlag) !EnSim compatible r2c file
cd              print*,'back from reading',fln(59)(1:40)
c              if(newDataFlag)then
c!               if the hdrflg = 'y' there is new data              
c!               vectorize 
c                do n=1,naa
c                  i=yyy(n)
c                  j=xxx(n)
cc                  winddir(n)=int(inarray(i,j))
c                end do
c              endif
c            endif   !lakeflg





!     rev. 9.9.06  Jan.  08/14  - NK: Add daily differences to Harfreaves ETHarg.f
            if(dlyflg)then

                
                
      deallocate(inarray)     !fix <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      allocate(inarray(ycount,xcount))
      
      
      
c              if(ju.ne.julast)then
!               read the data in tempr\yyyymmdd_dif.r2c
!               it is assumed that this file will have just one grid per day
!               but since it is written at the end of the day, we can not use the 
!               timestamp to 
                newDataFlag=.false.
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call read_r2c(292,62,'0',jz,newDataFlag) !EnSim  r2c file
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if(newDataFlag)then
                  do n=1,na
                    i=yyy(n)
                    j=xxx(n)
                    dly_diff(n)=inarray(i,j)
                  end do
d                 if(iopt.ge.2)then
d                  print*
d                  print*
d                  print*,'new dly_diff found'
d                  print*
d                  print*
d                  print*
d                 endif
                endif  
c                julast=ju
c              endif
            endif

!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
!     rev  9.9.12  Oct.  15/14  - CJD: added in frc_file_flg='c' for time series dPPT inputs.
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H

            if(frcflg.eq.'y')then
            !TH: reading in relative humidity from EC data based r2c
              newDataFlag=.false.
              if(RH_flg.eq..true.)then
               call read_r2c(251,21,'0',jz,newDataFlag)
               if(newDataFlag)then
                do n=1,naa                
                i=yyy(n)
                j=xxx(n)           
                relh(n)=inarray(i,j)/100.
                if(relh(n).gt.0.98)relh(n)=0.98
                end do
               endif
              else
               do n=1,naa
                 relh(n)=(10/1000.)/(((1e-06*tempv(n)**4.-3e-05*
     *                 tempv(n)**3.+0.0036*tempv(n)**2.+0.0182*tempv(n)
     *                 +0.6607)*1000.)/101325.*0.625)
                  if(relh(n).gt.0.98) relh(n)=0.98  ! upper limit due to wind turbulence
	            if(relh(n).lt.0.30) relh(n)=0.30  ! can't be less than 30%
	         end do
	        endif

              if(frc_file_flg.eq.'y')then

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!              call read_hum(251,21,'0',jan,jz)   ! humidity for REMOiso
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             vectorize 
!              do n=1,naa
!              i=yyy(n)
!              j=xxx(n)
!              spech(n)=inarray(i,j)
!              call process_hum(time,n)
!              end do

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_gsn(277,47,'0',jan,jz)   ! snow_precip for REMIiso
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             vectorize 
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              do ii=1,classcount
                snowf(n,ii)=inarray(i,j)*0.01
              end do
              sum_precip(i,j)=sum_precip(i,j)+inarray(i,j)
              end do
              
c!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c              call read_drn(278,48,'0',jan,jz)   ! REMIiso delta rain
c!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c!             vectorize 
c              do n=1,naa
c              i=yyy(n)
c              j=xxx(n)
c              dlt_rain(n)=inarray(i,j)
c              end do

c!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c              call read_dsn(279,49,'0',jan,jz)   ! REMOiso delta snow
cc!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c
c!             vectorize 
c              do n=1,naa
c              i=yyy(n)
c              j=xxx(n)
c              dlt_snow(n)=inarray(i,j)
c              end do
c!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!             Check if times series delta rain file exists             
              elseif(frc_file_flg.eq.'c')then
              newDataFlag=.false.
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_r2c(278,48,'0',jz,newDataFlag)   ! time series delta rain
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d             if(iopt.eq.2)print*,'back from reading',fln(278)             
!              vectorize 
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
              if(newDataFlag)then
                do n=1,naa                
                i=yyy(n)
                j=xxx(n)           
                dlt_rain(n)=inarray(i,j)
                dlt_snow(n)=inarray(i,j)
                spech(n)=-999.9
  !              relh(n)=0.70 
                
                  do ii=1,classcount
                    snowf(n,ii)=0.0
                  end do
        
                  if(n.eq.nnprint)write(866,*)
     *                     totaltime,newDataFlag,dlt_rain(n)
                end do
              endif
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
              if(flg2H.eq.2)then
                newDataFlag=.false.
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call read_r2c(279,49,'0',jz,newDataFlag)   ! time series delta rain
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          
!               vectorize 
                if(newDataFlag)then
                  do n=1,naa           
                  i=yyy(n)
                  j=xxx(n)        
                  dlt2H_rain(n)=inarray(i,j)
                  dlt2H_snow(n)=inarray(i,j)
                  spech(n)=-999.9
                  end do
                endif
              endif

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              deallocate(inarray)
                         
!             if one of the needed files is mising in this event, use the defaults
 !            else  ! use default values from isotope.par

!               do n=1,naa
!               dlt_rain(n)=deltar(1)      ! avg precip @ start of simulation
!               dlt_snow(n)=deltas(1)      ! avg snow conc @ start of simulation
!               spech(n)=-999.9
    !           relh(n)=0.70        ! default value: calculate in craig_gordon.f
!               do ii=1,classcount
!                 snowf(n,ii)=0.0
!               end do
!               end do

             endif  ! frcfileflg
            endif

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(time.le.float(mhtot))then
!              if(flgevp2.eq.3.0)call rdrad(jan)
            endif
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!!!             mon=mo         !changed it back nk may 13/02
!           Changed this line to mon=mo1  AB May 10, 2002 again Aug. 1/02 nk
            mon=mo1
            dtmax=amin1(float(kt)*3600.0,float(itogo)*3600.0)
            
            aintvl=time-clock
            sintvl=aintvl*3600.0

            clock=time    ! used for r/w resume files
            tot2=tot1*conv*scale/float(naa)
c              arain=tot2  ! not used

!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
            mon=mo

d            if(iopt.eq.2)print*,' Gone to runof6'
          
!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f
!     rev. 10.1.44 Dec.  02/15  - NK: Reworked icerivflg & icelakeflg
!           note: strloss is set to zero in rinof6 when ice_fctr < 0
!           note: icerivflg = n for watroute
!           note: ice_factor is called if icerivflg and/or icelakeflg = y
            if(iceflg.eq.'y'.and.mod(int(time),24).eq.0)then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call ice_factor 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif

            if(iopt99)then
              call date_and_time(cday,ctime)
              read(ctime,11111)hhhhh
              read(ctime,11112)mmmmm
              read(ctime,11113)sssss
              now=hhhhh*3600.0+mmmmm*60.0+sssss
              input=input+now-last
              last=hhhhh*3600.0+mmmmm*60.0+sssss
            endif
          
!           RUNOF5 CALC'S RUNOFF FOR EACH HOUR (OR LARGER INTERVALS)
!           fixed the time step 3600.0 sec & 1.0 min rather than 
!           basin it on aintvl & sintvl which ends up with -ve 
!           values at new events which creates problems with ak & akfs.      
!     rev. 10.1.75 Apr.  03/17  - NK: Fixed time & thr in runof6 arg list
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call runof6(jan,time,3600.0,1.0,mon,e1,mz,ju)
c            call runof6(jan,time,sintvl,aintvl,mon,e1,mz,ju)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d            if(iopt.eq.2)print*,' Back from runof5_jan'

            if(iopt99)then 
              call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  runoff=runoff+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
            endif

!           Used for Great Lakes model only
!           For future lake evap model 
!           This calculates strloss - replaces strloss from runof6
c            if(na.eq.4029.and.
c     *         int(xorigin).eq.-93.and.int(yorigin).eq.40.)then

            if(noresv.gt.0)then
              if(resname(1)(1:8).eq.'Superior'.and.rd_evp_flg)then
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
!               this data will be used in lake_evap.f
c                if(rd_evp_flg)then

!                 read the lake evaporation from GEM output in r2c format
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d                 print*,'reading the lake evap file @ 2396'
                  call read_r2c(281,51,'0',jz,newDataFlag) !EnSim  r2c file
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  do n=1,naa
!     rev. 9.5.50  Jan.  05/09  - NK: read evap data for reaches only
                    if(ireach(n).gt.0)then
                      i=yyy(n)
                      j=xxx(n)
!                     inarray is evaporation in mm for the data timestep
!     replace /t by /data_time_step <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!     this replaces the strloss calculated by runof6
                      strloss(n)=inarray(i,j)*evap_convert(n)/3600.    !splx
                      sum_et(n,classcount)=
     *                        sum_et(n,classcount)+inarray(i,j) 
                    endif
                  end do
c                endif    !  rd_evp_flg
c              elseif(lakeflg.eq.'y')then
c              else
c!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c                call lake_evap
c!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              endif
            endif    !(noresv.gt.0)
            
!     rev. 10.1.83 May   09/17  - NK: Fixed lake evap bug - moved it outside lake-only loop
!     Bug created 10.1.45 Aug. 2016
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call lake_evap
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!           This is THE place to do this addition so runof6 and 
!           route and rerout can be common for the seperate programs. 
!           This way precip & loss is included in the gridflow.r2c file

!           But for wetland routing, it is taken off again in route
!           because qr is the inflow to the wetland!!

!     rev. 9.5.07  Feb.  05/08  - NK: fixed double counting of strloss & qstream

d            if(iopt.eq.2)print*,' Back from lake_evap'
 
            if(sedflg.eq.'y')then
!             send to sediment calculations >>>>>>>>>
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call wqsed(jan,aintvl)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             send to nutrient calculations >>>>>>>>>
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call wqnut
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            endif
!           REV. 8.82 - July 10/98 - ADDED RUNOFF OUTPUT OPTION: 
!           rev. 9.1.45  Jun.  11/03  - runoff, recharge and leakage files added 

!           ROUTEFLG
!           write the output for WATROUTE:
            if(routeflg.eq.'y'.and.numa.eq.0)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!              call write_flux(jz,dtmin,ju,tdum)
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.3.02  Jul.  18/06  - NK: converted runof, rchrg & lkage to r2c
!            runoff in mm per hour (does not include ground water)
             do i=1,ycount
               do j=1,xcount
                 outarray(i,j)=0.0
               end do
             end do
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              outarray(i,j)=
     *         (qr(n)+qstream(n)-strloss(n)-qlz(n))/tdum1   
!     *       (qr(n)-qlz(n))/tdum/frac(n) 
!     rev. 9.5.07  Feb.  05/08  - NK: fixed double counting of strloss & qstream
!             qstream(n) & strloss are not added in runof6 so it's done here
!             and in route
             end do   
             frame_no3=frame_no3+1
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c            call write_r2c(261,31,mhtot,1,frame_no3,0,3)    
             call write_r2c(261,31,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!            recharge in mm
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
               outarray(i,j)=rechrg(n)
             end do   
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c            call write_r2c(262,32,mhtot,1,frame_no3,0,3)    
             call write_r2c(262,32,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!            leakage in mm/hr
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              outarray(i,j)=qlz(n)/tdum1
             end do     
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c            call write_r2c(263,33,mhtot,1,frame_no3,0,3)    
             call write_r2c(263,33,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            elseif(routeflg.eq.'m')then
!             write output for MODFLOW:  added May, 2000 NK
!             recharge is accumulated over 24 hour in this case
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_modflow(ju,juold,jz)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif    !  if(routeflg......

d            if(iopt.eq.2)print*,'  1003'
            juold=ju
            jan=2
!           JAN HAS TO STAY HERE BECAUSE ROUTE MAY BE CALLED MORE
!           THAN FOR EACH TIME RUNOF5 IS CALLED - SO WE CAN'T USE 
!           JAN IN ROUTE.

          endif     !  modelflg.eq......       
          endif       ! CALL RUNOFF ONLY IN NEW HOUR 

!         ROUTE ROUTES WATER THROUGH EACH SQUARE USING STORAGE ROUTING
!         RESET QDWPR=0 INCASE THIS IS SECOND DT DURING FLOW INCREMENT

!         >>>>>>>IS THIS LOOK OK?? CHANGED 6 TO NORESVO   
 
!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!         Diversions    Diversions    Diversions    Diversions    Diversions
!     rev. 9.7.17  Jan.  05/11  - NK: Fixed diversions outside sub-basin
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.9.41  Nov.  20/14  - NK: Added check if diversion = in-basin 
          
          if(diversion)then
            do nd=1,nodivert
              if(divert_inbasin_flg(nd))then
                qr(gridtake(nd))=qr(gridtake(nd))-qdivert(nd,jz)
                qr(gridgive(nd))=qr(gridgive(nd))+qdivert(nd,jz)
              endif 
            end do
          endif
          
          if(irdt.le.kt)then
!           old way of doing things
            if(nastart.eq.1)then
!     rev. 9.3.11  Feb.  17/07  - NK: force hourly time steps for runoff
!     rev. 9.3.12  Feb.  20/07  - NK: changed dtmin & call to route
              no_dt=max(int(3599./dtmin)+1,1)
              route_dt=3600.0/float(no_dt)
              sec_div=route_dt/2.0
              hr_div=sec_div/3600.
!             write(55,*)dtmin,ndt,rdt,sec_dt,hr_dt
!             The value of dtmin has been used to determine how many
!             times route is called. Route will determine a new dtmin
!             for the next time step.
              dtmin=3600.0
              time2=time  ! so time incrementing doesn't get affected

              do n=1,no_dt

!     TS: added time update since routing timestep is less than increment of +1.00: Jan 4/08
                if(n.gt.1)time2=time+route_dt/3600.*float(n-1)


              if(iopt99)then
                  call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  input=input+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
              endif
      
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c               SUBROUTINE route(div,    thr   ,dtmin,jz,iz,time,date)
                call route(sec_div,hr_div,dtmin,jz,iz,time2,date,tdum)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

              if(iopt99)then
                  call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  router=router+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
               endif

!         rev. 9.1.47  Oct   30/03    - Tracer module parameter list changed
                if(numa.eq.0)then
!                 tracer turned off for optimization
                  if(trcflg.eq.'y')then
                    if(n.eq.no_dt)then
d                     if(iopt.eq.2)print*,'gone to tracer    (1)'                  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call tracer(iz,-iz,time2,route_dt,jan,tdum,1)
d                     if(iopt.eq.2)print*,'back from tracer  (1)'                  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    else
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d                     if(iopt.ge.2)print*,'gone to tracer    (2)'                   
                      call tracer(iz,iz,time2,route_dt,jan,tdum,0)
d                     if(iopt.eq.2)print*,'back from tracer  (2)'                  
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    endif
                  endif
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
                  if(frcflg.eq.'y')then
                   if(n.eq.no_dt)then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     call isotopes(iz,jz,time2,route_dt,1)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   else
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call isotopes(iz,jz,time2,route_dt,0)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   endif
!     end rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
                  endif
                endif
d                if(iopt.eq.2)print*,' Back from tracer'
              end do
!             This little ditty is here if we want routing dt's
!             longer than 1 hr. This may be needed for very large grids.
!             do ijk=1,2
!!              call route(div,thr,dtmin,jz,iz,time,date)
!               call route(1800.,.5,dtmin,jz,iz,time,date)
!               dtmin=3600.
!             end do
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
            endif 
          else
!           rev. 9.1.38  Mar.  31/03    - revised str header and routing dt selectable
!           For longer time steps, route is called at the desired intervals. 
!           This was done just for the DMIP paper    
            if(mod(jz,irdt).eq.0)then
              if(nastart.eq.1)then
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call route(rdt*1800.0,thr,dtmin,jz,iz,time,date,tdum)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
              endif 
            endif
          endif

c          if(wetflg.eq.'y')then
c!              call decay(time,n,l,t,ii,ha,fpw,kdn,nratio)
c          endif

d          if(iopt.eq.2)print*,' Back from route'
    
!         REV. 9.1 - SEDIMENT COMPONENT
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(sedflg.eq.'y')call wqroute(t)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

d          if(iopt.eq.2)print*,' Gone to tracer'

!         rev. 9.1.47  Oct   30/03    - Tracer module parameter list changed
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!          if(trcflg.eq.'y')call tracer(iz,jz,time,t,jan,tdum)
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c              if(iopt.eq.2)print*,' Back from tracer'

!         INTERPOLATE TO GET FLOWS AT reporting TIMES:
          if(irdt.le.kt)then
!         old way of doing things
          if(nastart.eq.1)then
            if(iz.lt.jz.and.jz.ge.1)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call synflw(time,thr)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif      
          endif 
          else
!         rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
          if(mod(jz,irdt).eq.0)then
            if(nastart.eq.1)then
              if(iz.lt.jz.and.jz.ge.1)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call synflw(time,thr)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              endif        
            endif 
          endif
          endif

!         print*,' ireport=',ireport,iz,jz,mod(jz,ireport)

d          if(iopt.eq.2)print*,' Back from synflw'

          if(jz.ne.iz.and.mod(jz,deltat_report).eq.0)then
!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
 
          if(id.lt.ni)then
!           n_trick=mhtot+100  
            n_trick=mhtot*ni+1 ! tricks write_r2c into NOT closing the file
          else
            n_trick=mhtot
          endif
          
!     rev. 10.2.52 Apr.  15/19  - NK: Added total UZS for reporting in FEWS
          if(netCDFflg)then
            do n=1,naa
              totd1(n)=0.0
              totuzs(n)=0.0
              do ii=1,classcount-3
                  if(aclass(n,ii).gt.0.0)then
c                      totd1(n)=totd1(n)
c     *                 +d1(n,ii)*aclass(n,ii)*(1.0-sca(n,ii))
c     *                 +d1fs(n,ii)*aclass(n,ii)*sca(n,ii)
                     totuzs(n)=totuzs(n)
     *                +(uzs(n,ii)/retn(ii))*aclass(n,ii)*(1.0-sca(n,ii))
     *                +(uzsfs(n,ii)/retn(ii))*aclass(n,ii)*sca(n,ii)
                  endif
              end do
c              totuzs(n)=totuzs(n)+totd1(n)    ! include d1 with uzs for reporting in FEWS
            end do
c      write(401,*)hour_now,',',totuzs(na/2)
          endif
          
!     rev. 9.5.31  May.  27/08  - NK: moved totsnw(n) computation in sub
          if(numa.eq.0.and.ensimflg.eq.'y'.or.netCDFflg)then
            do n=1,naa
              totsnw(n)=0.0
              do ii=1,classcount
              if(aclass(n,ii).gt.0.0)then
                totsnw(n)=totsnw(n)
     *              +snowc(n,ii)*aclass(n,ii)*sca(n,ii)
              endif
              end do
            end do     
          endif

!     rev. 9.5.80  Dec.  20/09  - NK: added swe_locations.txt file for swe input
!     write swe at designated snow courses
!     DDS_flag added April 4, 2010  nk
      if(.not.netCDFflg)then
      if(id.eq.1.and.no_swe_l.eq.0.and.dds_flag.ne.1)then
        inquire(FILE='basin\swe_locations.txt',EXIST=exists)
        if(exists)then
          open(99,file='basin\swe_locations.txt',
     *            status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  basin\swe_locations.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 3594'
          endif
          read(99,*)no_swe_l
          read(99,*)(swe_l(i),i=1,no_swe_l)
          close(unit=99,status='keep')
          write(*,64000)
          write(*,64001)no_swe_l
          write(*,64001)(swe_l(i),i=1,no_swe_l)
          if(writeflg(64))write(64,64002)(swe_l(i),i=1,no_swe_l)
          if(ensimflg.ne.'y')then
            print*,'ensimflg=',ensimflg
            print*,'ensimflg needs to be `y` or `a` to get output for'
            print*,'swe at snow courses whe specified in'
            print*,'basin\swe_locations.txt'
            print*
            print*,'If DDS_flag = 1, ensimflg is set to n'
            print*
c           stop 'Program aborted in sub @ 2204'
          endif
          print*
        endif
      endif
          
      if(ensimflg.eq.'y')then
        if(ju.eq.60.or.ju.eq.91.or.ju.eq.121.and.no_swe_l.ge.0)then
          if(writeflg(64))write(64,64000)year_now,ju,(totsnw(swe_l(i)),
     *                             i=1,no_swe_l)
64000     format(2i5,99f10.2)
64001     format(99i5)
64002     format(99i10)
        endif
      endif
      endif   !netCDFflg

!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
          if(grdflg.eq.'y')then
!     rev. 9.9.21  Jul.  27/14  - NK: Added allocation for outarray in sub
            if(allocated(outarray))deallocate(outarray)
            allocate(outarray(ycount,xcount),stat=iAllocate)
            if(iAllocate.ne.0)then
              print*,'Error with allocation of outarray in sub @ 594'
              STOP 'Program aborted in sub @ 595'
            endif
            do i=1,ycount
              do j=1,xcount
                outarray(i,j)=0.0
              end do
            end do
            xcount_temp=xcount
            ycount_temp=ycount

            if(iopt99)then
            if(numa.eq.0.and.ensimflg.eq.'y')then
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=qo2(n)
              end do     
!             unit=72  fln(72)=gridflow.r2c  - gridded flow - r2c file
              frame_no2=frame_no2+1
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c              call write_r2c(72,72,n_trick,1,int(totaltime),1,8)  
              call write_r2c(72,72,mhtot+8784,0,frame_no2,0,8)  
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             use 8784 as the total # of frames so the file only closes when the run is done.
            endif

!           this added for Vincent Fortin:
            if(numa.eq.0.and.ensimflg.eq.'y')then
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=totsnw(n)
              end do     
              frame_no4=frame_no4+1
!             unit=61  fln(61)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_r2c(61,61,mhtot+8784,1,frame_no4,0,0)  
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif

!     rev. 9.5.09  Feb.  12/08  - NK: added evap.r2c to the output files
!           this added for Vincent Fortin:
            if(numa.eq.0.and.ensimflg.eq.'y')then
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=eloss(n)
            end do     
            frame_no5=frame_no5+1
!           unit=100  fln(100)=evap.r2c  - gridded evap - r2c file
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!     rev. 9.9.60  Mar.  06/15  - NK: In sub: fixed call write_r2c for close condition 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c            call write_r2c(100,100,mhtot+8784,0,frame_no5,0,8)  
            call write_r2c(100,100,int(totaltime),0,frame_no5,0,8)  
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif
            endif    ! iopt99
          endif   !  if(grdflg.eq.'y'
          
          if(iopt99)then
          if(frcflg.eq.'y'.and.numa.eq.0)then 
            if(allocated(outarray))deallocate(outarray)
            allocate(outarray(ycount,xcount),stat=iAllocate)
            if(iAllocate.ne.0)then
              print*,'Error with allocation of outarray in sub @ 594'
              STOP 'Program aborted in sub @ 595'
            endif
d            print*,'outarray allocated for '
d            print*,ycount,' rows'
d            print*,xcount,' cols'
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
              l=nbasin(i,j)
              if(l.ne.0)then
                outarray(i,j)=dSTRconc2(n) !isoSTRconc2(n,l)
              else 
                outarray(i,j)=0.0
              endif
            end do     
            ycount_temp=ycount
            xcount_temp=xcount
            frame_no6=frame_no6+1
 !          unit=72  fln(72)- gridded flow - r2c file
!     rev. 9.9.60  Mar.  06/15  - NK: In sub: fixed call write_r2c for close condition 
!           changed mhtot+8784 to totaltime to make it work for monthly events
!           longer than one year
 !          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c           call write_r2c(200,200,mhtot+8784,0,frame_no6,0,8) 
            call write_r2c(200,200,8784000,0,frame_no6,0,8)  
 !          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
          endif   !iopt99

          endif   !  if(jz.ne.iz.and.mod(jz,deltat_report).eq.0

          if(ensimflg.eq.'y'.and.jz.ne.iz)then
          if(ireport.ge.1.and.wfo_open_flg.eq.'y')then
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 
            if(int(totaltime).gt.ireport_start
     *        .and.int(totaltime).le.ireport_end)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_wfo(t,jz,iz)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif
          endif
          endif

!>>>>>>>>>>>>>>>>>>>>





!>>>>>>>>>>>>>>>>>>>>
 
          do n=1,naa
!           SELECT THE MAXIMUM FLOW FOR EACH GRID DURING THE EVENT 
            qmax(n)=amax1(qmax(n),qo2(n))   
!           FIND THE MINIMUM SNOWC FOR ERROR MSG 
            do ii=1,classcount
              snowcmin(n,ii)=amin1(snowc(n,ii),snowcmin(n,ii))
            end do
          end do
   82     m=m+1
 
 
!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
!         extract the computed swe at snow course locations
          if(mod(jz,24).eq.0)then
            do i=1,nswe
              if(indomainflg(i))then
                n=s(sng_swe(i),ewg_swe(i))
c      print*,i,sng_swe(i),ewg_swe(i),n
                sum_swe=0.0
                class_sum=0.0
                do ii=1,classcount
!                 we have to not include the water class as it has 0 swe
                  if(ii.ne.ii_water)then
                    class_sum=class_sum+aclass(n,ii)
                    sum_swe=sum_swe+snowc(n,ii)*aclass(n,ii)*sca(n,ii)
                  endif
                end do
c                course_calc(i,ju)=sum_swe/class_sum
                course_calc(i,jz/24)=sum_swe/class_sum
              else
c                course_calc(i,ju)=-1.0            
                course_calc(i,jz/24)=-1.0            
              endif
              end do
c              write(777,*)ju,(course_calc(i,jz/24),i=1,nswe)
          endif


c          call swe_extract(ju)
 
!      May 1/11  NK 
!      save this little ditty. Used to create WSC file format for 
!      missing flows at any station
c          if(mod(jz,24).eq.0)then
c            if(qhyd(68,jz).lt.0.0)then
c              write(900,828)
c     *         '05PF999',year1,month_now,day_now,qsyn(68,jz)
c            else
c              write(900,829)
c     *         '02PF999',year1,month_now,day_now,qhyd(68,jz)
c            endif
c          endif
c828       format(a7,',1,',i4,',',i2,',',i2,',',f10.3,',c,')     
c829       format(a7,',1,',i4,',',i2,',',i2,',',f10.3,',o,')     

        if(iopt99)then
          call date_and_time(cday,ctime)
          read(ctime,11111)hhhhh
          read(ctime,11112)mmmmm
          read(ctime,11113)sssss
          now=hhhhh*3600.0+mmmmm*60.0+sssss
          output=output+now-last
          last=hhhhh*3600.0+mmmmm*60.0+sssss
        endif
          
!     rev. 10.1.78 Apr.  17/17  - NK: New s/r dds_UZS to calculate low flow penalty
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          if(dds_flag.gt.0)then
              if(errflg.eq.10.and.id.gt.idskip)then
                  call dds_uzs(score)
              endif
          endif
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!         write the CHARM_output.nc file for one time step
!         Assume this file is wanted if one of str, met or tem file is .nc       
!         Common 6 hr output time step - see Ben's e-mail Apr. 8/19      
!         Note: for netCDF (FEWS) applications, we use 6 hour time steps 
!               so qsum is set = 0 for that application          
!               For other uses, flow is summed for the whole run so we can
!               calculate runoff in mm for the whole upstream area at every grid.
!               This can help find discontinuities.
          do n=1,naa
                i=yyy(n)
                j=xxx(n)
                QQsum(n)=QQsum(n)+qo2(n)
          end do  
          if(netCDFflg)then
!             calculate the mean flow for the time step              
              deltat=6
              if(mod(int(totaltime),6).eq.0)then
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=QQsum(n)/6.0
                  QQsum(n)=0.0
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
              call write_2D_flow(int(totaltime/deltat),mhtot/deltat,201)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=totsnw(n)
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
               call write_2D_swe(int(totaltime/deltat),mhtot/deltat,202)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=totuzs(n)
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
               call write_2D_uzs(int(totaltime/deltat),mhtot/deltat,203)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
!     rev. 10.2.56 June  13/19  - NK Added .nc output for grid_runoff & cumm ET
                do n=1,naa                  ! added June 13/19 NK
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=qr(n)
                end do   
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
               call write_2D_grid_runoff(int(totaltime/deltat),
     *                                                mhtot/deltat,204)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa                  ! added June 13/19 NK
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=eloss(n)
                end do    
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
               call write_2D_cumm_ET(int(totaltime/deltat),
     *                                                mhtot/deltat,205)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
            endif
          endif
          
          

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
        end do     !while(time.lt.float(mhtot)
!         END TIME LOOP
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

        if(numa.eq.0.and.dds_flag.eq.0)print*

   83   CONTINUE       ! FROM STOP COMMAND

!       rev. 9.8.21  Jun.  18/12  - NK: Assess swe observed date & report
!       rev. 9.8.44  Jan.  31/13  - NK: fixed bug in sub.f : uninitialized course_calc(n,j)
!       rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
!       write the file only if snow course data is availabel in file 951
        if(courseflg)then
          do j=1,mhtot/24
          if(iopt99)write(951,91100)
     *                (course_obs(n,j),course_calc(n,j),n=1,nswe)
91100       format(f10.2,<2*nswe-1>(',',f10.2))
          end do
!         calculate the error
          do n=1,nswe
            if(indomainflg(n))then
              do j=1,mhtot/24
                if(course_obs(n,j).ge.0.0)then
                  swe_error=swe_error
     *                  +(course_obs(n,j)-course_calc(n,j))**2
                  no_swe_obs=no_swe_obs+1
                endif
              end do    
            endif
          end do    
          swe_penalty=swe_error/no_swe_obs 
          print*,'>>NEW<< swe_penalty =',swe_penalty 
        endif

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(iopt.eq.2)then
          print*,' In sub before call lst'
          print*
        endif

!       Although it would be nice to write the hydrographs whenever a new.par
!       file is written, the data for the first  
!       ni-1 events is not available because the spl.csv file is
!       appended with each event and the data is lost. So it would have to be 
!       put into memory (which is also not attractive) so it could be written
!       at the time each new.par is written.

        mhtot=mhrd    
        if(.not.netCDFflg.or.dds.eq.0.or.iopt99)then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call lst(scale,igrdshft)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else
          print*,'Note'
          print*,'Supressing normal output in lst.f'
          print*,'---------------------------------'
        endif

!       STATUS LINE:
        if(icase.gt.0.and.numa.eq.0.and.dds_flag.eq.0)then
          write(6,5003)id,ni,mz,mhtot,nnn,maxn,scale,optlow
        endif

        if(mhtot.gt.8000)then
!         ONLY FOR ANNUAL RUNS
!         This is to apply a penaly if the snow does not melt each year. 
!         In the high mountains this can happen if the base temp is too high
!         from dds - the program will just accumulate swe if there's too much
!         water. Instead, this forces more evaporation to get rid of it.            
          minsnwflg=0
          do n=1,naa
          do ii=1,classcount
            if(aclass(n,ii).gt.0.0)then
              if(snowcmin(n,ii).gt.0.00001)then
              if(numa.le.0)then
                write(98,6400)n,ii,snowcmin(n,ii),id
              endif
              minsnwflg=1
              endif
            endif
          end do
          end do
        endif   !  mhtot.gt.8000
        if(minsnwflg.eq.1)then
          print*,'Warning: check spl.err file for snow problems'
          dds_penalty=10.0
        endif
        if(mod(id,12).eq.0.and.iopt99)then
           write(29,*)id,domain_precip/domain_area
           domain_precip=0.0
        endif
       
!     rev. 10.1.77 Apr.  17/17  - NK: Moved DDS err calcs to new dds_code s/r's
        if(abs(dds_flag).eq.1.and.id.gt.idskip)then
c            print*,trcflg,penalty,score
c            pause 6565
          penalty=penalty+score
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          call dds_options(dds_error)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          if(errflg.eq.10)dds_error=dds_error+score
        endif           ! if(abs(dds_flag).eq.1.and.......)
        
!       for insurance:	
	  close(unit=40,status='keep',iostat=ios)
	  close(unit=45,status='keep',iostat=ios)
        
        
        if(tbcflg.eq.'y')then
!         THIS SECTION IS USED TO WRITE ALL STATE VARIABLES
!         SO PRGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!         Called only after the last event is complete.
!         REV. 8.1  - Feb.    15/96 -  TBC & RSM (TO BE CONTINUED & RESUME)
!         rev. 10.2.47 Feb.  10/19  - NK: Revised write_resume
!         soil_init, flow_init & lake_level_init moved there          
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_resume(jz)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        endif    !   if(tbcflg.eq.'y')....

      end do     ! EVENT LOOP END
 
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     **************************************************** 


!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!     Close the CHARM_output.nc file with nrecs = -1
      if(netCDFflg)then
!         unit=???  fln(201)-Gridded output for FEWS       CHARM_output.nc
!         close the files          
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          call write_2D_flow(int(totaltime),-int(totaltime),201)
          call write_2D_swe(int(totaltime),-int(totaltime),202)
          call write_2D_uzs(int(totaltime),-int(totaltime),203)
          call write_2D_grid_runoff(int(totaltime),-int(totaltime),204)
          call write_2D_cumm_ET(int(totaltime),-int(totaltime),205)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          deltat=6
          fln(99)='results\CHARM_flow_vector.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_flow(no,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_levels.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_levels(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_inflow.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_inflow(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_outflow.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_outflow(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif


!     rev. 9.8.08  Nov.  18/11  - NK: added fratio for interception hight optimization
!     set interception capacity to values read in originally in read_par_parser
      if(fratioflg)then
        do i=1,12
          do ii=1,classcount
            h(i,ii)=h(i,ii)/fratio(ii)
          end do
        end do
      endif

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!       for sensitivity analysis and pattern search
c      if(dds_flag.eq.-1)then

      if(dds_flag.lt.0)then
	      optim=dds_error
	      if(optim.le.0.0)then
	        print*,'For sensitivity run:'
	        print*,'calculated error = zero'
	        print*,'Please make sure there is streamflow and/or'
	        print*,'value1 in the str files are set to 1'
	        stop 'Program aborted in sub @ line 3696'
	      endif
	      return                     !<<<<<<<<<<<<<<<<<<<<<return
      endif

!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!     stats not caculated for FEWS      
      if(numa.eq.0.and.iopt.lt.99.and.FLtype(6).eq.'tb0')then
!       call stats only when there's no pre-emption:
!       but not for the pattern search as it get here with every trial
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call stats(28,28)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif

!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.6.01  Mar.  01/10  - NK: DDS capability added

c      if(errflg.eq.7)dds_error=optim  !  for nash obj fn only

!     write the function value for DDS
      if(dds_flag.eq.1)then
        open(unit=99,file='dds\function_out.txt',
     *          status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file  dds\function_out.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in sub.f @ 4299'
        endif
c       write(99,*)temp_ashnum
        write(99,*)dds_error
        close(unit=99,status='keep')
        write(30,*)  !blank line between trials in dds_log.txt
         
!       this copied here from lst - error is needed each time an improvement 
!       is found for the dds\best directory
!       fix: this could be eliminated here by moving the call lst after the ddserror
!       calculation above        
c        if(dds_error.lt.pre_emption_value)then
!     rev. 9.3.07  Dec.  29/06  - NK: added error field for whole domain
!     rev. 9.8.15  Mar.  12/11  - NK: write error.txt for every dds evaluation
!         (because it's needed whe doing on-the-fly validation runs)
          author='watflood                                '
          name='Volume errors in %                      '
          coordsys_temp=coordsys1
!         GreenKenue uses LatLong - code below uses LATLONG
          if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
          if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
          zone_temp=zone1
	    datum_temp=datum1
	    xorigin_temp=xorigin
	    yorigin_temp=yorigin
	    xcount_temp=xcount
	    ycount_temp=ycount
	    xdelta_temp=xdelta
	    ydelta_temp=ydelta
	    startdate='unknown   '
	    starttime='unknown   '
          unit_conversion=1.0
          attribute_count=1
	    attribute_name='error                                    '
	    attribute_units='percent                                 ' 
          source_file_name='last spl run'     
          do j=1,xcount
	      do i=1,ycount
              outarray(i,j)=basinerr(i,j)
	      end do
  	    end do
        
!         write the header
!         written in lst for ddsflg=0
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(67,67,1,0,0,0,11)   
        call write_r2c(67,67,0,0,0,0,11)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       write the data
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_r2c(67,67,1,1,1,1,11)   
        call write_r2c(67,67,0,0,0,1,11)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        endif
      endif

!     STATUS LINE:   PS optimization only
      if(numa.gt.0.and.dds_flag.eq.0)then
        if(nnn.eq.0)optim=optim*4.0
        write(6,5006)id-1,ni,mz,mhtot,nnn,maxn,optlow
      endif

      close(unit=271,status='keep')   ! gridflow.r2c

      id=ni

!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
      
      if(iopt.ge.1)then
        write(51,*)'Continuity check for wetlands:'
        write(51,*)
     *'grid #,    net_inflow,    delta_storage,      difference,     %'
      if(wetflg.eq.'y')then
        do n=1,naa
          xtemp=qiwetsum(n)-qowetsum(n)
          ytemp=wstore2(n)-wstoreinit(n)
          ztemp=(xtemp-ytemp)/xtemp
          if(ztemp.gt.0.0001)then
!            write(51,5103)n,xtemp,ytemp,ztemp*100.0
            write(51,*)n,xtemp,ytemp,xtemp-ytemp,ztemp*100.0
          endif
          end do
        endif
5103    format(i10,2f20.3)
      endif

!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
      errflg_store=.false.
c      if(numa.eq.0.and.dds_flag.eq.0)then
        do n=1,naa
          if(store_error_flag(n))then
            Print*,'WARNING: -ve storage(s) in grid no ',n
            errflg_store='true'
          endif
        end do
c     endif
      if(errflg_store)then
        print*,'-ve storage errors found in the grids listed above'
        print*,'Probable cause:'
        print*,'1. steep slopes with low Manning n'
        print*,'2. grids with 100% water not marked as a reach'
        print*,'3. cummulative evaporation exceeds inflow + precip'
        print*,'Storages are set to 0.0 when -ve'
        print*,'and you get this annoying message'
        print*
      endif


c      if(tbcflg.eq.'y')then
!       THIS SECTION IS USED TO WRITE ALL STATE VARIABLES
!       SO PRGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!       Called only after the last event is complete.
!     REV. 8.1  - Feb.    15/96 -  TBC & RSM (TO BE CONTINUED & RESUME)
!     rev. 10.2.47 Feb.  10/19  - NK: Revised write_resume
!     soil_init, flow_init & lake_level_init moved there          
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c        call write_resume(jz)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c      endif    !   if(tbcflg.eq.'y')....

!     end writing the resume file

!     CALL RUNOF5 TO PRINT SUMMARY WATERBALANCE FILE WATBAL.TXT

      oldjan=jan
      if(iopt.eq.2)then
        print*,' In sub before call runof6(3,...'
        print*
      endif

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call runof6(3,time,sintvl,aintvl,mon,e1,mz,ju)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

      jan=oldjan
      
c      if(iopt.ge.1)then
      if(writeFlg(1))then
      open(unit=99,file='rff_grid_specs.txt',status='unknown',
     *        iostat=ios)
          write(99,*)'Frac ,',frac(nnprint)
          write(99,*)'GridArea,',grid_area(nnprint)
       
      
        do ii=1,classcount
          if(aclass(nnprint,ii).gt.0.0)then
            write(99,*)
            write(99,*)'Class ',ii,nclass(ii)
            write(99,*)'ClassRatio,',aclass(nnprint,ii)
            write(99,*)'ClassArea,',
     *                grid_area(nnprint)*aclass(nnprint,ii)
            write(99,*)'ClassFraction,',
     *                frac(nnprint)*aclass(nnprint,ii)
          endif
        end do
      endif
      
!     if(iopt.eq.2)print*,' In sub before call snout3'
!
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     if(iopt.ge.1)call snout3()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     rev. 9.9.39  Nov.  14/14  - NK: Modifications for watroute
      if(ittoflg.eq.0.and.vapflg.eq.'y'.and.modelflg.eq.'n')then
!       only needed if we have evaporation turned on
        write(98,*)'WARNING: In .par file, temp3 set too low'
        write(98,*)'Results in underestimated evaporation'
        write(98,*)'Please see manual section 2.4.2'
      endif

      if(climate_delta_flg)then
        write(98,*)'Reminder:'
	  write(98,*)'Montly climate deltas from file:'
	  write(98,*)'basin\monthly_climate_deltas.txt'
	  write(98,*)'Temperatures were adjusted by dC:'
	  write(98,*)monthly_temperature_delta
	  write(98,*)'Precipition were multiplied by:'
	  write(98,*)monthly_precipitation_delta
      endif

      firstpass=.false.

      if(msgflg.and..not.netCDFflg)then
        write(98,*)'WARNING:'
        write(98,*)'Tracer model data may not reflect'
        write(98,*)'the actual flow components at locations downstream'
        write(98,*)'of stations with nudging'
      endif

      RETURN

! FORMATS

  201 format(999f5.2)
 2000 format(5i5)
 2001 format(60i1)
 2002 format(a1)
 2003 format(a20,i50)
 3004 format(a20,a10,2x,a10)
 5001 format('+',1x,'id=',i3,'/',i3,' mz=',i3,'/',i3,' nnn=',i5,'/',i5,
     *         ' smc=',5f4.2,' optlow=',e16.10)
 5002 format(i5,f5.2,i5,f5.1)
 5003 format('+',1x,'id=',i3,'/',i3,' mz=',i5,'/',i5,' nnn=',i5,'/',i5,
     *         ' scale=',f4.2,' optlow=',e16.10)

 5004 format(a20,a10)
 5005 format(a20,i50)
 5006 format('+',1x,'id=',i3,'/',i3,' mz=',i5,'/',i5,' nnn=',i5,'/',i5,
     *         ' optlow=',e16.10)

 5010 format(' id,l,mhtot,kt,nu,delta,opt/',5i5,2e10.3)
 5101 format('new shed file read in')
 5102 format(' id = ',i5,' filename = ',a30)
 5558 format(' n,nnx,qda(n),qda(nnx),da(n),da(nnx)/',2i3,4f10.1)
 6001 format(5x,' no of storms =',i5)
 6002 format(35x,' * * * time =',f7.2,' hours * * *',f12.3)
 6004 format('+',i5,' hrs rainfall available, ',i5,' hrs used')
 6005 format(' Warning: no streamflow stations selected for '/
     *' error calculation. Enter data in 1st line of .str file.')
 6007 format(' no,nl,mhtot,kt/',4i5)
 6008 format(' id,nr,tj1,mo,conv/',2i5,f5.2,i5,f5.2)
c 6012 format(' ',2f12.3,i5,1x,a12,3x,2a1,3x,2a1)
 6013 format(' ',2f12.3,i5,1x,a12,99f5.2)
 6014 format(' ',2i5,99f5.2)
 6015 format(' ','sub basin file'/
     *   '      sub-basin percent of land covers')
 6016 format(' ','sub basin file'/
     *   '      can be used to find sub-basin percent of land covers')
 6017 format('           xx          yy    # name         sum   ',
     *                        ' classes 1-',i5)
 6018 format(' ',i7,99f7.2)
 6100 format(' [in sub]'/
     *'   n    i    j      da     qda  qbase')
 6102 format(' ',3i5,3f10.2)
 6103 format(' element #',i5,' base flow = 1 cms assumed')
 6104 format(25i3)
 6105 format(' initial flows modified by reservoir releases') 
 6106 format(' i,qinit(i)/',i5,f10.3)
 6107 format(' n,yyy(n),xxx(n),i,ires(i),jres(i)/',6i3)
 6108 format(' initial base flows prorated upstream')
 6109 format(' reservoir releases added back in') 
 6110 format(' initial flow at streamflow stations')
 6120 format(a1)
 6121 format(5i10,2f10.2)
 6226 format(' error encountered opening unit=37 fln=',a31/)
 6227 format(' error encountered on unit=37 fln=',a31/)
 6229 format(' error encountered on unit=38 fln=',a31/)
 6231 format(' error encountered on unit=40 fln=',a31,'on line 5'/)
 6233 format(' error: problems opening unit=45 fln=',a31/
     *    '     OK if vapflg=y and flgevp.le.1')
 6235 format(' end of file encountered on unit=36 fln=',a31/) 
 6237 format(' end of file encountered on unit=40 fln=',a31/)
 6250 format(' error encountered on unit=99 fln=',a31/)
 6263 format(' error encountered on unit=49 fln=',a31/)
 6273 format(' error encountered on unit=50 fln=',a31/)
 6300 format(' ','Mode is set to check all input files'/
     *' iopt = ',i5, ' To run the event, change debug level to'/
     *' a value less than 99'/)
 6400 format(' Warning: min swe on (grid,class)',i4,' ',i2,
     *    ' =',f8.2,'mm in event #',i3)
 6501 format(' number of grids,',i5)
 6502 format(' number of rows,',i5)
 6503 format(' number of colums,',i5)
 6504 format(' number of land cover classes = classcount,',i5) 
 6505 format(' The reference grid is the bottom left hand corner'/
     *       ' there are blanks around the watershed'/
     *       ' All units are mm or cms')
 6508 format(' time=',f14.2)
 6509 format(/' Colunm Key:'/ 
     *'      grid no, row no, column no, precip'/ 
     *i5,' liquid surface storage bare/snow (2*classcount)'/
     *i5,' snow water equivalent (classcount)'/
     *i5,' snow covered area (classcount)'/
     *i5,' upper zone storage bare/snow (2*classcount)'/
     *' lower zone storage'/
     *' grid flow, channel flow') 
 6510 format(3i5,60e10.2)

 9001 format(f25.0)
 9700 format(19e14.7)
 9701 format(a3)
 9702 format(' resume.txt file length does not match current'/
     *       ' memory array spec. Regenerate the file'/)
 9703 format('block no.',i2)
 9704 format(9x,i2)
 9706 format(16i5)
 9999 format(15x,f16.6)
 9990 format(i5)
 9991 format(12x,f9.6)
 9992 format(12x,<ninit>(i9))
 9993 format(12x,<ninit>(f9.6))
 9994 format(5x,i9)
 9995 format(7x,f9.6)
99000 format(f5.1)
99001 format(f25.0)
99002 format(2f15.3,i6,4x,2a12,f12.1)
99003 format(i1,5x,a50)
99004 format(i5)
99005 format(i10,<noresv>g12.3)
99182   format(' Warning: Error opening or reading fln:',a30/
     *  ' Probable cause: missing strfw/yymmdd.str input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/)
98001 format(' Warning: Error reading resume.txt'/
     *' Probable cause: wrong format or end of file reached'/
     *' This could be due to a change in grid characteristics'/
     *' since creating the resume file'/
     *' Solution: create a new resume file with current executable'/
     *' block= ',i5)

      end  SUBROUTINE sub

    suBROUTINE sub(jan,e1,smc5,conv,scale,icase,smok,optlow,igrdshft)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

!  THIS SUBROUTINE ORGANIZES ALL THE CALCULATIONS.

!     REV. 7.51 oct.  08/95   -   revise init channel flow in SUB
!     REV.        aug   07/96 - to read in mica inflow file and
!                       use mica data for optimization when
!                       maxn=2002
!     REV. 7.80 Oct.  29/96   - spl7 added yymmdd.rin for res inflows
!                     - unit = 49   fln = 19
!     REV. 7.9  Dec   18/96   - Todd's Evaporation, changed above
!                       res inflows to unit=99  fln=21Fpro
!     REV. 8.1  - Feb.    15/96 - TBC & RSM (to be continued & resume) 
!     REV. 8.61 - Dec.    12/97 - added contflg for statistics cont'n
!     REV. 8.75 - Apr.    27/89 - took da out of the resume file
!     REV. 8.90 - Dec.    04/98 - input to memory for opt runs
!     REV. 8.91 - Dec.    07/98 - read rdevt in sub as well as spl!
!     REV. 8.94 - Feb.    01/99 - crseflg to read resume & snow course
!     REV. 8.82 - July    10/98 - added runoff output option: routeflg
!     REV. 8.82 - July    10/98 - added runoff output option: routeflg
!     REV. 8.83 - Oct.    23/98 - added step to the lst argument list
!     REV. 8.86 - Nov.    02/98 - fixed opt problem found by ted.
!     REV. 8.96.1 May 12/99 - added ireport for reporting interval
!     REV. 8.98   July    15/99 - met grid increased
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 
!     rev. 9.1.18  Jun.  03/02  - Added sub-watershed modelling capability
!     rev. 9.1.21  Jun.  28/02  - Added wetland storage & outflow to the wfo file
!     rev. 9.1.23  Jul.  23/02  - Added control for nudging in event #1
!     rev. 9.1.28  Sept. 19/02  - Added shedlfg to replace the bsnm.shd file
!     rev  9.1.29  Oct.  24/02  - Added q1, qint & drng to wfo file
!     rev. 9.1.35  Dec.  26/02  - Added wetland & channel heights to the wfo file
!     rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
!     rev. 9.1.42  May     31/03  - Tracer module added - first try
!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!     rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added
!     rev. 9.1.47  July  11/03  - TS: Tracer s/r call line modified 
!     rev. 9.1.50  Jan.  14/04  - NK: version number added to the wfo_spec.txt file
!     rev. 9.1.51  Jan.  28/04  - NK: added iz.ne.jz conditional to ENSIM output  
!     rev. 9.1.56  Jun.  18/04  - NK: write new rel & rin files to resrl\newfmt folder.
!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout
!     rev. 9.1.67  Oct.  21/04  - NK; added unit 80 for lake_stor & lake_flow
!     rev. 9.1.81  Apr.  04/05  - NK: added sublimation,et and etfs to wfo file
!     rev. 9.2.05  Jul.  15/05  - NK: reversed order of reading resume file 
!     rev. 9.2.07  Jul.  29/05  - NK: soilinit moved from runoff to sub 
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 
!     rev. 9.2.25  Dec.  13/05  - NK: ENSIM r2c gridded soil moisture 
!     rev. 9.2.28  Jan.  30/06  - NK: Added low slope a4 for grids with water
!     rev. 9.2.30  Feb.  07/06  - NK: Added class_distribution.txt to output
!     rev. 9.2.35  Mar.  22/06  - NK: Glacier flow bypasses wetlands
!     rev. 9.2.39  May.  09/06  - NK: thr added to route & rerout arg list
!     rev. 9.3.02  Jul.  18/06  - NK: converted runof, rchrg & lkage to r2c
!     rev. 9.3.08  Jan.  15/07  - NK: added lzs_init_new.r2c output to sub.for
!     rev. 9.3.10  Jan.  29/07  - NK: routing pars changed to gridded values
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!     rev. 9.4.14  Jul.  09/07  - NK: added lake loss file 
!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
!     rev. 9.5.18  Mar.  03/08  - NK: added conv to options & sub argument list
!     rev. 9.5.19  Mar.  05/08  - NK: prevented use of tracer * iso models with nudging
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!     rev. 9.5.31  May.  27/08  - NK: moved totsnw(n) computation in sub
!     rev. 9.5.33  Sep.  12/08  - NK: added column labels for grapher in flow_station_location.xyz
!     rev. 9.5.35  Sep.  22/08  - NK: moved flow_sta_location to flowinit
!     rev. 9.5.45  Dec.  16/08  - NK: added various error calculations - user's choice with errflg
!     rev. 9.5.48  Dec.  26/08  - NK: added event_fln() to allow unlimited events
!     rev. 9.5.50  Jan.  05/09  - NK: read evap data for reaches only
!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
!     rev. 9.5.57  Apr.  13/09  - NK: added ntrlflg for natural lake flows
!     rev. 9.5.62  Sep.  04/09  - NK: new tb0 file for DW routing
!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
!     rev. 9.5.73  Oct.  12/09  - NK: bypass using lake levels when optimizing
!     rev. 9.5.75  Oct.  26/09  - NK: commented "deallocate in sub for watroute reads
!     rev. 9.5.77  Oct.  26/09  - NK: fixed some inits for out of basin gauges
!     rev. 9.5.80  Dec.  20/09  - NK: added swe_locations.txt file for swe input
!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.03  Jun.  24/10  - NK: normalized SSE with station Qmean**2
!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
!     rev. 9.7.17  Jan.  05/11  - NK: Fixed diversions outside sub-basin
!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.7.27  May.  26/11  - NK: Add lake_ice_factor
!     rev. 9.8.03  Aug.  08/11  - NK: chech no of mean observed flows in file are ok
!     rev. 9.8.09  Nov.  22/11  - NK: nopt(l)=0 for area_error(l) > 10%
!     rev. 9.8.14  Jan.  27/11  - NK: dds_penalty added for swe not to zero in summer
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
!     rev. 9.8.44  Jan.  31/13  - NK: fixed bug in sub.f : uninitialized course_calc(n,j)
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals
!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!     rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
!     rev. 9.8.93  Nov.  12/13  - NK: Added the routing initialization with yyyymmdd_fli.r2c
!     rev. 9.9.06  Jan.  08/14  - NK: Add daily differences to Harfreaves ETHarg.f
!     rev. 9.9.09  Feb.  24/14  - NK: Fixed reading the time stame in r2c frame headers
!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!     rev. 9.9.21  Jul.  27/14  - NK: Added allocation for outarray in sub
!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!     rev. 9.9.36  Nov.  03/14  - NK: Revised error message for daily diff choices
!     rev. 9.9.64  Apr.  08/15  - NK: DDS bypass in sub for single runs
!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!     rev. 10.3.00 Dec.  **/19  = NK Conversion f77 to f90      
!
!  id     - storm id number
!  l      - station number
!  ni     - total # of storms
!  nl     - forecast period = total length of the streamflow file
!  no     - total # of stations
!  nr     - the # of hours rainfall is available
!  mhrd   - length of streamflow record = time elapsed since start
!  mhtot  - the simulation length in hours or is the length of rainfall
!         input for simulated forecasts
!  aintvl - precip interval in hours
!  sintvl - precip. interval in seconds
!  tot2   - the total average precipitation over the watershed


!***********************************************************************

      use areacg
      use area_watflood
      use area_debug


!C///////////////////////// 
!C// Added by Dave
      USE EF_module
!C// End Dave addition
!C/////////////////////////

      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        DIMENSION     :: smc5(16)
        CHARACTER(14) :: date
        CHARACTER(3)  :: eofmark
        CHARACTER(1)  :: lineflg,smok,answer
        character(20) :: junk
        REAL(4)       :: optlow,time,time2,tot1,qwert,conv,scale,&
                smc5,tj1,clock,t,thr,dtmin,dtmax,div,aintvl,sintvl,&
                tot2,e1,tdum,tdum1,qtemp,diff2,sdlz,dlz,&
                wfo_spec_version_number,&
                route_dt,sec_div,hr_div
      integer         :: frame_no1,frame_no2,frame_no3,frame_no4
      integer         :: frame_no5,frame_no6,frame_no7,frame_no8

      real*4          ::  input,runoff,router,output,last,now
      real*4          ::  hhhhh,mmmmm,sssss
      integer         ::  yyyyy,moooo,ddddd
      integer         ::  today,startHour,julian_day
      
  
      INTEGER*4       :: rbin,inta,block,no1,classcount1,na1,&
                   ycount1,xcount1,&
                   iallcnt1,iallcnt2,n1,ii1,jan,m,ios,n,iallocate,&
                   l,ii,juold,julast,jj,kk,lun,nhr,nhf,nfg,&
                   i,j,icase,iz,jz,jzz,nchr,mz,ju,mon,&
                   iwest,ieast,isouth,inorth,nocolumns,nno,k,&
                   nu,igrdshft,minsnwflg,oldjan,flgevp22,&
                   noresv1,nj,npick,n_trick,no_frames,&
                   no_dt,iDeallocate,id_last,nd,MC_id
      integer       :: swe_l(99),no_swe_l,no_swe_obs
      integer       :: nrows,ncols
      integer       :: flnNum
      integer       :: n_max,nold,nlines_old,nlines
      integer       :: cdayYear,cdayMonth,cdayDay

      CHARACTER(10) :: ctime
      CHARACTER(8)  :: cday
      CHARACTER(12) :: outlet_type
      logical   :: exists,newpafflg,firstpass,errflg_store,msgflg
      logical   :: dataflg,newDataFlag
      logical   :: climateFlg

        CHARACTER(10) :: coordsys
!        INTEGER      :: xcount,ycount
!        REAL     :: xorigin,yorigin,xdelta,ydelta,
      real     :: a66,sum_mean_flow,class_sum
      real :: swe_error,swe_penalty
      real :: ha,fpw,kdn,nratio,xtemp,ytemp,ztemp
      real :: domain_precip,domain_area
      real :: store_live

      data firstpass/.true./
      data climateFlg/.false./
      data id_last/0/
      data no_swe_l/0/
      DATA iallcnt1/0/
      DATA iallcnt2/0/
!c      DATA col1/'b','d','f','h','j','l','n','p','r','t','v','x','z'/
!c      DATA col0/'c','e','g','i','k','m','o','q','s','u','w','y','a'/
!c      DATA col2/' ','a','b','c','d','e','f','g','h','i','j','k','l'
!c     *       ,'m','n','o','p','q','r','s','t','v','u','w','x','y'/


!     NOTE: FOR MONTHLY RUNS, DIMENSIONS CAN BE CHANGED FROM 
!         3,8784,500  TO  12,366,3000

!>>>>>>>>>>>>>  AB: STUFF FOR ENSIM
      INTEGER(4) :: wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss,wfo_ms
      INTEGER(4) :: wfo_seq
      real*4     :: dds_penalty

      character(256) line,tmpLine
      CHARACTER(100) sys_command ! Command line input string

!      replaced by areawfo
!      REAL*4, DIMENSION(:,:), ALLOCATABLE :: outwfo

!     DDS error functions
      real*4    :: log_qhyd,log_qinfl,log_mean_obs           
      real*4    ::  sum_swe
      real*4    ::   score
      real*4    ::   temp_value,sum_sq_error,temp_value_sum,dds_error

!     WFO IO FUNCTIONS
      INTEGER :: wfo_write_attribute_data
      INTEGER :: wfo_write_timestamp
      
!>>>>>>>>>>>>>
    if(debug_output)write(63,*)' In sub after definitions'

!     RESET SETS ALL INITIAL VARIABLES

!     CHECK FILES MODE    iopt=99
!     FOR IOPT=99 NL AND MHRD ARE SET TO KT AND THE PROGRAM WILL RUN
!     FOR ONE TIME STEP ONLY - THIS WILL CHECK AND ECHO ALL INPUT FILES
!     >> VERY HANDY FOR CHECKING DATA FILE PRIOR TO LONG RUNS

      id=1  ! just so it's not some value from before

      if(firstpass)then
      
        input=0.0
        runoff=0.0
        router=0.0
        output=0.0
        min_flow_cutoff=0.01    ! error not calculated below this flow
        min_flow_cutoff=0.000    ! error not calculated below this flow

      
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
        tdum1=1000.*step2/3600.

!       rev. 9.8.21  Jun.  18/12  - NK: Assed swe observed date & report
        if(iopt99)open(unit=951,file=filename(951),iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          write(98,*)'Error: Unable to open file',filename(951)(1:40)
          write(98,*)'Error: Possible cause(s):'
          write(98,*)'Error: file in use by another application'
          write(98,*)'Error: or target directory does not exist'
          write(98,*)'Error: Program aborted in sub.f @ 236'
          stop 'Program aborted in sub.f @ 236 - SEE debug\warnings.txt'
        endif

!     rev. 9.9.00  Dec.  08/13  - NK: Added Lake Evaporation model
        if(lakeflg.eq.'y')then
            allocate(WindSpd(na),WindDir(na),stat=iAll)
            if(iAll.ne.0)then
                write(98,*)'Error: Error allocating wind arrays in sub'
                STOP 'Error allocating wind arrays in sub' 
            endif
        endif
          
        allocate(QQsum(na),QRsum(na),stat=iAll)
	    if(iAll.ne.0)then
            write(98,*)'Error: Error allocating QQsum in sub' 
            STOP 'Error allocating QQsum in sub' 
        endif
        do n=1,na
            QQsum(n)=0.0
            QRsum(n)=0.0
        end do 

!     rev. 9.8.80  Aug   09/13  - NK: Added withdraw.r2c output file in route.f
!       write the header for the withdraw.r2c file 
      if(iopt99)then
        author='watflood                    '
        name='Irrigation withdrawals             '
        coordsys_temp=coordsys1
!       GreenKenue uses LatLong - code below uses LATLONG
        if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
        if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
        zone_temp=zone1
        datum_temp=datum1
        xorigin_temp=xorigin
        yorigin_temp=yorigin
        xcount_temp=xcount
        ycount_temp=ycount
        xdelta_temp=xdelta
        ydelta_temp=ydelta
        attribute_name='withdrawalslow                    '
        attribute_units='cms                           ' 
        attribute_type='Flow                          '
        unit_conversion=1.0   
	    startdate='unknown   '
	    starttime='unknown   '
        source_file_name='various rff,rch,lkg files'     
        no_frames=2      
        frame_no1=0       ! write the header
!       no_frames=2 tricks write_r2c to write frame .....
!       write the header for gridded withdrawal flows
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        fln(23)='results\withdraw.r2c'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(23,23,ni*12,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif
!       added for BC Hydro
        if(iopt99)then
        open(unit=29,file=filename(29),status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',filename(29)(1:40)   ! 'results\domain_precip.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          write(98,*)
          write(98,*)'Error: Unable to open file',filename(29)(1:40)   ! 'results\domain_precip.txt'
          write(98,*)'Error: Possible cause(s):'
          write(98,*)'Error: file in use by another application'
          write(98,*)'Error: or target directory does not exist'
          stop 'Program aborted in sub.f @ 293'
        else
          write(29,*)'       ID domain_precip'     
        endif
        
        domain_area=0.0 
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          domain_area=domain_area+grid_area(n)
        end do
        domain_precip=0.0
        endif
        
!       rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins
!       This will only happen is the user has created a folder & file: 'radcl\new_grid\junk'
        open(unit=99,file='radcl\new_grid\junk',status='unknown',iostat=ios)
        if(ios.eq.0)then
          new_precip_grid_flg=.true.
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          print*,'re-gridded met file will be written in radcl\new_grid'
	      print*,'delete the \new_grid folder to stop this message'
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        else
          new_precip_grid_flg=.false.
        endif
        close(unit=99,status='delete')
        open(unit=99,file='tempr\new_grid\junk',status='unknown',iostat=ios)
        if(ios.eq.0)then
          new_temp_grid_flg=.true.
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
          print*,'re-gridded tem file will be written in tempr\new_grid'
	      print*,'delete the \new_grid folder to stop this message'
          print*,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        else
          new_temp_grid_flg=.false.
        endif
        close(unit=99,status='delete')
!       end rev. 9.7.15  Dec.  14/10  

!       assume we do a swe report untuil we do not find the swe.tb0 files
        courseflg=.true.

!     rev. 9.8.51  Mar.  11/13  - NK: Link skiplines in s/r stats to value1 in the str file
        skiplines=0
        


!     rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg
!       this needs to be read along with the event file; include with read_evt()?
!       ? ... or flow_init -- either has correct scope and occurs at start of event
!       these declarations are in area_watflood.f
!       logical :: fcst_exists,fcst_mode ! declare  in header of 
!       integer :: fcst_yr, fcst_hr0, fcst_days2avg
!       real*4 :: fsct_snow_adj, fcst_rain_adj
! --    the rest of this located in main scope; could add to separate sub

        fcst_mode=.false.
        INQUIRE(FILE='fcst_params.txt',EXIST=fcst_exists)
        IF(fcst_exists)THEN
          open(unit=99,file='fcst_params.txt',iostat=ios)    ! 99 is a scratch file #
!           -- unit number selected randomly (fix!);
!           -- can't figure out filename convention
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  fcst_params.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            write(98,*)'Error: Unable to open file  fcst_params.txt'
            write(98,*)'Error: Possible cause(s):'
            write(98,*)'Error: file in use by another application'
            stop 'Program aborted in sub.f @ 358'
          endif
          read(99,*)fcst_yr ! read each line and assign to forecast parameter variables
          read(99,*)fcst_hr0
          read(99,*)fcst_days2avg
          read(99,*)fcst_snow_adj
          read(99,*)fcst_rain_adj
          close(unit=99,status='keep')
!         check if this is the current year
          if(fcst_yr.eq.year_now)then          ! Trish believes 'year1' is the current year; might be 'year' or 'yearnow'?
!                                                 look in timer.f
            fcst_mode=.true.
          end if
        END IF    
!       end rev. 9.9.26  Sep.  16/14  - NK: Added precip adjust for forecast & fcstflg

!     rev. 10.1.08 Dec.  04/15  - NK: Added msg re: replacing "mean_observed_flows.txt"' 
        if(dds_flag.eq.0.and.id.eq.ni)then
          inquire(FILE='mean_observed_flows.txt',EXIST=exists)
          if(exists)then
            write(98,*)'Info: found the file mean_observed_flows.txt'
            write(98,*)'Info: If you wish to replace this file with the current'
            write(98,*)'Info: the old file must be deleted'
          endif
        endif
        
        if(iopt99)then
          open(unit=1000,file='debug\benchmark_time.txt',iostat=ios)
          if(ios.ne.0)then
            write(98,*)'Warning: Problems opening benchmark_time.txt'
            write(98,*)'Warning: needs debug\ directory in the working dir'
          endif
        endif
        
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!       New here        
        if(.not.allocated(p).and.FLtype(10)(1:2).eq.'nc')then
           allocate(p(ycount,xcount),stat=iAllocate)
           if(iAllocate.ne.0)then
               write(98,*)'Error: Error with allocation of p in sub @ 117'
               STOP 'Error with allocation of p in sub @ 117'
           endif
        endif
        
!       Stuff for FEWS & netCDF files
        deltaT2 = 1  ! Will be reset as soom as we read the first precip file
        deltaT3 = 1  ! Will be reset as soom as we read the first temp file
        
      endif   ! firstpass
 
      if(numa.ne.0)then
        trcflg='n'
        ensimflg='n'
        initflg='n'
        modelflg='n'
      endif

      m=1
      tot1=0.0
      totaltime=0.0       ! used for ensim time series
	  mo=mo1              ! added jan 22/11 nk for repeated runs
      wfo_open_flg='n'
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
      dtmin=a6

!     Write the header in rte.txt
      IF(iopt.ge.1.and.n.eq.nnprint)write(55,5551)
5551  format('   id   time         at     qi1     qi2     qo1     qo2   store1     store2')

    if(debug_output)write(63,*)' In sub - gone to rdflow @ 147'

!     get no and nopt for allocations etc.  nk Apr. 8/03 
!     read the str header for allocation and initialization purposes

!      call rdflow('0',date)     
 
      if(IsFileTypeTB0(fln(6)).or.FLtype(6)(1:2).eq.'nc') then
      if(debug_output)write(63,*)'reading flow header'      
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call read_flow_ef('0',date)  !EnSim compatible tb0 file
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      else
         print*,'Old format .str files not accepted'
         print*,'Please create yyyymmdd_str.tb0 files & rerun'
         stop 'Program aborted in sub @ 192'
      endif

!     rev. 9.5.19  Mar.  05/08  - NK: prevented use of tracer * iso models with nudging
      msgflg=.false.
      do l=1,no
        if(nopt(l).eq.2)then
          frcflg='n'
!c          trcflg='n'
          if(msgflg)then
            write(98,*)'Info: Flow nudging is turned on in flow station ',l
          else
            write(98,*)'Info: also at station',l
          endif
          msgflg=.true.
        endif
      end do
      if(msgflg)then
        write(98,*)'Warning: Tracer and isotope model data may have issues at'
        write(98,*)'Warning: locations downstream from stations with nudging'
        write(98,*)'Warning: due to a possible lack of continuity'
      endif
 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     Section added to allow for lengthened routing time step for large grids
      if(irdt.gt.kt)then
        a6=float(irdt)*3600.0
        write(51,*)' Warning'
        write(51,*)' Min time step a6 changed to ',a6
        write(51,*)
        write(*,*)
        write(*,*)'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
        write(*,*)' WARNING'
        write(*,*)' deltaT (str file) irdt=',irdt
        write(*,*)' Min time step a6 changed to ',a6
        write(*,*)'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
        write(*,*)
    if(debug_output)   pause 'hit enter to continue - in sub @167'
      endif
    if(debug_output)write(63,*)' In sub - back from rdflow @ 152'

      if(iallcnt1.eq.0)then
        iallcnt1=1
      endif   ! iallcnt1=0
      if(iallcnt2.eq.0)then
        iallcnt2=1
      endif   ! iallcnt2=0

    if(debug_output)write(63,*)' In sub after allocations 1'

      if(snwflg.eq.'y')then
         do n=1,naa
          do ii=1,classcount
!            will print warning if snow never disappears
             snowcmin(n,ii)=1.0e+32
          end do
         end do
      endif
    if(debug_output)write(63,*)' In sub after allocations 2'

!     SINGLE RUN USING SOIL MOISTURE GRID IS THE DEFAULT.
!     NO SOIL MOISTURE OPTIMIZATION - THIS CAN BE CHANGED WITH 
!     SETTING ICASE=-1 IN THE PARAMETER FILE & SM GRID WILL BE IGNORED

!     SAVE THE ORIGINAL VALUE:

      flgevp22=flgevp2

    if(debug_output)write(63,*)' In sub after allocations 3'

      do n=1,naa
        rechrg(n)=0.0
!       qstream & strloss need to be initialized for watroute
        qstream(n)=0.0
        strloss(n)=0.0
!        rh(n)=.50   ! moved to rdtemp 28/12/04 nk
        
      end do
      juold=0

!     call decread(ha,fpw,kdn,nratio)

 !     NK - ALLOCATION OF AREAwfo ARRAYS
      if(iallcnt1.eq.1)then
        allocate(outwfo(xcount,ycount),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: Error with allocation of ensim arrays in sub' 
            STOP 'Error with allocation of ensim arrays in sub'   
        endif
        iallcnt1=2
      endif
!
!      if(routeflg.eq.'y')then
      if(iallcnt2.eq.1)then
        allocate(outarray(ycount,xcount),stat=iAllocate)
        if(iAllocate.ne.0)then
            write(98,*)'Error: Error with allocation of ensim arrays in sub'
            STOP 'Error with allocation of ensim arrays in sub'    
        endif
        iallcnt2=2
      endif
!     endif

!     Initialize all grids for write_r2c
!      if(routeflg.eq.'y')then
        do i=1,ycount
          do j=1,xcount
          outarray(i,j)=0.0
          end do
        end do
!      endif

      if(iopt.eq.2)print*,'In sub before writing header / gridflow.r2c'

      if(iopt99)then
      if(numa.eq.0.and.dds_flag.eq.0)then
        author='watflood                    '
        name='Gridded Channel Flow (SPL)          '
        coordsys_temp=coordsys1
!       GreenKenue uses LatLong - code below uses LATLONG
        if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
        if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
        zone_temp=zone1
        datum_temp=datum1
        xorigin_temp=xorigin
        yorigin_temp=yorigin
        xcount_temp=xcount
        ycount_temp=ycount
        xdelta_temp=xdelta
        ydelta_temp=ydelta
        attribute_name='channel_inflow                    '
        attribute_units='mm                            ' 
        attribute_type='Runoff                        '
        unit_conversion=1.0   
        source_file_name='various rff,rch,lkg files'     
        frame_no2=0
!       write the header for gridded channel flow (gridflow.r2c)
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!c        call write_r2c(72,72,no_frames,1,frame_no2,1,1) 
!       use mhtot+1 so the file statys open until the end of the last event.  
        call write_r2c(72,72,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          write(98,*)'Info: disabled output to',fln(72)(1:30)
          write(72,*)'to write this file, set ensimflg= y or a'
        endif

        name='Snow Water Equivalent - weighted        '
        attribute_name='Weighted swe                  '
        attribute_type='SWE                           '
        source_file_name=fln(10)   ! met file
        frame_no4=0      
!       write the header for weighted swe
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(61,61,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          write(98,*)'Info: disabled output to',fln(61)(1:30)
          write(98,*)'Info: to write these files, set ensimflg= y or a'
          write(61,*)'to write this file, set ensimflg= y or a'
          print*
          print*
        endif

!     rev. 9.5.09  Feb.  12/08  - NK: added evap.r2c to the output files
        name='Total evaporation - weighted        '
        attribute_name='Weighted evaporation              '
        attribute_type='EVAP                          '
        source_file_name=fln(10)   ! met file
        frame_no5=0
!       write the header for weighted gridded et
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(100,100,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(ensimflg.eq.'n')then
          write(98,*)'Info: disabled output to',fln(100)(1:30)
          write(98,*)'Info: to write these files, set ensimflg= y or a'
          write(100,*)'to write this file, set ensimflg= y or a'
        endif

        name='isostrcon2                  '
        attribute_name='Iso_concentration_stream          '
        attribute_type='Concentration                 '
        source_file_name=fln(10)   ! met file
        fln(200)='results\isostrconc2.r2c'
        frame_no6=0
!       write the header        
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(200,200,0,0,0,0,1)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif
      endif   ! iopt99


!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
      if(dds_flag.eq.1)then
!       pre-emption 
        inquire(FILE='dds\pre-emption_value.txt',EXIST=exists)
        if(exists)then
!         read the pre-emption value which is the best solution so far
          open(unit=99,file='dds\pre-emption_value.txt',status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  dds\pre-emption_value.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 667'
          endif
          read(99,*)pre_emption_value
          print*,'from dds\pre-emption_value.txt'
          print*,'pre_emption_value read=',pre_emption_value
          close(unit=99,status='keep')
        else
!         first evaluation - set the pre-emption value to a large number
          open(unit=99,file='dds\pre-emption_value.txt',status='unknown',iostat=ios)
          if(ios.ne.0)then
            print*
            print*,'Unable to open file  dds\pre-emption_value.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
!     rev. 9.9.64  Apr.  08/15  - NK: DDS bypass in sub for single runs
            print*,'It looks like you are making a single run with'
            print*,'a par file generated by DDS or the PS'
            print*,'You can avoid this interruption by changing'
            print*,'ddsflg = 0 in the par file'
            print*
            pause 'For single run, to continue - hit Enter'
            dds_flag=0
          endif
          pre_emption_value=1.0E+35
          write(99,*)pre_emption_value
          close(unit=99,status='keep')
          print*,'first pre_emption_value written=',1.0E+35  ! changed 35 > 32 nk Jan. 22/11
        endif

      endif


!     rev. 9.7.11  Nov.  22/10  - NK: added monthly_climate_deltas.txt file
	climate_delta_flg=.false.     !default
      inquire(FILE='basin\monthly_climate_deltas.txt',EXIST=exists)
	if(exists)then
        open(unit=99,file='basin\monthly_climate_deltas.txt',status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          write(98,*)'Error: Unable to open file  basin\monthly_climate_deltas.txt'
          write(98,*)'Error: Possible cause(s):'
          write(98,*)'Error: file in use by another application'
          write(98,*)'Error: or target directory does not exist'
          write(98,*)'Error: Program aborted in sub.f @ 700'
          stop 'Program aborted in sub.f @ 700 - SEE debug\warnings.txt'
        endif
	  read(99,*)(monthly_temperature_delta(j),j=1,12)
	  read(99,*)(monthly_precipitation_delta(j),j=1,12)
	  close(unit=99,status='keep')
	  write(98,*)'Info:  basin\monthly_climate_deltas.txt'
	  write(98,*)'Info: All temperatures will be adjusted by dC:'
	  write(98,*)'Info: monthly_temperature_delta'
	  write(98,*)'Info: All precipition will be adjusted by %:'
	  write(98,*)'Info: monthly_precipitation_delta'
	  do j=1,12
	    monthly_precipitation_delta(j)=1.0+monthly_precipitation_delta(j)/100.0
      end do
      if(fewsflg.ne.'y')then
	    print*,'Do you want to continue with these adjustments?  y/n'
	    read*,answer
      else
!       don't want this for FEWS          
        answer='n'
      endif
	  if(answer.eq.'y')then
	    climate_delta_flg=.true.
	    print*,'All temperatures will be adjusted as per table'
	    print*
	    print*
	  else
	    do j=1,12
	      monthly_temperature_delta(j)=0.0
	      monthly_precipitation_delta(j)=1.0
         end do
	  endif
	endif

!     rev. 9.8.08  Nov.  18/11  - NK: added fratio for interception hight optimization
!     correct the interception capacity by the multiplier fratio
      fratioflg=.false.  ! i.e. it's equal to 1.0
      do i=1,12
        do ii=1,classcount
          h(i,ii)=h(i,ii)*fratio(ii)
          if(fratio(ii).gt.1.00001.or.fratio(ii).lt.0.99999)fratioflg=.true.
        end do
      end do
      
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
!     This is to just use a multiplier or an additive amount
      swe_update=.false.
      inquire(file='snow1\swe_update.xml',EXIST=exists)
      if(exists)then
          call read_swe_update(yy_swe,mm_swe,dd_swe,hh_swe,swe_add,swe_mult)
          if(swe_add.gt.-999.or.swe_mult.gt.-999.0)swe_update=.true.
          if(swe_add.lt.-998.and.swe_mult.lt.-998.0)then
              write(98,*)'Warning: Both the swe adjustment factors are < -999'
              swe_update=.false.
          endif
          if(swe_update)then
              write(98,*)'INFO: swe update'
              write(98,*)'INFO: swe update for ',yy_swe,mm_swe,dd_swe,hh_swe
              write(98,*)'INFO: swe_add/swe_mult',swe_add,swe_mult
              write(98,*)
          endif
      endif
      
!     rev. 10.2.62 Sep.  09/19  - NK Added read_sm_update.f90 for read in sm adjustment factors
!     This is to just use a multiplier or an additive amount
      uzs_update=.false.
      inquire(file='moist\uzs_update.xml',EXIST=exists)
      if(exists)then
          call read_uzs_update(yy_uzs,mm_uzs,dd_uzs,hh_uzs,uzs_add,uzs_mult)
          if(uzs_add.gt.-999.or.uzs_mult.gt.-999.0)uzs_update=.true.
          if(uzs_add.lt.-998.and.uzs_mult.lt.-998.0)then
              write(98,*)'Warning: Both the uzs adjustment factors are < -999'
              uzs_update=.false.
          endif
          if(uzs_update)then
              write(98,*)'INFO:uzs update for ',yy_uzs,mm_uzs,dd_uzs,hh_uzs
              write(98,*)'INFO:uzs_add/uzs_mult',uzs_add,uzs_mult
          endif
      endif
      
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating
!     For gridded swe updating with FEWS generated nc file      
      inquire(file='snow1\SWE_use.xml',EXIST=exists)
      if(exists)call read_swe_use    ! find out whether or not to update with FEWS generated swe
      if(debug_output)print*,'FEWS SWE update =',use_swe_update
      if(use_swe_update)then
          inquire(file='snow1\SWE_date.xml',EXIST=exists)
          if(exists)then
              call read_swe_date    ! find out what date & hour to do it
              if(debug_output)then
                  print*,'FEWS SWE update =',use_swe_update
                  if(use_swe_update)print*,'@ ',yy_swe,mm_swe,dd_swe,hh_swe
              endif
          else    
              write(98,*)'Error: snow1\SWEdate.xml required but does not excist'
              write(98,*)'Error: Program aborted in sub @ 856'
              write(*,*)'Error: snow1\SWEdate.xml required but does not excist'
              write(*,*)'Error: Program aborted in sub @ 856'
              stop
          endif
      endif
      
      if(iopt.eq.2)print*,'Before event loop start'

!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP START  * * * * * * * * * * * * * * *


      do id=1,ni
     
!         TIMER SETS ALL THE CLOCKS i.e. SUM HOURS, SUM SECONDS, ETC.
!     rev. 10.1.74 Apr.  01/17  - NK: Changed timer to fix 1 day-off problem 
!       This hasd to be moved here so the read_rain, read_temp, read_r2c etc files
!       have a proper initisl clock time        
        time=0.0
        jz=0 
        if(netCDFflg)jz=1         
       
          
!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\      
!\\\\\added by Dave Newson
!      rev. 9.9.72  Jul.  21/15  - NK: Dave Newson additions to sub & process_rain
!       DN addition of forecast mode code
        fcst_mode=.false.
        !print *, '*** looking for fcst_params.txt in . ...'
        inquire(FILE="fcst_params.txt",EXIST=exists)
        !inquire(FILE='fcst_params.txt',EXIST=exists)
        
	  !print *,"cwd=",getcwd()
	  
        IF(exists)THEN
          print *, 'FOUND fcst_params.txt! checking forecast year...'
          open(unit=99,file='fcst_params.txt',iostat=ios)    ! 99 is a scratch file #
!           -- unit number selected randomly (fix!);
!           -- can't figure out filename convention
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  fcst_params.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            stop 'Program aborted in sub.f @ 358'
          endif
          read(99,*)fcst_yr ! read each line and assign to forecast parameter variables
          read(99,*)fcst_hr0
          read(99,*)fcst_days2avg
          read(99,*)fcst_snow_adj
          read(99,*)fcst_rain_adj
          close(unit=99,status='keep')
!         check if this is the current year
          print *, 'forecast year, current year: ', fcst_yr, year1
          if(fcst_yr.eq.year1)then          ! Trish believes 'year1' is the current year; might be 'year' or 'yearnow'?
!                                                look in timer.f
          fcst_mode=.true.
!         DN 2015-02-07 -- these are temporary debug statements
          !print *, 'in sub at 372, forecast parameters:'
          !print *, fcst_yr,fcst_hr0,fcst_snow_adj,fcst_rain_adj
          print *, 'forecast mode enabled?: ', fcst_mode
          end if
        ELSE 
          if(dds_flag.eq.0)then
            print*
            print*, '!WARNING fcst_params.txt not found!'
            print*
          endif
        END IF
!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\      
!\\\\\end Dave Newson addition

    if(debug_output)write(63,*)' In sub, passed location  201'
        julast=0
!     rev. 9.9.49  Jan.  06/14  - NK: Added courantflg
        courantflg=.true.    ! All's well Courant criteria not violated
!       
!       CHECK FOR STOP COMMAND:
        open(unit=99,file='stop.txt',form='formatted',status='unknown',iostat=ios)
        if(ios.ne.0)print*,'Problems opening stop.txt file ignored'
        read(99,99001,iostat=ios)qwert
        if(ios.ne.0)print*,'Problems reading stop.txt file ignored'
        close(unit=99,status='keep')

        if(debug_output)write(63,*)' In sub, passed location  2011'
        if(qwert.gt.0.0)go to 83

!       RESET TO THE ORIGINAL VALUE -  WILL BE CHANGED IF NO DATA
        flgevp2=flgevp22

!     rev. 10.1.79 Apr.  18/17  - NK: Set trcflg=0 for all dds except errflg=10
        if(numa.ne.0.or.dds_flag.ne.0)then
          iopt=0
          trcflg='n'
          ensimflg='n'
          initflg='n'
          modelflg='n'
!         but GW flows are needd to run this dds criteria          
          if(errflg.eq.10)trcflg='y'
        endif

        index=1
!       INDEX = 1 FOR FIRST PASS REROUT ONLY
!       INDEX = 2 FOR SUBSEQUENT PASSES
!       SET   = 1 FOR EACH NEW LINKED EVENT TO READ IN NEXT SET OF 
!              RESERVOIR RELEASES

!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout

        if(debug_output)write(63,*)' In sub, passed location  2012'

!       REV. 8.91 - Dec.  07/98 - READ rdevt IN SUB AS WELL AS SPL 
!       READ THE EVENT FILE - HAS TO BE DONE FOR EACH ID
        if(id.le.1)then
!         event file used to be read here as well but no longer needed
!         it is read in spl9 at the beginning
!         except for optimization when it has to be re-read
!         for each new iteration           apr. 30/08 nk
        else

!     rev. 9.5.48  Dec.  26/08  - NK: added event_fln() to allow unlimited events
          fln(99)=event_fln(id)

!         rdevt WAS CALLED IN SPL9 FOR THE FIRST EVENT
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!          call rdevt(date,conv,scale,smc5,nhr,nhf)
          if(debug_output)write(63,*)'reading event file id > 1'      
          call read_evt(date,conv,scale,smc5,nhr,nhf)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        endif

!       needed of precip fitting: scale is set in options
        if(icase.eq.2)scale=a(1)

        if(numa.eq.0.or.id.eq.1.and.nnn.eq.0)then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call header()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(abs(dds_flag).eq.1)ensimflg='n'

        endif

!     Changed the order: has to be after opening the next event!!
!     Nov. 24/02 nk

!     make sure we don't write the wfo file when optimizing
!     has to be her because flag is read with each new event
        if(ensimflg.eq.'y'.and.wfo_open_flg.eq.'n')then
!         read the wfo_spec file & do allocations
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if(debug_output)write(63,*)'reading wfo_spec file'
          call rd_wfo_spec()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AB:  ENSIM HEADERS
!         WRITE THE HEADER FOR ENSIM FILES:

!         NK - ALLOCATIONS FOR AREA2 arrays
!         rev  9.1.29  Oct.  24/02    - Added q1, qint & drng to wfo file

!         added nj to the arg lst to allocate attname ...nk  30/01/03
          if(llflg.ne.'y')then
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_both_headers('UTM       ',jan)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_both_headers('LATLONG ',jan)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif

          wfo_open_flg='y'

!         NOTE: IF YOU CHANGE WHICH DATA YOU OUTPUT YOU WILL HAVE TO EDIT
!           THE ABOVE SUBROUTINE
!           YOU CAN REPLACE 'UTM' WITH 'LATLONG' WHERE NECESSARY
!         ALSO, MAKE THE ARRAY FOR OUTPUTTING
!          xcount     ! number of columns
!          ycount     ! number of rows
           if(iopt.eq.2)print*,' In sub before initializing outwfo()'
          do j=1,xcount
            do i=1,ycount
              outwfo(j,i)=0.0
            end do
          end do
          do n=1,na
            wfo_sum_p(n)=0.0
          end do
          wfo_seq=0
!         LUN IS THE UNIT NUMBER for the watflood.wfo file
          lun=65
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>....>!
        endif ! if(ensimflg.eq......

!       rev. 9.1.28  Sept. 19/02  - Added shdlfg to replace the bsnm_shd.r2c file
        if(shdflg.eq.'y')then      
!         basin/bsnm.shd
          open(unit=31 ,file=fln(1) ,status='old',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            write(98,*)'Error: Unable to open file',fln(1)(1:40)
            write(98,*)'Error: Possible cause(s):'
            write(98,*)'Error: file in use by another application'
            write(98,*)'Error: or target directory does not exist'
            write(98,*)'Error: or wrong # of events listed in event file'
            write(98,*)'Error: Program aborted in sub.f @ 896'
            stop 'Program aborted in sub.f @ 896 - SEE debug\warnings.txt'
          endif

          if(IsFileTypeR2C(fln(1))) then
    if(debug_output)write(63,*)'reading shd file'      
              call read_shed_ef(31,1) !EnSim compatible r2c file
          else
!             call rdshed()
               print*,'Old format shd files not accepted'
               print*,'Please create EF ????_shd.r2c files & rerun'
               stop 'Program aborted in sub @ 528'
          endif

          write(98,*)'Info:  New watershed file '
          write(98,5102)id,fln(1) 
          write(98,*)'Info:  read in'
          close(unit= 31)

        endif     !  if(shdflg.eq......

!     rev. 9.8.93  Nov.  12/13  - NK: Added the routing initialization with yyyymmdd_fli.r2c
        if(fliflg.eq.'y')then
          flnNum=99
          fln(99)=fln(55)
!         There are 2 flowinit possibilities:
!         One with a resume: the flow_init.r2c file will be in the working directory
!         the other when is it done on the fly as an updating tool with
!                    strfw\yyyymmdd_fli.r2c
!             This is on the fly with the file name from the event file
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_flowinit(flnNum)
!             ~~~~~~~~~~~~~~~~~~~~~
        endif
    if(debug_output)write(63,*)' In sub, passed location  202'

!     rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!     wqual/yymmdd.wqd
        if(sedflg.eq.'y')then
          close(unit=256,status='keep',iostat=ios)
          if(ios.ne.0)then
          print*,'Problem closing unit 256 fln=',fln(26)
          print*
          stop ' program aborted in sub @ 645'
          endif
        endif
    if(debug_output)write(63,*)' In sub, passed location  2026a'

!       REV 7.9  ADDED GRIDDED RADIATION FILE
        if(ver.ge.7.9)then
          if(flgevp2.eq.3.0)then 
    if(debug_output)write(63,*)' In sub, passed location  2044'
          close(unit=49,status='keep')
    if(debug_output)write(63,*)' In sub, passed location  2045'
          close(unit=50,status='keep')
          endif
        endif

!       if(resinflg.eq.'y') close(unit=99,status='keep')

    if(debug_output)write(63,*)' In sub, passed location  203'

!       INPUT FILES

!       unit    32 = fln(2)  - parameter data file .par
!       unit    36 = fln(6)  - flow file .str
!       unit    37 = fln(7)  - reservoir releases file .rel
!       unit    38 = fln(8)  - snow file .snw
!       unit    40 = fln(10) - precip file .met

!       AND OPEN THE FILES FOR THE NEXT ONE:

    if(debug_output)write(63,*)' In sub, passed location  205'

!       rev. 9.1.52  Mar.  11/04  - NK: continuous water quality modelling
!       wqual/yymmdd.wqd
        if(sedflg.eq.'y')then
          open(unit=256,file=fln(40),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(40)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            print*
            print*,'This file is optional - used for nutrient loading'
            print*,'needed only if sedflg=y in yymmdd.evt'
            stop 'Program aborted in sub.f @ 990'
          endif
        endif

!       unit 261 = fln(31) - gridded runoff files for watroute .rff
!       unit 262 = fln(32) - gridded recharge for modflow .rch
!       unit 263 = fln(33) - gridded leakage for watroute

!       rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added 
!       WRITING FILES FOR WATROUTE
        if(modelflg.eq.'l')then
!         route surface  flow & leakage
!         these 2 are added together and then routed
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1011'
          endif
!         open lkage\yyyymmdd_lkg.r2c
          open(unit=263,file=fln(33),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(33)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1021'
          endif
        endif

        if(modelflg.eq.'r')then
!         route surface flow to stream and rchrg thru the lzs
!         leakage is computed using the watflood LZ routing module
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1036'
          endif
!         open rchrg\yyyymmdd_rch.r2c
          open(unit=262,file=fln(32),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(32)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1046'
          endif
        endif

        if(modelflg.eq.'i')then
!         surface flow only to the stream for routing
!         leakage is not included in the routing
!         open runof\yyyymmdd_rff.r2c
          open(unit=261,file=fln(31),status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(31)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1061'
          endif
        endif

!       WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE WATROUTE

!       rev. 9.1.45  Jun.  11/03  - WATROUTE: runoff, recharge and leakage files added 
!       Writing FILES FOR WATROUTE
        if(routeflg.eq.'y'.and.numa.eq.0)then
          mhtot=2   ! <<<<<<<<<<<< just to get the right header - reset later
          author='spl.exe                     '    
          name='Gridded Channel Inflow              '
          coordsys_temp=coordsys1
!         GreenKenue uses LatLong - code below uses LATLONG
          if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
          if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
          zone_temp=zone1
          datum_temp=datum1
          xorigin_temp=xorigin
          yorigin_temp=yorigin
          xcount_temp=xcount
          ycount_temp=ycount
          xdelta_temp=xdelta
          ydelta_temp=ydelta
          attribute_name='channel_inflow                  '
          attribute_units='mm                          ' 
          unit_conversion=1.0
          attribute_type='Runoff                      '  
          source_file_name=fln(10)
          frame_no3=0            ! write the headers               
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(261,31,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          name='Gridded Recharge                '
          attribute_name='recharge                        '
          attribute_units='mm                          ' 
          attribute_type='recharge                        '  
          source_file_name=fln(10)                           
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(262,32,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          name='Gridded Leakage                 '
          attribute_name='leakage                     '
          attribute_units='mm                          ' 
          attribute_type='leakage                         '  
          source_file_name=fln(10)                           
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_r2c(263,33,mhtot,0,frame_no3,0,1)     
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        endif

    if(debug_output)write(63,*)' In sub, passed location  206'

        if(ver.ge.7.9)then
          if(flgevp2.eq.3.0)then
!         RADIATION FILE
          open(unit=49,file=fln(19),status='unknown',iostat=ios)
! unit=50  fln(20)- radiation data point            yyyymmdd_prn.tb0
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(19)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1131'
          endif
          open(unit=50,file=fln(20),status='unknown',iostat=ios)
! unit=50  fln(20)- radiation data point            yyyymmdd_prn.tb0
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',fln(20)(1:40)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1140'
          endif
          endif
        endif

    if(debug_output)write(63,*)' In sub, passed location  207'

!       RESET THE CLOCK:   >>>>>>>>>>>> CHECK THIS OUT
        m=1
        tot1=0.0

    if(debug_output)write(63,*)' In sub, passed location  209'

! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!       FROM THE STREAMFLOW FILE:

!       REV. 7.32   feb.  07/95 - ADDED NOPT TO SELECT OPT FLOW STA 
!       NOPT IS A VECTOR SIZE = # OF STREAMFLOW STATIONS
!       IF = 0 STATION NOT USED FOR OPTIMIZATION
!       IF = 1 STATION USED FOR OPTIMIZATION
!       if = 2 station is used to "correct" flows for that event only
!       if = 3 in 1st event, station nudges in all events

!       rev. 9.1.23  Jul.  23/02  - Added control for nudging in event #1
        if(id.eq.1)then
!         the first event is the master event for settings    
!         if nopt=3
          do l=1,no
            nopt1(l)=nopt(l)
            if(nopt(l).eq.3)nopt(l)=2   ! set to nudge first event
          end do
        else
!         subsequent events are nudged if nopt1(?)=3
          do l=1,no
            if(nopt1(l).eq.3)then
              nopt(l)=2     ! set to nudge following events
            endif
          end do
        endif

    if(debug_output)write(63,*)' In sub, passed location  214'

        if(iopt.eq.99)then
!         THIS OPTION IS TO CHECK ALL INPUT FILES
!          kt=1
!          nl=1
          mhrd=kt
          if(id.le.1)then
          write(*,6300)iopt
          write(98,6300)iopt
          write(*,'(A)',advance='no') 'In sub: hit any key to continue checking files'
          read(*,*)
          endif
        endif

    if(debug_output)write(63,*)' In sub, passed location  722'

!       MHRD CAN BE ENTERED WHEN SAVING THE STR FILE.
!       MHRD DEFAULT VALUE IS THE END OF THE STREAMFLOW DATA.

!*******************
! RAIN (MET FILE)
!*******************
!//////////////////////////////////////////////
!///////////////////////// 
!// Added by Dave
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list

!         changed argument list  nov. 9/06 nk
!         read the header:
		write(63,*)'In sub, passed location  904 before read_rain'
        write(63,*)'If program dies here, check the precip file'

        if(modelflg.eq.'n')then
!       rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
          inquire(FILE=fln(10),EXIST=exists)
          if(.not.exists)then
            write(98,*)'Error: Fatal error'
            write(98,*)'Error: ',fln(10)(1:40),' file not found'
            write(98,*)'Error: Please check the event\event.evt file'
            write(98,*)'Error: for correct keyword and/or file name'
            write(98,*)'Error: Program aborted in sub @ 1185'
            stop 'Program aborted in sub @ 1185 - SEE debug\warnings.txt'
          endif

          
          call find_filetype(10)
          if(filetype.eq.'r2c')then
!         read the header:
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_rain_ef('1',conv,0,jan) !EnSim compatible r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(filetype.eq.'nc ')then
              continue
!             no header to read for the nc file at this point
          else
            write(98,*)'Error: File type for met file =',filetype
            write(98,*)'Error: Old format met files not accepted'
            write(98,*)'Error: Please create EF _met.r2c files & rerun'
            write(98,*)'Error: Forward slashes / in the event files not'
            write(98,*)'Error: accepted on the PC (it`s ok in unix)'
            write(98,*)'Error: Program aborted in sub @ 830'
            stop 'Program aborted in sub @ 830 - SEE debug\warnings.txt'
          endif
        endif
        
!// End Dave addition
!/////////////////////////
!//////////////////////////////////////////////

    if(debug_output)write(63,*)' In sub, passed location  769 - met file header read'

!*******************
! TEMP (TEM FILE)
!*******************

        if(modelflg.eq.'n')then
          
        if(snwflg.eq.'y'.or.vapflg.eq.'y')then    ! added nk Jun. 28/06
!//////////////////////////////////////////////
!///////////////////////// 
!// Added by Dave
    if(debug_output)write(63,*)' In sub, passed location  936'
!         rev. 9.9.35  Oct.  20/14  - NK: Added keyword & file checks
          inquire(FILE=fln(15),EXIST=exists)
          if(.not.exists)then
            write(98,*)'Error: Error: Fatal error <<<<<'
            write(98,*)'Error: ',fln(15)(1:40)
            write(98,*)'Error:   not found'
            write(98,*)'Error: Please check the event\event.evt file'
            write(98,*)'Error:  for correct keyword and/or file name'
!           THE TEMP FILE IS MISSING WHEN IT SHOULD BE THERE -> TERMINATE
            write(98,*)'Error:  This file is optional - used to input gridded temps'
            write(98,*)'Error:  needed if snwflg=y or vapflg=y in yymmdd.evt'
            write(98,*)'Error:  not needed if flgevp2 .le. 1.0'
            write(98,*)'Error:  OR: in config.sys have you set files=100 & buffers=50?'
            write(98,*)'Error: Program aborted in sub @ 1259'
            stop 'Program aborted in sub @ 1259 - SEE debug\warnings.txt'
          endif

          if(IsFileTypeR2C(fln(15)).and..not.FLtype(15)(1:2).eq.'nc')then
            if(debug_output)then
		  	   print*,'In sub, passed location  796 before read_temp'
               print*,'If program dies here, check the tem file'
		    endif 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_temp_ef('1',jan,jz) !EnSim  r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(debug_output)write(63,*)' In sub, passed location  798'
          elseif(.not.FLtype(15)(1:2).eq.'nc')then   !  i.e. nc is ok so go on
!           call rdtemp('1',jan,jz)
            print*,'Old format tem files not accepted'
            print*,'Please create EF _tem.r2c files & rerun'
            print*
            stop 'Program aborted in runof6 @ 857'
          endif
!// End Dave addition
!/////////////////////////
!//////////////////////////////////////////////

!     rev. 9.9.06  Jan.08/14  - NK: Add daily differences to Harfreaves ETHarg.f
          if(flgevp2.eq.4)then
            INQUIRE(FILE=fln(62),EXIST=exists)
            if(exists)then
              dlyflg=.true.
!             read the header of tempr\yyyymmdd_dif.r2c
              if(iopt99)then
                write(63,*)'Reading the header on unit 292 ',fln(62)(1:40)
              endif
!             Note that for FEWS, the daily diff are computed by diff64.exe and 
!             and r2c (not nc) format is used to transfer the data to CHARM
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_r2c(292,62,'1',jz,newDataFlag) !EnSim  r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              if(iopt99)then
                write(63,*)'Back from reading the header ',fln(62)(1:40)
                write(63,*)'SPL will use the daily temperature differences'
                write(63,*)'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                write(63,*)   
              endif           
            else
!     rev. 9.9.36  Nov.  03/14  - NK: Revised error message for daily diff choices
              write(98,*)'Error: flgevp is read having a value of 4'
              write(98,*)'Error: expecting file: ',fln(62)(1:40)
              write(98,*)'Error: but is is not found'
              write(98,*)'Error: Are you using a current evt file?????'
              write(98,*)'Error: If the temp data was not produced by tmp.exe,'
              write(98,*)'Error: the *dif.r2c file was not created.' 
              write(98,*)'Error: Please use diff64.exe to create the *dif.r2c files.'
              write(98,*)'Error: Program aborted in sub @ 1455'
              stop 'Program aborted in sub @ 1455 - SEE debug\warnings.txt'
            endif
          endif
        endif  ! added nk Jun. 28/06
        endif    !modelflg='n'

!       ***********************
!       EVAPORATION (EVP FILE) for lakes
!       ***********************

!C//////////////////////////////////////////////
!C///////////////////////// 
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
    if(debug_output)write(63,*)' In sub, passed location  922'
        inquire(FILE=fln(51),EXIST=exists)  !gridded evaporation used by Vincent & co
        if(exists)then
          rd_evp_flg=.true.
!         if the evp file exists, it will be used for lake evaporation. 
!         there's no way not to use it if it is not there
!         it also means that we can switch during a run

          if(IsFileTypeR2C(fln(51))) then     ! yyyymmdd_evp.r2c
             if(debug_output)then
	    		  print*,'In sub, passed location  929 before read_r2c'
                  print*,'If program dies here, check the evaporation file'
	 	     endif 
!           read the header
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if(debug_output)write(63,*)'reading evaporaton r2c file'     
            call read_r2c(281,51,'1',jz,newDataFlag) !EnSim  r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(id.eq.1)then
              if(.NOT.allocated(evap_convert))then      
              allocate(evap_convert(na),lake_evaporation(na),stat=iAllocate)
              if(iAllocate.ne.0) STOP 'Error with allocation of evap_convert in sub @ 941'
                print*
              endif
!             conversion factor for m evaporation on a grid to m**3
              do n=1,naa
              evap_convert(n)=grid_area(n)*aclass(n,classcount)/1000.0
                end do
              print*,'read header fln='
              print*,fln(51)
              print*,'Time step other than 1hr to be fixed'
              print*

            endif
           
    if(debug_output)write(63,*)' In sub, passed location  1499'
          else
            write(98,*)'Error: Fatal error: r2c file expected'
            write(98,*)'Error: Wrong file type found for file fln(51)'
            write(98,*)'Error: ',fln(51)(1:60)
            write(98,*)'Error: Delete this file if not needed or just junk and try again'
            write(98,*)'Error: Program aborted in sub @ 942'
            stop 'Program aborted in sub @ 942 - SEE debug\warnings.txt'
          endif
        else
          rd_evp_flg=.false.
        endif

!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes

        if(frcflg.eq.'y') then

!         Check for REMIiso input files. If all of the 4 required files are present, use them, otherwise check for other inputs.            
          frc_file_flg='y'
            inquire(FILE=fln(21),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(47),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(48),EXIST=exists)
          if(.not.exists)frc_file_flg='n'
            inquire(FILE=fln(49),EXIST=exists)
          if(.not.exists)frc_file_flg='n'

!         If all REMOiso inputs are present, then skip the next section of code (because frac_file_flg='y' will be written over).         
         if(frc_file_flg.eq.'y') GOTO 1221 
         
!         Check if the time series delta rain input is present.            
          frc_file_flg='c'  
          inquire(FILE=fln(48),EXIST=exists)
          if(.not.exists)then
            frc_file_flg='n'
            if(dds_flag.eq.0)then
              print*,'WARNING:'
              print*,'Looking for :',fln(48)(1:60)
              print*,'but file not found'
              print*,'Program continues without time series dRain data'
            endif
          else
            if(dds_flag.eq.0)then
              print*
              print*,'frc_file_flg =',frc_file_flg
              print*,'Program continues with time series dRain data'
            endif
          endif
          print*

 1221     CONTINUE
          
          if(frc_file_flg.eq.'y')then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(debug_output)write(63,*)'reading humidity file'      
!c          call read_hum(251,21,'1',jan,jz)   ! humidity  removed by TH:
            if(debug_output)write(63,*)'reading gridded snow precip'      
            call read_gsn(277,47,'1',jan,jz)   ! snow_precip
            if(debug_output)write(63,*)'reading REMOiso delta rain'      
            call read_drn(278,48,'1',jan,jz)   ! delta rain
            if(debug_output)write(63,*)'reading REMOiso delta snow'      
            call read_dsn(279,49,'1',jan,jz)   ! delta snow
          
          elseif(frc_file_flg.eq.'c')then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         print*    
         print*,'reading time series delta rain'      
          call read_r2c(278,48,'1',jz,newDataFlag)   ! delta rain
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if(debug_output)write(63,*)'after reading ddrain time=',time

          endif 
          
          !TH: relative humidity from EC data based r2c
          inquire(FILE=fln(21),EXIST=exists)
          if(exists)then
            call read_r2c(251,21,'1',jz,newDataFlag)
            RH_flg=.true.
          else
            RH_flg=.false.
          endif

!         read in isotope parameter file from \basin
          inquire(FILE='basin\isotope.init',EXIST=exists)
          if(exists)then
          open(99,file='basin\isotope.init',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  basin\isotope.init'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 1593'
          endif
          
          read(99,9990)flg2H        ! deutirium flag 1=18O, 2=18O and 2H
          read(99,9990)ninit    ! number of initializations
          read(99,9990)h2oflg    ! classcount for isotope output

          if(.NOT.allocated(deltar))then
!         ALLOCATE ISOTOPE INPUT PARAMETERS
          allocate(isoyear(ninit),deltar(ninit),deltas(ninit),&
          rfoffset(ninit),smoffset(ninit),&
          deltar2H(ninit),deltas2H(ninit),&
          rfoffset2H(ninit),smoffset2H(ninit),stat=iall)
          if(iall.ne.0) STOP 'Error allocating isotope inputs'
          
          
          read(99,9991)delta1                    ! riverwater
          read(99,9991)delta2                    ! soil water
          read(99,9991)delta3                    ! groundwater
          read(99,9991)delta4                    ! snow
          read(99,9992)(isoyear(ii),ii=1,ninit)  ! data year 
          read(99,9993)(deltar(ii),ii=1,ninit)   ! rain
          read(99,9993)(deltas(ii),ii=1,ninit)   ! snow
          read(99,9993)(rfoffset(ii),ii=1,ninit)  ! per mil depletion for refreezing
          read(99,9993)(smoffset(ii),ii=1,ninit)  ! per mil enrichment for snowmelt
          if(flg2H==2)then
           read(99,9991)delta2H1                    ! riverwater 2H
           read(99,9991)delta2H2                    ! soil water 2H
           read(99,9991)delta2H3                    ! groundwater 2H
           read(99,9991)delta2H4                    ! snow 2H
           read(99,9993)(deltar2H(ii),ii=1,ninit)   ! 2H rain
           read(99,9993)(deltas2H(ii),ii=1,ninit)   ! 2H snow
           read(99,9993)(rfoffset2H(ii),ii=1,ninit)  ! 2H per mil depletion for refreezing
           read(99,9993)(smoffset2H(ii),ii=1,ninit)  ! 2H per mil enrichment for snowmelt
           read(99,9990)isoframeflg                 ! This doohickey is to set up the framework calcs: 1: whole basin avg framework, 2: 1 framework per gauge, 3: multiple frameworks, but with gauges aggregated-> read another file

           if(isoframeflg.eq.1)then 
           nisoframe=1
           else if(isoframeflg.eq.3)then
            
            inquire(FILE='basin\isobasin_combine.txt',EXIST=exists)
            if(exists)then
             open(98,file='basin\isobasin_combine.txt',iostat=ios)
             if(ios.ne.0)print*,'Unable to open file  basin\isobasin_combine.txt'
             allocate (isoframecom(no),stat=iall)
             if(iall.ne.0) STOP 'Error allocating isotope frame combine'
             nisoframe=1
             do n=1,no
              read(98,9994)isoframecom(n)
              if(isoframecom(n).gt.nisoframe)nisoframe=isoframecom(n)
             end do
             close(98)
            else
             STOP 'Error reading \basin\isobasin_combine.txt  - create or do not use option 3'
            endif
            
           else 
           nisoframe=no
           end if
           
          end if
          close(99)
          endif

!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
          !TH: NEW ET split pars
          inquire(FILE='basin\ET.par',EXIST=exists)
            if(exists)then
             open(98,file='basin\ET.par',iostat=ios)
             if(ios.ne.0)print*,'Unable to open file  basin\ET.par'
             do ii=1,classcount
              read(98,9995)acg(ii)
              read(98,9995)bcg(ii)
             end do
             close(98)
            else
             do ii=1,classcount
              acg(ii)=0.3
              bcg(ii)=4.
             end do
          end if
          
          else
          STOP  'Error reading \basin\isotope.init - create file & re-run'
          
          endif  !if par exists

!     REV. 10.1.21 Jan.  22/16  - NK: isotope updates
          !TH: if 18O is coming from gridded frc file, 2H should be checked too
           !TH: added 2H flg to allow for 18O runs only with CD gridded data
          if(frc_file_flg.eq.'c'.and.flg2H==2)then
           inquire(FILE=fln(49),EXIST=exists)
              if(.not.exists)then
                  print*,'Error reading time series 2H data. '
                  print*,'Either added gridded 2H, turn off 2H flg, or turn off gridded 18O'
                  print*,'reading time series delta 2H rain'
                  stop 'Error reading time series 2H data.'
              endif
           call read_r2c(279,49,'1',jz,newDataFlag) !TH: I stole the gridded snow file for 2H (hopefully temp)
          endif
        endif

!     rev. 9.1.75  Feb.  08/05  - NK: added rdgsm (gridded soil moisture)
!     rev. 9.2.25  Dec.  13/05  - NK: ENSIM r2c gridded soil moisture 

        if(id.eq.1)then 
          INQUIRE(FILE=fln(37),EXIST=exists)  ! gridded initial soil moisture
          IF(exists)THEN
            if(IsFileTypeR2C(fln(37)))then 
!             unit=267  fln(37)- gridded soil moisture          yyyymmdd_gsm.r2c
!             note: gsm is read again later to overwrite soil_init.r2c
!                 when present
              if(debug_output)then
		    	  write(63,*)'In sub, passed location 1083 before read_gsm'
                  write(63,*)'If program dies here, check the gsm file'
		      endif 
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              if(debug_output)write(63,*)'reading gridded soil moisture'      
              call read_gsm_ef    !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            else
              print*,'Old format gsm files not accepted'
              print*,'Please create EF _gsm.r2c files & rerun'
              print*
              stop 'Program aborted in sub @ 841'
            endif
            if(debug_output)write(63,*)'gridded soil moistures read'
          else
            if(resumflg.ne.'n')then  ! could be y of s
              write(98,*)'Info: resumflg = n - Soil moisture from soil_init.r2c file used'
            else
              print*
              print*,'WARNING:'
              write(98,*)'Error: ',fln(37)(1:50)
              write(98,*)'Error: not found - Please see manual on how to create a gridded soil moisture file'
              write(98,*)'Error: Program aborted in sub @ 1729'
              stop 'Program aborted in sub @ 1729 - SEE debug\warnings.txt'
            endif
            ssmc_firstpass='n'    
            if(.NOT.allocated(ssmc))then      
!             suggested modification by D. Watson  mar 21/06 
              allocate(ssmc(ycount,xcount),stat=iAllocate)
              if(iAllocate.ne.0)then
                  write(98,*)'Error: Error with allocation of ssmc in sub @ 919'
                  STOP 'Error with allocation of ssmc in sub @ 919'
              endif
              if(debug_output)write(63,*)'allocation done in sub',ycount,xcount
              print*
            endif
            if(.NOT.allocated(api))then  
!             suggested modification by D. Watson  mar 21/06 
              allocate(api(na,classcount),stat=iAllocate)
              if(iAllocate.ne.0)then
                  write(98,*)'Error: Error with allocation of api in sub @ 927'
                  STOP 'Error with allocation of api in sub @ 927'
              endif
              if(debug_output)write(63,*)'allocation done in sub',ycount,xcount
              print*
            endif
          endif
        endif

    if(debug_output)write(63,*)' In sub, passed location  934'

!       THIS SIMPLIFIES THE RAINFALL INPUT SO AN ENTIRE RAINFALL 
!       SEQUENCE CAN BE INPUTTED AT ONCE BUT ONLY THE DATA FOR THE 
!       CALIBRATION PERIOD WILL BE USED FOR THE FORECAST.

    if(debug_output)write(63,*)' In sub - gone to read_flow_ef'

           if(IsFileTypeTB0(fln(6))) then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_flow_ef('1',date)  !EnSim compatible tb0 file
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           endif
            
    if(debug_output)write(63,*)' In sub - back from read_flow_ef'
    if(debug_output)write(63,*)'flows read'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     rev. 9.1.59  Jul.  15/04  - NK: split rerout into two parts: rdresv & rerout

    if(debug_output)write(63,*)' In sub - gone to read_resv_ef'

!     rev. 9.5.57  Apr.  13/09  - NK: added ntrlflg for natural lake flows
!     rev. 9.9.40  Nov.  19/14  - NK: Modified the 'a' option for ntrlflg
           if(id.eq.1.and.ntrlflg.eq.'a')then
!             read the rel file - running natural flows
!             For natural flows, read the rel file only once for 1st event
!             then keep the same coefficients throughout the run
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_resv_ef()  !EnSim compatible tb0 file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           elseif(ntrlflg.eq.'a')then
!            in this case we are using the coefficients from event #1           
             continue
           else
!            for ntrlflg y or n in any event file except if ntrlflg = a in event #1  
!            read the release file           
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call read_resv_ef()  !EnSim compatible tb0 file
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif
            if(id.eq.1.and.noresv.ge.1)then
!             no need to do this if there are no reservoirs or lakes

!             fist event - read the rel file no matter what.
!             to run natural flows, make sure all locations have coefficients. 
!             you can rename the rel file resrl\yyyymmdd_ntrl.tb0
!             write an xyz file flow reservoir location plotting in GK
!             Added this here for FEWS  NK Jul.                
              if(iopt99.or.FLtype(6).eq.'nc')then
                open(unit=99,file='debug\reservoir_location.xyz',status='unknown',iostat=ios)
                if(ios.ne.0)then    ! added Nov. 10/14  nk
                  write(98,*)'Error: Unable to open file  reservoir_location.xyz'
                  write(98,*)'Error: Possible cause(s):'
                  write(98,*)'Error: file in use by another application'
                  write(98,*)'Error: Program aborted in sub.f @ 1637'
                  stop 'Program aborted in sub.f @ 1637 - SEE debug\warnings.txt'
                endif
                do i=1,noresv
                  if(b1(i).gt.0.0)then
                    outlet_type='weir       '
                  else
                    outlet_type='regulated   '
                  endif
!     rev. 10.1.87 May   18/17  - NK: Added DA to reservoir_location.xyz
!     rev. 10.2.18 Mar.  12/18  - NK: Fixed array fault in read_resv_ef and sub
                  if(ires(i).le.ycount.and.jres(i).le.xcount.and.ires(i).gt.0.and.jres(i).gt.0)then
                    n=s(ires(i),jres(i))
                    if(n.gt.0)write(99,99002)xres(i),yres(i),i,resname(i),outlet_type,da(n)
                  endif
                end do
                close (unit=99,status='keep')
              endif   ! iopt99
              
              
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!             initialize    
              do l=1,noresv
                b6(l)=100.0     ! changed from 0.0  Dec. 3/14 nk
                b7(l)=100.0
!     rev. 9.9.38  Nov.  12/14  - NK: Added LKdepth to ill file
                LKdepth(l)=1.0  !default value if not assigned in yyyymmdd_ill.pt2
                fpet_lake(l)=-1.0
              end do 
              

!     rev. 9.5.51  Jan.  13/09  - NK: added reading yyyymmdd_ill.pt2 foa all lakes
!     rev. 9.5.59  Jul.  26/09  - NK: added fpet_lake for each lake in ill file
!             read the initial lake elevations for all lakes:
!             read the initial lake levels for all lakes:
!             test if yyyymmdd_ill.pt2 file exists. if yes, read it
!               Initial lake levels
!               read ill.pt2 file               ill   ill   ill   ill   ill   ill   ill
                INQUIRE(FILE=fln(50),EXIST=exists)
!               unit=280  fln(50)- point initial lake conditions  yyyymmdd_ill.pt2
                if(exists)then
!                 read the initial lake level & datum  yyyymmdd_ill.pt2                 
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_pt2(280,50,nrows,ncols)
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  print*
                  if(nrows.ne.noresv)then
                    write(98,*)'Error: Number of initial lake levels does not '
                    write(98,*)'Error: match the number of lakes & reservoirs'
                    write(98,*)'Error: No of reservoirs & lakes =',noresv
                    write(98,*)'Error: No init lake levels =',nrows
                    write(98,*)'Error: program aborted!'
                    if(dds_flag.eq.1)pause 'Pause in sub in sub @ 1347 - please fix'
                    stop 'Aborted in sub @ 1347 -SEE debug\warnings.txt'
                  endif
                  write(53,*)'in sub - init lake levels & datums'
                  write(63,*)'Finished reading ',fln(50)(1:40),nrows,ncols      

!                 Qmin set as a flag to check that qmin & safe_max
!                 are entered in the ill file
                  qmin(1)=-999.0  
                  do l=1,noresv
                    b6(l)=inarray(l,1)           ! init lake level
!     rev. 10.1.95 Sep   11/17  - NK: Fixed LKdepth bug in sub
                    lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned
                    b7(l)=inarray(l,2)           ! datum
                    if(ncols.ge.4)then
                        
                        ! 4 attributes incl. name
!                     default value = 1.0 set above                    
                      LKdepth(l)=inarray(l,3)
                      if(LKdepth(l).lt.b6(l)-b7(l))then
                          print*,'WARNING: Lake Depth',l,' lower than Datum'
                      endif    
!                     LKdepth in the ill file is the initial lake depth below the invert
!                     like the hight of a weir - and is dead storage usually 
!                     But here it is redefined as tha actual depth of water in the lake
!                     and becomes a variable and is used in the evaporation routine
                      LKinvert(l)=b7(l)-inarray(l,3)
                      LKdepth(l)=lake_elv(l,1)-LKinvert(l)

                      write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),'LKdepth=',LKdepth(l),'LKinve=',LKinvert(l)
                    endif  
                    if(ncols.ge.6)then
                      safe_max(l)=inarray(l,4)
                      qmin(l)=inarray(l,5)
                      DecayT(l)=inarray(l,6)
                      write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),&
                          'LKdepth=',LKdepth(l),'LKinvert=',LKinvert(l),&
                            'Qmin=',qmin(l),'safe_max=',safe_max(l),&
                            'DecayT=',DecayT(l)
                    endif
                  end do
                  deallocate(inarray)
!                 NOTE:
!                 initial lake storage & outflows are calculated in flowinit.f below
                  
!                 write a file that has the datum for lakes & reservoirs
!                 so the datum can be plotted
                  if(iopt99)then
                    open(unit=99,file='results\datum.txt',status='unknown',iostat=ios)
                    write(99,99005)0,(b7(l),l=1,noresv)
                    do i=1,ni
                      write(99,99005)i*365,(b7(l),l=1,noresv)  
                    end do
                    close(unit=99,status='keep')
                  endif
                else
                  if(dds_flag.eq.0)then
                    write(53,*)
                    write(53,*)'WARNING'
                    write(53,*)'No initial lake levels file found.'
                    write(53,*)'Looking for file:' 
                    write(53,*)fln(50)(1:40)
                    write(53,*)'Default values for datum & initial level = 0.0'
                    write(98,*)'WARNING'
                    write(98,*)'Warning: No initial lake levels file found.'
                    write(98,*)'Warning: Looking for file:',fln(50)(1:40)
                    write(98,*)'Warning: Default values for datum & initial level = 0.0'
                    if(lakeflg.eq.'y')then 
                      write(98,*)'Error: NOTE: for lake evap model, ill file with'
                      write(98,*)'Error: lake depths are required'
                      write(98,*)'Error: program aborted in sub @ 1714'
                      stop 'program aborted in sub @ 1714 - SEE debug\warnings.txt'
                    endif
                  endif
                endif  ! (exist)

!     rev. 9.7.27  May.  26/11  - NK: Add lake_ice_factor
!     Commented out for MRBM in 2014
!     REV. 10.1.42 Oct   20/16  - NK: Reinstated read_ice_factor.f as default if present
              icefactorfile=.false.   ! change to true if file exists
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_ice_factor()    !!for lakes only!!
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            endif    ! id=1

    if(debug_output)write(63,*)' In sub - back from read_resv_ef'
    if(debug_output)write(63,*)'releases read'

!     rev. 9.8.23  Aug.  03/12  - NK: Added resinid1flg to use resinflg for id=1
          if(resinflg.eq.'y')then
!         call rdresvin() 
          if(IsFileTypeTB0(fln(8))) then
    if(debug_output)write(63,*)' In sub - gone to read_resvin_ef'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_resvin_ef()  !EnSim compatible tb0 file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
!            call rdresvin()   
             print*,'Old format .tin files not accepted'
             print*,'Please create yyyymmdd_rin.tb0 files & rerun'
             stop 'Program aborted in sub @ 979'
          endif
          if(debug_output)write(63,*)' In sub - back from read_resvin_ef'
        if(debug_output)write(63,*)'reservoir inflows read'
          endif        

 
!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.tb0 for diversions
!     rev. 9.8.53  Mar.  20/13  - NK: Add Lake St. Joseph diversion algorithm to REROUT.f
!                                 This added the divertflg to see whether to read the 
!                                 diversion data or generate it.
!         Diversions    Diversions    Diversions    Diversions    Diversions
          diversion=.false.
          if(divertflg.eq.'y')then
            INQUIRE(FILE=fln(52),EXIST=exists)
            if(exists)then
              diversion=.true.
                call read_divert(282,52)
                write(98,*)'Info: Diversion file read:',fln(52)(1:40)
            else
!     rev. 9.9.42  Nov.  26/14  - NK: Added errer check if diversion does not exist 
              write(98,*)'Error: divertflg in the event file = `y`'
              write(98,*)'Error: but',fln(52)(1:40)
              write(98,*)'Error: i.e.  diver\yyyymmdd_div.tb0 is not found'
              write(98,*)'Error: Program aborted in sub @ 1827'
              stop 'Program aborted in sub @ 1827 - SEE debug\warnings.txt'
            endif
          else
           nodivert=0    ! used as a flag in rerout
          endif

!     rev. 9.8.24  Aug.  07/12  - NK: Added reading yyyymmdd_lvl.tb0 for lake levels
          lvlflg=.false.
            if(dds_flag.eq.0)then     !added Feb. 20/14 nk
               
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          
              call read_level(283,53)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     
              
              write(63,*)'Lake levels read:',fln(53)(1:40)
!             open levels output file results\levels.txt
              if(id.eq.1.and.lvlflg)then  
!               open 'results\levels.csv'    !lake level comparison                  
                open(unit=953,file=filename(953),status='unknown',iostat=ios)
                if(ios.ne.0)then    ! added Nov. 10/14  nk
                  print*
                  write(98,*)'Error: Unable to open file',filename(953)(1:40)
                  write(98,*)'Error: Possible cause(s):'
                  write(98,*)'Error: file in use by another application'
                  write(98,*)'Error: or target directory does not exist'
                  write(98,*)'Error: Program aborted in sub.f @ 1792'
                  stop 'Program aborted in sub.f @ 1792- SEE debug\warnings.txt'
                else
                  write(98,*)'Info: Opened file ',filename(953)(1:50)
                endif
              endif
              print*,'~~~~~~~~~~~~~~~~~~~~~~~~'
          endif   ! dds_flag.eq.0

        if(icase.le.-10)then

!         TO RUN A FORECAST SIMULATION (BEYOND REAL TIME DATA)
!         AND USE ALL ENTERED (INCLUDING FORECAST) RAINFALL 
!         THE SOIL MOISTURE COMES FROM THE EVENT FILE, NOT    
!         FROM THE MET FILE.

!         WE HAVE OPTIMIZED SOIL MOISTURE OR SCALED THE RADAR
!         NOW WE WANT TO FORECAST WITH THE RAIN UP TO THE FORECAST
!         TIME.

          mhtot=nl
          nr=min(nr,mhrd)

        elseif(icase.eq.-2)then

!         FOR SCALING THE ENTIRE RAINFALL FIELD BY THE SAME AMOUNT
!         CALIBRATE TO RECORDED FLOWS ONLY UNTIL MHRD
!         SEE ALSO THE CALL TO RAIN BELOW.  

          if(nnn.le.0)write(51,6004)nr,mhrd

!         ACTIVATE THIS IF YOU WANT TO READ IN THE OPT PERIOD 
!         WITH THE STREAMFLOW INPUT MENU

!!!!!!    scale=a(1)
          mhtot=mhrd

        elseif(icase.eq.-1)then

!         FOR SMC FITTING ONLY
!         CALIBRATE TO RECORDED FLOWS ONLY FOR SMC FITTING
!         USES STREAMFLOW AND RAINFALL UNTIL MHRD
!         BUT RUNS SPL FOR THE ENTIRE PERIOD NL

          if(nnn.le.0)write(51,6004)nr,mhrd

!         ACTIVATE THIS IF YOU WANT TO READ IN THE OPT PERIOD 
!         WITH THE STREAMFLOW INPUT MENU

          mhtot=mhrd

        elseif(icase.eq.0)then

!         DO A SINGLE RUN WITH ALL AVAILABLE RAINFALL 
!         TO THE END OF THE RAINFALL RECORD
!         FOR THIS OPTION, THE AP's AT THE GAUGES WILL BE USED
!         IF AVAILABLE, OTHERWISE THE NUMBERS IN THE EVENT FILE
!         ALSO, THE SCALING FACTOR IS SET eq. TO CONV
  
          mhrd=nl
          mhtot=nl

        elseif(icase.gt.0)then

!         OR DO A PARAMETER CALIBRATION ON WHOLE HYDROGRAPH, 
!         WHERE NUMA IS THE NUMBER OF PARAMETERS TO BE OPTIMIZED
!         ALL AVAILABLE RAINFALL WILL BE USED.
!         AND FOR PARAMETER CALIBRATION USE THE SAME FOR ALL
!         ELEMENTS.

          mhtot=nl    

        endif

!       VER. 9.1 - SEDIMENT/NUTRIENT COMPONENT 
!       TO CALL wqread, SEDFLG MUST BE READ IN AS 'Y' IN rdevtA
!       Read water quality data (sediments and nutrients)

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(sedflg.eq.'y')call wqread
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        if(iopt.ge.1)write(51,5002)nr,smc5(1),mo,conv

    if(debug_output)write(63,*)' In sub, passed location  234'
  
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        if(id.eq.1)then

    if(debug_output)write(63,*)'in sub, gone to flowinit'
!         make sure this call is after reading initial lake levels
!         read_pt2(280,50)....      

!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call flowinit()
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

          if(routeflg.eq.'y')then
!           write a new flow_init file only if creating files for watroute  
!           first delete the old file if one exists:      
            inquire(FILE='flow_init.r2c',EXIST=exists)
            if(exists)then
              fln(99)='flow_init.r2c'
              open(99,file=fln(99),status='unknown',iostat=ios)
              close(unit=99,status='delete')
              print*
              print*,'Old ***',fln(99)(1:60),'*** deleted'
            endif
          endif

          if(initflg.eq.'y')then
            author='charm.exe (flowinit)    '
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_flowinit()
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            write(98,*)'Info: flowinit.r2c  written in working directory'
          endif

          if(resumflg.eq.'n'.and.snwflg.eq.'y') then
!           READ THE SNOW COURSE DATA FOR INIT SNOW
!           but not if there is a resume file
!           If swe needs to be read in, set the crseflg='y'
!           read swe in the first event if snwflg = y
!           but it would be overridden by the resume file
!           values if resumflg = y
            if(IsFileTypeR2C(fln(36))) then
              if(debug_output)then
		   	    write(98,*)'Info: In sub, passed location 1430 before read_swe'
                write(98,*)'Info: If program dies here, check the swe file'
		      endif 
              if(debug_output)write(63,*)'reading swe r2c file'      
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_sweinit(266,36)  !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            else
              write(98,*)'Error: Found SWE file ',fln(36)
              write(98,*)'Error: Old format swe files not accepted'
              write(98,*)'Error: Please create EF ????_swe.r2c files & rerun'
              write(98,*)'Error: Program aborted in sub @ 1216'
              stop 'Program aborted in sub @ 1216- SEE debug\warnings.txt'
              if(debug_output)write(63,*)'in sub, passed location 1114'
            endif
            if(debug_output)write(98,*)'swe file read'
            if(debug_output)write(63,*)'in sub, back from read_sweinit'
          else
!           ADDED DEC. 13/98  NK
!           default swe = 0.0 - replaced be rdresume or rdswe 
!           if files are present & read.
            do n=1,naa
              do ii=1,classcount
              snowc(n,ii)=0.0
              end do
            end do
          endif

    if(debug_output)write(63,*)'in sub, passed location 237'
          do n=1,naa
            if(slope(n).gt.0.0)then  
              sump(n)=0.0
              sumrff(n)=0.0
              do ii=1,classcount
                ssumr(n,ii)=0.0
                intev(n,ii)=0.0
                ev(n,ii)=0.0
              end do
            endif
          end do
    if(debug_output)write(63,*)'in sub, passed location 238'

!     rev. 9.2.30  Feb.  07/06  - NK: Added class_distribution.txt to output

          if(.NOT.allocated(areaclass))then     
!            fixed april 1/10 - has to be max # gauges  # grids  nk
            n=max(no,na)
            allocate(areaclass(n,classcount),areasum(n),stat=iAllocate)
            if(iAllocate.ne.0)then
                write(98,*)'Error: Error with allocation of areaclass in sub @ 1351'
                STOP 'Error with allocation of areaclass in sub @ 1351'
            endif
            print*
          endif

!     rev. 9.5.65  Sep.  23/09  - NK: change class frac to whole basin values
          if(numa.eq.0.and..not.netCDFflg)then
            open(unit=99,file='class_distribution.txt',status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file  class_distribution.txt'
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              stop 'Program aborted in sub.f @ 2004'
            endif
            write(51,6016)
            write(51,6017)classcount
            write(99,6017)classcount

            do n=1,na
!             initialize values
              areasum(n)=0.0
              do ii=1,classcount
                areaclass(n,ii)=0.0
              end do
            end do

            do n=1,naa
              if(n.gt.0.and.next(n).gt.0)then        ! ??????????????????????
                areasum(next(n))=areasum(next(n))+areasum(n)+frac(n)
                areasum(n)=areasum(n)+frac(n)
                do ii=1,classcount
                  areaclass(next(n),ii)=areaclass(next(n),ii)+areaclass(n,ii)+frac(n)*aclass(n,ii)
                  areaclass(n,ii)=areaclass(n,ii)+frac(n)*aclass(n,ii)
                end do
              endif
            end do

            do l=1,no
!     rev. 9.5.77  Oct.  26/09  - NK: fixed some inits for out of basin gauges
              if(inbsnflg(l).eq.1)then
                i=(ystr(l)-yorigin)/ydelta+1
                j=(xstr(l)-xorigin)/xdelta+1
                n=s(i,j)
                write(99,6013)xstr(l),ystr(l),l,gage(l),areasum(l),((areaclass(n,ii)/areasum(n)),ii=1,classcount)
                write(51,6014)
              endif
            end do
            close(unit=99,status='keep')
          endif

          if(modelflg.eq.'r'.or.modelflg.eq.'l'.or.modelflg.eq.'i')then
!           skip soilinit for watroute
            continue
          else

!           ~~~~~~~~~~~~~~~~~~~
            call soilinit()
!           ~~~~~~~~~~~~~~~~~~~

            if(initflg.eq.'y')then
!             ~~~~~~~~~~~~~~~~~~~~~
              call write_soilinit()
!             ~~~~~~~~~~~~~~~~~~~~~
            endif

            endif
            
            
            
!     rev. 9.2.05  Jul.  15/05  - NK: reversed order of reading resume file 
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
!         RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME  RESUME              
resume:   if(resumflg.ne.'n')then   !NOTE THE .NE. 
!         .NE. IS USED BECAuSE IT CAN BE OTHER THAN 'n' OR 'y'
!         THIS SECTION IS USED TO READ IN ALL STATE VARIABLES
!         SO PROGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!         IN RUNOF6, SOILINIT.F IS not SKIPPED but over written
!         ~~~~~~~~~~~~~~~~~~~~~~~~

!         NOTE: these 3 calls go together for a resumed run:
!     rev. 9.5.79  Nov.  04/09  - NK: added resumflg='s' for read_soilinit ONLY
         if(resumflg.ne.'s')then
!             these are skipped for the special case when we want to 
!             read the soilinit file (below) but not the flow init and other stuff
!             i.e. we skip this is the resumflg='s'
!             ~~~~~~~~~~~~~~~~~~~~~
              call rdresume()
!             ~~~~~~~~~~~~~~~~~~~~~
              flnNum=99
              fln(99)='flow_init.r2c'
!             There are 2 flowinit possibilities:
!             One with a resume: the flow_init.r2c file will be in the working directory
!             the other when is it done on the fly as an updating tool with
!                       strfw\yyyymmdd_fli.r2c
!             This is with a resume:
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_flowinit(flnNum)
!             ~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!             This data is in the flow_init.r2c file so it's not needed 
!             ~~~~~~~~~~~~~~~~~~~~~
            endif 
!           For resumflg = s, only the soil_init.r2c file will be read 
!           but the lzs and all flow variables will be initialized with 
!           streamflow.
!           Soilinit is read every time we use the resume files
            fln(99)='soil_init.r2c'
            if(debug_output)write(63,*)'reading soil_init.r2c file'     
!           ~~~~~~~~~~~~~~~~~~~~~
            call read_soilinit()
!           ~~~~~~~~~~~~~~~~~~~~~
!           NOTE: if the _gsm.r2c and _swe.r2c files exist, values therein
!           will replace values from the soil_init.r2c file 
            if(resumflg.ne.'s')then           
!             i.e. we skip this if the resumflg='s'
              if(debug_output)write(63,*)'reading gridded soil moisture file'      
!             ~~~~~~~~~~~~~~~~~~~~~
              call read_gsm_ef()
!             ~~~~~~~~~~~~~~~~~~~~~
              if(debug_output)write(63,*)'reading swe r2c file' 
!     rev. 9.9.10  Mar.  20/14  - NK: Update swe anytime a file is found
!             but don't call if the resumflg = 'y' 
!             It will update later if the sweflag = 'u'
              if(.not.resumflg.eq.'y')then     
!               ~~~~~~~~~~~~~~~~~~~~~
                call read_sweinit(266,36)  
!               ~~~~~~~~~~~~~~~~~~~
              endif
            endif
            
!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!           >>>>>resume with updated lake storage
!           No matter what, we need coefficients (safe max etc.) from this file
            fln(99)='lake_level_init.pt2'   ! for resume only - generic name
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_pt2(99,99,nrows,ncols)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(debug_output)print*
            if(debug_output)write(63,*)'Back from read_pt2 to read initial lake levels'
            if(debug_output)print*
            if(nrows.ne.noresv)then
              write(98,*)'Error: Number of initial lake levels does not'
              write(98,*)'Error: match the number of lakes & reservoirs'
              write(98,*)'Error: No of reservoirs & lakes =',noresv
              write(98,*)'Error: No init lake levels =',nrows
              write(98,*)'Error: Program aborted in sub @ 1966 => please fix'
              stop 'Program aborted in sub @ 1966- SEE debug\warnings.txt'
            endif
            write(53,*)'in sub @ 1951 - init lake levels & datums'
            write(98,*)'Info: Finished reading ',fln(99)(1:40)

            
            do l=1,noresv                                                            
               b6(l)=inarray(l,1)           ! init lake level                         
!         rev. 10.1.95 Sep   11/17  - NK: Fixed LKdepth bug in sub                    
               lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned              
               b7(l)=inarray(l,2)           ! datum                                   
               if(ncols.ge.4)then                                                     
                                                                                      
                   ! 4 attributes incl. name                                          
!                default value = 1.0 set above                                        
                 LKdepth(l)=inarray(l,3)                                              
                 if(LKdepth(l).lt.b6(l)-b7(l))then                                    
                     write(53,*)'Warning:  Lake Depth',l,' lower than Datum'                         
                     write(98,*)'Warning:  Lake Depth',l,' lower than Datum'                         
                 endif                                                                
                 LKinvert(l)=b7(l)-inarray(l,3)                                       
                 LKdepth(l)=lake_elv(l,1)-LKinvert(l)                                 
                                                                                      
                 write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),'LKdepth=',LKdepth(l),'LKinve=',LKinvert(l)                   
               endif                                                                  
               if(ncols.ge.6)then                                                     
                 safe_max(l)=inarray(l,4)                                             
                 qmin(l)=inarray(l,5)                                                 
                 DecayT(l)=inarray(l,6)                                               
                 write(53,*)'l=',l,'level=',b6(l),'datum=',b7(l),'LKdepth=',LKdepth(l),&                  
                      'LKinvert=',LKinvert(l),'Qmin=',qmin(l),'safe_max=',safe_max(l),'DecayT=',DecayT(l)                       
                 if(debug_output)write(63,63000)'l=',l,'level=',b6(l),'datum=',b7(l),'LKdepth=',LKdepth(l),&                  
                      'LKinvert=',LKinvert(l),'Qmin=',qmin(l),'safe_max=',safe_max(l),'DecayT=',DecayT(l)    
63000            format(a5,i5,7(a10,f10.3))                 
               endif                                                                  
            end do                                                                  

               
            do l=1,noresv
              LKinvert(l)=b7(l)-inarray(l,3)
              lake_elv(l,1)=inarray(l,1)   ! to make sure it's assigned
!             lake storage must be recalculated 
!             as lake levels could be reset
!             this will overwrite the storaged read from flow_init.r2c

!     rev. 9.9.34  Oct.  17/14  - NK: Added re-compute of lake storage re: new lake levels
	        if(b6(l).ne.0.0.or.b7(l).ne.0.0)then
!               initial lake levels can be lower than the datum	        
                write(53,*)
                write(53,*)'Override flow based initial storage:'
!               store1 & store2 are now total lake storage
 !     rev. 10.2.45 Jan.  21/19  - NK: Fixed bug in reservoir initialization in sub - n was undefined
                i=ires(l)
                j=jres(l)
                n=s(i,j)
                store1(n)=(b6(l)-b7(l))*lake_area(l)+store_dead(l)
                store2(n)=store1(n)
                if(store2(n).ge.0.0)then
                  if(b3(l).eq.0.0)then
                    qo2(n)=b1(l)*(store2(n)-store_dead(l))**b2(l)
                  else
                    store_live=store2(l)-store_dead(l)
                    qo1(n)=store_live*&
                      (b1(l)+store_live*&
                      (b2(l)+store_live*&
                      (b3(l)+store_live*&
                      (b4(l)+b5(l)*store_live))))
                  endif   
                  qo2(n)=qo1(n)
                else
                  qo2(n)=0.0
                endif
              endif
!     end rev. 9.9.34  Oct.  17/14  - NK: Added re-compute of lake storage re: new lake levels
            end do

            write(98,*)'Info: NEW        Rev. 9.9.34        Oct.  17/14'
            write(98,*)'Info: Recalculated lake storage & outflow based'
            write(98,*)'Info: on the file lake_level_init.pt2'
            write(98,*)'Info: in the working directory'
            deallocate(inarray)
          endif    resume
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME                 
!         END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME  END RESUME            


          if(debug_output)write(63,*)'In SUB: initialization completed '
          
!     rev. 9.8.69  Jun   17/13  - NK: Fixed bug in allocating clumnunits in SUB.f
!         moved from below to make it general
          if(allocated(column_type))then
            deallocate(column_type,column_units,stat=iDeallocate)
            if(iDeallocate.ne.0)then
              write(98,*)'Error: Error with deallocation of resv stuff'
              write(98,*)'Error: Program aborted in subf @ 1575'
              stop 'Program aborted in subf @ 2442- SEE debug\warnings.txt'
            endif
          endif
!         allocate for the largest number needed              
          n=max(noresv,2*no)
          allocate(column_type(n),column_units(n),stat=iAllocate)
          if(iAllocate.ne.0)then
              write(98,*)'Error: Allocation Error:  arrays in sub @1558' 
              write(98,*)'Error: Program aborted in sub @ 2450'
              STOP 'Program aborted in sub @ 2450- SEE debug\warnings.txt'
          endif
          
!         Net Basin Supply header for Great Lakes and Mackenzie
          if(noresv.gt.0.and.dds_flag.eq.0)then
!           write the header for the nbs.tb0 file
            if(resname(1).eq.'Superior     '.or.routeflg.eq.'q'     )then
!             create a nbs.tb0 file for 1D
              author='watflood                                '
              if(resname(1).eq.'Superior     ')then
                name='Net_Basin_Supply_GLAKE                  '
              elseif(routeflg.eq.'q')then                                
                name='MRBB_MASTER_INFLOWS                     '
              else
                name='Net_Basin_Supply                        '
              endif
              coordsys_temp=coordsys1
!             GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
              zone_temp=zone1
              datum_temp=datum1
              xorigin_temp=xorigin
              yorigin_temp=yorigin
              author='WATROUTE'

              if(mo1.lt.10.and.day1.lt.10)then
                write(line,77661)year1,mo1,day1
77661           format(i4,'/',i1'/',i1)
              elseif(mo1.lt.10.and.day1.ge.10)then
                write(line,77662)year1,mo1,day1
77662           format(i4,'/',i1'/',i2)
              elseif(mo1.ge.10.and.day1.lt.10)then
                write(line,77663)year1,mo1,day1
77663           format(i4,'/',i2'/',i1)
              else
                write(line,77664)year1,mo1,day1
77664           format(i4,'/',i2'/',i2)
              endif
              startdate=line
              write(line,77665)hour1
77665         format(i2,':00:00')
              starttime=line
              unit_conversion=1.0
!             attribute_name='sum precipitation                       '
              attribute_units='m3/s' 
!              attribute_type='Runoff                                  '  
              source_file_name='last spl run' 
  
              if(allocated(column_type))then
                deallocate(column_type,stat=iDeallocate)
                deallocate(column_units,stat=iDeallocate)
                if(iDeallocate.ne.0)then
                  write(98,*)'Error: Error with deallocation of resv stuff'
                  write(98,*)'Error: Program aborted in sub @ 1575'
                  stop 'Program aborted in subf @ 2506- SEE debug\warnings.txt'
                endif
              endif
!             allocate for the largest number needed              
              n=MAX0(noresv,2*no)
              allocate(column_type(n),stat=iAllocate)
              allocate(column_units(n),stat=iAllocate)
              if(iAllocate.ne.0)then
                  write(98,*)'Error: Error with allocation of resv stuff'
                  write(98,*)'Error: Program aborted in sub @ 2515'
                  stop 'Program aborted in subf @ 1575- SEE debug\warnings.txt'
              endif
              do l=1,n
                column_type(l)='float' 
                column_units(l)='m**3/s'   
              end do
!             write the header for the nbs.tb0 file
!             
!     REV. 10.1.15 Jan.  08/16  - NK: Custom coding for Mackenzie River Basin Hydraulic Model
!             write the header for the mrb_master_inflows.tb0 file
!             the last 20 lakes are not to be writted to this file but 
!             passed through rerout for natural lake routing
!                                   un,fn,nfg,ng,no_signf
!             # of MRBHM nodes = 126
              call write_flow1d_tb0(70,70,nfg,126,-1)
            endif
          endif

        endif    !id.eq.1
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        
!     rev. 9.8.09  Nov.  22/11  - NK: nopt(l)=0 for area_error(l) > 10%

!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!       this section of code needs to stay here because we need to
!       know the no of flow & reservoir locations
!       pre-emption
        if(id.eq.1)then
        
          sum_sq_error=0.0
          dds_error=0.0

          if(.not.allocated(mean_observed))then
            allocate(mean_observed(no+noresvi),pre_sse(no+noresvi),stat=iAllocate)
            if(iAllocate.ne.0) STOP 'Error with allocation in sub @ 1598'
	      allocate(qhyd_sum(no+noresvi),qsyn_sum(no+noresvi),&
                 qhyd_mean(no+noresvi),qsyn_mean(no+noresvi),&
                 qhyd_mean_evt(no+noresvi,ni),&
                 qsyn_mean_evt(no+noresvi,ni),&
                 sum_den(no+noresvi),sum_num(no+noresvi),&
                 num_obs(no+noresvi),&
                 stat=iAllocate)
            if(iAllocate.ne.0)then
                 write(98,*)'Error: Error with allocation of output stuff'
                 write(98,*)'Error: Program aborted in sub@ 2560'
                 STOP 'Program aborted in sub@ 2560- SEE debug\warnings.txt'
            endif
	    endif

!         initialize the sums
          do l=1,no+noresvi
            qhyd_sum(l)=0.0
            qsyn_sum(l)=0.0
            num_obs(l)=0
	      sum_num(l)=0.0
	      sum_den(l)=0.0
	      do i=1,ni
              qhyd_mean_evt(l,i)=0.0
              qsyn_mean_evt(l,i)=0.0
            end do
          end do

          if(dds_flag.eq.1)then
!           open the dds_log.txt file:
            open(unit=30,file=filename(30),status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file',filename(30)(1:40)
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              print*,'or target directory does not exist'
              print*
              pause 'For single run, to continue - hit Enter'
              dds_flag=0
            endif
!           go to the end of the file so new data is appended  
            DO WHILE(.NOT.EOF(30))
              read(30,*,iostat=ios)
            end do
          endif

!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
          if(.not.allocated(sta_weight))then
	      allocate(sta_weight(no+noresvi),mse(no+noresvi),stat=iAllocate)
            if(iAllocate.ne.0) STOP 'Error with allocation of sta_weight in sub @491'   
          endif 

!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
          if(abs(dds_flag).eq.1)then
          inquire(FILE='mean_observed_flows.txt',EXIST=exists)
          if(exists)then
            open(unit=99,file='mean_observed_flows.txt',status='unknown',iostat=ios)
            if(ios.ne.0)then    ! added Nov. 10/14  nk
              print*
              print*,'Unable to open file  mean_observed_flows.txt'
              print*,'Possible cause(s):'
              print*,'file in use by another application'
              pause 'Program will abort with hit enter'
              stop 'Program aborted in sub.f @ 2380'
            endif
            if(debug_output)write(63,*)'reading the mean flows in sub'

!     rev. 9.8.03  Aug.  08/11  - NK: check no of mean observed flows in file are ok
!     rev. 10.1.71 Mar.  14/17  - NK: Revised reading mean_observed_flows in sub 
              i=0
              ios=0
              read(99,*,iostat=ios)
              DO WHILE(.NOT.EOF(99))
                read(99,*,iostat=ios)i,mean_observed(i)
                if(debug_output)write(63,*)i,mean_observed(i)
              end do
              ios=0
              if(iopt.ge.1)then
                print*,'no of entries in mean_observed_flows.txt =',i
                print*
              endif
              if(errflg.eq.1.or.errflg.eq.3.or.errflg.eq.5.or.&
                errflg.eq.6.or.errflg.eq.7.or.errflg.eq.8.or.&
                errflg.eq.100)then

                if(i.ne.no+noresvi)then
                  print*,'no of mean_observed_flows.txt =',i
                  print*,'no of flow & resv inflow statns =',no+noresvi
                  print*,'These numbers must be equal'
                  print*,'Remove file & run splx to get a new file'
                  print*,'It is needed only for DDS'
                  print*,'program paused in sub @ 1830'
                  if(dds_flag.eq.1)pause 'Hit enter to abort splx'
                  stop 'Program aborted in sub @ 1904'
                endif
              endif
            close(unit=99,status='keep')
!     rev. 9.8.03 -- end              

!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            if(i.ne.no+noresvi)then
                print*,'File found but'
                print*,'Problems reading mean_observed_flows.txt'
                print*,'# entries found =',i
                print*,'# entries needed =',no+noresvi
                print*,'for # flow stations =',no
                print*,'and # reservoir inflows =',noresvi
                print*,'Have you changed the number of stations?'
                print*,'Do you have a reservoir or lake inflow file?'
                print*,'Please fix or remove the file'
                print*,'Remove file & run splx to get a new file'
                print*,'It is needed only for DDS'
                stop 'Program aborted in sub @ 1792'
            endif
!     rev. 9.7.08  Sep.  21/10  - NK: revised error weighting for DDS
            if(errflg.eq.1.and.dds_flag.ge.0)then
              print*
              print*,'mean_observed_flows.txt file  found'
              print*,'station mean squared errors will be weighted'
              print*,'with station weights based on'
              Print*,'Weight(i)=sta_MSE(i)/sum(sta_MSE(n))'
	        print*,'where n is the number of stations used for'
	        print*,'calibration'
              print*
	        print*,'Calculating station weights for DDS'
	        print*,'Table in spl.txt'
	        print*
            endif

!     rev. 9.7.08  Sep.  21/10  - NK: revised mean squared error weighting for DDS
            i=0
	        sum_mean_flow=0.0
            do l=1,no
              if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
                sum_mean_flow=sum_mean_flow+mean_observed(l)
	          i=i+1
	        endif
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
            do l=1,noresvi
              if(nopti(l).eq.1.and.mean_observed(no+l).gt.0.0)then
                sum_mean_flow=sum_mean_flow+mean_observed(no+l)
	          i=i+1
	        endif
	      end do

	      write(51,*)
	      write(51,*)'Station weights for DDS error calculation:'
	      do l=1,no
	        if(nopt(l).eq.1.and.mean_observed(l).gt.0.0)then
	          sta_weight(l)=mean_observed(l)/sum_mean_flow
	        else
	          sta_weight(l)=0.0
	        endif
	        if(nopt(l).eq.1)then
	          write(51,*)l,mean_observed(l),sum_mean_flow,sta_weight(l)
	        endif
	        num_obs(l)=0          !initialize number of observations
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
	      do l=1,noresvi
	        if(nopti(l).eq.1.and.mean_observed(no+l).gt.0.0)then
	          sta_weight(no+l)=mean_observed(no+l)/sum_mean_flow
	        else
	          sta_weight(no+l)=0.0
	        endif
	        if(nopti(l).eq.1)then
	          write(51,*)l,mean_observed(no+l),sum_mean_flow,sta_weight(no+l)
	        endif
	        num_obs(no+l)=0          !initialize number of observations
	      end do

          else
            do l=1,no+noresvi
              mean_observed(l)=1.0
            end do

            i=0
	      do l=1,no
	        if(nopt(l).eq.1)then
	          i=i+1
	        endif
	      end do
	      do l=1,no
	        if(nopt(l).eq.1)then
	          sta_weight(l)=1.0/float(i)
	        else
	          sta_weight(l)=0.0
	        endif
	        if(nopt(l).eq.1)then
	          write(51,*)l,mean_observed(l),sum_mean_flow,sta_weight(l)
	        endif
	      end do
!     rev. 9.8.16  Mar.  21/11  - NK: reinstate reservoir inflow error for dds
	      do l=1,noresvi
	        if(nopti(l).eq.1)then
	          i=i+1
	        endif
	      end do
	      do l=1,noresvi
	        if(nopt(no+l).eq.1)then
	          sta_weight(no+l)=1.0/float(i)
	        else
	          sta_weight(no+l)=0.0
	        endif
	        if(nopti(no+l).eq.1)then
	          write(51,*)l,mean_observed(no+l),sum_mean_flow,sta_weight(no+l)
	        endif
	      end do
            print*,'WARNING:'
            print*,'mean_observed_flows.txt file not found'
            print*,'all flagged stations will be equally weighted'
	      print*,'--including stations without any flows if flagged--'
            print*
            if(errflg.eq.1.or.errflg.eq.7.or.errflg.eq.8.or.errflg.eq.100)then
              print*,'For errflg=',errflg,' mean flow file is required'
              print*
            endif
          endif
        endif
        endif  ! dds_flag.eq.1

!       read in new snow course data and replace computed swe
!       moved  April 12/01  nk
!       moved here June 09/06  nk
!       moved here so swe can be read in even if run starts with
!       a resume file. SWE from here overrides the resume file values
!       I.e. to use swe from the swe file, it has to be explicitly 
!       asked for with the crseflg. Just the snwflg is not enough!

        if(crseflg.eq.'y'.and.snwflg.eq.'y')then
!         this is where swe is updated at the start of an new event        
!         in a sequence to update the swe
          if(IsFileTypeR2C(fln(36))) then
            if(debug_output)write(63,*)'reading swe r2c file @ 1905'      
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_sweinit(266,36)    !EnSim compatible r2c file
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
            write(98,*)'Error: Old format swe files not accepted'
            write(98,*)'Error: Please create EF ????_swe.r2c files & rerun'
            write(98,*)'Error: Program aborted in sub @ 1321'
            stop 'Program aborted in sub @ 1321 - SEE debug\warnings.txt'
          endif
          if(debug_output)write(63,*)'swe file read'
        endif
        
        if(resumflg.eq.'y'.and.crseflg.eq.'y')then
          write(98,*)'Warning: WARNING  WARNING    WARNING  WARNING    WARNING  '
          write(98,*)'Warning: Snow course swe used - not swe in the resume file'
          print*
          write(*,*)'Warning: WARNING  WARNING    WARNING  WARNING    WARNING  '
          write(*,*)'Warning: Snow course swe used - not swe in the resume file'
          print*
        endif

!       END OF INITIALIZATION SECTION

! ^^^^^^^^^^^^^^^^^^^^^^^^^



!       WATROUTE START    WATROUTE START  WATROUTE START  WATROUTE START

        if(modelflg.ne.'n')then
          if(id.gt.1)close(unit=261,status='keep')
!         read the header in the runoff file:
          if(debug_output)write(63,*)'reading runoff file'      
          call read_r2c(261,31,'1',jz,newDataFlag)
          if(modelflg.eq.'l')then
          if(id.gt.1)close(unit=263,status='keep')
!           read the header in the leakage (baseflow) file:
          if(debug_output)write(63,*)'reading leakage file'      
            call read_r2c(263,33,'1',jz,newDataFlag)
          elseif(modelflg.eq.'r')then
            if(id.gt.1)close(unit=262,status='keep')
!           read the header in the recharge file:
            if(debug_output)write(63,*)'reading recharge file'      
            call read_r2c(262,32,'1',jz,newDataFlag)
          endif
        endif

!       WATROUTE END   WATROUTE END    WATROUTE END    WATROUTE END 

        if(debug_output)write(63,*)' In sub, passed location  244'

        a66=a6

        if(iopt.eq.99)then
!         THIS OPTION IS TO CHECK ALL INPUT FILES
!         see above for more
          mhtot=kt*2
        endif

!       rev. 9.8.21  Jun.  18/12  - NK: Assed swe observed date & report
!       check & see if there is time series snow course data
!       this subroutine will check if the file yyyymmdd_swe.tb0 exists
!       If it exists, compute swe will be compared with observed values
!       unit number is 951 & filename(951) is used
!     rev. 10.2.63 Sep.  09/19  - NK Fixed check for file exists for fln(54) - swe time series
        call find_filetype(54)  
        inquire(file=fln(54),EXIST=exists)
!       unit=284  fln(54)- swe time series pillows & crs  yyyymmdd_swe.ts5
        if(.not.exists)courseflg=.false.
        if(courseflg)then
          if(filetype(1:3).eq.'tb0')then
            if(debug_output)write(63,*)' Gone to read_swe'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_swe()
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(filetype(1:3).eq.'ts5')then
!     rev. 10.2.51 Apr.  03/19  - NK: New section to read ts5 format file for swe
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call read_ts5(284,54)        !( not an .nc read)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(debug_output)write(63,*)'Finished reading ',fln(54)(1:30)
		    if(id.eq.1)then
			    n_max=xcount_temp
			    nold=xcount_temp
			    nlines=ycount_temp
			    nlines_old=ycount_temp
                nswe=xcount_temp
                if(debug_output) print*,'nswe',nswe
	            allocate(course_obs(nswe,max0(366,nlines)),course_calc(nswe,max0(366,nlines)),indomainflg(nswe),stat=iAllocate)
!               corrected bug above - replaced na by nswe   Nov. 19/14  nk     
                write(98,*)'Warning: course_obs dimensioned for:',max0(366,nlines)
			    if(iAllocate.ne.0)then
                    write(98,*)'Error: Error with allocation of  arrays in sub @ 2878'
                    write(98,*)'Error: Program aborted in sub @ 2879'
                    STOP	'Program aborted in sub @ 2879 - SEE debug\warnings.txt'
                endif
		    else                    !  firstpass
!         check to see memory allocated is adequate      

			    if(nswe.ne.nold)then
				    write(98,*)'Error: No of swe stations has been changed in'
				    write(98,*)'Error: nold=',nold,' n=',n
				    write(98,*)'Error: in file ',fln(99)(1:60)
				    write(98,*)'Error: This is not permitted'
				    write(98,*)'Error: Program aborted in sub @ 2890'
				    stop 'Program aborted in sub @ 2890 - SEE debug\warnings.txt'
			    endif
			    if(nlines.gt.nlines_old)then
				    write(98,*)'Warning: No of data lines have changed in'
				    write(98,*)'Warning: nlines_old=',nlines_old,' nlines=',nlines
				    write(98,*)'Warning: in file ',fln(99)(1:60)
				    n_max=n

!                   the file length is longer than any of the previous events so 
!                   more memory has to be allocated

!                   DEALLOCATION OF ARRAYS FROM AREA10A:
				    deallocate(course_obs,course_calc,stat=iDeallocate)
				    if(iDeallocate.ne.0)then
					    write(98,*)'Error: Error with deallocation ofswe)obs'
					    write(98,*)'Error: Program aborted in sub @ 2906'
					    stop 'Program aborted in sub @ 2906 - SEE debug\warnings.txt'
				    endif

                    write(98,*)'Info: reallocation for more swe locations',nswe

				    allocate(course_obs(nswe,max(366,nlines)),course_calc(nswe,max(366,nlines)),stat=iAllocate)
				    if(iAllocate.ne.0)then
                        write(98,*)'Error: Allocation Error: arrays in sub @ 2915'
                        write(98,*)'Error: Program aborted in sub @ 2914'
                    STOP ' Program aborted in sub @ 2914'
                    endif
                    nlines_old=nlines
                    if(debug_output)write(63,*)'course_obs re-dimensioned for:',max(366,nlines)
			    endif
		    endif                   !  firstpass
		
          if(.not.allocated(xswe))then
              allocate(xswe(nswe),yswe(nswe),gname_swe(nswe),ewg_swe(nswe),sng_swe(nswe),stat=iAllocate)
              if(iAllocate.ne.0)then
                  write(98,*)'Error: Error with allocation of station descripters in read_swe'
                  write(98,*)'Error: Program aborted in read_swe @ 213'
                  STOP 'Program aborted in read_swe @ 213 - SEE debug\warnings.txt'
              endif
          endif
!     rev. 9.1.68  Dec.  19/04  - NK: rewrote read_tbo c/w memory allocation 
!       turn into local coordinates
          do n=1,nswe
            ewg_swe(n)=int((x_temp(n)-xorigin)/xdelta+1.0)
            sng_swe(n)=int((y_temp(n)-yorigin)/ydelta+1.0)
            gname_swe(n)=gname_temp(n)
          end do
          if(debug_output)write(63,*)(ewg_swe(n),n=1,nswe)
          if(debug_output)write(63,*)(sng_swe(n),n=1,nswe)
          if(debug_output)write(63,*)(gname_swe(n),n=1,nswe)
            
          do l=1,xcount_temp
!           convert to local coordinate unit system 
!           and check that the stations are in the watershed
            j=int((x_temp(l)-xorigin)/xdelta)+1
            i=int((y_temp(l)-yorigin)/ydelta)+1
!           find the rank for this data point
            if(i.lt.1.or.i.gt.ycount.or.j.lt.1.or.j.gt.xcount)then
              write(98,*)'Warning: coordinates in yyyymmdd_swe.ts5 are outside watershed grid for location No.',i,j 
              write(98,*)'Warning: No problem if intended'
            else
              if(s(i,j).le.0)then
                write(98,*)'Warning: coordinates in yyyymmdd_swe.ts5 are outside watershedfor location No.',i,j 
                write(98,*)'Warning: No problem if intended'
              endif
            endif
          end do
          do j=1,ycount_temp
            do i=1,xcount_temp
              course_obs(i,j)=inarray(j,i)
            end do
            if(debug_output)write(63,*)(course_obs(i,j),i=1,xcount_temp)
          end do  

!         Write the header in the results\swe.csv file 
          if(id.eq.1)write(951,91101)(gname_swe(n),gname_swe(n),n=1,nswe)
91101   format(<2*nswe>(a9,','))      

!         check to see if stations are in the model domain
          do n=1,nswe
            if(ewg_swe(n).ge.1.and.ewg_swe(n).le.xcount.and.sng_swe(n).ge.1.and.sng_swe(n).le.ycount)then
              if(s(sng_swe(n),ewg_swe(n)).gt.0)then
              indomainflg(n)=.true.
              if(debug_output)write(63,*)n,xswe(n),yswe(n),s(sng_swe(n),ewg_swe(n)),indomainflg(n)
              else
                  indomainflg(n)=.false.
              endif
            else
              indomainflg(n)=.false.
            endif
          end do
!     END rev. 10.2.51 Apr.  03/19  - NK: New section to read ts5 format file for swe
          
          
            open(unit=99,file='debug\swe_location.xyz',status='unknown')
            do l=1,xcount_temp
                write(99,*)x_temp(l),y_temp(l),l,gname_swe(l)
                write(*,*)x_temp(l),y_temp(l),l,gname_swe(l)
            end do
            close(unit=99,status='keep')
            
          else
            if(dds_flag.eq.0)then
              print*,fln(54)(1:60),'not found'
	          write(98,*)'Info: program continues without swe analysis'
            endif
	      courseflg=.false.
          endif
        endif
        
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipla & irrigation withdrawals
        if(debug_output)write(63,*)' Gone to withdraw'
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call withdraw()
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(debug_output)write(63,*)' Back from withdraw'

!     rev. 10.1.11 Dec.  11/15  - NK: Revised ice factor initialization and calculation   
!       re-initialize ice factors Jan 1 each year.
!c        if(jul_day_now.eq.1)then
!c          do n=1,naa
!c            ice_fctr_min(n)=0.5
!c            ice_fctr_max(n)=0.5
!c          end do
!c        end if

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
!         THIS IS THE MAIN TIME LOOP, EXECUTED FOR EACH TIME STEP
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
!       start time loop
!       start time loop
!       start time loop
!       start time loop
!       start time loop

        if(.NOT.allocated(inarray))then    
!         inarray not previously allocated
          allocate(inarray(ycount,xcount),stat=iAllocate)
          if(iAllocate.ne.0)then
              write(98,*)'Error: Error with allocation of inarray in sub @ 3028'
              write(98,*)'Error: Program aborted in sub @ 3028'
            STOP 'Program aborted in sub @ 3028 - SEE debug\warnings.txt'      
          end if
        endif

!        do while(time.le.float(mhtot-1))
!        do while(time.le.float(mhtot))
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!        do while(time.lt.float(mhtot+kt))

!       cant do this when running opt
        if(debug_output)write(63,*)'in sub @ 1553 mhtot set to 24 hours'
        
        
        
        
        
        
!     rev. 10.3.05 Feb.  06/20  = NK added climate data
        if(fln(10)(1:21).eq.'radcl\climate_pcp.r2c')climateFlg=.true.
        if(climateFlg)then
!           skip over the climate data until today                
            call date_and_time(cday,ctime)
            read(cday,1000)cdayYear,cdayMonth,cdayDay
1000        format(i4,i2,i2)
            print*,cdayYear,cdayMonth,cdayDay
            today=julian_day(cdayYear,cdayMonth,cdayDay)
!           Add 10 days of the Regl & Glb forecast            
            startHour=(today+10)*24-24
!            time=startHour
            mhtot=min(mhtot-startHour,2184)  ! shorten the run length to the end of the year
            print*,today,startHour,mhtot
            nl=mhtot
            mhrd=mhtot   ! mhrd would be used below
        else
            startHour=0
        endif

     
        do while(time.lt.float(mhtot)) !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
          time=time+1.000
          totaltime=totaltime+1.0

          if(iopt99)then
            call date_and_time(cday,ctime)
            read(ctime,11111)hhhhh
            read(ctime,11112)mmmmm
            read(ctime,11113)sssss
11111       format(f2.0)
11112       format(2x,f2.0)
11113       format(4x,f6.0)      
          endif

      if(debug_output)write(63,*)' Gone to timer'
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call timer(iz,jz,mz,clock,time,t,thr,dtmin,dtmax,div,m,ju,a66)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(debug_output)write(63,*)'****************************************************************************'
      if(debug_output)write(63,*)'Back from timer'
      if(debug_output)write(63,*)'yy=',year_now,' mm=',month_now,' dd=',day_now,' hh= ',hour_now

!     rev. 10.1.54 Nov.  25/16  - NK: Moved tdum under call timer in sub
      tdum=1000.*step2/t

!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
        if(resetflg)then
          if(jul_day_now.gt.265.and.jul_day_now.lt.275)then !Oct. 1 approx
            do n=1,naa
              sump(n)=0.0
              wfo_cum_p(n)=0.0
              do ii=1,classcount
                intevt(n,ii)=0.0
                evt(n,ii)=0.0
                ssumr(n,ii)=0.0
                sum_sublim(n,ii)=0.0
              end do
            end do
          endif
        endif
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1
        if(resetflg)then
!         reset the cummulative precip to 0 at the beginning of Sept.        
          do n=1,naa
            if(jul_day_now.gt.265.and.jul_day_now.lt.275)wfo_cum_p(n)=0.0
          end do
        endif


        if(iz.lt.jz)then 
!         STATUS LINE:
          if(iopt.lt.99.and.abs(dds_flag).ne.1)then
!           THIS IS TO PREVENT DIV BY 0
            if(mhtot.gt.10)then       ! added Mar. 15/14 NK to prevent div/0
              if(mod(jz,mhtot/10).eq.0.and.mhtot.gt.10)then
                if(icase.le.0)then
                  if(icase.eq.-1.or.icase.eq.-11)then
                    write(6,5001)id,ni,jz,mhtot,nnn,maxn,smc5,optlow
                  elseif(numa.eq.0.and.na.gt.100)then 
                    write(6,5003)id,ni,jz,mhtot,nnn,maxn,scale,optlow
                  endif
                endif
              endif
            endif
          endif
!         FIRST AND SUBSEQUENT PASSES  
!         IF FLGEVP = 'n' IN THE EVENT FILE, FLGEVP2 IS SET TO 0
!         IN SPL
!         DON'T NEED TEMPERATURES FOR EVAP OPTION .LE. 1.0

!     rev. 9.9.10  Mar.  20/14  - NK: Update swe anytime a file is found
!         create a file name for today's snow course
!         use the 'u' for update - this will do the first event also
!         for crseflg = 'y', swe will only be used at the beginning of an event
!         and an error will result if the file is not there.
          if(crseflg.eq.'u')then

          
!           Method 1:  using the snow1\yyyymmdd_swe.r2c  file              
            write(line,77670)year_now,month_now,day_now  
77670       format('snow1\',i4,i2.2,i2.2,'_swe.r2c')
            if(hour_now.eq.12)then
              fln(99)=line
              INQUIRE(FILE=fln(99),EXIST=exists)
              if(exists)then
                write(98,*)'Info: Updating the swe with fln',fln(99)(1:40)
                call read_sweinit(99,99)
                write(98,*)'Info: swe updated with file:',fln(99)(1:50)
              endif
            endif
          endif


          
          
!         Method 2:  using the snow1\yyyymmdd_swe.r2c  file              
!     rev. 10.2.55 June  09/19  - NK Added read_swe_update.f90 for read in swe adjustment factors
!         This will use the XML file           snow1\swe_update.xml
          if(swe_update)then 
!             This order is with the least # checks - but fix so we find hour from sart so there needs to be just one check              
              if(year_now.eq.yy_swe)then
              if(month_now.eq.mm_swe)then
              if(day_now.eq.dd_swe)then
              if(hour_now.eq.hh_swe)then
              if(swe_mult.gt.-998.)then
!                 This keeps the relative amounts wrt. land cover classes                  
                  do n=1,naa
                      do ii=1,classcount
                          snowc(n,ii)=snowc(n,ii)*swe_mult
                      end do
                  end do
                  if(swe_mult.gt.-998..and.swe_add.gt.-998.)then
                      write(98,*)'Warning:'
                      write(98,*)'Both swe mult & add factors > -999'
                      write(98,*)'Mult applied on '
                      write(98,*)year_now,month_now,day_now,hour_now
                      write(98,*)
                  endif
             elseif(swe_add.gt.-998.)then
!                 This does not keep the relative amounts wrt. land cover classes                  
                  do n=1,naa
                      do ii=1,classcount
                          snowc(n,ii)=snowc(n,ii)+swe_add
                          snowc(n,ii)=amax1(0.0,snowc(n,ii))
                      end do
                  end do
              endif
              endif
              endif
              endif
              endif
          endif
          
!         Method 3:  using the snow1\swe.nc  file              
          

          
          
          
          
          
          
          
          
          
          

!     rev. 10.2.62 Sep.  09/19  - NK Added read_sm_update.f90 for read in sm adjustment factors
          if(uzs_update)then 
!             This order is with the least # checks - but fix so we find hour from sart so there needs to be just one check              
              if(day_now.eq.dd_uzs)then            ! check once a day
              if(hour_now.eq.hh_uzs.and.year_now.eq.yy_uzs.and.month_now.eq.mm_uzs)then
              if(uzs_mult.gt.-998.)then
!                  print*,uzs_mult
                  do n=1,naa
                      do ii=1,classcount
!                         set upper limit for uzs adjustment                          
                          uzs(n,ii)=amin1(retn(ii),uzs(n,ii)*uzs_mult)
                      end do
                  end do
                  if(uzs_mult.gt.-998..and.uzs_add.gt.-998.)then
                      write(98,*)'Warning: Both uzs mult & add factors > -999'
                      write(98,*)'Info: Mult applied on ',year_now,month_now,day_now,hour_now
                      write(98,*)
                  endif
             elseif(uzs_add.gt.-998.)then
                  do n=1,naa
                      do ii=1,classcount
!                         set limits for uzs adjustment                          
                          uzs(n,ii)=amin1(retn(ii),uzs(n,ii)+uzs_add)
                          uzs(n,ii)=amax1(0.0,uzs(n,ii))
                      end do
                  end do
                  write(98,*)'Info: UZS addition applied on ',year_now,month_now,day_now,hour_now
              endif
              endif
              endif
          endif

!     rev. 10.2.21 Apr.  14/18  - NK: Added Lake Level update 
          if(ruleflg)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call lake_lvl_update(jz,date,time)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
          
!       WATROUTE START    WATROUTE START  WATROUTE START  WATROUTE START

          if(modelflg.ne.'n')then     ! i.e. modelflg.eq.i or l or r

!           WATROUTE only <<<<<< !!!!!!
!           the headers have been read above.
            newDataFlag=.false.
            call read_r2c(261,31,'0',jz,newDataFlag)
            if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow

      
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              qr(n)=inarray(i,j)*tdum1*frac(n)
              end do
            else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 1406'
            endif
            if(modelflg.eq.'r')then
!             read the recharge and route through the lz
              call read_r2c(262,32,'0',jz,newDataFlag)
              if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow
              do n=1,naa
                i=yyy(n)
                j=xxx(n)
                lzs(n)=lzs(n)+inarray(i,j)
!     rev. 9.4.08  May.  29/07  - NK: changed baseflow argument list
!               call baseflow(n,ibn(n),dlz,sdlz,tdum)
                call baseflow(n,dlz,sdlz,tdum)
                qr(n)=qr(n)+qlz(n)
              end do
              else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 11420'
              endif
            endif
            if(modelflg.eq.'l')then
!             read qlz = groundwater flow (leakage/baseflow)       
              call read_r2c(263,33,'0',jz,newDataFlag)
              if(xcount.eq.xcount_temp.and.ycount.eq.ycount_temp)then
!             vectorize & convert mm to flow
              do n=1,naa
                i=yyy(n)
                j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!               need tdum1 here for hour time step conversion              
                qr(n)=qr(n)+inarray(i,j)*tdum1
              end do
              else
              print*,'runoff grid size does not match the shed grid'
              print*
              stop 'Program aborted in sub @ 1434'
              endif
            endif

!     rev. 9.5.75  Oct.  26/09  - NK: commented "deallocate in sub for watroute reads
!     this deallocate killed the watroute run. Used only for watroute 
!     so we can probably leave it out at theis point as we need to use 
!     inarray to read the files for each following time step.

!       WATROUTE END   WATROUTE END    WATROUTE END    WATROUTE END 

          else         ! modelflg.eq.........

!           DO THE MODELLING!!!!!!!!!

!           REV. 8.90 - Dec.  04/98 - INPUT TO MEMORY FOR OPT RUNS
!           RAIN PUTS PROPER AMOUNT OF PRECIPITATION ON EACH SQUARE, 
!           ONCE, ONLY AT THE BEGINNING OF EACH HOUR
!           AVERP IS THE AVERAGE OF THE PRECIP READ IN AT THE 
!           PRECIP STATIONS.      


!           Add the binary file option here - unit 91
            if(debug_output)write(63,*)' Gone to rain'
!     rev. 9.5.30  May.  26/08  - NK: conv back in read_rain & process_rain arg. list
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
!     rev. 10.3.05 Feb.  06/20  = NK added climate data
            if(climateFlg)then
!               skip over the climate data until today                
                if(fln(10)(1:21).eq.'radcl\climate_pcp.r2c')then 
!                    read(cday,1000)cdayYear,cdayMonth,cdayDay
!                    print*,cdayYear,cdayMonth,cdayDay
                    today=julian_day(cdayYear,cdayMonth,cdayDay)
                    startHour=today*24-24
!                    print*,today,startHour
                    do jzz=1,startHour
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        call read_rain_ef('0',conv,jzz,jan) !EnSim compatible r2c file
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                        print*,'skipping ',jzz,inarray(1,1)
                    end do
                endif
            endif

!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
            if(netCDFflg)then
              do i = 1,ycount
                  do j=1,xcount
                      p(i,j)=0.0
                  end do    
              end do
!              write(666,*)'in sub',jz,jz+5,mod(jz+5,6)
              ! in the netCDF file the precip is given every 6 hours at the end of the time step
              ! For CHARM, we need the precipp at the start of the time step = hour #1
              ! and it is then disaggregated over the next 6 hour time step
!print*,'to read_swe_2D_nc'
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                      call read_swe_2D_nc((jz+5)/6,36,1)     
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              
              if(mod(jz+6,6).eq.0)then
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                  call read_2D_pcp_nc((jz+5)/6,10,1)                ! netCDF
                  call read_2D_pcp_nc((jz+11)/6,10,1)     ! this extra 6 hours off set is to ignore 1st data set
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  
                  
!     rev. 10.3.08 Mar.  06/20  = NK For FEWS, add snow1\swe.nc for swe updating
                  if(debug_output)print*,'FEWS SWE update =',use_swe_update
                  if(use_swe_update)then    ! read by read_swe_update.f90  (above)
                      if(debug_output)print*,'@ ',yy_swe,mm_swe,dd_swe,hh_swe
                      if(debug_output)print*,'@ ',year_now,month_now,day_now,hour_now_fews
                      if(hh_swe.eq.hour_now_fews)then
                          if(dd_swe.eq.day_now)then
                              if(mm_swe.eq.month_now)then
                                  if(yy_swe.eq.year_now)then
                                     if(debug_output)print*,'to read_swe_2D_nc with frame #',(jz+5)/6
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call read_swe_2D_nc((jz+5)/6,36,1)     
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                  endif
                              endif
                          endif
                      endif
                  endif
              endif
              
              
              
!     rev. 10.3.04 Jan.  29/20  = NK added smrflg = "t" for FEWS only      
              if(smrflg.eq.'t')call disaggregate(jz)
              if(debug_output)write(63,*)'hour',jz,' precip(1,1) ',p(1,1)
            else
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_rain_ef('0',conv,jz+startHour,jan) !EnSim compatible r2c file
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif

!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call process_rain(conv,scale)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.7.15  Dec.  14/10  - NK: Create reduced precip & temp files for sub-basins

            if(new_precip_grid_flg)then
            if(xcount.ne.xcount2.or.ycount.ne.ycount2)then
!             create a new name for the met file       
              if(jz.eq.1)then
                write(line,66001)fln(10)(1:6),'new_grid\',fln(10)(7:73)
66001           format(a6,a9,a66)
                read(line,*)fln(12)
!               write the header for the new condensed met file    
                author='watflood                    '
                name='Precipitation                       '
                coordsys_temp=coordsys1
!               GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
                zone_temp=zone1
                datum_temp=datum1
                xorigin_temp=xorigin
                yorigin_temp=yorigin
                xcount_temp=xcount
                ycount_temp=ycount
                xdelta_temp=xdelta
                ydelta_temp=ydelta
                attribute_name='Precipitation                     '
                attribute_units='mm                            ' 
                attribute_type='                              '
                unit_conversion=1.0   
                source_file_name=fln(10)     
                no_frames=mhtot*ni+1
!               write the header for new precipitation file
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call write_r2c(42,12,no_frames,1,0,1,1)   
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              endif
              if(new_precip_flg)then
                dataflg=.false.
                do i=1,ycount
                  do j=1,xcount
                    if(p(i,j).gt.0.0)dataflg=.true.
                  end do
                end do
                if(dataflg)then      
                  write(42,66003)precip_frame_header
66003             format(a60)                
                  do i=1,ycount
                    write(42,66002)(p(i,j),j=1,xcount)
66002               format(9999f6.1)                  
                  end do
                endif
              endif  
            endif
            endif
        
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
            end do

!           adjust the precip
            if(debug_output)write(63,*)' Back from rain, gone to rdtemp'

!            if(flgevp2.ge.2.0.or.snwflg.eq.'y')then
            if(vapflg.eq.'y'.or.snwflg.eq.'y')then
              if(time.le.float(mhtot))then
                  
!     rev. 10.3.05 Feb.  06/20  = NK added climate data
                if(climateFlg)then
!                   skip over the climate data until today                
                    if(fln(15)(1:21).eq.'tempr\climate_tmp.r2c')then 
                        do jzz=1,startHour
!                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            call read_temp_ef('0',jan,jzz) !EnSim compatible r2c file
!                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                            print*,'skipping ',jzz
                        end do
                        climateFlg=.false.
                    endif
                endif
                
                if(netCDFflg)then
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
                  if(mod(jz+5,6).eq.0)then
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                      call read_2D_tmp_nc((jz+5)/6,15,1)    
                      call read_2D_tmp_nc((jz+11)/6,15,1) ! this extra 6 hours off set is to ignore 1st data set   
 !                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  endif
                 else
 !                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_temp_ef('0',jan,jz+startHour)     !EnSim compatible r2c file
  !                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                endif

!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call process_temp(jz)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  if(debug_output)write(63,*)'hour',jz,' tmp(1,1) ',ttemp(1,1)
!                 call process_temp_gcm(jz)
                  if(new_temp_grid_flg)then
                    if(xcount.ne.xcount3.or.ycount.ne.ycount3)then
!                     create a new name for the met file       
                      if(jz.eq.1)then
                        write(line,66001)fln(15)(1:6),'new_grid\',fln(15)(7:73)
66011                   format(a6,a9,a66)
                        read(line,*)fln(9)
!                       write the header for the new condensed met file    
                        author='watflood                    '
                        name='temperature                         '
                        coordsys_temp=coordsys1
!            GreenKenue uses LatLong - code below uses LATLONG
             if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
             if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
                        zone_temp=zone1
                        datum_temp=datum1
                        xorigin_temp=xorigin
                        yorigin_temp=yorigin
                        xcount_temp=xcount
                        ycount_temp=ycount
                        xdelta_temp=xdelta
                        ydelta_temp=ydelta
                        attribute_name='Temperature                    '
                        attribute_units='dC                            ' 
                        attribute_type='                              '
                        unit_conversion=0.0   
                        source_file_name=fln(10)     
                        no_frames=mhtot*ni+1
!                       write the header for new precipitation file
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        call write_r2c(39,9,no_frames,1,0,1,1)   
!                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      endif
                      if(new_temp_flg)then
                        dataflg=.false.
                        do i=1,ycount
                          do j=1,xcount
                            if(ttemp(i,j).gt.-99.0)dataflg=.true.
                          end do
                        end do
                        if(dataflg)then      
                          write(39,66013)temp_frame_header
66013                     format(a60)                
                          do i=1,ycount
                            write(39,66012)(ttemp(i,j),j=1,xcount)
66012                       format(9999f7.1)                  
                          end do
                        endif
                      endif  
                    endif
                  endif
              endif  
            end if

            if(debug_output)write(63,*)' Back from rdtemp'


!     rev. 9.9.06  Jan.  08/14  - NK: Add daily differences to Harfreaves ETHarg.f
            if(dlyflg)then
                deallocate(inarray)     !fix <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                allocate(inarray(ycount,xcount))
!               read the data in tempr\yyyymmdd_dif.r2c
!               it is assumed that this file will have just one grid per day
!               but since it is written at the end of the day, we can not use the 
!               timestamp to 
                newDataFlag=.false.
                if(debug_output)write(63,*)'Gone to read daily diff`s'
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call read_r2c(292,62,'0',jz,newDataFlag) !EnSim  r2c file
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if(debug_output)write(63,*)'Back from reading daily diff`s'
                if(newDataFlag)then
                  do n=1,na
                    i=yyy(n)
                    j=xxx(n)
                    dly_diff(n)=inarray(i,j)
                  end do
                  if(debug_output)write(63,*)'new dly_diff found'
                endif  
            endif

!     rev. 9.5.03  Dec.  09/07  - NK: added reads for precip isotopes
!     rev  9.9.12  Oct.  15/14  - CJD: added in frc_file_flg='c' for time series dPPT inputs.
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H

            if(frcflg.eq.'y')then
            !TH: reading in relative humidity from EC data based r2c
              newDataFlag=.false.
              if(RH_flg.eq..true.)then
               call read_r2c(251,21,'0',jz,newDataFlag)
               if(newDataFlag)then
                do n=1,naa                
                i=yyy(n)
                j=xxx(n)           
                relh(n)=inarray(i,j)/100.
                if(relh(n).gt.0.98)relh(n)=0.98
                end do
               endif
              else
               do n=1,naa
                 relh(n)=(10/1000.)/(((1e-06*tempv(n)**4.-3e-05*&
                       tempv(n)**3.+0.0036*tempv(n)**2.+0.0182*tempv(n)&
                       +0.6607)*1000.)/101325.*0.625)
                  if(relh(n).gt.0.98) relh(n)=0.98  ! upper limit due to wind turbulence
	            if(relh(n).lt.0.30) relh(n)=0.30  ! can't be less than 30%
	         end do
	        endif

              if(frc_file_flg.eq.'y')then

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!              call read_hum(251,21,'0',jan,jz)   ! humidity for REMOiso
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             vectorize 
!              do n=1,naa
!              i=yyy(n)
!              j=xxx(n)
!              spech(n)=inarray(i,j)
!              call process_hum(time,n)
!              end do

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_gsn(277,47,'0',jan,jz)   ! snow_precip for REMIiso
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             vectorize 
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              do ii=1,classcount
                snowf(n,ii)=inarray(i,j)*0.01
              end do
              sum_precip(i,j)=sum_precip(i,j)+inarray(i,j)
              end do
              

!             Check if times series delta rain file exists             
              elseif(frc_file_flg.eq.'c')then
              newDataFlag=.false.
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call read_r2c(278,48,'0',jz,newDataFlag)   ! time series delta rain
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if(debug_output)write(63,*)'back from reading',fln(278)             
!              vectorize 
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
              if(newDataFlag)then
                do n=1,naa                
                i=yyy(n)
                j=xxx(n)           
                dlt_rain(n)=inarray(i,j)
                dlt_snow(n)=inarray(i,j)
                spech(n)=-999.9
  !              relh(n)=0.70 
                
                  do ii=1,classcount
                    snowf(n,ii)=0.0
                  end do
        
                  if(n.eq.nnprint)write(866,*)totaltime,newDataFlag,dlt_rain(n)
                end do
              endif
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
              if(flg2H.eq.2)then
                newDataFlag=.false.
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call read_r2c(279,49,'0',jz,newDataFlag)   ! time series delta rain
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          
!               vectorize 
                if(newDataFlag)then
                  do n=1,naa           
                  i=yyy(n)
                  j=xxx(n)        
                  dlt2H_rain(n)=inarray(i,j)
                  dlt2H_snow(n)=inarray(i,j)
                  spech(n)=-999.9
                  end do
                endif
              endif

!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              deallocate(inarray)
                         
!             if one of the needed files is mising in this event, use the defaults
 !            else  ! use default values from isotope.par

!               do n=1,naa
!               dlt_rain(n)=deltar(1)      ! avg precip @ start of simulation
!               dlt_snow(n)=deltas(1)      ! avg snow conc @ start of simulation
!               spech(n)=-999.9
    !           relh(n)=0.70        ! default value: calculate in craig_gordon.f
!               do ii=1,classcount
!                 snowf(n,ii)=0.0
!               end do
!               end do

             endif  ! frcfileflg
            endif

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(time.le.float(mhtot))then
!              if(flgevp2.eq.3.0)call rdrad(jan)
            endif
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!!!             mon=mo         !changed it back nk may 13/02
!           Changed this line to mon=mo1  AB May 10, 2002 again Aug. 1/02 nk
            mon=mo1
            dtmax=amin1(float(kt)*3600.0,float(itogo)*3600.0)
            
            aintvl=time-clock
            sintvl=aintvl*3600.0

            clock=time    ! used for r/w resume files
            tot2=tot1*conv*scale/float(naa)

!     rev. 9.5.56  Mar.  26/09  - NK: Fix bug with month in yearly events
            mon=mo

           if(debug_output)write(63,*)' Gone to runof6'
          
!     REV. 10.1.16 Jan.  11/16  - NK: Added subroutine ice_factor.f
!     rev. 10.1.44 Dec.  02/15  - NK: Reworked icerivflg & icelakeflg
!           note: strloss is set to zero in rinof6 when ice_fctr < 0
!           note: icerivflg = n for watroute
!           note: ice_factor is called if icerivflg and/or icelakeflg = y
            if(iceflg.eq.'y'.and.mod(int(time),24).eq.0)then
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call ice_factor 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif

            if(iopt99)then
              call date_and_time(cday,ctime)
              read(ctime,11111)hhhhh
              read(ctime,11112)mmmmm
              read(ctime,11113)sssss
              now=hhhhh*3600.0+mmmmm*60.0+sssss
              input=input+now-last
              last=hhhhh*3600.0+mmmmm*60.0+sssss
            endif
          
!           RUNOF5 CALC'S RUNOFF FOR EACH HOUR (OR LARGER INTERVALS)
!           fixed the time step 3600.0 sec & 1.0 min rather than 
!           basin it on aintvl & sintvl which ends up with -ve 
!           values at new events which creates problems with ak & akfs.      
!     rev. 10.1.75 Apr.  03/17  - NK: Fixed time & thr in runof6 arg list
            if(debug_output)write(63,*)'Gone to runof6'
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call runof6(jan,time,3600.0,1.0,mon,e1,mz,ju)
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if(debug_output)write(63,*)' Back from runof6'

            if(iopt99)then 
              call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  runoff=runoff+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
            endif

!           Used for Great Lakes model only
!           For future lake evap model 
!           This calculates strloss - replaces strloss from runof6

            if(noresv.gt.0)then
              if(resname(1)(1:8).eq.'Superior'.and.rd_evp_flg)then
!     rev. 9.5.12  Feb.  13/08  - NK: added evaporation input file with read_r2c
!               this data will be used in lake_evap.f

!                 read the lake evaporation from GEM output in r2c format
                  if(debug_output)write(63,*)'reading the lake evap file @ 2396'
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  call read_r2c(281,51,'0',jz,newDataFlag) !EnSim  r2c file
!                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  if(debug_output)write(63,*)'Back from reading the lake evap file @ 2396'
                  do n=1,naa
!     rev. 9.5.50  Jan.  05/09  - NK: read evap data for reaches only
                    if(ireach(n).gt.0)then
                      i=yyy(n)
                      j=xxx(n)
!                     inarray is evaporation in mm for the data timestep
!     replace /t by /data_time_step <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!     this replaces the strloss calculated by runof6
                      strloss(n)=inarray(i,j)*evap_convert(n)/3600.    !splx
                      sum_et(n,classcount)=sum_et(n,classcount)+inarray(i,j) 
                    endif
                  end do
              endif
            endif    !(noresv.gt.0)
            
!     rev. 10.1.83 May   09/17  - NK: Fixed lake evap bug - moved it outside lake-only loop
!     Bug created 10.1.45 Aug. 2016
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call lake_evap
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!           This is THE place to do this addition so runof6 and 
!           route and rerout can be common for the seperate programs. 
!           This way precip & loss is included in the gridflow.r2c file

!           But for wetland routing, it is taken off again in route
!           because qr is the inflow to the wetland!!

!     rev. 9.5.07  Feb.  05/08  - NK: fixed double counting of strloss & qstream

            if(debug_output)write(63,*)' Back from lake_evap'
 
            if(sedflg.eq.'y')then
!             send to sediment calculations >>>>>>>>>
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call wqsed(jan,aintvl)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             send to nutrient calculations >>>>>>>>>
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call wqnut
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            endif
!           REV. 8.82 - July 10/98 - ADDED RUNOFF OUTPUT OPTION: 
!           rev. 9.1.45  Jun.  11/03  - runoff, recharge and leakage files added 

!           ROUTEFLG
!           write the output for WATROUTE:
            if(routeflg.eq.'y'.and.numa.eq.0)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!              call write_flux(jz,dtmin,ju,tdum)
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     rev. 9.3.02  Jul.  18/06  - NK: converted runof, rchrg & lkage to r2c
!            runoff in mm per hour (does not include ground water)
             do i=1,ycount
               do j=1,xcount
                 outarray(i,j)=0.0
               end do
             end do
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              outarray(i,j)=(qr(n)+qstream(n)-strloss(n)-qlz(n))/tdum1   
!     rev. 9.5.07  Feb.  05/08  - NK: fixed double counting of strloss & qstream
!             qstream(n) & strloss are not added in runof6 so it's done here
!             and in route
             end do   
             frame_no3=frame_no3+1
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call write_r2c(261,31,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!            recharge in mm
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
               outarray(i,j)=rechrg(n)
             end do   
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call write_r2c(262,32,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!            leakage in mm/hr
             do n=1,naa
              i=yyy(n)
              j=xxx(n)
!     rev. 10.1.58 Dec.  06/16  - NK: corrected tdum > tdum1 for modelflg=i
!             need tdum1 here for hour time step conversion              
              outarray(i,j)=qlz(n)/tdum1
             end do     
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             call write_r2c(263,33,mhtot,0,frame_no3,0,3)    
!            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            elseif(routeflg.eq.'m')then
!             write output for MODFLOW:  added May, 2000 NK
!             recharge is accumulated over 24 hour in this case
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_modflow(ju,juold,jz)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif    !  if(routeflg......

            if(debug_output)write(63,*)'Back from writing files for watroute'
            juold=ju
            jan=2
!           JAN HAS TO STAY HERE BECAUSE ROUTE MAY BE CALLED MORE
!           THAN FOR EACH TIME RUNOF5 IS CALLED - SO WE CAN'T USE 
!           JAN IN ROUTE.

          endif     !  modelflg.eq......       
          endif       ! CALL RUNOFF ONLY IN NEW HOUR 

!         ROUTE ROUTES WATER THROUGH EACH SQUARE USING STORAGE ROUTING
!         RESET QDWPR=0 INCASE THIS IS SECOND DT DURING FLOW INCREMENT

!         >>>>>>>IS THIS LOOK OK?? CHANGED 6 TO NORESVO   
 
!     rev. 9.5.52  Jan.  20/09  - NK: added reading yyyymmdd_div.pt2 for diversions
!         Diversions    Diversions    Diversions    Diversions    Diversions
!     rev. 9.7.17  Jan.  05/11  - NK: Fixed diversions outside sub-basin
!     rev. 9.7.22. Mar.  07/11  - NK: Changed diversion code: give/route take/rerout
!     rev. 9.9.41  Nov.  20/14  - NK: Added check if diversion = in-basin 
          
          if(diversion)then
            do nd=1,nodivert
              if(divert_inbasin_flg(nd))then
                qr(gridtake(nd))=qr(gridtake(nd))-qdivert(nd,jz)
                qr(gridgive(nd))=qr(gridgive(nd))+qdivert(nd,jz)
              endif 
            end do
          endif
          
          if(irdt.le.kt)then
!           old way of doing things
            if(nastart.eq.1)then
!     rev. 9.3.11  Feb.  17/07  - NK: force hourly time steps for runoff
!     rev. 9.3.12  Feb.  20/07  - NK: changed dtmin & call to route
              no_dt=max(int(3599./dtmin)+1,1)
              route_dt=3600.0/float(no_dt)
              sec_div=route_dt/2.0
              hr_div=sec_div/3600.
!             write(55,*)dtmin,ndt,rdt,sec_dt,hr_dt
!             The value of dtmin has been used to determine how many
!             times route is called. Route will determine a new dtmin
!             for the next time step.
              dtmin=3600.0
              time2=time  ! so time incrementing doesn't get affected

              do n=1,no_dt

!     TS: added time update since routing timestep is less than increment of +1.00: Jan 4/08
                if(n.gt.1)time2=time+route_dt/3600.*float(n-1)


              if(iopt99)then
                  call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  input=input+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
              endif
      
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                call route(sec_div,hr_div,dtmin,jz,iz,time2,date,tdum)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

              if(iopt99)then
                  call date_and_time(cday,ctime)
                  read(ctime,11111)hhhhh
                  read(ctime,11112)mmmmm
                  read(ctime,11113)sssss
                  now=hhhhh*3600.0+mmmmm*60.0+sssss
                  router=router+now-last
                  last=hhhhh*3600.0+mmmmm*60.0+sssss
               endif

!         rev. 9.1.47  Oct   30/03    - Tracer module parameter list changed
                if(numa.eq.0)then
!                 tracer turned off for optimization
                  if(trcflg.eq.'y')then
                    if(n.eq.no_dt)then
                      if(debug_output)write(63,*)'gone to tracer    (1)'                  
!                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call tracer(iz,-iz,time2,route_dt,jan,tdum,1)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      if(debug_output)write(63,*)'back from tracer  (1)'                  
                    else
                      if(debug_output)write(63,*)'gone to tracer    (2)'                   
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call tracer(iz,iz,time2,route_dt,jan,tdum,0)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      if(debug_output)write(63,*)'back from tracer  (2)'                  
                    endif
                  endif
!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
                  if(frcflg.eq.'y')then
                   if(n.eq.no_dt)then
!                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     call isotopes(iz,jz,time2,route_dt,1)
!                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   else
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call isotopes(iz,jz,time2,route_dt,0)
!                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   endif
!     end rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
                  endif
                endif
                if(debug_output)write(63,*)' Back from tracer'
              end do
!             This little ditty is here if we want routing dt's
!             longer than 1 hr. This may be needed for very large grids.
!             do ijk=1,2
!!              call route(div,thr,dtmin,jz,iz,time,date)
!               call route(1800.,.5,dtmin,jz,iz,time,date)
!               dtmin=3600.
!             end do
            endif 
          else
!           rev. 9.1.38  Mar.  31/03    - revised str header and routing dt selectable
!           For longer time steps, route is called at the desired intervals. 
!           This was done just for the DMIP paper    
            if(mod(jz,irdt).eq.0)then
              if(nastart.eq.1)then
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call route(rdt*1800.0,thr,dtmin,jz,iz,time,date,tdum)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
              endif 
            endif
          endif
          if(debug_output)write(63,*)' Back from route'
    
!         REV. 9.1 - SEDIMENT COMPONENT
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(sedflg.eq.'y')call wqroute(t)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

          if(debug_output)write(63,*)' Gone to tracer'

!         rev. 9.1.47  Oct   30/03    - Tracer module parameter list changed
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!          if(trcflg.eq.'y')call tracer(iz,jz,time,t,jan,tdum)
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           if(debug_output)write(63,*)' Back from tracer'

!         INTERPOLATE TO GET FLOWS AT reporting TIMES:
          if(irdt.le.kt)then
!         old way of doing things
          if(nastart.eq.1)then
            if(iz.lt.jz.and.jz.ge.1)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call synflw(time,thr)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif      
          endif 
          else
!         rev. 9.1.38  Mar.  31/03  - revised str header and routing dt selectable
          if(mod(jz,irdt).eq.0)then
            if(nastart.eq.1)then
              if(iz.lt.jz.and.jz.ge.1)then
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call synflw(time,thr)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              endif        
            endif 
          endif
          endif

!         print*,' ireport=',ireport,iz,jz,mod(jz,ireport)

          if(debug_output)write(63,*)' Back from synflw'

          if(jz.ne.iz.and.mod(jz,deltat_report).eq.0)then
!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
 
          if(id.lt.ni)then
!           n_trick=mhtot+100  
            n_trick=mhtot*ni+1 ! tricks write_r2c into NOT closing the file
          else
            n_trick=mhtot
          endif
          
!     rev. 10.2.52 Apr.  15/19  - NK: Added total UZS for reporting in FEWS
          if(netCDFflg)then
            do n=1,naa
              totd1(n)=0.0
              totuzs(n)=0.0
              do ii=1,classcount-3
                  if(aclass(n,ii).gt.0.0)then
                     totuzs(n)=totuzs(n)+(uzs(n,ii)/retn(ii))*aclass(n,ii)*(1.0-sca(n,ii))&
                                     +(uzsfs(n,ii)/retn(ii))*aclass(n,ii)*sca(n,ii)
                  endif
              end do
            end do
          endif
          
!     rev. 9.5.31  May.  27/08  - NK: moved totsnw(n) computation in sub
!     rev. 10.3.07 Mar.  04/20  = NK Fixed weighted swe in wfo file for grids with water
!     Note:  this is also done for updating swe above  -  this stays here for reporting in wfo file
          if(numa.eq.0.and.ensimflg.eq.'y'.or.netCDFflg)then
            do n=1,naa
              totsnw(n)=0.0
              class_sum=0.0
              do ii=1,classcount
                if(aclass(n,ii).gt.0.0)then
                  if(ii.ne.ii_water)then
                      class_sum=class_sum+aclass(n,ii)
                      totsnw(n)=totsnw(n)+snowc(n,ii)*aclass(n,ii)*sca(n,ii)
                  endif
                endif
              end do
              totsnw(n)=totsnw(n)/class_sum
            end do     
          endif

!     rev. 9.5.80  Dec.  20/09  - NK: added swe_locations.txt file for swe input
!     write swe at designated snow courses
!     DDS_flag added April 4, 2010  nk
      if(.not.netCDFflg)then
      if(id.eq.1.and.no_swe_l.eq.0.and.dds_flag.ne.1)then
        inquire(FILE='basin\swe_locations.txt',EXIST=exists)
        if(exists)then
          open(99,file='basin\swe_locations.txt',status='unknown',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file  basin\swe_locations.txt'
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in sub.f @ 3594'
          endif
          read(99,*)no_swe_l
          read(99,*)(swe_l(i),i=1,no_swe_l)
          close(unit=99,status='keep')
          write(*,64000)
          write(*,64001)no_swe_l
          write(*,64001)(swe_l(i),i=1,no_swe_l)
          if(writeflg(64))write(64,64002)(swe_l(i),i=1,no_swe_l)
          if(ensimflg.ne.'y')then
            print*,'ensimflg=',ensimflg
            print*,'ensimflg needs to be `y` or `a` to get output for'
            print*,'swe at snow courses when specified in'
            print*,'basin\swe_locations.txt'
            print*
            print*,'If DDS_flag = 1, ensimflg is set to n'
            print*
          endif
          print*
        endif
      endif
          
      if(ensimflg.eq.'y')then
        if(ju.eq.60.or.ju.eq.91.or.ju.eq.121.and.no_swe_l.ge.0)then
          if(writeflg(64))write(64,64000)year_now,ju,(totsnw(swe_l(i)),i=1,no_swe_l)
64000     format(2i5,99f10.2)
64001     format(99i5)
64002     format(99i10)
        endif
      endif
      endif   !netCDFflg

!     rev. 9.5.22  Mar.  12/08  - NK: added grdflg to print gridded flow, swe & evap
          if(grdflg.eq.'y')then
!     rev. 9.9.21  Jul.  27/14  - NK: Added allocation for outarray in sub
            if(allocated(outarray))deallocate(outarray)
            allocate(outarray(ycount,xcount),stat=iAllocate)
            if(iAllocate.ne.0)then
              print*,'Error with allocation of outarray in sub @ 594'
              STOP 'Program aborted in sub @ 595'
            endif
            do i=1,ycount
              do j=1,xcount
                outarray(i,j)=0.0
              end do
            end do
            xcount_temp=xcount
            ycount_temp=ycount

            if(iopt99)then
            if(numa.eq.0.and.ensimflg.eq.'y')then
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=qo2(n)
              end do     
!             unit=72  fln(72)=gridflow.r2c  - gridded flow - r2c file
              frame_no2=frame_no2+1
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_r2c(72,72,mhtot+8784,0,frame_no2,0,8)  
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!             use 8784 as the total # of frames so the file only closes when the run is done.
            endif

!           this added for Vincent Fortin:
            if(numa.eq.0.and.ensimflg.eq.'y')then
              do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=totsnw(n)
              end do     
              frame_no4=frame_no4+1
!             unit=61  fln(61)
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              call write_r2c(61,61,mhtot+8784,1,frame_no4,0,0)  
!             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif

!     rev. 9.5.09  Feb.  12/08  - NK: added evap.r2c to the output files
!           this added for Vincent Fortin:
            if(numa.eq.0.and.ensimflg.eq.'y')then
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
              outarray(i,j)=eloss(n)
            end do     
            frame_no5=frame_no5+1
!           unit=100  fln(100)=evap.r2c  - gridded evap - r2c file
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!     rev. 9.9.60  Mar.  06/15  - NK: In sub: fixed call write_r2c for close condition 
!           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_r2c(100,100,int(totaltime),0,frame_no5,0,8)  
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            endif
            endif    ! iopt99
          endif   !  if(grdflg.eq.'y'
          
          if(iopt99)then
          if(frcflg.eq.'y'.and.numa.eq.0)then 
            if(allocated(outarray))deallocate(outarray)
            allocate(outarray(ycount,xcount),stat=iAllocate)
            if(iAllocate.ne.0)then
              print*,'Error with allocation of outarray in sub @ 594'
              STOP 'Program aborted in sub @ 595'
            endif
            if(debug_output)write(63,*)'outarray allocated for '
            if(debug_output)write(63,*)ycount,' rows'
            if(debug_output)write(63,*)xcount,' cols'
            do n=1,naa
              i=yyy(n)
              j=xxx(n)
              l=nbasin(i,j)
              if(l.ne.0)then
                outarray(i,j)=dSTRconc2(n) !isoSTRconc2(n,l)
              else 
                outarray(i,j)=0.0
              endif
            end do     
            ycount_temp=ycount
            xcount_temp=xcount
            frame_no6=frame_no6+1
!          unit=72  fln(72)- gridded flow - r2c file
!     rev. 9.9.60  Mar.  06/15  - NK: In sub: fixed call write_r2c for close condition 
!           changed mhtot+8784 to totaltime to make it work for monthly events
!           longer than one year
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            call write_r2c(200,200,8784000,0,frame_no6,0,8)  
!          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          endif
          endif   !iopt99

          endif   !  if(jz.ne.iz.and.mod(jz,deltat_report).eq.0

          if(ensimflg.eq.'y'.and.jz.ne.iz)then
              if(ireport.ge.1.and.wfo_open_flg.eq.'y')then
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 
                  if(int(totaltime).gt.ireport_start.and.int(totaltime).le.ireport_end)then
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      call write_wfo(t,jz,iz)
!                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  endif
              endif
          endif

 
          do n=1,naa
!           SELECT THE MAXIMUM FLOW FOR EACH GRID DURING THE EVENT 
            qmax(n)=amax1(qmax(n),qo2(n))    
!           FIND THE MINIMUM SNOWC FOR ERROR MSG (to check for unwanted glacier like activity)
            do ii=1,classcount
              snowcmin(n,ii)=amin1(snowc(n,ii),snowcmin(n,ii))
            end do
          end do
   82     m=m+1
 
 
!     rev. 9.8.21  Jun.  18/12  - NK: Added swe observed date & report
!         extract the computed swe at snow course locations
          if(mod(jz,24).eq.0)then
            do i=1,nswe
              if(indomainflg(i))then
                n=s(sng_swe(i),ewg_swe(i))
                sum_swe=0.0
                class_sum=0.0
                do ii=1,classcount
!                 we have to not include the water class as it has 0 swe
                  if(ii.ne.ii_water)then
                    class_sum=class_sum+aclass(n,ii)
                    sum_swe=sum_swe+snowc(n,ii)*aclass(n,ii)*sca(n,ii)
                  endif
                end do
                course_calc(i,jz/24)=sum_swe/class_sum
              else
                course_calc(i,jz/24)=-1.0            
              endif
              end do
          endif


 
!      May 1/11  NK 
!      save this little ditty. Used to create WSC file format for 
!      missing flows at any station
!c          if(mod(jz,24).eq.0)then
!c            if(qhyd(68,jz).lt.0.0)then
!c              write(900,828)
!c     *         '05PF999',year1,month_now,day_now,qsyn(68,jz)
!c            else
!c              write(900,829)
!c     *         '02PF999',year1,month_now,day_now,qhyd(68,jz)
!c            endif
!c          endif
!c828       format(a7,',1,',i4,',',i2,',',i2,',',f10.3,',c,')     
!c829       format(a7,',1,',i4,',',i2,',',i2,',',f10.3,',o,')     

        if(iopt99)then
          call date_and_time(cday,ctime)
          read(ctime,11111)hhhhh
          read(ctime,11112)mmmmm
          read(ctime,11113)sssss
          now=hhhhh*3600.0+mmmmm*60.0+sssss
          output=output+now-last
          last=hhhhh*3600.0+mmmmm*60.0+sssss
        endif
          
!     rev. 10.1.78 Apr.  17/17  - NK: New s/r dds_UZS to calculate low flow penalty
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          if(dds_flag.gt.0)then
              if(errflg.eq.10.and.id.gt.idskip)then
                  call dds_uzs(score)
              endif
          endif
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          
!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!         write the CHARM_output.nc file for one time step
!         Assume this file is wanted if one of str, met or tem file is .nc       
!         Common 6 hr output time step - see Ben's e-mail Apr. 8/19      
!         Note: for netCDF (FEWS) applications, we use 6 hour time steps 
!               so qsum is set = 0 for that application          
!               For other uses, flow is summed for the whole run so we can
!               calculate runoff in mm for the whole upstream area at every grid.
!               This can help find discontinuities.
          do n=1,naa
                i=yyy(n)
                j=xxx(n)
                QQsum(n)=QQsum(n)+qo2(n)
                QRsum(n)=QRsum(n)+qr(n)
          end do  
          if(netCDFflg)then
!             calculate the mean flow for the time step              
              deltat=6
              if(mod(int(totaltime),6).eq.0)then
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=QQsum(n)/float(deltat)
                  QQsum(n)=0.0
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call write_2D_flow(int(totaltime/deltat),mhtot/deltat,201)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=totsnw(n)
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call write_2D_swe(int(totaltime/deltat),mhtot/deltat,202)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=totuzs(n)
                end do     
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call write_2D_uzs(int(totaltime/deltat),mhtot/deltat,203)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
!     rev. 10.2.56 June  13/19  - NK Added .nc output for grid_runoff & cumm ET
                do n=1,naa                  ! added June 13/19 NK
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=QRsum(n)/float(deltat)
                  QRsum(n)=0.0
                end do   
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call write_2D_grid_runoff(int(totaltime/deltat),mhtot/deltat,204)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                do n=1,naa                  ! added June 13/19 NK
                  i=yyy(n)
                  j=xxx(n)
                  outarray(i,j)=eloss(n)
                end do    
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                call write_2D_cumm_ET(int(totaltime/deltat), mhtot/deltat,205)
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
              endif
              if(debug_output)write(63,*)'Info: Finished writing the .nc output files @ ',&
                                 year_now,month_now,day_now,hour_now
          endif
          
          

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
        end do     !while(time.lt.float(mhtot)
!         END TIME LOOP
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
!         --------------------------------------------------
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

        if(numa.eq.0.and.dds_flag.eq.0)print*

83      CONTINUE       ! FROM STOP COMMAND

!       rev. 9.8.21  Jun.  18/12  - NK: Assess swe observed date & report
!       rev. 9.8.44  Jan.  31/13  - NK: fixed bug in sub.f : uninitialized course_calc(n,j)
!       rev. 9.8.92  Nov.  06/13  - NK: Changed output file swe.txt to swe.csv
!       write the file only if snow course data is availabel in file 951
        if(courseflg)then
          do j=1,mhtot/24
          if(iopt99)write(951,91100)(course_obs(n,j),course_calc(n,j),n=1,nswe)
91100       format(f10.2,<2*nswe-1>(',',f10.2))
          end do
!         calculate the error
          do n=1,nswe
            if(indomainflg(n))then
              do j=1,mhtot/24
                if(course_obs(n,j).ge.0.0)then
                  swe_error=swe_error+(course_obs(n,j)-course_calc(n,j))**2
                  no_swe_obs=no_swe_obs+1
                endif
              end do    
            endif
          end do    
          swe_penalty=swe_error/no_swe_obs 
          print*,'>>NEW<< swe_penalty =',swe_penalty 
        endif

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if(iopt.eq.2)then
          print*,' In sub before call lst'
          print*
        endif

!       Although it would be nice to write the hydrographs whenever a new.par
!       file is written, the data for the first  
!       ni-1 events is not available because the spl.csv file is
!       appended with each event and the data is lost. So it would have to be 
!       put into memory (which is also not attractive) so it could be written
!       at the time each new.par is written.

        mhtot=mhrd    
        if(.not.netCDFflg.or.dds.eq.0.or.iopt99)then
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call lst(scale,igrdshft)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else
          write(98,*)'Info: Supressing normal output in lst.f'
        endif

!       STATUS LINE:
        if(icase.gt.0.and.numa.eq.0.and.dds_flag.eq.0)then
          write(6,5003)id,ni,mz,mhtot,nnn,maxn,scale,optlow
        endif

        if(mhtot.gt.8000)then
!         ONLY FOR ANNUAL RUNS
!         This is to apply a penaly if the snow does not melt each year. 
!         In the high mountains this can happen if the base temp is too high
!         from dds - the program will just accumulate swe if there's too much
!         water. Instead, this forces more evaporation to get rid of it.            
          minsnwflg=0
          do n=1,naa
            do ii=1,classcount
                if(aclass(n,ii).gt.0.0)then
                    if(snowcmin(n,ii).gt.0.00001)then
                        if(numa.le.0)then
                            write(98,6400)n,ii,snowcmin(n,ii),id
                        endif
                        minsnwflg=1
                    endif
                endif
            end do
          end do
        endif   !  mhtot.gt.8000
        if(minsnwflg.eq.1)then
          print*,'Warning: check debug\warnings.txt file for snow problems'
          write(98,*)'Warning:  check spl.err file for snow problems'
          dds_penalty=10.0
        endif
        
        if(mod(id,12).eq.0.and.iopt99)then
           write(29,*)id,domain_precip/domain_area
           domain_precip=0.0
        endif
       
!     rev. 10.1.77 Apr.  17/17  - NK: Moved DDS err calcs to new dds_code s/r's
        if(abs(dds_flag).eq.1.and.id.gt.idskip)then
          penalty=penalty+score
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          call dds_options(dds_error)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          if(errflg.eq.10)dds_error=dds_error+score
        endif           ! if(abs(dds_flag).eq.1.and.......)
        
!       for insurance:	
	    close(unit=40,status='keep',iostat=ios)
	    close(unit=45,status='keep',iostat=ios)
        
        
        if(tbcflg.eq.'y')then
!         THIS SECTION IS USED TO WRITE ALL STATE VARIABLES
!         SO PRGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!         Called only after the last event is complete.
!         REV. 8.1  - Feb.    15/96 -  TBC & RSM (TO BE CONTINUED & RESUME)
!         rev. 10.2.47 Feb.  10/19  - NK: Revised write_resume
!         soil_init, flow_init & lake_level_init moved there          
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_resume(jz)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(98,*)'Info: Finished writing the resume files'       
        endif    !   if(tbcflg.eq.'y')....

      end do     ! EVENT LOOP END
 
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     * * * * * * * *  EVENT LOOP END  * * * * * * * * * *
!     **************************************************** 


!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!     Close the CHARM_output.nc file with nrecs = -1
      if(netCDFflg)then
!         unit=???  fln(201)-Gridded output for FEWS       CHARM_output.nc
!         close the files          
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          call write_2D_flow(int(totaltime),-int(totaltime),201)
          call write_2D_swe(int(totaltime),-int(totaltime),202)
          call write_2D_uzs(int(totaltime),-int(totaltime),203)
          call write_2D_grid_runoff(int(totaltime),-int(totaltime),204)
          call write_2D_cumm_ET(int(totaltime),-int(totaltime),205)
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
          deltat=6
          fln(99)='results\CHARM_flow_vector.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_flow(no,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_levels.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_levels(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_inflow.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_inflow(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          
          fln(99)='results\CHARM_lake_outflow.nc'
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          call write_ts_lake_outflow(noresv,mhtot/deltat,99) 
!         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          write(98,*)'Info: Finished writing the .nc output files files'       
      endif


!     rev. 9.8.08  Nov.  18/11  - NK: added fratio for interception hight optimization
!     set interception capacity to values read in originally in read_par_parser
      if(fratioflg)then
        do i=1,12
          do ii=1,classcount
            h(i,ii)=h(i,ii)/fratio(ii)
          end do
        end do
      endif

!     rev. 9.7.19  Jan.  18/11  - NK: Added sensitivity analysis
!       for sensitivity analysis and pattern search

      if(dds_flag.lt.0)then
	      optim=dds_error
	      if(optim.le.0.0)then
	        print*,'For sensitivity run:'
	        print*,'calculated error = zero'
	        print*,'Please make sure there is streamflow and/or'
	        print*,'value1 in the str files are set to 1'
	        stop 'Program aborted in sub @ line 3696'
	      endif
	      return                     !<<<<<<<<<<<<<<<<<<<<<return
      endif

!     rev. 10.2.46 Jan.  21/19  - NK: Added netCDF capability
!     stats not caculated for FEWS      
      if(numa.eq.0.and.iopt.lt.99.and.FLtype(6).eq.'tb0')then
!       call stats only when there's no pre-emption:
!       but not for the pattern search as it get here with every trial
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call stats(28,28)
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif

!     rev. 9.7.00  May.  26/10  - NK: dds with pre-emption
!     rev. 9.6.01  Mar.  01/10  - NK: DDS capability added

!     write the function value for DDS
      if(dds_flag.eq.1)then
        open(unit=99,file='dds\function_out.txt',status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file  dds\function_out.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in sub.f @ 4299'
        endif
        write(99,*)dds_error
        close(unit=99,status='keep')
        write(30,*)  !blank line between trials in dds_log.txt
         
!       this copied here from lst - error is needed each time an improvement 
!       is found for the dds\best directory
!       fix: this could be eliminated here by moving the call lst after the ddserror
!       calculation above        
!     rev. 9.3.07  Dec.  29/06  - NK: added error field for whole domain
!     rev. 9.8.15  Mar.  12/11  - NK: write error.txt for every dds evaluation
!       (because it's needed whe doing on-the-fly validation runs)
        author='watflood                                '
        name='Volume errors in %                      '
        coordsys_temp=coordsys1
!       GreenKenue uses LatLong - code below uses LATLONG
        if(coordsys_temp.eq.'LatLong   ')coordsys_temp='LATLONG   '
        if(coordsys_temp.eq.'Cartesian ')coordsys_temp='CARTESIAN '
        zone_temp=zone1
	    datum_temp=datum1
	    xorigin_temp=xorigin
	    yorigin_temp=yorigin
	    xcount_temp=xcount
	    ycount_temp=ycount
	    xdelta_temp=xdelta
	    ydelta_temp=ydelta
	    startdate='unknown   '
	    starttime='unknown   '
        unit_conversion=1.0
        attribute_count=1
	    attribute_name='error                                    '
	    attribute_units='percent                                 ' 
        source_file_name='last spl run'     
        do j=1,xcount
	      do i=1,ycount
              outarray(i,j)=basinerr(i,j)
	      end do
  	    end do
        
!         write the header
!         written in lst for ddsflg=0
!     rev. 9.9.23  Aug.  10/14  - NK: Uniform arguments for write_r2c
!      filename(67)='results\error.r2c'    !gridded flow errors
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(67,67,0,0,0,0,11)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       write the data
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_r2c(67,67,0,0,0,1,11)   
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      endif

!     STATUS LINE:   PS optimization only
      if(numa.gt.0.and.dds_flag.eq.0)then
        if(nnn.eq.0)optim=optim*4.0
        write(6,5006)id-1,ni,mz,mhtot,nnn,maxn,optlow
      endif

      close(unit=271,status='keep')   ! gridflow.r2c

      id=ni

!     rev. 9.5.01  Oct.  15/07  - NK: added wetland continuity check
      
      if(iopt.ge.1)then
        write(51,*)'Continuity check for wetlands:'
        write(51,*)'grid #,    net_inflow,    delta_storage,      difference,     %'
      if(wetflg.eq.'y')then
        do n=1,naa
          xtemp=qiwetsum(n)-qowetsum(n)
          ytemp=wstore2(n)-wstoreinit(n)
          ztemp=(xtemp-ytemp)/xtemp
          if(ztemp.gt.0.0001)then
!            write(51,5103)n,xtemp,ytemp,ztemp*100.0
            write(51,*)n,xtemp,ytemp,xtemp-ytemp,ztemp*100.0
          endif
          end do
        endif
5103    format(i10,2f20.3)
      endif

!     rev. 9.6.05  Apr.  06/10  - NK: added store_error_flag for -ve storage grids
      errflg_store=.false.
        do n=1,naa
          if(store_error_flag(n))then
            Print*,'WARNING: -ve storage(s) in grid no ',n
            errflg_store='true'
          endif
        end do
      if(errflg_store)then
        print*,'-ve storage errors found in the grids listed above'
        print*,'Probable cause:'
        print*,'1. steep slopes with low Manning n'
        print*,'2. grids with 100% water not marked as a reach'
        print*,'3. cummulative evaporation exceeds inflow + precip'
        print*,'Storages are set to 0.0 when -ve'
        print*,'and you get this annoying message'
        print*
      endif

!     end writing the resume file

!     CALL RUNOF5 TO PRINT SUMMARY WATERBALANCE FILE WATBAL.TXT

      oldjan=jan
      if(debug_output)write(63,*)' In sub before end of run call runof6(3,...'

!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call runof6(3,time,sintvl,aintvl,mon,e1,mz,ju)
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

      jan=oldjan
      
      if(writeFlg(1))then
      open(unit=99,file='rff_grid_specs.txt',status='unknown',iostat=ios)
          write(99,*)'Frac ,',frac(nnprint)
          write(99,*)'GridArea,',grid_area(nnprint)
       
      
        do ii=1,classcount
          if(aclass(nnprint,ii).gt.0.0)then
            write(99,*)
            write(99,*)'Class ',ii,nclass(ii)
            write(99,*)'ClassRatio,',aclass(nnprint,ii)
            write(99,*)'ClassArea,',grid_area(nnprint)*aclass(nnprint,ii)
            write(99,*)'ClassFraction,',frac(nnprint)*aclass(nnprint,ii)
          endif
        end do
      endif
      
!     if(iopt.eq.2)print*,' In sub before call snout3'
!
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     if(iopt.ge.1)call snout3()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!     rev. 9.9.39  Nov.  14/14  - NK: Modifications for watroute
      if(ittoflg.eq.0.and.vapflg.eq.'y'.and.modelflg.eq.'n')then
!       only needed if we have evaporation turned on
        write(98,*)'WARNING: In .par file, temp3 set too low'
        write(98,*)'Results in underestimated evaporation'
        write(98,*)'Please see manual section 2.4.2'
      endif

      if(climate_delta_flg)then
        write(98,*)'Reminder:'
	    write(98,*)'Montly climate deltas from file:'
	    write(98,*)'basin\monthly_climate_deltas.txt'
	    write(98,*)'Temperatures were adjusted by dC:'
	    write(98,*)monthly_temperature_delta
	    write(98,*)'Precipition were multiplied by:'
	    write(98,*)monthly_precipitation_delta
      endif

      firstpass=.false.

      if(msgflg.and..not.netCDFflg)then
        write(98,*)'WARNING:'
        write(98,*)'Tracer model data may not reflect'
        write(98,*)'the actual flow components at locations downstream'
        write(98,*)'of stations with nudging'
      endif

      RETURN

! FORMATS

  201 format(999f5.2)
 2000 format(5i5)
 2001 format(60i1)
 2002 format(a1)
 2003 format(a20,i50)
 3004 format(a20,a10,2x,a10)
 5001 format('+',1x,'id=',i3,'/',i3,' mz=',i3,'/',i3,' nnn=',i5,'/',i5,' smc=',5f4.2,' optlow=',e16.10)
 5002 format(i5,f5.2,i5,f5.1)
 5003 format('+',1x,'id=',i3,'/',i3,' mz=',i5,'/',i5,' nnn=',i5,'/',i5,' scale=',f4.2,' optlow=',e16.10)

 5004 format(a20,a10)
 5005 format(a20,i50)
 5006 format('+',1x,'id=',i3,'/',i3,' mz=',i5,'/',i5,' nnn=',i5,'/',i5,' optlow=',e16.10)

 5010 format(' id,l,mhtot,kt,nu,delta,opt/',5i5,2e10.3)
 5101 format('new shed file read in')
 5102 format('Info: id = ',i5,' filename = ',a30)
 5558 format(' n,nnx,qda(n),qda(nnx),da(n),da(nnx)/',2i3,4f10.1)
 6001 format(5x,' no of storms =',i5)
 6002 format(35x,' * * * time =',f7.2,' hours * * *',f12.3)
 6004 format('+',i5,' hrs rainfall available, ',i5,' hrs used')
 6005 format(' Warning: no streamflow stations selected for error calculation. Enter data in 1st line of .str file.')
 6007 format(' no,nl,mhtot,kt/',4i5)
 6008 format(' id,nr,tj1,mo,conv/',2i5,f5.2,i5,f5.2)
! 6012 format(' ',2f12.3,i5,1x,a12,3x,2a1,3x,2a1)
 6013 format(' ',2f12.3,i5,1x,a12,99f5.2)
 6014 format(' ',2i5,99f5.2)
 6015 format(' ','sub basin file sub-basin percent of land covers')
 6016 format(' ','sub basin file can be used to find sub-basin percent of land covers')
 6017 format('           xx          yy    # name         sum    classes 1-',i5)
 6018 format(' ',i7,99f7.2)
 6100 format(' [in sub]   n    i    j      da     qda  qbase')
 6102 format(' ',3i5,3f10.2)
 6103 format(' element #',i5,' base flow = 1 cms assumed')
 6104 format(25i3)
 6105 format(' initial flows modified by reservoir releases') 
 6106 format(' i,qinit(i)/',i5,f10.3)
 6107 format(' n,yyy(n),xxx(n),i,ires(i),jres(i)/',6i3)
 6108 format(' initial base flows prorated upstream')
 6109 format(' reservoir releases added back in') 
 6110 format(' initial flow at streamflow stations')
 6120 format(a1)
 6121 format(5i10,2f10.2)
 6226 format(' error encountered opening unit=37 fln=',a31/)
 6227 format(' error encountered on unit=37 fln=',a31/)
 6229 format(' error encountered on unit=38 fln=',a31/)
 6231 format(' error encountered on unit=40 fln=',a31,'on line 5'/)
 6233 format(' error: problems opening unit=45 fln=',a31,' OK if vapflg=y and flgevp.le.1')
 6235 format(' end of file encountered on unit=36 fln=',a31/) 
 6237 format(' end of file encountered on unit=40 fln=',a31/)
 6250 format(' error encountered on unit=99 fln=',a31/)
 6263 format(' error encountered on unit=49 fln=',a31/)
 6273 format(' error encountered on unit=50 fln=',a31/)
 6300 format(' ','Mode is set to check all input files iopt = ',i5, ' To run the event, change debug level to a value less than 99'/)
 6400 format(' Warning: min swe on (grid,class)',i4,' ',i2,' =',f8.2,'mm in event #',i3)
 6501 format(' number of grids,',i5)
 6502 format(' number of rows,',i5)
 6503 format(' number of colums,',i5)
 6504 format(' number of land cover classes = classcount,',i5) 
 6505 format(' The reference grid is the bottom left hand corner there are blanks around the watershed All units are mm or cms')
 6508 format(' time=',f14.2)
 6509 format(/' Colunm Key: grid no, row no, column no, precip',i5,' liquid surface storage bare/snow (2*classcount)'/&
     i5,' snow water equivalent (classcount)',i5,' snow covered area (classcount)'/&
     i5,' upper zone storage bare/snow (2*classcount) lower zone storage grid flow, channel flow') 
 6510 format(3i5,60e10.2)

 9001 format(f25.0)
 9700 format(19e14.7)
 9701 format(a3)
 9702 format(' resume.txt file length does not match current memory array spec. Regenerate the file')
 9703 format('block no.',i2)
 9704 format(9x,i2)
 9706 format(16i5)
 9999 format(15x,f16.6)
 9990 format(i5)
 9991 format(12x,f9.6)
 9992 format(12x,<ninit>(i9))
 9993 format(12x,<ninit>(f9.6))
 9994 format(5x,i9)
 9995 format(7x,f9.6)
99000 format(f5.1)
99001 format(f25.0)
99002 format(2f15.3,i6,4x,2a12,f12.1)
99003 format(i1,5x,a50)
99004 format(i5)
99005 format(i10,<noresv>g12.3)
99182   format(' Warning: Error opening or reading fln:',a30,' Probable cause: missing strfw/yymmdd.str input file OR: in config.sys have you set files=100 & buffers=50?'/)
98001 format(' Warning: Error reading resume.txt'/&
     ' Probable cause: wrong format or end of file reached'/&
     ' This could be due to a change in grid characteristics'/&
     ' since creating the resume file'/&
     ' Solution: create a new resume file with current executable'/&
     ' block= ',i5)

      end  SUBROUTINE sub

      SUBROUTINE synflw(time,thr)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

!  THIS SUBROUTINE CALCULATES THE FLOW AT THE RECORDED FLOW TIMES, 
!  THEREFORE INTERPOLATES WHEN ROUTE DOES NOT GIVE FLOWS AT THE 
!  EVEN HOURS

!     REV. 7.6  -  SEDIMENT ROUTINE INCLUDED
!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90

!  id  - is the storm identification number

!***********************************************************************

      use area_watflood
	implicit none

      integer*4    :: kr,kq,l,i,j,n,k,kkt
      real*4       :: time,thr

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE
      

      kr=int(time-thr)+1
      kq=int(time)
!     save the flows at the gage locations:
      do l=1,no
       if(inbsnflg(l).eq.1)then
          i=iy(l)
          j=jx(l)
          n=s(i,j)
          qsyn(l,kq)=qo2(n)
        else
          qsyn(l,kq)=-1.0  !added Dec. 14/10 nk
	  endif
      end do
      
      do l=1,no
       if(inbsnflg(l).eq.1)then
        i=iy(l)
        j=jx(l)
        n=s(i,j)
        if(sedflg.eq.'y')then
          do k=kr,kq
            kkt=k/kt
            if(kkt.lt.1)kkt=1
!            rev. 7.6
             sedsyn(l,kkt)=yfinal(n)
             nitsyn(l,kkt)=nfinal(n)
             phssyn(l,kkt)=pfinal(n)
!            Calculate Mass(kg): kg/m3 * m3/s * 3600 (/1000 in tons for sed)
             sedmss(l,kkt)=yfinal(n)*qsyn(l,kkt)*3.6
             nitmss(l,kkt)=nfinal(n)*qsyn(l,kkt)*3600
             phsmss(l,kkt)=pfinal(n)*qsyn(l,kkt)*3600
          end do
        endif
       endif   !inbsnflg
      end do

!     SAVE THE FLOWS AT THE DAMAGE LOCATIONS:
      do l=1,ndam
!         i=iys(l)
!         j=jxs(l)
!         n=s(i,j)
        if(iys(l).le.0.or.jxs(l).le.0)then
!         this can happen if the stream gauge is outside the waterhsed
!         as when subwaterhseds are modelled as separate watersheds
!         added Mar 14/04 nk.          
          n=0
        else
          n=s(iys(l),jxs(l))
        endif
         if(n.eq.1)then
!          only if it is in the watershed           
           do k=kr,kq
             qloc(l,k)=qo2(n)-(qo2(n)-qo1(n))*(time-float(k))/thr
           end do
         endif
      end do

! FORMATS

 5678 format(' ','in synflw: element ',2i5,' is outside basin')


      RETURN

      END SUBROUTINE synflw

      SUBROUTINE temper(n,ii,time,ttime)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

! THIS SUBROUTINE CALCULATES THE TEMPERATURE FOR THE CURRENT TIME STEP
!   -use general cos function, with no offset to represent
!    temperature variation between tmax and tmin
!   -tmax at hour 12
!   -tmin at hour 0

!   calling program = pmelt

!     REV. 9.00 - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90

!***********************************************************************

      use area_watflood
	implicit none

      real*4      :: time,ttime,difft,sumt
      integer*4   :: hour,itime,n,ii

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

!     CALCULATE HOUR OF DAY      
      itime=int(time)
      hour=mod(itime,24)

!     1ST 12 HOURS OF DAY 
      if((hour.ge.0).and.(hour.le.12))then
         if(tmin1(n).eq.tmax(n))then
            ttime=tmin1(n)
         else   
            difft=tmin1(n)-tmax(n)
            sumt=tmin1(n)+tmax(n)
            ttime=-abs(difft)/2*cos(2*3.14159*hour/24)+sumt/2
         endif  
      else
!        2ND 12 HOURS OF DAY 
         if(tmin2(n).eq.tmax(n))then
            ttime=tmin2(n)
         else  
            difft=tmin2(n)-tmax(n)
            sumt=tmin2(n)+tmax(n)
            ttime=-abs(difft)/2*cos(2*3.14159*hour/24)+sumt/2
         endif  
      endif
      
!     DEBUGGING      
      if((n.eq.s(ipr,jpr)).and.(ii.eq.classcount).and.(numa.eq.0))then
         write(57,5000) difft,sumt
         write(57,5001) time,hour,n,tmin1(n),tmin2(n),tmax(n),ttime 
      endif


! FORMATS:

 5000 format(' diff,sum',2f6.1)	
 5001 format(' time,hour,n,tmin1,tmin2,tmax,ttime',
     *            2f6.1,i3,4f6.1)

      RETURN

      END SUBROUTINE temper

      SUBROUTINE timer(iz,jz,mz,clock,time,t,thr,dtmin,
     *                dtmax,div,m,ju,a66)

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!                                 Also rewrote second portion of this s/r

!***********************************************************************

!  DEBUG INFORMATION IS WRITTEN TO UNIT 55 - RTE.LST

!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 

!  t			- time increment in seconds
!  thr		- time increment in hours
!  time		- time from the beginning of the event in hours
!  totaltime	- time from beginning in hours
!  mz			- the integer value of the hour
!				smallest time interval allowed will be a66 seconds (param file)
!  dtmin		- found in 'route' and is equal to the smallest travel
!				through a square found in the computation during the time inc
!				being considred.

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        INTEGER        :: mohours_ly(24),ju_mon_ly(24)
        INTEGER        :: mohours(24),ju_mon(24),
     *                    m,iz,ik,jz,mz,ju,i
        real(4)        :: time,t1
        real*4         :: a66,t,div,thr,clock,dtmax,dtmin,tmv(3)
        logical        :: leapyear,firstpass

      DATA mohours/744,672,744,720,744,720,744,744,720,744,720,744,
     *             744,672,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon/1, 32, 60, 91,121,152,182,213,244,274,305,335,
     *            1, 32, 60, 91,121,152,182,213,244,274,305,335/

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
      DATA mohours_ly/744,696,744,720,744,720,744,744,720,744,720,744,
     *             744,696,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon_ly/1, 32, 61, 92,122,153,183,214,245,275,306,336,
     *            1, 32, 61, 92,122,153,183,214,245,275,306,336/
c     *          366,397,425,456,486,517,547,578,609,639,670,700/
      data firstpass/.true./
      

!     DURING PRECIP, EACH EVEN HOUR IS INCREMENTED 
!     AFTER PRECIP, EACH KT HOUR WILL BE INCORPORATED
!     M IS EQUAL TO 1 IN THE 'RESET' SUBROUTINE AT THE STRAT    
!          OF EACH NEW HYDROGRAPH
!     THE TIME INCREMENT IS ALLOWED TO DECREASE RSMCDLY BUT TO INCRE.
!          Y SLOWLY - STAETEMNT 2 - TO PREVENT HYRDRAULIC INSTABILITY

!     a temporary fix for a66 getting clobbered
!      a66=900.0

      if(iopt.gt.1)then
         write(55,6006)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

      if(m.le.1)then
c      if(firstpass)then
!        THIS SECTION IS ONLY USED AT THE START OF EACH EVENT

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
         t=3600.0
c	   time=1.0

          itogo=1
          div=t/2.0
          thr=t/3600.
          iz=-1
          iz=0
          clock=0.0
          dtmax=3600.0
          do ik=1,3
              tmv(ik)=a66
          end do
!         time reset in sub =1.00 for new event
!         This is the main thing - to reset to 1.0 so the first time frame
!         is read in any r2c input files          
          jz=int(time)   
          mz=jz+1
         
          if(firstpass)then
              year_now=year1
              month_now=mo1
              if(mod(year_now,4).eq.0)then
                  leapyear=.true.
              else
                  leapyear=.false.
              endif
              if(leapyear)then
                  ju=ju_mon_ly(mo1)+day1-1    ! changed May4/07  nk
              else
                  ju=ju_mon(mo1)+day1-1    ! changed May4/07  nk
              endif
              ju=max(ju,1)
              jul_day_now=ju           ! added Apr. 06/15 NK

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!     rev. 10.1.67 Feb.  18/17  - NK: Ignore start year in subsequent event files 
              if(leapyear)then
                  day_now=ju-ju_mon_ly(mo1)+1
              else
                  day_now=ju-ju_mon(mo1)+1
              endif
              hour_now=mod(jz,24)

              if(iopt.ge.3)then
                  write(55,6003)
                  write(55,6005)
     *            iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
              endif
          endif
         
         firstpass=.false.

         RETURN      ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----------------

      else
         
!        MIN TRAVEL TIME IS DETERMINED IN ROUTE - SHOULD NOT BE .LT. a66
!        SO MAX TIME STEP IN SECONDS:
         dtmax=amax1(dtmin,a66)
!        ROUND THIS OFF SO THAT IT CAN BE DIVIDED INTO 3600:       
c         dtmax=float(int(dtmax)/int(a66))*a66
         dtmax=float(int(dtmax/a66))*a66
         

!        CURRENT TIME IS TIME & JZ IN HRS OR T IN SECONDS
!        CALCULATE THE TIME UNTIL THE NEXT RAINFALL
!        THE EXACT TIME UNTIL THE NEXT RAIN IS: 

         t1=float(jz+itogo-1)-time
         t1=max(1.0,t1)
!        THE NEXT TIME STEP IS MAX OF DTMAX AND TIME TO NEXT RAINFALL:
!        FOR SNOW MELT, THE MAX TIME STEP IS 1 HOUR
         t=min(t1*3600.0,dtmax,kt*3600.0)
         div=t/2.0
         thr=t/3600.
         iz=jz
!        WHEN IZ.NE.JZ A NEW RAIN WILL BE READ IN
!        (this is probably no longer needed because this s/r is alled only hourly)         

         jz=int(time)  ! time is incremented in sub
         mz=jz+1

!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
c         if(mod(jz-1,24).eq.0)then
         if(mod(jz,24).eq.0)then
	     ju=ju+1
!          reset the julian day on Jan 1 each year
!          First see if next year is a leap year

            if(ju.ge.365)then
              if(mod(year_now+1,4).eq.0)then
!                 next year is a leap year               
                  leapyear=.true.
              else
                  leapyear=.false.
              endif
           
              if(leapyear)then
	            if(ju.gt.366)then
                      ju=1
                      year_now=year_now+1
                  endif
	        else
	            if(ju.gt.365)then
                      ju=1
                      year_now=year_now+1
                  endif
              endif
           endif
         endif
         
         jul_day_now=ju

!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!        FIND OUT WHAT MONTH WE ARE IN:
         do i=12,1,-1
           mo=i  
           if(leapyear)then
             if(ju.ge.ju_mon_ly(mo))then
               month_now=mo
               go to 1000
             endif
           else
             if(ju.ge.ju_mon(mo))then
               month_now=mo
               go to 1000
             endif
           endif
         end do
!        Do not change this go to - 
!        need to jump out of the loop before it's done
 1000    if(mo.gt.12)month_now=month_now-12

         If(leapyear)then
           day_now=ju-ju_mon_ly(month_now)+1
         else
           day_now=ju-ju_mon(month_now)+1
         endif

        hour_now=mod(jz,24)
        
!       take this out and it won't read next data
        if(hour_now.eq.0)then
          hour_now=24
        endif
        
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!       on the first day of every year add a year
        if(ju.eq.1.and.hour_now.eq.0)then
             year_now=year_now+1
             month_now=1
             day_now=1
             if(mod(year_now,4).eq.0)then
               leapyear=.true.
             else
               leapyear=.false.
             endif
        endif
             
c        if(mod(hour_now,24).eq.0)then
c          write(778,7777)
c     *     '2',ju,jz,hour_now,day_now,month_now,year_now,leapyear
c7777      format(a1,6I5,5x,l1)
c        endif
      
      endif

      if(iopt.ge.3)then
!         if(mz-mz/12*12.eq.0)write(55,6003)
         if(jz-mz/12*12.eq.0)write(55,6003)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

!     rev. 10.1.64 Jan.  26/17  - NK: Added XML output file 
      if(mod(hour_now,24).eq.0)then
        if(month_now.le.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6011)year_now,month_now,day_now
6011    format(i4,'-0',i1,'-0',i1)      
        elseif(month_now.gt.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6012)year_now,month_now,day_now
6012    format(i4,'-',i2,'-0',i1)      
        elseif(month_now.le.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6013)year_now,month_now,day_now
6013    format(i4,'-0',i1,'-',i2)      
        elseif(month_now.gt.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6014)year_now,month_now,day_now
6014      format(i4,'-',i2,'-',i2)      
        endif
c        print*,yyyymmdd12(ju)(1:12),' in timer'
      endif
! FORMATS

 6003 format('   iz   jz   mz  itogo   t1    dtmin   dtmax   clock
     *    time    t       thr')
 6005 format(4i5,f8.2,2f8.0,2f8.2,f8.0,f8.2)
 6006 format(' into timer')

      RETURN
      END SUBROUTINE timer

      SUBROUTINE timer(iz,jz,mz,clock,time,t,thr,dtmin,
     *                dtmax,div,m,ju,a66)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!                                 Also rewrote second portion of this s/r
!     rev. 10.1.88 May   23/17  - NK: Fixed Julian_day problems for iso R/W

!***********************************************************************

!  DEBUG INFORMATION IS WRITTEN TO UNIT 55 - RTE.LST

!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 

!  t			- time increment in seconds
!  thr		- time increment in hours
!  time		- time from the beginning of the event in hours
!  totaltime	- time from beginning in hours
!  mz			- the integer value of the hour
!				smallest time interval allowed will be a66 seconds (param file)
!  dtmin		- found in 'route' and is equal to the smallest travel
!				through a square found in the computation during the time inc
!				being considred.

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        INTEGER        :: mohours_ly(24),ju_mon_ly(24)
        INTEGER        :: mohours(24),ju_mon(24),
     *                    m,iz,ik,jz,mz,ju,i
        real(4)        :: time,t1
        real*4         :: a66,t,div,thr,clock,dtmax,dtmin,tmv(3)
        logical        :: firstpass,next_leapyear

      DATA mohours/744,672,744,720,744,720,744,744,720,744,720,744,
     *             744,672,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon/1, 32, 60, 91,121,152,182,213,244,274,305,335,
     *            1, 32, 60, 91,121,152,182,213,244,274,305,335/

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
      DATA mohours_ly/744,696,744,720,744,720,744,744,720,744,720,744,
     *             744,696,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon_ly/1, 32, 61, 92,122,153,183,214,245,275,306,336,
     *            1, 32, 61, 92,122,153,183,214,245,275,306,336/
c     *          366,397,425,456,486,517,547,578,609,639,670,700/
      data firstpass/.true./
      

!     DURING PRECIP, EACH EVEN HOUR IS INCREMENTED 
!     AFTER PRECIP, EACH KT HOUR WILL BE INCORPORATED
!     M IS EQUAL TO 1 IN THE 'RESET' SUBROUTINE AT THE STRAT    
!          OF EACH NEW HYDROGRAPH
!     THE TIME INCREMENT IS ALLOWED TO DECREASE RSMCDLY BUT TO INCRE.
!          Y SLOWLY - STAETEMNT 2 - TO PREVENT HYRDRAULIC INSTABILITY

!     a temporary fix for a66 getting clobbered
!      a66=900.0

      if(iopt.gt.1)then
         write(55,6006)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

c      if(m.le.1)then
      if(firstpass)then
!        THIS SECTION IS ONLY USED AT THE START OF EACH EVENT

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
         t=3600.0
c	   time=1.0  ! done in sub now
         
!         time reset in sub =1.00 for new event
!         This is the main thing - to reset to 1.0 so the first time frame
!         is read in any r2c input files          
          jz=int(time)   
          mz=jz+1

          itogo=1
          div=t/2.0
          thr=t/3600.
          iz=-1
          iz=0
          clock=0.0
          dtmax=3600.0
          do ik=1,3
              tmv(ik)=a66
          end do
c!         time reset in sub =1.00 for new event
c!         This is the main thing - to reset to 1.0 so the first time frame
c!         is read in any r2c input files          
c          jz=int(time)   
c          mz=jz+1
         
!     rev. 10.1.93 Aug   17/17  - NK: allow year1 etc. to be passed for each event
!         no change here !!!!!!!
          if(firstpass)then
              year_now=year1
              month_now=mo1
              if(mod(year_now,4).eq.0)then
                  leapyear=.true.
              else
                  leapyear=.false.
              endif
              if(leapyear)then
                  ju=ju_mon_ly(mo1)+day1-1    ! changed May4/07  nk
              else
                  ju=ju_mon(mo1)+day1-1    ! changed May4/07  nk
              endif
              ju=max(ju,1)
              jul_day_now=ju           ! added Apr. 06/15 NK

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!     rev. 10.1.67 Feb.  18/17  - NK: Ignore start year in subsequent event files 
              if(leapyear)then
                  day_now=ju-ju_mon_ly(mo1)+1
              else
                  day_now=ju-ju_mon(mo1)+1
              endif
              hour_now=mod(jz,24)
              hour_now_fews=hour_now
              if(hour_now.eq.24)then
                  hour_now_fews=0
              else
                  hour_now_fews=hour_now
              endif

              if(iopt.ge.3)then
                  write(55,6003)
                  write(55,6005)
     *            iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
              endif
          endif
         
c         firstpass=.false.

c         RETURN      ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----------------

      else
         
         iz=jz
!        WHEN IZ.NE.JZ A NEW RAIN WILL BE READ IN
!        (this is probably no longer needed because this s/r is alled only hourly)         
         jz=int(time)  ! time is incremented in sub
         mz=jz+1

!        MIN TRAVEL TIME IS DETERMINED IN ROUTE - SHOULD NOT BE .LT. a66
!        SO MAX TIME STEP IN SECONDS:
         dtmax=amax1(dtmin,a66)
!        ROUND THIS OFF SO THAT IT CAN BE DIVIDED INTO 3600:       
c         dtmax=float(int(dtmax)/int(a66))*a66
         dtmax=float(int(dtmax/a66))*a66

!        CURRENT TIME IS TIME & JZ IN HRS OR T IN SECONDS
!        CALCULATE THE TIME UNTIL THE NEXT RAINFALL
!        THE EXACT TIME UNTIL THE NEXT RAIN IS: 

         t1=float(jz+itogo-1)-time
         t1=max(1.0,t1)
!        THE NEXT TIME STEP IS MAX OF DTMAX AND TIME TO NEXT RAINFALL:
!        FOR SNOW MELT, THE MAX TIME STEP IS 1 HOUR
         t=min(t1*3600.0,dtmax,kt*3600.0)
         div=t/2.0
         thr=t/3600.
c         iz=jz
c!        WHEN IZ.NE.JZ A NEW RAIN WILL BE READ IN
c!        (this is probably no longer needed because this s/r is alled only hourly)         
c         jz=int(time)  ! time is incremented in sub
c         mz=jz+1

!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 10.1.74 Apr.  01/17  - NK: Changed timer to fix 1 day-off problem 
c         if(mod(jz-1,24).eq.0)then
        if(mod(jz,24).eq.0)then
	     ju=ju+1
c          write(778,7777)' ',ju   !,jz,hour_now,day_now,month_now,year_now,leapyear

           !          reset the julian day on Jan 1 each year
!          First see if next year is a leap year

!         see if we're in a leapyear:
           if(mod(year_now,4).eq.0)then
              leapyear=.true.
           else
              leapyear=.false.
           endif           
           
           if(leapyear)then
	        if(ju.gt.366)then
                ju=1
                year_now=year_now+1
              endif
	     else
	        if(ju.gt.365)then
                ju=1
                year_now=year_now+1
               endif
           endif
c           ju=ju+1
         endif

         jul_day_now=ju

!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!        FIND OUT WHAT MONTH WE ARE IN:
         do i=12,1,-1
           mo=i  
           if(leapyear)then
             if(ju.ge.ju_mon_ly(mo))then
               month_now=mo
               go to 1000
             endif
           else
             if(ju.ge.ju_mon(mo))then
               month_now=mo
               go to 1000
             endif
           endif
         end do
!        Do not change this go to - 
!        need to jump out of the loop before it's done
 1000    if(mo.gt.12)month_now=month_now-12

         If(leapyear)then
           day_now=ju-ju_mon_ly(month_now)+1
         else
           day_now=ju-ju_mon(month_now)+1
         endif

        hour_now=mod(jz,24)
        if(hour_now.eq.24)then
            hour_now_fews=0
        else
            hour_now_fews=hour_now
        endif
        
!       take this out and it won't read next data
        if(hour_now.eq.0)then
          hour_now=24
        endif
        
c        if(mod(hour_now,1).eq.0)then
c          write(778,7777)
c     *     'b',ju,jz,hour_now,day_now,month_now,year_now,leapyear
c7777      format(a1,6I5,5x,l1)
c        endif
      
      endif

      if(iopt.ge.3)then
!         if(mz-mz/12*12.eq.0)write(55,6003)
         if(jz-mz/12*12.eq.0)write(55,6003)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

!     rev. 10.1.64 Jan.  26/17  - NK: Added XML output file 
c      if(mod(hour_now,24).eq.0)then
      if(hour_now.eq.1)then
        if(month_now.le.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6011)year_now,month_now,day_now
6011    format(i4,'-0',i1,'-0',i1)      
        elseif(month_now.gt.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6012)year_now,month_now,day_now
6012    format(i4,'-',i2,'-0',i1)      
        elseif(month_now.le.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6013)year_now,month_now,day_now
6013    format(i4,'-0',i1,'-',i2)      
        elseif(month_now.gt.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6014)year_now,month_now,day_now
6014      format(i4,'-',i2,'-',i2)      
        endif
c        print*,yyyymmdd12(ju)(1:12),' in timer'
      endif
! FORMATS
      
!     rev. 10.1.90 Jul.  27/17  - NK: Added date_now for i/o files
      if(month_now.le.9.and.day_now.le.9)then
          write(date_now,20001)year_now,month_now,day_now
20001     format(i4,'-0',i1,'-0',i1)
      elseif(month_now.le.9.and.day_now.gt.9)then
          write(date_now,20002)year_now,month_now,day_now
20002     format(i4,'-0',i1,'-',i2)
      elseif(month_now.gt.9.and.day_now.le.9)then
          write(date_now,20003)year_now,month_now,day_now
20003     format(i4,'-',i2,'-0',i1)
      elseif(month_now.gt.9.and.day_now.gt.9)then
          write(date_now,20004)year_now,month_now,day_now
20004     format(i4,'-',i2,'-',i2)
      endif

      if(firstpass)then
          startdateXML=date_now
          starttimeXML='00:00:00'
      endif

 6003 format('   iz   jz   mz  itogo   t1    dtmin   dtmax   clock
     *    time    t       thr')
 6005 format(4i5,f8.2,2f8.0,2f8.2,f8.0,f8.2)
 6006 format(' into timer')

      firstpass=.false.
      
      RETURN
      END SUBROUTINE timer

      SUBROUTINE timer_new(iz,jz,mz,clock,time,t,thr,dtmin,
     *                dtmax,div,m,ju,a66)

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)

!***********************************************************************

!  DEBUG INFORMATION IS WRITTEN TO UNIT 55 - RTE.LST

!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 

!  t			- time increment in seconds
!  thr		- time increment in hours
!  time		- time from the beginning of the event in hours
!  totaltime	- time from beginning in hours
!  mz			- the integer value of the hour
!				smallest time interval allowed will be a66 seconds (param file)
!  dtmin		- found in 'route' and is equal to the smallest travel
!				through a square found in the computation during the time inc
!				being considred.

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        INTEGER        :: mohours_ly(24),ju_mon_ly(24)
        INTEGER        :: mohours(24),ju_mon(24),
     *                    m,iz,ik,jz,mz,ju,i
        real(4)        :: time,t1
        real*4         :: a66,t,div,thr,clock,dtmax,dtmin,tmv(3)
        logical        :: leapyear,firstpass

      DATA mohours/744,672,744,720,744,720,744,744,720,744,720,744,
     *             744,672,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon/1, 32, 60, 91,121,152,182,213,244,274,305,335,
     *            1, 32, 60, 91,121,152,182,213,244,274,305,335/

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
      DATA mohours_ly/744,696,744,720,744,720,744,744,720,744,720,744,
     *             744,696,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon_ly/1, 32, 61, 92,122,153,183,214,245,275,306,336,
     *            1, 32, 61, 92,122,153,183,214,245,275,306,336/
c     *          366,397,425,456,486,517,547,578,609,639,670,700/
      data firstpass/.true./
      

!     DURING PRECIP, EACH EVEN HOUR IS INCREMENTED 
!     AFTER PRECIP, EACH KT HOUR WILL BE INCORPORATED
!     M IS EQUAL TO 1 IN THE 'RESET' SUBROUTINE AT THE STRAT    
!          OF EACH NEW HYDROGRAPH
!     THE TIME INCREMENT IS ALLOWED TO DECREASE RSMCDLY BUT TO INCRE.
!          Y SLOWLY - STAETEMNT 2 - TO PREVENT HYRDRAULIC INSTABILITY

!     a temporary fix for a66 getting clobbered
!      a66=900.0

      if(iopt.gt.1)then
         write(55,6006)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

      if(m.le.1)then
c      if(firstpass)then
!        THIS SECTION IS ONLY USED AT THE START OF EACH EVENT

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
         t=3600.0
c	   time=1.0

         itogo=1
         div=t/2.0
         thr=t/3600.
         iz=-1
         iz=0
         clock=0.0
         dtmax=3600.0

         do ik=1,3
            tmv(ik)=a66
         end do
         jz=int(time)
         mz=jz+1
         year_now=year1
         month_now=mo1
         if(mod(year_now,4).eq.0)then
           leapyear=.true.
         else
           leapyear=.false.
         endif

         if(leapyear)then
           ju=ju_mon_ly(mo1)+day1-1    ! changed May4/07  nk
         else
           ju=ju_mon(mo1)+day1-1    ! changed May4/07  nk
         endif

         ju=max(ju,1)
         jul_day_now=ju           ! added Apr. 06/15 NK

!     rev. 10.1.66 Jan.  28/17  - NK: Fixed leap year in timer 
!     rev. 10.1.67 Feb.  18/17  - NK: Ignore start year in subsequent event files 
         if(leapyear)then
           day_now=ju-ju_mon_ly(mo1)+1
         else
           day_now=ju-ju_mon(mo1)+1
         endif
         hour_now=mod(jz,24)

c      print*,ju,mo,ju_mon(mo1),mo1,day_now,hour_now,'start'

         if(iopt.ge.3)then
            write(55,6003)
            write(55,6005)
     *            iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
         endif
         
c          write(778,7777)
c     *     '1',ju,jz,hour_now,day_now,month_now,year_now,leapyear
      
         firstpass=.false.
         RETURN
      else
         
!        MIN TRAVEL TIME IS DETERMINED IN ROUTE - SHOULD NOT BE .LT. a66
!        SO MAX TIME STEP IN SECONDS:
         dtmax=amax1(dtmin,a66)
!        ROUND THIS OFF SO THAT IT CAN BE DIVIDED INTO 3600:       
c         dtmax=float(int(dtmax)/int(a66))*a66
         dtmax=float(int(dtmax/a66))*a66
         

!        CURRENT TIME IS TIME & JZ IN HRS OR T IN SECONDS
!        CALCULATE THE TIME UNTIL THE NEXT RAINFALL
!        THE EXACT TIME UNTIL THE NEXT RAIN IS: 

         t1=float(jz+itogo-1)-time
         t1=max(1.0,t1)
!        THE NEXT TIME STEP IS MAX OF DTMAX AND TIME TO NEXT RAINFALL:
!        FOR SNOW MELT, THE MAX TIME STEP IS 1 HOUR
         t=min(t1*3600.0,dtmax,kt*3600.0)
         div=t/2.0
         thr=t/3600.
         iz=jz
!        WHEN IZ.NE.JZ A NEW RAIN WILL BE READ IN
!        (this is probably no longer needed because this s/r is alled only hourly)         

         jz=int(time)  ! time is incremented in sub
         mz=jz+1

!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
c         if(mod(jz-1,24).eq.0)then
         if(mod(jz,24).eq.0)then
	     ju=ju+1
!          reset the julian day on Jan 1 each year
c	     if(leapflg.eq.'0')then
	     if(leapyear)then
	       if(ju.gt.366)ju=1
	     else
	       if(ju.gt.365)ju=1
	     endif
         endif
         jul_day_now=ju

!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!        FIND OUT WHAT MONTH WE ARE IN:
         do i=12,1,-1
           mo=i  
           if(leapyear)then
             if(ju.ge.ju_mon_ly(mo))then
               month_now=mo
               go to 1000
             endif
           else
             if(ju.ge.ju_mon(mo))then
               month_now=mo
               go to 1000
             endif
           endif
         end do
!        Do not change this go to - 
!        need to jump out of the loop before it's done
 1000    if(mo.gt.12)month_now=month_now-12

         If(leapyear)then
           day_now=ju-ju_mon_ly(month_now)+1
         else
           day_now=ju-ju_mon(month_now)+1
         endif

        hour_now=mod(jz,24)
        
!       take this out and it won't read next data
        if(hour_now.eq.0)then
          hour_now=24
        endif
        
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!       on the first day of every year add a year
        if(ju.eq.1.and.hour_now.eq.0)then
             year_now=year_now+1
             month_now=1
             day_now=1
             if(mod(year_now,4).eq.0)then
               leapyear=.true.
             else
               leapyear=.false.
             endif
        endif
             
c        if(mod(hour_now,24).eq.0)then
c          write(778,7777)
c     *     '2',ju,jz,hour_now,day_now,month_now,year_now,leapyear
c7777      format(a1,6I5,5x,l1)
c        endif
      
      endif

      if(iopt.ge.3)then
!         if(mz-mz/12*12.eq.0)write(55,6003)
         if(jz-mz/12*12.eq.0)write(55,6003)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

!     rev. 10.1.64 Jan.  26/17  - NK: Added XML output file 
      if(mod(hour_now,24).eq.0)then
        if(month_now.le.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6011)year_now,month_now,day_now
6011    format(i4,'-0',i1,'-0',i1)      
        elseif(month_now.gt.9.and.day_now.le.9)then
          write(yyyymmdd12(ju),6012)year_now,month_now,day_now
6012    format(i4,'-',i2,'-0',i1)      
        elseif(month_now.le.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6013)year_now,month_now,day_now
6013    format(i4,'-0',i1,'-',i2)      
        elseif(month_now.gt.9.and.day_now.gt.9)then
          write(yyyymmdd12(ju),6014)year_now,month_now,day_now
6014      format(i4,'-',i2,'-',i2)      
        endif
c        print*,yyyymmdd12(ju)(1:12),' in timer'
      endif
! FORMATS

 6003 format('   iz   jz   mz  itogo   t1    dtmin   dtmax   clock
     *    time    t       thr')
 6005 format(4i5,f8.2,2f8.0,2f8.2,f8.0,f8.2)
 6006 format(' into timer')

      RETURN
      END SUBROUTINE timer_new

      SUBROUTINE timer(iz,jz,mz,clock,time,t,thr,dtmin,
     *                dtmax,div,m,ju,a66)

!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)

!***********************************************************************

!  DEBUG INFORMATION IS WRITTEN TO UNIT 55 - RTE.LST

!     REV. 9.00    Mar.  2000 - TS: CONVERTED TO FORTRAN 90 

!  t			- time increment in seconds
!  thr		- time increment in hours
!  time		- time from the beginning of the event in hours
!  totaltime	- time from beginning in hours
!  mz			- the integer value of the hour
!				smallest time interval allowed will be a66 seconds (param file)
!  dtmin		- found in 'route' and is equal to the smallest travel
!				through a square found in the computation during the time inc
!				being considred.

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        INTEGER        :: mohours(24),ju_mon(24),
     *                    m,iz,ik,jz,mz,ju,i
        real(4)        :: time,t1
        real*4         :: a66,t,div,thr,clock,dtmax,dtmin,tmv(3)

      DATA mohours/744,672,744,720,744,720,744,744,720,744,720,744,
     *             744,672,744,720,744,720,744,744,720,744,720,744/
      DATA ju_mon/1, 32, 60, 91,121,152,182,213,244,274,305,335,
     *            1, 32, 60, 91,121,152,182,213,244,274,305,335/
c     *          366,397,425,456,486,517,547,578,609,639,670,700/

!     DURING PRECIP, EACH EVEN HOUR IS INCREMENTED 
!     AFTER PRECIP, EACH KT HOUR WILL BE INCORPORATED
!     M IS EQUAL TO 1 IN THE 'RESET' SUBROUTINE AT THE STRAT    
!          OF EACH NEW HYDROGRAPH
!     THE TIME INCREMENT IS ALLOWED TO DECREASE RSMCDLY BUT TO INCRE.
!          Y SLOWLY - STAETEMNT 2 - TO PREVENT HYRDRAULIC INSTABILITY

!     a temporary fix for a66 getting clobbered
!      a66=900.0

      if(iopt.gt.1)then
         write(55,6006)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

      if(m.le.1)then

!        THIS SECTION IS ONLY USED AT THE START OF EACH EVENT


!     rev. 9.2.43  Jun.  21/06  - NK: fixed spikes in route
!         if(id.eq.1)t=3600.0
         t=3600.0
	   time=1.0

         itogo=1
         div=t/2.0
         thr=t/3600.
         iz=-1
         iz=0
         clock=0.0

!      time=t/3600.
!        totaltime=totaltime+1.0

         dtmax=3600.0
!     rev. 9.5.21  Mar.  06/08  - NK: fixed dtmin for first time step each event
c         if(snwflg.eq.'y')then
c!           THIS IS A TEMPORARY FIX
c!           TO MAKE SURE WE ARE DOING HOURLY COMPUTATIONS OF SNOW
c            dtmin=3600.
c         else
c!           NO SNOW, SO NO RESTRICTIONS OTHER THAN STRFW TIME STEP
c            dtmin=3600.0*kt
c         endif

         do ik=1,3
            tmv(ik)=a66
         end do
         jz=int(time)
         mz=jz+1

!         ju=ju_mon(mo1)+jz/24

         ju=ju_mon(mo1)+day1-1    ! changed May4/07  nk
         ju=max(ju,1)
         jul_day_now=ju           ! added Apr. 06/15 NK

         year_now=year1
         month_now=mo1
         day_now=ju-ju_mon(mo1)+1
         hour_now=mod(jz,24)

c      print*,ju,mo,ju_mon(mo1),mo1,day_now,hour_now,'start'

         if(iopt.ge.3)then
            write(55,6003)
            write(55,6005)
     *            iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
         endif
         RETURN
      else
!        MIN TRAVEL TIME IS DETERMINED IN ROUTE - SHOULD NOT BE .LT. a66


!        SO MAX TIME STEP IN SECONDS:
         dtmax=amax1(dtmin,a66)

!        ROUND THIS OFF SO THAT IT CAN BE DIVIDED INTO 3600:       
!         dtmax=float(int(dtmax)/int(a66))*a66
         dtmax=float(int(dtmax/a66))*a66

!        CURRENT TIME IS TIME & JZ IN HRS OR T IN SECONDS
!        CALCULATE THE TIME UNTIL THE NEXT RAINFALL
!        THE EXACT TIME UNTIL THE NEXT RAIN IS: 

         t1=float(jz+itogo-1)-time
         t1=max(1.0,t1)
!        THE NEXT TIME STEP IS MAX OF DTMAX AND TIME TO NEXT RAINFALL:
!        FOR SNOW MELT, THE MAX TIME STEP IS 1 HOUR
         t=min(t1*3600.0,dtmax,kt*3600.0)
         div=t/2.0
         thr=t/3600.
         iz=jz
!        WHEN IZ.NE.JZ A NEW RAIN WILL BE READ IN

         jz=int(time)
         mz=jz+1

!     rev. 9.4.05  May.  04/07  - NK: revised timer for julian day calc.
         if(mod(jz-1,24).eq.0)then
	     ju=ju+1
!          reset the julian day on Jan 1 each year
	     if(leapflg.eq.'0')then
	       if(ju.gt.365)ju=1
	     else
	       if(ju.gt.366)ju=1
	     endif
         endif

         jul_day_now=ju

!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!        FIND OUT WHAT MONTH WE ARE IN:
         do i=12,1,-1
           mo=i         
           if(ju.ge.ju_mon(mo))then
             month_now=mo
             go to 1000
           endif
         end do


 1000   if(mo.gt.12)month_now=month_now-12

        day_now=ju-ju_mon(month_now)+1
        hour_now=mod(jz,24)

        if(hour_now.eq.0)then
          hour_now=24
        endif

!     rev. 9.5.70  Oct.  11/09  - NK: fixed timer for r2c frames (use year_now)
!       on the first day of every year add a year
        if(ju.eq.1.and.hour_now.eq.1)year_now=year_now+1

c        write(777,*)ju,hour_now,day_now,month_now,year_now

      endif

      if(iopt.ge.3)then
!         if(mz-mz/12*12.eq.0)write(55,6003)
         if(jz-mz/12*12.eq.0)write(55,6003)
         write(55,6005)
     *         iz,jz,mz,itogo,t1,dtmin,dtmax,clock,time,t,thr
      endif

! FORMATS

 6003 format('   iz   jz   mz  itogo   t1    dtmin   dtmax   clock
     *    time    t       thr')
 6005 format(4i5,f8.2,2f8.0,2f8.2,f8.0,f8.2)
 6006 format(' into timer')

      RETURN
      END SUBROUTINE timer

      SUBROUTINE tracer(iz,jz,time,t,jan,tdum,irte)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! PROGRAM TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model.  It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!
!*****************************************************************************


      use area_watflood
	implicit none

!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: iz,jz,jan,n,i,j,l,ii,jjz,jjzold,rbin,irte
	REAL*4  :: time,tdum,t,ustar,Pe,Cr
      real*4  :: tt1,elat,elon1,elon2,lm,fr,hydd

      DATA jjzold/0/

      jjzold=jjz
      jjz=jz
	if(jjz.lt.1) jjz=1

	if(icount.eq.0)then
c        allocate(nn(no),vel(naa),disp(naa),coeff(naa),stat=iAll)
        allocate(nn(no),vel(na),disp(na),coeff(na),stat=iAll)
	  if(iAll.ne.0) STOP 'Error allocating arrays in Tracer.for'
      endif

!     CALCULATE THE DISPERSION COEFFICIENT FOR TRACER MIXING
!***TS:  to check -- slope(n) already sqrt'd
        do n=1,naa
c          if(slope(n).gt.0.0.and.hcha2(n).gt.0.001.and.ireach(n).le.0
c     *     .or.ireach(n).gt.0.and.res(n).eq.0)then     nk
          if(slope(n).gt.0.0.and.hcha2(n).gt.0.001.and.ireach(n).le.0
     *     .or.ireach(n).gt.0.and.res(n).eq.0.and.hcha2(n).gt.0.001)then
            
            vel(n)=qo2(n)/chaxa(n)
            disp(n)=vel(n)*al/2.
            tt1=al*chaxa(n)/qo2(n)
            hcha2(n)=amax1(hcha2(n),0.0)  ! nk

            ustar=sqrt(9.81*hcha2(n))*slope(n)   !slope(n) already sqrt'd
!            print*,vel(n),ustar,hcha2(n)
!            print*,disp(n),tt1

	      coeff(n)=2*vel(n)*t/(al) !(chawid(n)/vel(n))
!            print*,coeff(n)
!            PAUSE
	      if(coeff(n).gt.1.0) coeff(n)=1.0
            if(coeff(n).lt.0) coeff(n)=0.0
            
          else
	      coeff(n)=0.0
          endif

!         DETERMINE THE MIXING LENGTH
!         ELON = longitudinal dispersion (m^2/s)
!         ELAT = lateral dispersion (m^2/s)
          elon1=0.011*vel(n)**2*chawid(n)**2/hcha2(n)/ustar  ! std

          hcha2(n)=amax1(hcha2(n),0.0)   ! nk
          hydd=(2/3.*chawid(n)*hcha2(n))/   ! hydraulic depth for parabolic channel
     *         (chawid(n)*sqrt(hcha2(n)/chadep(n)))

	    fr=vel(n)/sqrt(9.81*hcha2(n))         ! Froude number

	    elon2=0.05937*qo2(n)/slope(n)**2/chawid(n)   ! Fr<0.5
          elat=0.6*hcha2(n)*ustar  !
	    lm=0.1*vel(n)*chawid(n)**2/elat
          Pe=al*vel(n)/elon1
	    Cr=vel(n)*t/al

d         if(n.eq.nnprint)write(120,1200)time,n,qo2(n),hcha2(n),
d    *    chadep(n),vel(n),hydd,fr,elon1,elon2,elat,lm,Pe,Cr

!	    if(dds_flag.ne.1) write(888,*)n,coeff(n),vel(n),disp(n),Pe,Cr
          coeff(n)=1.0  ! only for Gr2k!

        end do






! FOR NOW, HARD CODE THE TYPE OF TRACER BEING USED
! SET IN AREATRC SO THAT SPL CAN READ IT...
! 0 = SUB-GAUGE TRACER
! 1 = GLACIER MELT TRACER (ii=6)
! 2 = LANDCOVER TRACER
! 3 = RAIN-ON-STREAM TRACER AS FXN OF SUB-BASIN
! 4 = FLOW TYPE TRACER (SW+IF+GW) AS FXN OF SUB-BASIN
! 5 = SNOWMELT TRACER (SW+IF) AS FXN OF SUB-BASIN
!100= ORIGINAL GW TRACER (NK) AS FXN OF SUB-BASIN
!101= WETLAND FLOW TRACER (qowet2)
! **********************************************************************
      if(itrace.eq.0)then

	  print*,'Sub-basin tracer under development'
	  print*,'Select a different itrace number and re-run'
	  STOP 'Program terminated in trace.for @0'

        if(icount.eq.0)then
!         ALLOCATE THE SUB-BASIN TRACER ARRAYS:
          allocate(isoin1IBN(na),isoin2IBN(na),
     *    isoout1IBN(na),isoout2IBN(na),isoconcIBN(na),
     *    isostore1IBN(na),isostore2IBN(na),
     *    massin(na),massout(na),masstore(na),ISOdelta(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating IBN Tracer arrays'

!         ALLOCATE WETLAND ARRAYS IF WETLAND OPTION TURNED ON
          if(wetflg.eq.'y')
     *     allocate(isoin1wet(na,no),isoin2wet(na,no),isoout1wet(na,no),
     *     isoout2wet(na,no),isoconcwet(na,no),isowstore1(na,no),
     *     isowstore2(na,no),wmassin(na),wmassout(na),wmasstore(na),
     *     wISOdelta(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating Wetland Tracer arrays'

!         ALLOCATE LAKE GW TRACER
          allocate(isolakeGW(noresv),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating Lake Tracer array'          

          do n=1,naa
	      i=yyy(n)
	      j=xxx(n)
	      l=nbasin(i,j)
!           INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1:
            isoin2IBN(n)=0.0
            isoout2IBN(n)=0.0
            isostore2IBN(n)=0.0
!           INITIALIZE WETLAND ARRAYS
            if(wetland_flag(n))then
              isoin2wet(n,l)=0.0
              isoout2wet(n,l)=0.0
              isowstore2(n,l)=0.0
            endif
	    end do
        endif

!       WRITE OUTPUT FILE HEADERS
	  if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(92,50000)

	  call tracer0(iz,jz,time,t,jan,tdum)

! **********************************************************************
	elseif(itrace.eq.1)then
c	  print*,'Landcover tracer under development'
c	  print*,'Select a different itrace number and re-run'
c	  STOP 'Program terminated in trace.for @2'

        if(icount.eq.0)then 
!         ALLOCATE THE BC (BASIN-COVER) TRACER ARRAYS:
          allocate(isoin1LC(na,no,classcount-1),
     *    isoin2LC(na,no,classcount-1),
     *    isoout1LC(na,no,classcount-1),isoout2LC(na,no,classcount-1),
     *    isoconcLC(na,no,classcount-1),isoconcBLZS(na,no,classcount-1),
     *    isostore1LC(na,no,classcount-1),
     *    isostore2LC(na,no,classcount-1),
     *    isoin1BLZS(na,no,classcount-1),isoin2BLZS(na,no,classcount-1),
     *    isoout1BLZS(na,no,classcount-1),
     *    isoout2BLZS(na,no,classcount-1),
     *    isoBLZS1(na,no,classcount-1),isoBLZS2(na,no,classcount-1),
     *    isosum(na,no),
     *    massin(na),massout(na),masstore(na),ISOdelta(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating B-LC Tracer arrays'
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)	    
	      if(l.ne.0)then
	        do ii=1,classcount-1
!              INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1:
                isoin2LC(n,l,ii)=0.0
                isoout2LC(n,l,ii)=0.0
                isostore2LC(n,l,ii)=0.0
                isoin2BLZS(n,l,ii)=0.0
	          isoout2BLZS(n,l,ii)=0.0
                isoBLZS2(n,l,ii)=isoBLZS2(n,l,ii)*1.0*(drng(n,ii)+
     *                    drngfs(n,ii))/1000.*aclass(n,ii)*frac(n)*al**2
              end do
            endif
	    end do
        endif

!       WRITE OUTPUT FILE HEADERS
        if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(92,52000)

	  call tracer1(iz,jz,time,t,jan,tdum)


! **********************************************************************
	elseif(itrace.eq.2)then

c	  print*,'Landcover tracer under development'
c	  print*,'Select a different itrace number and re-run'
c	  STOP 'Program terminated in trace.for @2'

        if(icount.eq.0)then 
!         ALLOCATE THE BC (BASIN-COVER) TRACER ARRAYS:
          allocate(isoin1LC(na,no,classcount-1),
     *     isoin2LC(na,no,classcount-1),
     *    isoout1LC(na,no,classcount-1),isoout2LC(na,no,classcount-1),
     *    isoconcLC(na,no,classcount-1),isoconcBLZS(na,no,classcount-1),
     *    isostore1LC(na,no,classcount-1),
     *    isostore2LC(na,no,classcount-1),
     *    isoin1BLZS(na,no,classcount-1),isoin2BLZS(na,no,classcount-1),
     *    isoout1BLZS(na,no,classcount-1),
     *    isoout2BLZS(na,no,classcount-1),
     *    isoBLZS1(na,no,classcount-1),isoBLZS2(na,no,classcount-1),
     *    isosum(na,no),
     *    massin(na),massout(na),masstore(na),ISOdelta(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating B-LC Tracer arrays'
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)	    
	      if(l.ne.0)then
	        do ii=1,classcount-1
!              INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1:
                isoin2LC(n,l,ii)=0.0
                isoout2LC(n,l,ii)=0.0
                isostore2LC(n,l,ii)=0.0
                isoin2BLZS(n,l,ii)=0.0
	          isoout2BLZS(n,l,ii)=0.0
                isoBLZS2(n,l,ii)=isoBLZS2(n,l,ii)*1.0*(drng(n,ii)+
     *                    drngfs(n,ii))/1000.*aclass(n,ii)*frac(n)*al**2
              end do
            endif
	    end do
        endif

!       WRITE OUTPUT FILE HEADERS
        if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(92,52000)

	  call tracer2(iz,jz,time,t,jan,tdum)

! **********************************************************************
	elseif(itrace.eq.3)then

	  print*,'Rain tracer under development'
	  print*,'Select a different itrace number and re-run'
	  STOP 'Program terminated in trace.for @3'

        if(icount.eq.0)then 
!         ALLOCATE THE GW TRACER ARRAYS:
          allocate(isoin1P(na,no),isoin2P(na,no),isoout1P(na,no),
     *    isoout2P(na,no),isoconcP(na,no),isostore1P(na,no),
     *    isostore2P(na,no),massin(na),massout(na),masstore(na),
     *    ISOdelta(na),stat=iAll)
          if(iAll.ne.0) STOP 'Error allocating RAIN Tracer arrays'
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)	    
!           INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1:
!           INITIALIZE STORAGE TO SOME BACKGROUND CONC'N OF TRACER:
	      if(l.ne.0)then
              isoin2P(n,l)=0.0
              isoout2P(n,l)=0.0
              isostore2P(n,l)=0.0
              isostore2P(n,l)=0.0
            endif
          end do
        endif

!       WRITE OUTPUT FILE HEADERS
        if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(92,53000)

	  call tracer3(iz,jz,time,t,jan,tdum)

! **********************************************************************
	elseif(itrace.eq.4)then
      
        if(icount.eq.0)then 

!         ALLOCATE THE FLOW-TYPE TRACER ARRAYS:
          allocate(isoin1GW(na,no),isoin2GW(na,no),isoout1GW(na,no),
     *    isoout2GW(na,no),isoconcGW(na,no),
     *    isostore1GW(na,no),isostore2GW(na,no),isoin1SW(na,no),
     *    isoin2SW(na,no),isoout1SW(na,no),isoout2SW(na,no),
     *    isoconcSW(na,no),isostore1SW(na,no),
     *    isostore2SW(na,no),isoin1IF(na,no),isoin2IF(na,no),
     *    isoout1IF(na,no),isoout2IF(na,no),
     *    isoconcIF(na,no),isostore1IF(na,no),isostore2IF(na,no),
     *    massin(na),massout(na),masstore(na),ISOdelta(na),
     *    isosumQ(na),tt(na),stat=iAll)
		if(iAll.ne.0) STOP 'Error allocating FLOW-TYPE Tracer arrays'

!         ALLOCATE WETLAND ARRAYS IF WETLAND OPTION TURNED ON
          if(wetflg.eq.'y')
     *     allocate(isoin1wet(na,no),isoin2wet(na,no),isoout1wet(na,no),
     *     isoout2wet(na,no),isoconcwet(na,no),isowstore1(na,no),
     *     isowstore2(na,no),isoin1SWwet(na,no),isoin2SWwet(na,no),
     *     isoout1SWwet(na,no),isoout2SWwet(na,no),isoconcSWwet(na,no),
     *     isowstore1SW(na,no),isowstore2SW(na,no),isoin1IFwet(na,no),
     *     isoin2IFwet(na,no),isoout1IFwet(na,no),isoout2IFwet(na,no),
     *     isoconcIFwet(na,no),isowstore1IF(na,no),isowstore2IF(na,no),
     *     wmassin(na),wmassout(na),wmasstore(na),wISOdelta(na),
     *     stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating Wetland Tracer arrays'

!         ALLOCATE LAKE TRACER ARRAYS
          allocate(isolakeGW(noresv),
     *    isolakest(noresv),isolakeSW(noresv),
     *    isolakeIF(noresv),stat=iAll)

	print*,'4 isolakeGW allocated with',noresv

	    if(iAll.ne.0) STOP 'Error allocating Lake Tracer array'          

!         INITIALIZE PRELIMINARY ITERATION VALUES
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)
!           INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1
!           BASED ON INITIALIZATION LOOP BELOW WHERE 1'S = 2'S:
!           INITIALIZE STORAGE TO SOME BACKGROUND CONC'N OF TRACER:
	      if(l.ne.0)then
              isoconcGW(n,l)=0.0
              isoin2GW(n,l)=0.0
              isoout2GW(n,l)=0.0
              isostore2GW(n,l)=0.75*store2(n)
              isoconcSW(n,l)=0.0
              isoin2SW(n,l)=0.0
              isoout2SW(n,l)=0.0
	        isostore2SW(n,l)=0.0
              isoconcIF(n,l)=0.0
              isoin2IF(n,l)=0.0
              isoout2IF(n,l)=0.0
	        isostore2IF(n,l)=0.0
	        isosumQ(n)=0.0
!             INITIALIZE WETLAND ARRAYS
  	        if(wetland_flag(n))then
                isoconcwet(n,l)=0.0
                isoin2wet(n,l)=0.0
                isoout2wet(n,l)=0.0
                isowstore2(n,l)=0.75*wstore2(n)
                isoconcSWwet(n,l)=0.0
                isoin2SWwet(n,l)=0.0
                isoout2SWwet(n,l)=0.0
                isowstore2SW(n,l)=0.0
                isoconcIFwet(n,l)=0.0
                isoin2IFwet(n,l)=0.0
                isoout2IFwet(n,l)=0.0
                isowstore2IF(n,l)=0.0
              endif
            endif
          end do
        endif

!       WRITE OUTPUT FILE HEADERS        
        if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(90,57000)        
                
        call tracer4(iz,jz,time,t,jan,tdum,jjz,jjzold)

!       FOR ISOTOPE MODELLING
!       + rd_iso.for to read in isotope data

d       if(iopt.eq.2)print*,
d    *   'tracer.f - line 387, about to call isotopes.f'

!     rev. 10.1.01 Oct.  05/15  - NK: Isotope update: added 2H
!     This call moved to sub
!	  if(frcflg.eq.'y') call isotopes(iz,jz,jjz,time,t,irte)

! **********************************************************************
	elseif(itrace.eq.5)then

        if(icount.eq.0)then 
!         ALLOCATE THE FLOW-TYPE TRACER ARRAYS:
          allocate(isoin1SW(na,no),isoin2SW(na,no),isoout1SW(na,no),
     *    isoout2SW(na,no),isoconcSW(na,no),isostore1SW(na,no),
     *    isostore2SW(na,no),isoin1SWfs(na,no),isoin2SWfs(na,no),
     *    isoout1SWfs(na,no),isoout2SWfs(na,no),isoconcSWfs(na,no),
     *    isostore1SWfs(na,no),isostore2SWfs(na,no),isoin1IF(na,no),
     *    isoin2IF(na,no),isoout1IF(na,no),isoout2IF(na,no),
     *    isoconcIF(na,no),isostore1IF(na,no),isostore2IF(na,no),
     *    isoin1IFfs(na,no),isoin2IFfs(na,no),isoout1IFfs(na,no),
     *    isoout2IFfs(na,no),isoconcIFfs(na,no),isostore1IFfs(na,no),
     *    isostore2IFfs(na,no),isoin1GW(na,no),isoin2GW(na,no),
     *    isoout1GW(na,no),isoout2GW(na,no),isoconcGW(na,no),
     *    isostore1GW(na,no),isostore2GW(na,no),isoin1GWfs(na,no),
     *    isoin2GWfs(na,no),isoout1GWfs(na,no),isoout2GWfs(na,no),
     *    isoconcGWfs(na,no),isostore1GWfs(na,no),isostore2GWfs(na,no),
     *    isoLZS1(na,no),isoLZS2(na,no),isoconcLZS(na,no),
     *    isoin1LZS(na,no),isoin2LZS(na,no),isoout1LZS(na,no),
     *    isoout2LZS(na,no),isoconcLZSfs(na,no),isoin1LZSfs(na,no),
     *    isoin2LZSfs(na,no),isoout1LZSfs(na,no),isoout2LZSfs(na,no),
     *    isoLZS1fs(na,no),isoLZS2fs(na,no),massin(na),massout(na),
     *    masstore(na),ISOdelta(na),isosumQ(na),isosumQfs(na),
     *    tt(na),stat=iAll)
          if(iAll.ne.0) STOP 'Error allocating SNOWMELT Tracer arrays'

!         ALLOCATE WETLAND ARRAYS IF WETLAND OPTION TURNED ON
          if(wetflg.eq.'y')
     *     allocate(isoin1wet(na,no),isoin2wet(na,no),isoout1wet(na,no),
     *     isoout2wet(na,no),isoconcwet(na,no),isowstore1(na,no),
     *     isowstore2(na,no),isoin1SWwet(na,no),isoin2SWwet(na,no),
     *     isoout1SWwet(na,no),isoout2SWwet(na,no),isoconcSWwet(na,no),
     *     isowstore1SW(na,no),isowstore2SW(na,no),isoin1IFwet(na,no),
     *     isoin2IFwet(na,no),isoout1IFwet(na,no),isoout2IFwet(na,no),
     *     isoconcIFwet(na,no),isowstore1IF(na,no),isowstore2IF(na,no),
     *     isoin1fswet(na,no),isoin2fswet(na,no),isoout1fswet(na,no),
     *     isoout2fswet(na,no),isoconcfswet(na,no),isowstore1fs(na,no),
     *     isowstore2fs(na,no),
     *     isoin1SWfswet(na,no),isoin2SWfswet(na,no),
     *     isoout1SWfswet(na,no),isoout2SWfswet(na,no),
     *     isoconcSWfswet(na,no),isowstore1SWfs(na,no),
     *     isowstore2SWfs(na,no),isoin1IFfswet(na,no),
     *     isoin2IFfswet(na,no),isoout1IFfswet(na,no),
     *     isoout2IFfswet(na,no),isoconcIFfswet(na,no),
     *     isowstore1IFfs(na,no),isowstore2IFfs(na,no),
     *     wmassin(na),wmassout(na),wmasstore(na),wISOdelta(na),
     *     stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating Wetland Tracer arrays'
          if(iopt.gt.1) print*,'allocations completed'

!         ALLOCATE LAKE GW TRACER
          allocate(isolakeGW(noresv),isolakest(noresv),
     *             stat=iAll)

	print*,'5 isolakeGW allocated with',noresv

	    if(iAll.ne.0) STOP 'Error allocating Lake Tracer array'          

          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)
!           INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1
!           BASED ON INITIALIZATION LOOP BELOW WHERE 1'S = 2'S:
!           INITIALIZE STORAGE TO SOME BACKGROUND CONC'N OF TRACER:
	      if(l.ne.0)then
	        isosumQ(n)=0.0
	        isosumQfs(n)=0.0
	        isoconcSW(n,l)=0.0
              isoin2SW(n,l)=0.0
              isoout2SW(n,l)=0.0
              isostore2SW(n,l)=0.0
	        isoconcSWfs(n,l)=0.0
              isoin2SWfs(n,l)=0.0
              isoout2SWfs(n,l)=0.0
              isostore2SWfs(n,l)=0.0
	        isoconcIF(n,l)=0.0
              isoin2IF(n,l)=0.0
              isoout2IF(n,l)=0.0
              isostore2IF(n,l)=0.0
	        isoconcIFfs(n,l)=0.0
              isoin2IFfs(n,l)=0.0
              isoout2IFfs(n,l)=0.0
              isostore2IFfs(n,l)=0.0
	        isoconcGW(n,l)=0.0
              isoin2GW(n,l)=0.0
              isoout2GW(n,l)=0.0
              isostore2GW(n,l)=0.0*store2(n)
	        isoconcGWfs(n,l)=0.0
              isoin2GWfs(n,l)=0.0
              isoout2GWfs(n,l)=0.0
              isostore2GWfs(n,l)=0.0
	        isoconcLZS(n,l)=0.0
              isoin2LZS(n,l)=0.0
              isoout2LZS(n,l)=0.0
              isoLZS2(n,l)=0.0
	        isoconcLZSfs(n,l)=0.0
              isoin2LZSfs(n,l)=0.0
              isoout2LZSfs(n,l)=0.0
              isoLZS2fs(n,l)=0.0

!             SUM ALL CONTRIBUTIONS FROM ALL LANDCLASSES TO GET TOTAL INITIAL STORAGE
!             FOR UZS AND LZS => CAN'T INITIALIZE CHANNEL/SURFACE STORAGES!!
!              do ii=1,classcount-1
!                isoLZS2(n,l)=isoLZS2(n,l)+1.0*drng(n,ii)*
!     *                    (1-sca(n,ii))/1000.*aclass(n,ii)*frac(n)*al**2
!                isoLZS2fs(n,l)=isoLZS2fs(n,l)+1.0*drngfs(n,ii)*
!     *                     sca(n,ii)/1000.*aclass(n,ii)*frac(n)*al**2
!              end do

!             INITIALIZE WETLAND ARRAYS
  	        if(wetland_flag(n))then
                isoconcwet(n,l)=0.0
                isoin2wet(n,l)=0.0
                isoout2wet(n,l)=0.0
                isowstore2(n,l)=0.0*wstore2(n)
                isoconcSWwet(n,l)=0.0
                isoin2SWwet(n,l)=0.0
                isoout2SWwet(n,l)=0.0
                isowstore2SW(n,l)=0.0
                isoconcIFwet(n,l)=0.0
                isoin2IFwet(n,l)=0.0
                isoout2IFwet(n,l)=0.0
                isowstore2IF(n,l)=0.0
                isoconcfswet(n,l)=0.0
                isoin2fswet(n,l)=0.0
                isoout2fswet(n,l)=0.0
                isowstore2fs(n,l)=0.0
                isoconcSWfswet(n,l)=0.0
                isoin2SWfswet(n,l)=0.0
                isoout2SWfswet(n,l)=0.0
                isowstore2SWfs(n,l)=0.0
                isoconcIFfswet(n,l)=0.0
                isoin2IFfswet(n,l)=0.0
                isoout2IFfswet(n,l)=0.0
                isowstore2IFfs(n,l)=0.0
              endif
            endif
          end do
        endif


!       WRITE OUTPUT FILE HEADERS
        if(icount.eq.0)write(91,11000)
        if(icount.eq.0)write(90,58000)


        if(iopt.gt.1) print*,'initializations completed'
	  call tracer5(iz,jz,time,t,jan,tdum,jjz,jjzold)

! **********************************************************************
	elseif(itrace.eq.100)then

        if(icount.eq.0)then

!         ALLOCATE THE FLOW-TYPE TRACER ARRAYS:
          allocate(isoin1GW(na,no),isoin2GW(na,no),isoout1GW(na,no),
     *     isoout2GW(na,no),isoconcGW(na,no),
     *     isostore1GW(na,no),isostore2GW(na,no),massin(na),massout(na),
     *     masstore(na),ISOdelta(na),tt(na),stat=iAll)
          if(iAll.ne.0) PAUSE 'Error allocating GW Tracer arrays'

!         ALLOCATE WETLAND ARRAYS IF WETLAND OPTION TURNED ON
          if(wetflg.eq.'y')
     *     allocate(isoin1wet(na,no),isoin2wet(na,no),isoout1wet(na,no),
     *     isoout2wet(na,no),isoconcwet(na,no),isowstore1(na,no),
     *     isowstore2(na,no),wmassin(na),wmassout(na),wmasstore(na),
     *     wISOdelta(na),stat=iAll)
	    if(iAll.ne.0) STOP 'Error allocating Wetland Tracer arrays'

!         ALLOCATE LAKE GW TRACER
          allocate(isolakeGW(noresv),
     *             isolakest(noresv),stat=iAll)

	print*,'100 isolakeGW allocated with',noresv

	    if(iAll.ne.0) STOP 'Error allocating Lake Tracer array'          

!         INITIALIZE PRELIMINARY ITERATION VALUES 
          do n=1,naa
            i=yyy(n)
            j=xxx(n)
            l=nbasin(i,j)
!	      INITIALIZE 'OUT' ARRAYS SO 'IN' ARRAYS SET TO ZERO @t=1
!           BASED ON INITIALIZATION LOOP BELOW WHERE 1'S = 2'S.
!           INITIALIZE STORAGE TO SOME BACKGROUND CONC'N OF TRACER:
            if(l.ne.0)then
	        isoconcGW(n,l)=0.0
              isoin2GW(n,l)=0.0
              isoout2GW(n,l)=0.0
              isostore2GW(n,l)=0.75*store2(n)
!             INITIALIZE WETLAND ARRAYS
  	        if(wetland_flag(n))then
                isoconcwet(n,l)=0.0
                isoin2wet(n,l)=0.0
                isoout2wet(n,l)=0.0
                isowstore2(n,l)=0.75*wstore2(n)
              endif
	      endif
          end do
!        INITILIZE LAKE ARRAYS
          do n=1,noresv
            isolakeGW(n)=0.0
            isolakest(n)=0.0
          end do  
	  endif

!       WRITE OUTPUT FILE HEADERS
        if(icount.eq.0)write(90,56000)
	  if(icount.eq.0)write(91,11000)
	  if(icount.eq.0)write(94,11000)

!       output only GW variables
!        if(no.le.20.and.icount.eq.0)write(92,10000)
!        if(icount.eq.0)write(90,56000)

        call tracerGW(iz,jz,time,t,jan,tdum,jjz,jjzold)


! **********************************************************************
!	elseif(itrace.eq.101)then
!	  call tracer101(iz,jz,time,t,jan,tdum)


! **********************************************************************
	else
        print*,'Ivalid itrace code - exiting run'
	  print*,'Specify a different itrace number in PAR file and re-run'
	  STOP 'Program terminated in tracer.for @101'

	endif

! **********************************************************************



! FORMATS:
 1200 FORMAT(f8.2,',',i8,6(',',f16.4),3(',',f20.6),',',f16.4,
     *2(',',f20.6))
50000 FORMAT('   time   ,',
     *'         basin#,          grid#,        qo2    ,',
     *'        qr     ,        ISOoutQ,        ISOconc,')
52000 FORMAT('    time  ,',
     *<no>('         basin#,          grid#,       qo2     ,      ',
     *'sumQii   ,',<classcount-1>('        ISOoutQ,        ISOconc,')))
53000 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,        qo2    ,',
     *'       qstrm   ,       strloss ,        ISOoutQ,',
     *'        ISOconc,'))
54000 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,        tt     ,',
     *'        q02    ,        qlz    ,      ISOoutQGW,',
     *'      ISOconcGW,       q1      ,      ISOoutQSW,',
     *'      ISOconcSW,         qint  ,         ISOoutQIF,',
     *'      ISOconcIF,        ISOsumQ,'))
55000 FORMAT('      time   ,',
     *<no>('       qo2     ,        q1     ,',
     *'      ISOoutQSW,      ISOconcSW,      q1fs     ,',
     *'    ISOoutQSWfs,    ISOconcSWfs,     qint      ,',
     *'      ISOoutQIF,      ISOconcIF,     qintfs    ,',
     *'    ISOoutQIFfs,    ISOconcIFfs,     qdrng     ,',
     *'      ISOoutQGW,      ISOconcGW,     qdrngfs   ,',
     *'    ISOoutQGWfs,    ISOconcGWfs,'))
56000 FORMAT('      time   ,',
     *<no>('QGW  ,'))
57000 FORMAT('      time,',
     *<no>('QSW  ,','QIF  ,',
     *'QGW  ,'))
58000 FORMAT('      time,',
     *<no>('QSW  ,','QSWfs  ,','QIF  ,',
     *'QIFfs  ,','QGW  ,','QGWfs  ,'))
10000 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,          qo2  ,',
     *'        qlz    ,       strloss ,        ISOoutQ,',
     *'        ISOconc,'))
10100 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,          qlz  ,',
     *'        qowet  ,       qswevap ,        ISOoutQ,',
     *'        ISOconc,'))
11000 FORMAT('    time  ,        IN     ,       OUT     ,',
     *'        DELTA  ,       STORE   ,       SSE     ,')


      icount=1
      
      RETURN
      END SUBROUTINE tracer      SUBROUTINE tracer0(iz,jz,time,t,jan,tdum)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! SUB-BASIN TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to separate out flows from individual sub-basins.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes & fixed IBN tracking
!     REV. 9.1.51  Apr.  25/05 - TS: Added IF(lnxt.eq.ll) statement **not tested**
!
!*****************************************************************************

c      USE area1
c	USE area2
c      USE area3
c      USE area4
c      USE area5
c      USE area6
c	USE area10
c      USE areaet
cc	USE areamelt
c      USE areatrc
c	USE areawet

      use area_watflood
	implicit none

!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,lll,l,iz,jz,ii,jj,i,j,jan,ios,inxt,jnxt,lnxt,
     *           ll,llold
      REAL*4  :: wi,wold,t,woldn,woldp,isooutold,decay,time
     	REAL*4  :: tdum



      if(index.eq.0)then
        do n=1,na
          res(n)=0
        end do

        do n=1,na
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif
            
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 0 => SUB-BASIN TRACER                              * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     INITIALIZE AND RESET VALUES FOR EACH TIME STEP
      do n=1,na
!       INITIALIZE TRACERS:
        isoin1IBN(n)=isoin2IBN(n)
        isoin2IBN(n)=0.0
        isoout1IBN(n)=isoout2IBN(n)
        isoout2IBN(n)=0.0
        isostore1IBN(n)=isostore2IBN(n)
        isostore2IBN(n)=0.0
        if(wetland_flag(n))then
          isoin1wet(n,l)=isoin2wet(n,l)
          isoin2wet(n,l)=0.0
          isoout1wet(n,l)=isoout2wet(n,l)
          isoout2wet(n,l)=0.0
          isowstore1(n,l)=isowstore2(n,l)
          isowstore2(n,l)=0.0
	  endif
      end do

!     ^^^^^^^^^^^ CHANNEL ROUTE THE TRACER ^^^^^^^^^^^^^^^^^^
!     isoin    = isotope mass in kg
!     isoout   = isotope mass out in kg
!     isostore = isotope in storage in kg
!     isoconc  = isotope concentration in the unit in kg/m^3
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        do n=1,naa
          lll=next(n)
          inxt=yyy(lll)
          jnxt=xxx(lll)
	    lnxt=nbasin(inxt,jnxt)

          i=yyy(n)
          j=xxx(n)
	    ll=nbasin(i,j)

!         RUN TRACER CODE ONLY IF NOT IN A LAKE!!
          if(ireach(n).le.0.0 .OR.
     *       ireach(n).gt.0.and.res(n).gt.0) then


!           CHECK TO ENSURE WE'RE IN THE SAME BASIN AS PREVIOUS...
!           IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!           IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
            if(llold.eq.ll.and.ll.ne.0)then
 
!            WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
             if(slope(n).gt.0.0)then

               if(store2(n).ne.0.0)then
                  isooutold=1.0e+25

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                ROUTE TRACER THROUGH WETLAND FIRST (IF THERE ARE WETLANDS):
                 if(wetland_flag(n)==.true..and.nbasin(i,j).eq.l)then

!                  SET INITIAL CONCENTRATION AS 1 kg/m^3] UNITS:  = [KG]
!                  TRACE MASS OF TRACER ENTERING WETLAND, ADDING TRACER
!                  ONLY IF GRID=N IS IN THE CURRENT SUB-BASIN=L:
                   isoin2wet(n,ll)=isoin2wet(n,ll)+1.0*qr(n)*t   

                   call tracewet(iz,jz,time,n,ll,t)

                   if(qowet2(n).gt.0.0)then
!                    SPECIFY INITIAL MASS FOR CHANNEL FROM WETLAND:
                     isoin2IBN(n)=isoin2IBN(n)+isooutwet

                   else   ! qowet2(n) is -ve
!                   SPECIFY INITIAL MASS IN WETLAND (+MASS FROM CHANNEll)
!                   NOTE: -VE CAUSE QOWET2 IS -VE BUT MASS IS ADDED!
                    isoin2wet(n,ll)=isooutwet-isoconcIBN(n)*qowet2(n)*t
                    isoin2IBN(n)=isoin2IBN(n)+isoconcIBN(n)
     *                                           *qowet2(n)*t
	             endif

	           else
!                  EITHER NO WETLANDS, OR NOT IN RIGHT SUB-BASIN THEREFORE
!                  NO TRACER IS BEING ADDED ANYWAY...SKIP WETLAND ROUTING.
!                  TRACE MASS OF TRACER ENTERING CHANNEL FROM SUBBASIN=L
                   isoin2IBN(n)=isoin2IBN(n)+1.0*qr(n)*t
	           endif

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! WETLANDS AND QOWET2 IS -VE, SO REBALANCE THE WETLAND CONC'N WITH CHANNEL
!                INFLOW. THEN ROUTE WHATEVER'S LEFT IN THE CHANNEL.
                 if(wetland_flag(n)==.true..and.qowet2(n).lt.0
     *                               .and.ll.eq.llold)then ! QOWET2 IS -ve
!                  CHANNEL FEEDS THE WETLAND, THEREFORE MIX CHANNEL CONC'N
!                  WITH WETLAND AND UPDATE WETLAND CONC'N FOR NEXT TIME STEP.
!                  ROUTE TRACER FROM CHANNEL TO WETLAND:
                   isowetold=1.0e+25
!                  ROUTE THE TRACER THROUGH THE WETLAND STORAGE:
                   call tracewet(iz,jz,time,n,ll,t)
                 endif   ! QOWET IS -VE

! NO WETLANDS AND QOWET2 IS +VE (OR ALREADY REROUTED THRU WETLAND)
!                CHANNEL ROUTING OR WETLAND->CHANNEL ROUTING
!                ROUTE TRACER THROUGH CHANNEL - CONVERGENCE LOOP:

!                UPDATE THE TRACER MASS IN CHANNEL n
                 isostore2IBN(n)=isostore1IBN(n)+
     *                (isoin1IBN(n)+isoin2IBN(n)-
     *                 isoout1IBN(n)-isoout2IBN(n))/2.
	           isostore2IBN(n)=amax1(isostore2IBN(n),0.00001)

!                CONVERGENCE LOOP:
                 do ijk=1,50

!                  UPDATE THE CONCENTRATION
                   isoconcIBN(n)=isostore2IBN(n)/store2(n)

!                  COMPUTE THE TRACER MASS LEAVING THE GRID...
!                  EVAP LOSS TO PRESERVE FLOW BALANCES.
!                  THIS SHOULD BE BACK DATED ONE TIME STEP
                   isoout2IBN(n)=isoconcIBN(n)*qo2(n)*t
     *                            -isoconcIBN(n)*strloss(n)*t
	             isoout2IBN(n)=amax1(isoout2IBN(n),0.00001)

!                  UPDATE THE TRACER MASS IN CHANNEL n
                   isostore2IBN(n)=isostore1IBN(n)+
     *                  (isoin1IBN(n)+isoin2IBN(n)-
     *                   isoout1IBN(n)-isoout2IBN(n))/2.
	             isostore2IBN(n)=amax1(isostore2IBN(n),0.00001)

!                  CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                   if(abs(isoout2IBN(n)-isooutold).lt.0.01*isooutold) 
     *                GOTO 01
                   isooutold=isoout2IBN(n)
                 end do
   01            CONTINUE
          
               else
                 isostore2IBN(n)=0.0
                 isoout2IBN(n)=0.0
               end if                       ! if(store2(n).ne.0.0)
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  
!              ISOTOPES ARE CONSERVATIVE!
               decay = 0.0

!              UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT 
!              GRID IS NOT A "DUMMY GRID" AND ITS IN THE SAME BASIN
               if(lnxt.ne.0.and.lnxt.eq.ll)then
                  isoin2IBN(lll)=(1-(decay/100))*
     *                           (isoin2IBN(lll)+isoout2IBN(n))
	         else
                  isoin2IBN(lll)=0.0
	         endif

!              ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
               massin(n)=(isoin1IBN(n)+isoin2IBN(n))/2.
               massout(n)=(isoout1IBN(n)+isoout2IBN(n))/2.
               masstore(n)=(isostore2IBN(n)-isostore1IBN(n))
               ISOdelta(n)=massin(n)-massout(n)
 

 !             CHECK OVERALL MASS BALANCE:
 !             MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
               if(iz.ne.jz.and.n.eq.nnprint)then
                 sqerr=(ISOdelta(n)-masstore(n))**2.
                 write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                         masstore(n),sqerr
               endif

             endif      ! SLOPE>=0


            else
!             DON'T COUNT CONTRIBUTION FROM THIS GRID CAUSE IT DRAINS
!             TO A DIFFERENT BASIN (NOT CONTRIBUTING TO SUB-BASIN OUTLET)
	        CONTINUE
	      endif      ! BASIN CHECK


          else




!           IN A LAKE, DON'T RUN TRACER!
	      CONTINUE 





          endif

!         SAVE THE BASIN NUMBER FOR THE NEXT ITERATION
          llold=ll

!	if(n.eq.39) print*,n,ll,llold,lnxt,isoout2IBN(n)
!	if(n.eq.39) pause

	end do       ! GRID NO. LOOP
     


!     WRITE OUT DATA TO TRACER.CSV FILE
!      if(jan.eq.3)then    ! Prints every 0.25 hours
      if(iz.ne.jz)then     ! Prints every hour
!       WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!       GRID=NNPRINT. 
!       UNITS: isoout2IBN(n,ll)=[kg]/[s]=[kg/s]=[m^3/s]
!       PRINTS @ GRID NNPRINT FLOWS FOR BASIN L ONLY...
!!	  nnprint=39
        ii=yyy(nnprint)
        jj=xxx(nnprint)
	  ll=nbasin(ii,jj)
        write(90,9001)time,
     *    ll,nnprint,qo2(nnprint),qr(nnprint),
     *    isoout2IBN(nnprint)/t,isoconcIBN(nnprint)
      endif


! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
 9001 FORMAT(f10.3,2(',',I15),4(',',f15.5))




      RETURN
      END SUBROUTINE tracer0      SUBROUTINE tracer1(iz,jz,time,t,jan,tdum)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! GLACIER TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the amount of runoff coming from individual landclasses.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!     rev. 9.2.34  Mar.  21/06 - NK: Activated glacier tracer1
!
!*****************************************************************************

c      USE area1
c	USE area2
c      USE area3
c      USE area4
c      USE area5
c      USE area6
c	USE area10
cc      USE areaet
c	USE areamelt
c      USE areatrc
c	USE areawet

      use area_watflood
	implicit none


!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,lll,l,iz,jz,ii,jj,i,j,jan,ios,inxt,jnxt,lnxt
      REAL*4  :: wi,wold,t,woldn,woldp,isooutold,decay,time
     	REAL*4  :: tdum


      ii=glacier_class_number   ! set in rdpar


      if(index.eq.0)then
        do n=1,na
          res(n)=0
        end do

        do n=1,na
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 1 => GLACIER TRACER                                * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

!       INITIALIZE AND RESET VALUES FOR EACH TIME STEP
        do n=1,na
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)	    
	    if(l.ne.0)then
            isosum(n,l)=0.0
!		do ii=1,classcount
!             INITIALIZE TRACERS:
              isoin1LC(n,l,ii)=isoin2LC(n,l,ii)
              isoin2LC(n,l,ii)=0.0
              isoout1LC(n,l,ii)=isoout2LC(n,l,ii)
              isoout2LC(n,l,ii)=0.0
              isostore1LC(n,l,ii)=isostore2LC(n,l,ii)
              isostore2LC(n,l,ii)=0
	        isoin1BLZS(n,l,ii)=isoin2BLZS(n,l,ii)
              isoin2BLZS(n,l,ii)=0.0
	        isoout1BLZS(n,l,ii)=isoout2BLZS(n,l,ii)
	        isoout2BLZS(n,l,ii)=0.0
              isoBLZS1(n,l,ii)=isoBLZS2(n,l,ii)
	        isoBLZS2(n,l,ii)=0.0
!	      end do
	    endif
	  end do

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        do n=1,naa
          lll=next(n)
          inxt=yyy(lll)
          jnxt=xxx(lll)
	    lnxt=nbasin(inxt,jnxt)

          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)

!         RUN TRACER CODE ONLY IF NOT IN A LAKE
          if(ireach(n).le.0.0 .OR.
     *       ireach(n).gt.0.and.res(n).gt.0) then


!          do ii=1,classcount

!       ^^^^^^^^^^^^^ GW ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!           TO GET MASS OF TRACER ENTERING STREAM FROM QLZ
            if(qlz(n).ne.0.0.and.l.ne.0)then
              isooutold=1.0e+25

!             CALC MASS OF TRACER GOING INTO GW STORAGE, SET INITIAL
!             CONCENTRATION AS 1 kg/m^3 * m^s/3 * s = KG

!             ice melt only - from non-sca only
              isoin2BLZS(n,l,ii)=isoin2BLZS(n,l,ii)+
     *                       1.0*drng(n,ii)*frac(n)*tdum*(1-sca(n,ii))*t



!     *                      +1.0*drngfs(n,ii)*frac(n)*tdum*sca(n,ii)*t

!             CONVERGENCE LOOP:
              do ijk=1,50
!               UPDATE THE TRACER MASS IN GW STORAGE
                isoBLZS2(n,l,ii)=isoBLZS1(n,l,ii)+
     *            (isoin1BLZS(n,l,ii)+isoin2BLZS(n,l,ii)-
     *             isoout1BLZS(n,l,ii)-isoout2BLZS(n,l,ii))/2.
	          isoBLZS2(n,l,ii)=amax1(isoBLZS2(n,l,ii),0.00001)

!               UPDATE CONCENTRATION USING INSTANT MIXING!! 
!               GIVES UNITS KG/m^3
                isoconcBLZS(n,l,ii)=isoBLZS2(n,l,ii)/lzs(n)

!               COMPUTE THE TRACER MASS LEAVING THE LZS
!               THIS SHOULD BE BACK DATED ONE TIME STEP
!               KG/m^3 * m^3/s * s = KG
!               ASSUME: NO EVAP IN SOIL COLUMN!!
                isoout2BLZS(n,l,ii)=isoconcBLZS(n,l,ii)*qlz(n)*t

!               CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                if(abs(isoout2BLZS(n,l,ii)-isooutold).lt.0.01*isooutold) 
     *            GOTO 21
                isooutold=isoout2BLZS(n,l,ii)
              end do
   21         CONTINUE
            else
!             conditional added March23/06 nk
!             needed when grid is outside the gauged area
              if(l.ne.0)then   
                isoBLZS2(n,l,ii)=0.0
                isoout2BLZS(n,l,ii)=0.0
              endif
            end if

!       ^^^^^^^^^^^^^ CHANNEL ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!           ROUTED QLZ CONTRIBUTION ADDED TO CHANNEL AND ROUTED AGAIN.
!           WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!           IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!           IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
            if(slope(n).gt.0.0.and.l.ne.0)then
              if(store2(n).ne.0.0)then
                isooutold=1.0e+25
!               SET INITIAL CONCENTRATION AS 1 kg/m^3
!        * * * NOTE: THIS DOES NOT ACCOUNT FOR WETLANDS!!!
!               ADD TRACER TO SW FLOWS, PLUS ROUTED GW TRACER:

!                isoin2LC(n,l,ii)=isoin2LC(n,l,ii)+1.0*(q1(n,ii)+
!     *                           q1fs(n,ii)+qint(n,ii)+qintfs(n,ii))*t+
!     *                           isoout2BLZS(n,l,ii)

!               from ice area only (no melt)
                isoin2LC(n,l,ii)=isoin2LC(n,l,ii)
     *                           +1.0*(q1(n,ii)++qint(n,ii))*t
     *                           +isoout2BLZS(n,l,ii)

!               CONVERGENCE LOOP:
                do ijk=1,50
!                 UPDATE THE TRACER MASS IN CHANNEL n
                  isostore2LC(n,l,ii)=isostore1LC(n,l,ii)+
     *              (isoin1LC(n,l,ii)+isoin2LC(n,l,ii)-
     *               isoout1LC(n,l,ii)-isoout2LC(n,l,ii))/2.
	            isostore2LC(n,l,ii)=amax1(isostore2LC(n,l,ii),0.00001)

!                 UPDATE THE CONCENTRATION
                  isoconcLC(n,l,ii)=isostore2LC(n,l,ii)/store2(n)

!                 COMPUTE THE TRACER MASS LEAVING THE GRID...
!                 EVAP LOSS TO PRESERVE FLOW BALANCES.
!                 THIS SHOULD BE BACK DATED ONE TIME STEP
                  isoout2LC(n,l,ii)=isoconcLC(n,l,ii)*qo2(n)*t
     *                             -isoconcLC(n,l,ii)*strloss(n)*t
	            isoout2LC(n,l,ii)=amax1(isoout2LC(n,l,ii),0.00001)

!                 CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                  if(abs(isoout2LC(n,l,ii)-isooutold).lt.0.01*isooutold) 
     *              GOTO 20
                  isooutold=isoout2LC(n,l,ii)
                end do
   20           CONTINUE

              else
               isostore2LC(n,l,ii)=0.0
               isoout2LC(n,l,ii)=0.0
              end if
!             ISOTOPES ARE CONSERVATIVE!
              decay = 0.0
!             UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT 
!             GRID IS NOT A "DUMMY GRID"
              if(lnxt.ne.0)
     *           isoin2LC(lll,lnxt,ii)=(1-(decay/100))*
     *                       (isoin2LC(lll,lnxt,ii)+isoout2LC(n,l,ii))

!             ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
              massin(n)=(isoin1LC(n,l,ii)+isoin2LC(n,l,ii))/2.
              massout(n)=(isoout1LC(n,l,ii)+isoout2LC(n,l,ii))/2.
              masstore(n)=(isostore2LC(n,l,ii)-isostore1LC(n,l,ii))
              ISOdelta(n)=massin(n)-massout(n)

            endif    ! SLOPE>=0 AND L.NE.0


!           conditional added March23/06 nk
!           needed when grid is outside the gauged area
            if(l.ne.0)then   
              isosum(n,l)=isosum(n,l)+isoout2LC(n,l,ii)
            endif

!	    end do     ! classcount LOOP


!         CHECK OVERALL MASS BALANCE:
!         MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
          if(iz.ne.jz.and.n.eq.nnprint)then
            sqerr=(ISOdelta(n)-masstore(n))**2.
            write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                    masstore(n),sqerr
	    endif

          else
!          IN A LAKE, DON'T RUN TRACER!
	     CONTINUE 
	    endif

        end do       ! GRID NO./BASIN NO. LOOP

!       WRITE OUT DATA TO TRACER.CSV FILE
        if(iz.ne.jz)then     ! Prints every hour
!        if(jan.eq.3)then    ! Prints every 0.25 hours
          do l=1,no
!           STORES THE GRID NUMBERS AS FXN OF GAUGE NO.
            nn(l)=s(iy(l),jx(l))
          end do
!         WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!         GRID=NNPRINT. USE ii TO CYCLE THRU LCOVERS CAUSE W/IN l DO-LOOP.
!         UNITS: isoout2LC(n,ii)=[kg]/[s]=[m^3/s]
!         NB: TRACER OUTFLOW BASED ON MASS TO ACCOUNT FOR EVAP. LOSS

!          write(90,9002)time,(l,qo2(nn(l)),isosum(nn(l),l)/t,
!     *(isoout2LC(nn(l),l,ii)/t,isoconcLC(nn(l),l,ii),ii=1,classcount),l=1,no)





!     debug check added May 11/10  nk
	if(iopt.ge.1)then
          write(92,9002)time,(l,qo2(nn(l)),isosum(nn(l),l)/t,
     *   isoout2LC(nn(l),l,ii)/t,isoconcLC(nn(l),l,ii),l=1,no)

!        added Mar. 17/06    nk   glacier component.
!        outputs are grouped by subwatershed
         if(mod(iz,24).eq.0)then
!           write(92,9003)time,
!     *     ((qo2(nn(l))*(1.0-isoconcLC(nn(l),l,ii)),ii=1,classcount),l=1,no)
           write(90,9003)time,
     *     (qo2(nn(l))*isoconcLC(nn(l),l,ii),l=1,no)
!     *     (qo2(nn(l))*(1.0-isoconcLC(nn(l),l,ii)),l=1,no)
         endif

	endif





	  endif



! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
 9002 FORMAT(f10.3,<no>(',',I15,2(',',f15.5),2(',',f15.5)))
 9003 format(f10.0,<no>(',',f10.3))


      RETURN
      END SUBROUTINE tracer1      SUBROUTINE tracer2(iz,jz,time,t,jan,tdum)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! LANDCOVER TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the amount of runoff coming from individual landclasses.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!
!*****************************************************************************

c      USE area1
c	USE area2
c      USE area3
c      USE area4
c      USE area5
c      USE area6
c	USE area10
cc      USE areaet
c	USE areamelt
c      USE areatrc
c	USE areawet

      use area_watflood
	implicit none


!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,lll,l,iz,jz,ii,jj,i,j,jan,ios,inxt,jnxt,lnxt
      REAL*4  :: wi,wold,t,woldn,woldp,isooutold,decay,time
     	REAL*4  :: tdum



      if(index.eq.0)then
        do n=1,na
          res(n)=0
        end do

        do n=1,na
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 2 => LANDCOVER TRACER                              * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      if(itrace.eq.2)then    

!       INITIALIZE AND RESET VALUES FOR EACH TIME STEP
        do n=1,na
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)	    
	    if(l.ne.0)then
            isosum(n,l)=0.0
		  do ii=1,classcount
!             INITIALIZE TRACERS:
              isoin1LC(n,l,ii)=isoin2LC(n,l,ii)
              isoin2LC(n,l,ii)=0.0
              isoout1LC(n,l,ii)=isoout2LC(n,l,ii)
              isoout2LC(n,l,ii)=0.0
              isostore1LC(n,l,ii)=isostore2LC(n,l,ii)
              isostore2LC(n,l,ii)=0
	        isoin1BLZS(n,l,ii)=isoin2BLZS(n,l,ii)
              isoin2BLZS(n,l,ii)=0.0
	        isoout1BLZS(n,l,ii)=isoout2BLZS(n,l,ii)
	        isoout2BLZS(n,l,ii)=0.0
              isoBLZS1(n,l,ii)=isoBLZS2(n,l,ii)
	        isoBLZS2(n,l,ii)=0.0
	      end do
	    endif
	  end do

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        do n=1,naa
          lll=next(n)
          inxt=yyy(lll)
          jnxt=xxx(lll)
	    lnxt=nbasin(inxt,jnxt)

          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)

!         RUN TRACER CODE ONLY IF NOT IN A LAKE
          if(ireach(n).le.0.0 .OR.
     *       ireach(n).gt.0.and.res(n).gt.0) then


          do ii=1,classcount

!       ^^^^^^^^^^^^^ GW ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!           TO GET MASS OF TRACER ENTERING STREAM FROM QLZ
            if(qlz(n).ne.0.0.and.l.ne.0)then
              isooutold=1.0e+25

!             CALC MASS OF TRACER GOING INTO GW STORAGE, SET INITIAL
!             CONCENTRATION AS 1 kg/m^3 * m^s/3 * s = KG
              isoin2BLZS(n,l,ii)=isoin2BLZS(n,l,ii)+
     *                       1.0*drng(n,ii)*frac(n)*tdum*(1-sca(n,ii))*t
     *                      +1.0*drngfs(n,ii)*frac(n)*tdum*sca(n,ii)*t

!             CONVERGENCE LOOP:
              do ijk=1,50
!               UPDATE THE TRACER MASS IN GW STORAGE
                isoBLZS2(n,l,ii)=isoBLZS1(n,l,ii)+
     *            (isoin1BLZS(n,l,ii)+isoin2BLZS(n,l,ii)-
     *             isoout1BLZS(n,l,ii)-isoout2BLZS(n,l,ii))/2.
	          isoBLZS2(n,l,ii)=amax1(isoBLZS2(n,l,ii),0.00001)

!               UPDATE CONCENTRATION USING INSTANT MIXING!! 
!               GIVES UNITS KG/m^3
                isoconcBLZS(n,l,ii)=isoBLZS2(n,l,ii)/lzs(n)

!               COMPUTE THE TRACER MASS LEAVING THE LZS
!               THIS SHOULD BE BACK DATED ONE TIME STEP
!               KG/m^3 * m^3/s * s = KG
!               ASSUME: NO EVAP IN SOIL COLUMN!!
                isoout2BLZS(n,l,ii)=isoconcBLZS(n,l,ii)*qlz(n)*t

!               CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                if(abs(isoout2BLZS(n,l,ii)-isooutold).lt.0.01*isooutold) 
     *            GOTO 21
                isooutold=isoout2BLZS(n,l,ii)
              end do
   21         CONTINUE
            else
             isoBLZS2(n,l,ii)=0.0
             isoout2BLZS(n,l,ii)=0.0
            end if

!       ^^^^^^^^^^^^^ CHANNEL ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!           ROUTED QLZ CONTRIBUTION ADDED TO CHANNEL AND ROUTED AGAIN.
!           WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!           IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!           IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
            if(slope(n).gt.0.0.and.l.ne.0)then
              if(store2(n).ne.0.0)then
                isooutold=1.0e+25
!               SET INITIAL CONCENTRATION AS 1 kg/m^3
!        * * * NOTE: THIS DOES NOT ACCOUNT FOR WETLANDS!!!
!               ADD TRACER TO SW FLOWS, PLUS ROUTED GW TRACER:
                isoin2LC(n,l,ii)=isoin2LC(n,l,ii)+1.0*(q1(n,ii)+
     *                           q1fs(n,ii)+qint(n,ii)+qintfs(n,ii))*t+
     *                           isoout2BLZS(n,l,ii)

!               CONVERGENCE LOOP:
                do ijk=1,50
!                 UPDATE THE TRACER MASS IN CHANNEL n
                  isostore2LC(n,l,ii)=isostore1LC(n,l,ii)+
     *              (isoin1LC(n,l,ii)+isoin2LC(n,l,ii)-
     *               isoout1LC(n,l,ii)-isoout2LC(n,l,ii))/2.
	            isostore2LC(n,l,ii)=amax1(isostore2LC(n,l,ii),0.00001)

!                 UPDATE THE CONCENTRATION
                  isoconcLC(n,l,ii)=isostore2LC(n,l,ii)/store2(n)

!                 COMPUTE THE TRACER MASS LEAVING THE GRID...
!                 EVAP LOSS TO PRESERVE FLOW BALANCES.
!                 THIS SHOULD BE BACK DATED ONE TIME STEP
                  isoout2LC(n,l,ii)=isoconcLC(n,l,ii)*qo2(n)*t
     *                             -isoconcLC(n,l,ii)*strloss(n)*t
	            isoout2LC(n,l,ii)=amax1(isoout2LC(n,l,ii),0.00001)

!                 CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                  if(abs(isoout2LC(n,l,ii)-isooutold).lt.0.01*isooutold) 
     *              GOTO 20
                  isooutold=isoout2LC(n,l,ii)
                end do
   20           CONTINUE

              else
               isostore2LC(n,l,ii)=0.0
               isoout2LC(n,l,ii)=0.0
              end if
!             ISOTOPES ARE CONSERVATIVE!
              decay = 0.0
!             UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT 
!             GRID IS NOT A "DUMMY GRID"
              if(lnxt.ne.0)
     *           isoin2LC(lll,lnxt,ii)=(1-(decay/100))*
     *                       (isoin2LC(lll,lnxt,ii)+isoout2LC(n,l,ii))

!             ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
              massin(n)=(isoin1LC(n,l,ii)+isoin2LC(n,l,ii))/2.
              massout(n)=(isoout1LC(n,l,ii)+isoout2LC(n,l,ii))/2.
              masstore(n)=(isostore2LC(n,l,ii)-isostore1LC(n,l,ii))
              ISOdelta(n)=massin(n)-massout(n)

            endif    ! SLOPE>=0 AND L.NE.0
            isosum(n,l)=isosum(n,l)+isoout2LC(n,l,ii)


	    end do     ! classcount LOOP


!         CHECK OVERALL MASS BALANCE:
!         MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
          if(iz.ne.jz.and.n.eq.nnprint)then
            sqerr=(ISOdelta(n)-masstore(n))**2.
            write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                    masstore(n),sqerr
	    endif

          else
!          IN A LAKE, DON'T RUN TRACER!
	     CONTINUE 
	    endif

        end do       ! GRID NO./BASIN NO. LOOP

!       WRITE OUT DATA TO TRACER.CSV FILE
        if(iz.ne.jz)then     ! Prints every hour
!        if(jan.eq.3)then    ! Prints every 0.25 hours
          do l=1,no
!           STORES THE GRID NUMBERS AS FXN OF GAUGE NO.
            nn(l)=s(iy(l),jx(l))
          end do
!         WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!         GRID=NNPRINT. USE ii TO CYCLE THRU LCOVERS CAUSE W/IN l DO-LOOP.
!         UNITS: isoout2LC(n,ii)=[kg]/[s]=[m^3/s]
!         NB: TRACER OUTFLOW BASED ON MASS TO ACCOUNT FOR EVAP. LOSS
          write(90,9002)time,(l,qo2(nn(l)),isosum(nn(l),l)/t,
     *     (isoout2LC(nn(l),l,ii)/t,isoconcLC(nn(l),l,ii),
     *                ii=1,classcount),l=1,no)

!     debug check added May 11/10  nk
	if(iopt.ge.1)then

!        added Mar. 17/06    nk  temporary fix to get glacier component.
!        outputs are grouped by subwatershed
         if(mod(iz,24).eq.0)then
           ii=6
!           write(92,9003)time,
!     *     ((qo2(nn(l))*(1.0-isoconcLC(nn(l),l,ii)),ii=1,classcount),l=1,no)
           write(92,9003)time,
     *     (qo2(nn(l))*(1.0-isoconcLC(nn(l),l,ii)),l=1,no)
         endif

      endif

	  endif

	endif      ! LANDCOVER TRACER



! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
 9002 FORMAT(f10.3,<no>(2(',',I15),2(',',f15.5),
     *                <classcount>(2(',',f15.5))))
 9003 format(f10.0,<no*classcount>(',',f10.3))


      RETURN
      END SUBROUTINE tracer2      SUBROUTINE tracer3(iz,jz,time,t,jan,tdum)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! RAIN-ON-STREAM TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the amount of water coming from new rain.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!
!*****************************************************************************

c      USE area1
c	USE area2
c      USE area3
c      USE area4
c      USE area5
c      USE area6
cc	USE area9
c	USE area10
cc      USE areaet
cc	USE areamelt
c      USE areatrc
c	USE areawet

      USE area_watflood
      implicit none



!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,lll,l,iz,jz,ii,jj,i,j,jan,ios,inxt,jnxt,lnxt
      REAL*4  :: wi,wold,t,woldn,woldp,isooutold,decay,time
     	REAL*4  :: tdum
                 

      if(index.eq.0)then
        do n=1,na
          res(n)=0
        end do

        do n=1,na
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 3 => RAIN-ON-STREAM TRACER (QSTREAM)               * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      if(itrace.eq.3)then

!       INITIALIZE AND RESET VALUES FOR EACH TIME STEP
        do n=1,na
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)	    
	    if(l.ne.0)then
!           INITIALIZE TRACERS:
            isoin1P(n,l)=isoin2P(n,l)
            isoin2P(n,l)=0.0
            isoout1P(n,l)=isoout2P(n,l)
            isoout2P(n,l)=0.0
            isostore1P(n,l)=isostore2P(n,l)
            isostore2P(n,l)=0.0
	    endif
        end do

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
        do n=1,naa
          lll=next(n)
          inxt=yyy(lll)
          jnxt=xxx(lll)
	    lnxt=nbasin(inxt,jnxt)

          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)

!         RUN TRACER CODE ONLY IF NOT IN A LAKE
          if(ireach(n).le.0.0 .OR.
     *       ireach(n).gt.0.and.res(n).gt.0) then

!         WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!         IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!         IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
          if(slope(n).gt.0.0.and.l.ne.0)then
            if(store2(n).ne.0.0)then
               isooutold=1.0e+25

!              SET INITIAL CONCENTRATION AS 1 kg/m^3
!              INCLUDES ONLY GW
               isoin2P(n,l)=isoin2P(n,l)+1.0*qstrm(n)*t

!              CONVERGENCE LOOP:
               do ijk=1,50

!                UPDATE THE TRACER MASS IN CHANNEL n
                 isostore2P(n,l)=isostore1P(n,l)+(isoin1P(n,l)+
     *                      isoin2P(n,l)-isoout1P(n,l)-isoout2P(n,l))/2.
	           isostore2P(n,l)=amax1(isostore2P(n,l),0.00001)

!                UPDATE THE CONCENTRATION
                 isoconcP(n,l)=isostore2P(n,l)/store2(n)

!                COMPUTE THE TRACER MASS LEAVING THE GRID...ACCOUNTING FOR
!                EVAP LOSS TO PRESERVE FLOW BALANCES.
!                THIS SHOULD BE BACK DATED ONE TIME STEP
                 isoout2P(n,l)=isoconcP(n,l)*qo2(n)*t
     *                      -isoconcP(n,l)*strloss(n)*t
	           isoout2P(n,l)=amax1(isoout2P(n,l),0.00001)

!                CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                 if(abs(isoout2P(n,l)-isooutold).lt.0.0001) 
     *              GOTO 30
                 isooutold=isoout2P(n,l)
               end do
   30          CONTINUE

            else
              isostore2P(n,l)=0.0
              isoout2P(n,l)=0.0
            end if

!            DECREASED BY THE AMOUNT OF DEPOSITION:            
!            wi2(lll)=(1-(sdep/100))*(wi2(lll)+wo2(n))

!           ISOTOPES ARE CONSERVATIVE!
            decay=0.0
!           UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT
!           GRID IS NOT A "DUMMY GRID"
            if(lnxt.ne.0)
     *         isoin2P(lll,lnxt)=(1-(decay/100))*(isoin2P(lll,lnxt)+
     *                                      isoout2P(n,l))

!           ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
            massin(n)=(isoin1P(n,l)+isoin2P(n,l))/2.
            massout(n)=(isoout1P(n,l)+isoout2P(n,l))/2.
            masstore(n)=(isostore2P(n,l)-isostore1P(n,l))
            ISOdelta(n)=massin(n)-massout(n)


 !          CHECK OVERALL MASS BALANCE:
 !          MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
            if(iz.ne.jz.and.n.eq.nnprint)then
              sqerr=(ISOdelta(n)-masstore(n))**2.
              write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                      masstore(n),sqerr
	      endif 

          endif  ! SLOPE>=0 AND L.NE.0

          else
!           IN A LAKE, DON'T RUN TRACER!
	      CONTINUE 
	    endif


        end do   ! GRID NO. LOOP

!       WRITE OUT DATA TO TRACER.CSV FILE
!        if(jan.eq.3)then    ! Prints every 0.25 hours
        if(iz.ne.jz)then     ! Prints every hour
          do l=1,no
!           STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
            nn(l)=s(iy(l),jx(l))
	    end do
!         WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!         GRID=NNPRINT. 
!         UNITS: isoout2IBN(n,ll)=[kg]/[s]=[kg/s]=[m^3/s]
!         NB: TRACER OUTFLOW BASED ON MASS TO ACCOUNT FOR EVAP. LOSS
          write(90,9003)time,
     *     (l,nn(l),qo2(nn(l)),qstrm(nn(l)),strloss(nn(l)),
     *      isoout2P(nn(l),l)/t,isoconcP(nn(l),l),l=1,no)
        endif

	endif      ! RAIN-ON-STREAM TRACER



! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
 9003 FORMAT(f10.3,<no>(2(',',I15),5(',',f15.5)))


      RETURN
      END SUBROUTINE tracer3
      SUBROUTINE tracer4(iz,jz,time,t,jan,tdum,jjz,jjzold)

!***********************************************************************
!    Copyright (C) 2008 by Tricia Stadnyk, Tegan Holmes and Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! FLOW-TYPE TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the proportion of runoff from each different flow type.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!     REV. 9.8.18  Apr.  26/11 - NK: Added in-basin check in tracer4
!     REV. 9.8.77  July  2013  - TH: Added lake routing, diversions & nudging
!     REV.         Feb.  4/16  - TH: Replaced convergence loop with direct solution
!
!*****************************************************************************


      use area_watflood
	implicit none

!     SEE tracerGW.f FOR MORE COMPLETE COMMENTS
!     FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,m,lll,l,iz,jz,i,j,jan,inxt,jnxt,lnxt
	INTEGER :: rbin,resnum,jjz,jjzold,ii,jj
      REAL*4  :: t,time,GWchk,SWchk,IFchk
     	REAL*4  :: tdum,roe 
     	logical :: firstpass,trace_off
     	
     	data firstpass/.true./
      data trace_off/.false./

      if(firstpass)then
          do l=1,no
!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
              if(inbsnflg(l).eq.1)then    ! added nk Jan. 05/11
!             STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
                  nn(l)=s(iy(l),jx(l))
              else
!     rev. 9.8.18  Apr.  26/11  - NK: Added in-basin check in tracer4
                  nn(l)=-1
              endif
          end do
          do l=1,no
d             print*,l,iy(l),jx(l),nn(l)    !ok
              if(nn(l).le.0)then
                  trace_off=.true.
                  trcflg='n'
                  print*
                  print*,'WARNING:'
                  print*,'Tracers do not work when lakes are outside '
                  print*,'the model domain as when using a '
                  print*,'sub-watershed derived from a larger domain '
                  print*,'without making new reach numbers'
                  print*,'Reach # ',l,' is outside the watershed'
                  print*,'Grid #  ',s(iy(l),jx(l))
                  print*,'inbsnflg',inbsnflg
                  print*,'NOTE:'
                  Print*,'Program continues without doing tacers<<<<<<<'
                  print*
              endif
c              pause 'In tracer4'
c              return
          end do
	endif

      res_set: if(index==0)then
        do n=1,naa
          res(n)=0
        end do

        do n=1,naa
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif res_set
      

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 4 => FLOW-TYPE TRACER (SW, IF, GW)                 * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     INITIALIZE AND RESET VALUES FOR EACH TIME STEP
      initialize: do n=1,naa
        i=yyy(n)
        j=xxx(n)
        
        
        
        l=nbasin(i,j)
c        l=1
        
        
	  lll=next(n)
	  resnum=ireach(n)
	  rbin=ireach(lll)

        if(rbin.ne.0) then
          isolakeGW(rbin)=0.0
          isolakeSW(rbin)=0.0
          isolakeIF(rbin)=0.0
          isolakest(rbin)=0.0
	  endif

	  isosumQ(n)=0.0

	  if(l.ne.0)then
          isoin1GW(n,l)=isoin2GW(n,l)
          isoin2GW(n,l)=0.0
          isoout1GW(n,l)=isoout2GW(n,l)
          isoout2GW(n,l)=0.0
          isostore1GW(n,l)=isostore2GW(n,l)
          isostore2GW(n,l)=0.0
          isoin1SW(n,l)=isoin2SW(n,l)
          isoin2SW(n,l)=0.0
          isoout1SW(n,l)=isoout2SW(n,l)
          isoout2SW(n,l)=0.0
          isostore1SW(n,l)=isostore2SW(n,l)
          isostore2SW(n,l)=0.0
          isoin1IF(n,l)=isoin2IF(n,l)
          isoin2IF(n,l)=0.0
          isoout1IF(n,l)=isoout2IF(n,l)
          isoout2IF(n,l)=0.0
          isostore1IF(n,l)=isostore2IF(n,l)
          isostore2IF(n,l)=0.0
	    if(wetflg.eq.'y')then
            isoin1wet(n,l)=isoin2wet(n,l)
            isoin2wet(n,l)=0.0
            isoout1wet(n,l)=isoout2wet(n,l)
            isoout2wet(n,l)=0.0
            isowstore1(n,l)=isowstore2(n,l)
            isowstore2(n,l)=0.0
            isoin1SWwet(n,l)=isoin2SWwet(n,l)
            isoin2SWwet(n,l)=0.0
            isoout1SWwet(n,l)=isoout2SWwet(n,l)
            isoout2SWwet(n,l)=0.0
            isowstore1SW(n,l)=isowstore2SW(n,l)
            isowstore2SW(n,l)=0.0
            isoin1IFwet(n,l)=isoin2IFwet(n,l)
            isoin2IFwet(n,l)=0.0
            isoout1IFwet(n,l)=isoout2IFwet(n,l)
            isoout2IFwet(n,l)=0.0
            isowstore1IF(n,l)=isowstore2IF(n,l)
            isowstore2IF(n,l)=0.0
	    endif
	  endif
      end do initialize 

! trish  had to add the divertflg check

      if(divertflg.eq.'y')then
        divert: do m=1,nodivert
          n=gridgive(m)
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)
c          l=1
! NK  Jul. 22/2014         
!         It is possible that the give grid is outside the watershed
!         in which case nbasin(i,j) = 0   >>>  no good, so skip
!         it's not part of the tracer routing then anyways         
          if(l.gt.0)then
            isoin2GW(n,l)=isoin2GW(n,l)+0.75*qr(n)*t
            isoin2IF(n,l)=isoin2IF(n,l)+0.1*qr(n)*t
            isoin2SW(n,l)=isoin2SW(n,l)+0.05*qr(n)*t
          endif
        end do divert
      endif

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
      route: do n=1,naa
        lll=next(n)
        
        in_basin: if(lll>0)then       
        inxt=yyy(lll)
        jnxt=xxx(lll)
	  lnxt=nbasin(inxt,jnxt)
	  resnum=ireach(n)
	  rbin=ireach(lll)
        i=yyy(n)
        j=xxx(n)
          
          
          
          l=nbasin(i,j)
c          l=1
          
          
          

!	  WHEN IN LAKE, ADD OPEN WATER EVAPORATION FOR GRID 
!       TO TOTAL EVAPORATION FOR THE LAKE 
        lake_evap: if(resnum>0) then
          isolakest(resnum)=isolakest(resnum)+strloss(n)
        end if lake_evap
             
!       RUN TRACER CODE ONLY IF NOT IN A NON_OUTLET LAKE GRID
        if(resnum<=0.0 .OR.
     *     resnum>0.and.res(n)>0) then


!       WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!       IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!       IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
        if(slope(n)>0.0.and.l.ne.0)then
          if(store2(n)>0.0)then

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!              ROUTE TRACER THROUGH WETLAND FIRST (IF THERE ARE WETLANDS):
               if(wetland_flag(n)==.true.)then

!                SET INITIAL CONCENTRATION AS 1 kg/m^3]
!                UNITS:  = [KG]
!                TRACE MASS ENTERING WETLAND FROM FLOWPATH
                 isoin2wet(n,l)=isoin2wet(n,l)+1.0*qlz(n)*t
                 isoin2SWwet(n,l)=isoin2SWwet(n,l)
     *                           +1.0*(sumq1(n)+sumq1fs(n))*t
                 isoin2IFwet(n,l)=isoin2IFwet(n,l)
     *                           +1.0*(sumqint(n)+sumqintfs(n))*t


                 

                 if(qowet2(n).ge.0.0)then
!                  SPECIFY INITIAL MASS FOR CHANNEL FROM WETLAND:
                   call tracewet(iz,jz,time,n,l,t)
                   isoin2GW(n,l)=isoin2GW(n,l)+isooutwet1
                   isoin2SW(n,l)=isoin2SW(n,l)+isooutwet2
                   isoin2IF(n,l)=isoin2IF(n,l)+isooutwet3

	           else   ! qowet2(n) is -ve
!                  SPECIFY INITIAL MASS IN WETLAND (+MASS FROM CHANNEL)
!                  NOTE: -VE CAUSE QOWET2 IS -VE BUT MASS IS ADDED!

                   isoin2wet(n,l)=isoin2wet(n,l)  
     *                           -isoconcGW(n,l)*qowet2(n)*t
                   isoin2SWwet(n,l)=isoin2SWwet(n,l)
     *                             -isoconcSW(n,l)*qowet2(n)*t
                   isoin2IFwet(n,l)=isoin2IFwet(n,l)
     *                             -isoconcIF(n,l)*qowet2(n)*t

                   isoin2GW(n,l)=isoin2GW(n,l)
     *                          +isoconcGW(n,l)*qowet2(n)*t
                   isoin2SW(n,l)=isoin2SW(n,l)
     *                          +isoconcSW(n,l)*qowet2(n)*t
                   isoin2IF(n,l)=isoin2IF(n,l)
     *                          +isoconcIF(n,l)*qowet2(n)*t
                   call tracewet(iz,jz,time,n,l,t)
	           endif

	         else
!                SET INITIAL CONCENTRATION AS 1 kg/m^3
!                UNITS:  = [KG]
	           isoin2GW(n,l)=isoin2GW(n,l)+1.0*qlz(n)*t
                 isoin2SW(n,l)=isoin2SW(n,l)
     *                        +1.0*(sumq1(n)+sumq1fs(n))*t
                 isoin2IF(n,l)=isoin2IF(n,l)
     *                        +1.0*(sumqint(n)+sumqintfs(n))*t
     
!	           AT LAKE OUTLET, MAKE INFLOW EQUAL THE ACCUMULATED INFLOWS TO WHOLE LAKE
	           if(resnum>0.AND.res(n)>0)then
	               isoin2GW(n,l)=isolakeGW(resnum)
	               isoin2SW(n,l)=isolakeSW(resnum)
	               isoin2IF(n,l)=isolakeIF(resnum)
	           end if
	               
	        endif


! NO WETLANDS AND QOWET2 IS +VE (OR ALREADY REROUTED THRU WETLAND)
!            CHANNEL ROUTING OR WETLAND->CHANNEL ROUTING
!            ROUTE TRACER THROUGH CHANNEL - CONVERGENCE LOOP:

!            UPDATE THE TRACER MASSES IN CHANNEL     

!            COMPUTE THE TRACER MASSES LEAVING THE GRID...
!            EVAP LOSS ADDED TO PRESERVE FLOW BALANCES.
             if(resnum>0.AND.res(n)>0)then
               isostore2GW(n,l)=(isostore1GW(n,l)+(isoin1GW(n,l)+
     *               isoin2GW(n,l)-isoout1GW(n,l))/2.)
     *              /(1.0+(qo2(n)*coeff(n)+isolakest(resnum))*t
     *              /2.0/store2(n))
	         isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)
	         isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
               isoout2GW(n,l)=isoconcGW(n,l)*qo2(n)*t*coeff(n)
     *                     +isoconcGW(n,l)*isolakest(resnum)*t
     	         isoout2GW(n,l)=amax1(isoout2GW(n,l),0.00001)
     	         
     	         isostore2SW(n,l)=(isostore1SW(n,l)+(isoin1SW(n,l)+
     *               isoin2SW(n,l)-isoout1SW(n,l))/2.)
     *               /(1.0+(qo2(n)*coeff(n)+isolakest(resnum))*t
     *              /2.0/store2(n))
	         isostore2SW(n,l)=amax1(isostore2SW(n,l),0.00001)
	         isoconcSW(n,l)=isostore2SW(n,l)/store2(n)
     	         isoout2SW(n,l)=isoconcSW(n,l)*qo2(n)*t*coeff(n)
     *                     +isoconcSW(n,l)*isolakest(resnum)*t
     	         isoout2SW(n,l)=amax1(isoout2SW(n,l),0.00001)
     	         
     	         isostore2IF(n,l)=(isostore1IF(n,l)+(isoin1IF(n,l)+
     *               isoin2IF(n,l)-isoout1IF(n,l))/2.)
     *               /(1.0+(qo2(n)*coeff(n)+isolakest(resnum))*t
     *              /2.0/store2(n))
	         isostore2IF(n,l)=amax1(isostore2IF(n,l),0.00001)
	         isoconcIF(n,l)=isostore2IF(n,l)/store2(n)  
     	         isoout2IF(n,l)=isoconcIF(n,l)*qo2(n)*t*coeff(n)
     *                     +isoconcIF(n,l)*isolakest(resnum)*t
     	         isoout2IF(n,l)=amax1(isoout2IF(n,l),0.00001)
     	           
             else
               isostore2GW(n,l)=(isostore1GW(n,l)+(isoin1GW(n,l)+
     *               isoin2GW(n,l)-isoout1GW(n,l))/2.)
     *              /(1.0+(qo2(n)*coeff(n)+strloss(n))*t
     *              /2.0/store2(n))
	         isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)
	         isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
               isoout2GW(n,l)=isoconcGW(n,l)*qo2(n)*t*coeff(n)
     *                       +isoconcGW(n,l)*strloss(n)*t
       	       isoout2GW(n,l)=amax1(isoout2GW(n,l),0.00001)

               isostore2SW(n,l)=(isostore1SW(n,l)+(isoin1SW(n,l)+
     *               isoin2SW(n,l)-isoout1SW(n,l))/2.)
     *               /(1.0+(qo2(n)*coeff(n)+strloss(n))*t
     *              /2.0/store2(n))
	         isostore2SW(n,l)=amax1(isostore2SW(n,l),0.00001)
	         isoconcSW(n,l)=isostore2SW(n,l)/store2(n)
               isoout2SW(n,l)=isoconcSW(n,l)*qo2(n)*t*coeff(n)
     *                       +isoconcSW(n,l)*strloss(n)*t
     	         isoout2SW(n,l)=amax1(isoout2SW(n,l),0.00001)

               isostore2IF(n,l)=(isostore1IF(n,l)+(isoin1IF(n,l)+
     *               isoin2IF(n,l)-isoout1IF(n,l))/2.)
     *               /(1.0+(qo2(n)*coeff(n)+strloss(n))*t
     *              /2.0/store2(n))
	         isostore2IF(n,l)=amax1(isostore2IF(n,l),0.00001)
	         isoconcIF(n,l)=isostore2IF(n,l)/store2(n)
               isoout2IF(n,l)=isoconcIF(n,l)*qo2(n)*t*coeff(n)
     *                       +isoconcIF(n,l)*strloss(n)*t
     	         isoout2IF(n,l)=amax1(isoout2IF(n,l),0.00001)
     	         
     	       end if
     	              
            isosumQ(n)=isoout2GW(n,l)+isoout2IF(n,l)+isoout2SW(n,l)
   
          else   ! follow what's done in rerout
!           TS: added May 21/08 s.t tracer works when store2<0
            if(isoin2GW(n,l).lt.0.0)then
              isoout2GW(n,l)=isoin2GW(n,l)/2.0
            else
              isoout2GW(n,l)=0.0
	      endif
            isostore2GW(n,l)=isostore1GW(n,l)+(isoin1GW(n,l)+
     *            isoin2GW(n,l)-isoout1GW(n,l)-isoout2GW(n,l))/2.
	      isostore2GW(n,l)=amax1(isostore2GW(n,l),0.001)
            isostore2SW(n,l)=0.0
            isoout2SW(n,l)=0.0
            isostore2IF(n,l)=0.0
            isoout2IF(n,l)=0.0
          end if
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
!         ISOTOPES ARE CONSERVATIVE!
!         NOTE: CAN USE THIS TO MODEL GW RETARDATION OF FLOW

!         ADD MASS OUTFLOW OF CURRENT GRID AS INFLOW TO LAKE (NEXT GRID) (cms)
!         BUT ONLY IF ON THE EDGE OF A LAKE (NOT IN A LAKE)
          if(rbin>0) then
           if(nopt(l)==2.and.n==iflowgrid(l))then
            isolakeGW(rbin)=isolakeGW(rbin)
     *            +qhyd(l,iz+1)*t*isoconcGW(n,l)
            isolakeSW(rbin)=isolakeSW(rbin)
     *            +qhyd(l,iz+1)*t*isoconcSW(n,l)
            isolakeIF(rbin)=isolakeIF(rbin)
     *            +qhyd(l,iz+1)*t*isoconcIF(n,l)
           else
            isolakeGW(rbin)=isolakeGW(rbin)+isoout2GW(n,l)
            isolakeSW(rbin)=isolakeSW(rbin)+isoout2SW(n,l)
            isolakeIF(rbin)=isolakeIF(rbin)+isoout2IF(n,l)

	     endif
	    end if


          if(lnxt/=0) then
          
           if(nopt(l)==2.and.n==iflowgrid(l))then
           
              isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *            +qhyd(l,iz+1)*t*isoconcGW(n,l)
              isoin2IF(lll,lnxt)=isoin2IF(lll,lnxt)
     *            +qhyd(l,iz+1)*t*isoconcIF(n,l)
              isoin2SW(lll,lnxt)=isoin2SW(lll,lnxt)
     *            +qhyd(l,iz+1)*t*isoconcSW(n,l)
     
           else
            if(resnum>0.AND.res(n)>0)then
            
             isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *       +isoout2GW(n,l)-isoconcGW(n,l)*isolakest(resnum)*t
     
             isoin2IF(lll,lnxt)=isoin2IF(lll,lnxt)
     *       +isoout2IF(n,l)-isoconcIF(n,l)*isolakest(resnum)*t
     
             isoin2SW(lll,lnxt)=isoin2SW(lll,lnxt)
     *       +isoout2SW(n,l)-isoconcSW(n,l)*isolakest(resnum)*t
     
            else
             
             isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *       +isoout2GW(n,l)-isoconcGW(n,l)*strloss(n)*t
     
             isoin2IF(lll,lnxt)=isoin2IF(lll,lnxt)
     *       +isoout2IF(n,l)-isoconcIF(n,l)*strloss(n)*t
     
             isoin2SW(lll,lnxt)=isoin2SW(lll,lnxt)
     *       +isoout2SW(n,l)-isoconcSW(n,l)*strloss(n)*t
     
            end if
           end if
          endif


!         ERROR CHECK: ALL COMPONENTS MUST SUM TO TOTAL SIM'D Q
!         CAUSE SOME CONC'NS > 1.0 FROM ABOVE...
          isosumQ(n)=isoout2SW(n,l)+isoout2IF(n,l)+isoout2GW(n,l)

 !        ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
          massin(n)=(isoin1GW(n,l)+isoin2GW(n,l))/2.
     *             +(isoin1SW(n,l)+isoin2SW(n,l))/2.
     *             +(isoin1IF(n,l)+isoin2IF(n,l))/2.
          massout(n)=(isoout1GW(n,l)+isoout2GW(n,l))/2.
     *              +(isoout1SW(n,l)+isoout2SW(n,l))/2.
     *              +(isoout1IF(n,l)+isoout2IF(n,l))/2.
          masstore(n)=(isostore2GW(n,l)-isostore1GW(n,l))
     *               +(isostore2SW(n,l)-isostore1SW(n,l))
     *               +(isostore2IF(n,l)-isostore1IF(n,l))
          ISOdelta(n)=massin(n)-massout(n)
 
 !        CHECK OVERALL MASS BALANCE:
 !        MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
          if(iz.ne.jz.and.n.eq.nnprint)then
            sqerr=(ISOdelta(n)-masstore(n))**2.
            write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                    masstore(n),sqerr
	    endif
	    
        endif  ! SLOPE>=0 AND L.NE.0

        else   ! IREACH(N).gt.0 but res(n)=0
!         IN A LAKE, PASS UPSTREAM GROUNDWATER TO D/S GRID


! trish   rbin was 0 here so crashed when running debug  NK 20140626
! NK  Jul. 22/2014         
!         It is possible that the give grid is outside the watershed
!         in which case l = nbasin(i,j) = 0   >>>  no good, so skip
!         it's not part of the tracer routing then anyways         
            if(rbin.gt.0.and.l.gt.0)then
	        isoout2GW(n,l)=isolakeGW(rbin) 
	      endif

	  endif

	  tt(n)=rl(n)*chaxa(n)/qo2(n)
c	 if(n==595)write(230,*)isolakeGW(19),t,iz
c     * ,jz

        end if in_basin         !  lll<0
     
      end do route              ! GRID NO. LOOP
     

!     WRITE OUT DATA TO TRACER.CSV FILE
!      if(jan.eq.3)then    ! Prints every 0.25 hours
c      if(iz.ne.jz.and.dds_flag.ne.1)then     ! Prints every hour
      if(iz.ne.jz)then     ! Prints every hour
c        do l=1,no
c!     rev. 9.7.16  Jan.  05/11  - NK: Fixed init flows outside sub-basin
c          if(inbsnflg(l).eq.1)then    ! added nk Jan. 05/11
c!           STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
c            nn(l)=s(iy(l),jx(l))
c          else
c!     rev. 9.8.18  Apr.  26/11  - NK: Added in-basin check in tracer4
c            nn(l)=-1
c          endif
c	  end do
!       WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!       GRID=NNPRINT. 
!       UNITS: isoout2IBN(n,ll)=[kg]/[s]=[kg/s]=[m^3/s]
!       NB: TRACER OUTFLOW BASED ON MASS TO ACCOUNT FOR EVAP. LOSS

!Trish:
! problems for partial watersheds   fix fix fix  nk
c      if(mod(int(totaltime),kt).eq.0.and.nn(l).gt.0)

      if(firstpass)then
          do l=1,no
              if(nn(l).le.0)trace_off=.true.
          end do
      endif


        if(mod(int(totaltime),kt).eq.0)then

            
         write(90,9014)totaltime,
     *     (qo2(nn(l))*isoconcSW(nn(l),l),                   !isoconcSW(nn(l),l),
     *      qo2(nn(l))*isoconcIF(nn(l),l),                   !isoconcIF(nn(l),l),
     *      qo2(nn(l))*isoconcGW(nn(l),l),l=1,no)            !isoconcGW(nn(l),l),l=1,no)

         endif

cc	  if(dds_flag.ne.1)
cd          write(999,12345)time,
cd    *          (qo2(nn(l)),isosumQ(nn(l))/t,
cd    *          (qo2(nn(l))-isosumQ(nn(l))/t),l=1,no)


      endif

      firstpass=.false.

! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9004 FORMAT(f10.3,<no>(2(',',I15),10(',',f15.5)))
 9014 FORMAT(f10.3,<no>(3(',',f15.5)))
12345 FORMAT(f10.3,<no>(3(',',f15.5)))


      RETURN
      END SUBROUTINE tracer4      SUBROUTINE tracer5(iz,jz,time,t,jan,tdum,jjz,jjzold)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! SNOW-MELT TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the amount of runoff from e4ach flow-type includ. melt H20.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!
!*****************************************************************************


      use area_watflood
	implicit none


!*****NOTE: THIS PROGRAM ASSUMES (FOR NOW) ZERO BACKGROUND CONCENTRATIONS
!*****OF THE TRACERS.  FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,lll,l,iz,jz,ii,jj,i,j,jan,ios,inxt,jnxt,lnxt
	INTEGER :: rbin,jjz,jjzold
      REAL*4  :: wi,wold,t,woldn,woldp,decay,time,
     *           GWchk,GWfschk,SWchk,SWfschk,IFchk,IFfschk,isooutold1,
     *           isooutold2,isooutold3,isooutold4,isooutold5,isooutold6,
     *           isooutold7,isooutold8
     	REAL*4  :: tdum,isoratio,roe
c     	REAL*4  :: tdum,isoratio,ro


      roe=1.0    ! not used in this s/r  nk

      if(index.eq.0)then
        do n=1,na
          res(n)=0
        end do

        do n=1,na
          lll=next(n)
          do l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
          end do
        end do
      endif

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 5 => SNOWMELT TRACER (SW,IF,GW)                      * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	
      if(itrace.eq.5)then

!       INITIALIZE AND RESET VALUES FOR EACH TIME STEP
        do n=1,na
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)
	    lll=next(n)
	    if(lll.ne.0) rbin=ireach(lll)

          if(rbin.ne.0 .and. iz.ne.jz) then
!           RESET TO '0' ONLY IF TIME HAS CHANGED
!           OTHERWISE, KEEP ACCUMULATING THE MASS!
!  	      print*,'initializing isolakeGW',jjz,jjzold,rbin
! 	      pause
            isolakeGW(rbin)=0.0
	    endif

	    isosumQ(n)=0.0
	    isosumQfs(n)=0.0

	    if(l.ne.0)then
            isoin1SW(n,l)=isoin2SW(n,l)
            isoin2SW(n,l)=0.0
            isoout1SW(n,l)=isoout2SW(n,l)
            isoout2SW(n,l)=0.0
            isostore1SW(n,l)=isostore2SW(n,l)
            isostore2SW(n,l)=0.0
            isoin1SWfs(n,l)=isoin2SWfs(n,l)
            isoin2SWfs(n,l)=0.0
            isoout1SWfs(n,l)=isoout2SWfs(n,l)
            isoout2SWfs(n,l)=0.0
            isostore1SWfs(n,l)=isostore2SWfs(n,l)
            isostore2SWfs(n,l)=0.0
            isoin1IF(n,l)=isoin2IF(n,l)
            isoin2IF(n,l)=0.0
            isoout1IF(n,l)=isoout2IF(n,l)
            isoout2IF(n,l)=0.0
            isostore1IF(n,l)=isostore2IF(n,l)
            isostore2IF(n,l)=0.0
            isoin1IFfs(n,l)=isoin2IFfs(n,l)
            isoin2IFfs(n,l)=0.0
            isoout1IFfs(n,l)=isoout2IFfs(n,l)
            isoout2IFfs(n,l)=0.0
            isostore1IFfs(n,l)=isostore2IFfs(n,l)
            isostore2IFfs(n,l)=0.0
            isoin1GW(n,l)=isoin2GW(n,l)
            isoin2GW(n,l)=0.0
            isoout1GW(n,l)=isoout2GW(n,l)
            isoout2GW(n,l)=0.0
            isostore1GW(n,l)=isostore2GW(n,l)
            isostore2GW(n,l)=0.0
            isoin1GWfs(n,l)=isoin2GWfs(n,l)
            isoin2GWfs(n,l)=0.0
            isoout1GWfs(n,l)=isoout2GWfs(n,l)
            isoout2GWfs(n,l)=0.0
            isostore1GWfs(n,l)=isostore2GWfs(n,l)
            isostore2GWfs(n,l)=0.0
	      isoin1LZS(n,l)=isoin2LZS(n,l)
            isoin2LZS(n,l)=0.0
	      isoout1LZS(n,l)=isoout2LZS(n,l)
	      isoout2LZS(n,l)=0.0
	      isoLZS1(n,l)=isoLZS2(n,l)
	      isoLZS2(n,l)=0.0
            isoin1LZSfs(n,l)=isoin2LZSfs(n,l)
            isoin2LZSfs(n,l)=0.0
            isoout1LZSfs(n,l)=isoout2LZSfs(n,l)
            isoout2LZSfs(n,l)=0.0
            isoLZS1fs(n,l)=isoLZS2fs(n,l)
	      isoLZS2fs(n,l)=0.0
	      if(wetland_flag(n))then
              isoin1wet(n,l)=isoin2wet(n,l)
              isoin2wet(n,l)=0.0
              isoout1wet(n,l)=isoout2wet(n,l)
              isoout2wet(n,l)=0.0
              isowstore1(n,l)=isowstore2(n,l)
              isowstore2(n,l)=0.0
              isoin1fswet(n,l)=isoin2fswet(n,l)
              isoin2fswet(n,l)=0.0
              isoout1fswet(n,l)=isoout2fswet(n,l)
              isoout2fswet(n,l)=0.0
              isowstore1fs(n,l)=isowstore2fs(n,l)
              isowstore2fs(n,l)=0.0
              isoin1SWwet(n,l)=isoin2SWwet(n,l)
              isoin2SWwet(n,l)=0.0
              isoout1SWwet(n,l)=isoout2SWwet(n,l)
              isoout2SWwet(n,l)=0.0
              isowstore1SW(n,l)=isowstore2SW(n,l)
              isowstore2SW(n,l)=0.0
              isoin1SWfswet(n,l)=isoin2SWfswet(n,l)
              isoin2SWfswet(n,l)=0.0
              isoout1SWfswet(n,l)=isoout2SWfswet(n,l)
              isoout2SWfswet(n,l)=0.0
              isowstore1SWfs(n,l)=isowstore2SWfs(n,l)
              isowstore2SWfs(n,l)=0.0
              isoin1IFwet(n,l)=isoin2IFwet(n,l)
              isoin2IFwet(n,l)=0.0
              isoout1IFwet(n,l)=isoout2IFwet(n,l)
              isoout2IFwet(n,l)=0.0
              isowstore1IF(n,l)=isowstore2IF(n,l)
              isowstore2IF(n,l)=0.0
              isoin1IFfswet(n,l)=isoin2IFfswet(n,l)
              isoin2IFfswet(n,l)=0.0
              isoout1IFfswet(n,l)=isoout2IFfswet(n,l)
              isoout2IFfswet(n,l)=0.0
              isowstore1IFfs(n,l)=isowstore2IFfs(n,l)
              isowstore2IFfs(n,l)=0.0
	      endif
          endif
	  end do

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
        do n=1,naa
          lll=next(n)
          inxt=yyy(lll)
          jnxt=xxx(lll)
	    lnxt=nbasin(inxt,jnxt)
	    rbin=ireach(lll)
          i=yyy(n)
          j=xxx(n)
          l=nbasin(i,j)

!         RUN TRACER CODE ONLY IF NOT IN A LAKE
          if(ireach(n).le.0.0 .OR.
     *       ireach(n).gt.0.and.res(n).gt.0) then

!       ^^^^^^^^^^^^^ GW ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!         TO GET MASS OF TRACER ENTERING LZS FROM DRNG
          if(lzs(n).ne.0.0.and.l.ne.0)then
            isooutold7=1.0e+25
            isooutold8=1.0e+25
		  oldiso7=isoout2LZS(n,l)
            oldiso8=isoout2LZSfs(n,l)

!           CALC MASS OF TRACER GOING INTO GW STORAGE, SET INITIAL
!           CONCENTRATION AS 1 kg/m^3 * m^3/s * s = KG:
            isoin2LZS(n,l)=isoin2LZS(n,l)+1.0*qdrng(n)*t
            isoin2LZSfs(n,l)=isoin2LZSfs(n,l)+1.0*qdrngfs(n)*t

!           UPDATE THE TRACER MASS IN GW STORAGE
            isoLZS2(n,l)=isoLZS1(n,l)+(isoin1LZS(n,l)+
     *           isoin2LZS(n,l)-isoout1LZS(n,l)-isoout2LZS(n,l))/2.
	      isoLZS2(n,l)=amax1(isoLZS2(n,l),0.00001)

            isoLZS2fs(n,l)=isoLZS1fs(n,l)+(isoin1LZSfs(n,l)+
     *       isoin2LZSfs(n,l)-isoout1LZSfs(n,l)-isoout2LZSfs(n,l))/2.
	      isoLZS2fs(n,l)=amax1(isoLZS2fs(n,l),0.00001)

!           CONVERGENCE LOOP:
            do ijk=1,50

!             UPDATE CONCENTRATION USING INSTANT MIXING!! 
!             CONC = KG/m^3
!             LZS CONV: mm / 1000m/mm * m^2 = m^3
              isoconcLZS(n,l)=isoLZS2(n,l)/(lzs(n)/1000.*frac(n)*al**2)
              isoconcLZSfs(n,l)=isoLZS2fs(n,l)
     *                                    /(lzs(n)/1000.*frac(n)*al**2)
!	        if(isoconcLZS(n,l).lt.0.0001) isoconcLZS(n,l)=0.0
!	        if(isoconcLZSfs(n,l).lt.0.0001) isoconcLZSfs(n,l)=0.0

!             COMPUTE THE TRACER MASS LEAVING THE LZS
!             THIS SHOULD BE BACK DATED ONE TIME STEP
!             KG/m^3 * m^3/s * s = KG
!             ASSUME: NO EVAP IN SOIL COLUMN!!
              isoout2LZS(n,l)=isoconcLZS(n,l)*qlz(n)*t
              isoout2LZSfs(n,l)=isoconcLZSfs(n,l)*qlz(n)*t

!             TS: ADDED RELAXATION FOR ITERATING TO CODE TO HELP CONVERGENCE (04/1/06)
              isowt=amax1(.5,real(ijk/51.))
              isoout2LZS(n,l)=(1.0-isowt)*isoout2LZS(n,l)+isowt*oldiso7
	        oldiso7=isoout2LZS(n,l)
              isoout2LZSfs(n,l)=(1.0-isowt)*isoout2LZSfs(n,l)
     *                          +isowt*oldiso8
	        oldiso8=isoout2LZSfs(n,l)

!             UPDATE THE TRACER MASS IN GW STORAGE
              isoLZS2(n,l)=isoLZS1(n,l)+(isoin1LZS(n,l)+
     *             isoin2LZS(n,l)-isoout1LZS(n,l)-isoout2LZS(n,l))/2.
	        isoLZS2(n,l)=amax1(isoLZS2(n,l),0.00001)

              isoLZS2fs(n,l)=isoLZS1fs(n,l)+(isoin1LZSfs(n,l)+
     *       isoin2LZSfs(n,l)-isoout1LZSfs(n,l)-isoout2LZSfs(n,l))/2.
	        isoLZS2fs(n,l)=amax1(isoLZS2fs(n,l),0.00001)

!             CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
              if(abs(isoout2LZS(n,l)-isooutold7).lt.0.00001
     *          .and.abs(isoout2LZSfs(n,l)-isooutold8).lt.0.00001) 
     *          GOTO 110
              isooutold7=isoout2LZS(n,l)
              isooutold8=isoout2LZSfs(n,l)

            end do

  110       CONTINUE

          elseif(l.ne.0)then
           isoLZS2(n,l)=0.0
           isoout2LZS(n,l)=0.0
           isoLZS2fs(n,l)=0.0
           isoout2LZSfs(n,l)=0.0
          endif



!       ^^^^^^^^^^^^^ CHANNEL ROUTE THE TRACER ^^^^^^^^^^^^^^^^^
!         ROUTED QLZ CONTRIBUTION ADDED TO CHANNEL AND ROUTED AGAIN.
!         WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!         IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!         IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
          if(slope(n).gt.0.0.and.l.ne.0)then
            if(store2(n).ne.0.0)then
               isooutold1=1.0e+25
               isooutold2=1.0e+25
               isooutold3=1.0e+25
               isooutold4=1.0e+25
               isooutold5=1.0e+25
               isooutold6=1.0e+25
		     oldiso1=isoout2GW(n,l)
               oldiso2=isoout2SW(n,l)
               oldiso3=isoout2IF(n,l)
		     oldiso4=isoout2GWfs(n,l)
               oldiso5=isoout2SWfs(n,l)
               oldiso6=isoout2IFfs(n,l)

!  * * * * * * * * * PUT WETLAND CODE HERE  * * * * * * * * * * * * * * * * 
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!              ROUTE TRACER THROUGH WETLAND FIRST (IF THERE ARE WETLANDS):
               if(wetland_flag(n)==.true.)then

!                SET INITIAL CONCENTRATION AS 1 kg/m^3]
!                UNITS:  = [KG]
!                TRACE MASS ENTERING WETLAND FROM FLOWPATH
                 isoin2wet(n,l)=isoin2wet(n,l)+isoout2LZS(n,l)
                 isoin2SWwet(n,l)=isoin2SWwet(n,l)+1.0*sumq1(n)*t
                 isoin2IFwet(n,l)=isoin2IFwet(n,l)+1.0*sumqint(n)*t
                 isoin2fswet(n,l)=isoin2fswet(n,l)+isoout2LZSfs(n,l)
                 isoin2SWfswet(n,l)=isoin2SWfswet(n,l)+1.0*sumq1fs(n)*t
                 isoin2IFfswet(n,l)=isoin2IFfswet(n,l)
     *                                              +1.0*sumqintfs(n)*t

!      if(n.eq.46)write(801,'(3f10.3)')
!     *   time,isoin2IFwet(n,l),isoin2IFfswet(n,l)
!      if(n.eq.67) pause 'routing Tracer 5 through wetland @1'

                 call tracewet(iz,jz,time,n,l,t)

                 if(qowet2(n).gt.0.0)then
!                  SPECIFY INITIAL MASS FOR CHANNEL FROM WETLAND:
                   isoin2GW(n,l)=isoin2GW(n,l)+isooutwet1
                   isoin2SW(n,l)=isoin2SW(n,l)+isooutwet2
                   isoin2IF(n,l)=isoin2IF(n,l)+isooutwet3
                   isoin2GWfs(n,l)=isoin2GWfs(n,l)+isooutwet4
                   isoin2SWfs(n,l)=isoin2SWfs(n,l)+isooutwet5
                   isoin2IFfs(n,l)=isoin2IFfs(n,l)+isooutwet6

!      if(n.eq.67) pause 'routing Tracer 5 thru wetland @2, qowet2 +ve'

	           else   ! qowet2(n) is -ve
!                  SPECIFY INITIAL MASS IN WETLAND (+MASS FROM CHANNEL)
!                  NOTE: -VE CAUSE QOWET2 IS -VE BUT MASS IS ADDED!
                   isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
                   isoconcSW(n,l)=isostore2SW(n,l)/store2(n)
                   isoconcIF(n,l)=isostore2IF(n,l)/store2(n)
                   isoconcGWfs(n,l)=isostore2GWfs(n,l)/store2(n)
                   isoconcSWfs(n,l)=isostore2SWfs(n,l)/store2(n)
                   isoconcIFfs(n,l)=isostore2IFfs(n,l)/store2(n)

                   isoin2wet(n,l)=isooutwet1-isoconcGW(n,l)*qowet2(n)*t
                   isoin2SWwet(n,l)=isooutwet2
     *                             -isoconcSW(n,l)*qowet2(n)*t
                   isoin2IFwet(n,l)=isooutwet3
     *                             -isoconcIF(n,l)*qowet2(n)*t
                   isoin2fswet(n,l)=isooutwet4
     *                            -isoconcGWfs(n,l)*qowet2(n)*t
                   isoin2SWfswet(n,l)=isooutwet5
     *                            -isoconcSWfs(n,l)*qowet2(n)*t
                   isoin2IFfswet(n,l)=isooutwet6
     *                            -isoconcIFfs(n,l)*qowet2(n)*t

                   isoin2GW(n,l)=isoin2GW(n,l)+isoconcGW(n,l)
     *                                        *qowet2(n)*t
                   isoin2SW(n,l)=isoin2SW(n,l)+isoconcSW(n,l)
     *                                        *qowet2(n)*t
                   isoin2IF(n,l)=isoin2IF(n,l)+isoconcIF(n,l)
     *                                        *qowet2(n)*t
                   isoin2GWfs(n,l)=isoin2GWfs(n,l)+isoconcGWfs(n,l)
     *                                        *qowet2(n)*t
                   isoin2SWfs(n,l)=isoin2SWfs(n,l)+isoconcSWfs(n,l)
     *                                        *qowet2(n)*t
                   isoin2IFfs(n,l)=isoin2IFfs(n,l)+isoconcIFfs(n,l)
     *                                        *qowet2(n)*t

!      if(n.eq.67) pause 'routing Tracer 5 thru wetland @3, qowet2 -ve'

	           endif

	         else
!                SET INITIAL CONCENTRATION AS 1 kg/m^3
!                UNITS:  = [KG]
!                TRACE MASS OF GW ENTERING CHANNEL FROM QLZ
	           isoin2GW(n,l)=isoin2GW(n,l)+isoout2LZS(n,l)
                 isoin2SW(n,l)=isoin2SW(n,l)+1.0*sumq1(n)*t
                 isoin2IF(n,l)=isoin2IF(n,l)+1.0*sumqint(n)*t
	           isoin2GWfs(n,l)=isoin2GWfs(n,l)+isoout2LZSfs(n,l)
                 isoin2SWfs(n,l)=isoin2SWfs(n,l)+1.0*sumq1fs(n)*t
                 isoin2IFfs(n,l)=isoin2IFfs(n,l)+1.0*sumqintfs(n)*t

!      if(n.eq.67)pause 'routing Tracer 5 @4, no wetlands'


	         endif

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! WETLANDS AND QOWET2 IS -VE, SO REBALANCE THE WETLAND CONC'N WITH CHANNEL
!            INFLOW. THEN ROUTE WHATEVER'S LEFT IN THE CHANNEL.
             if(wetland_flag(n)==.true.
     *                       .and.qowet2(n).lt.0)then ! QOWET2 IS -ve
!              CHANNEL FEEDS THE WETLAND, THEREFORE MIX CHANNEL CONC'N
!              WITH WETLAND AND UPDATE WETLAND CONC'N FOR NEXT TIME STEP.
!              ROUTE TRACER FROM CHANNEL TO WETLAND:
               isowetold1=1.0e+25
               isowetold2=1.0e+25
               isowetold3=1.0e+25
               isowetold4=1.0e+25
               isowetold5=1.0e+25
               isowetold6=1.0e+25
!              ROUTE THE TRACER THROUGH THE WETLAND STORAGE:
               call tracewet(iz,jz,time,n,l,t)

!      if(n.eq.67) pause 're-routing Tracer 5 @5, qowet2 -ve'

             endif   ! QOWET IS -VE

!  * * * * * * * * * END WETLAND CODE HERE  * * * * * * * * * * * * * * * * 
! NO WETLANDS AND QOWET2 IS +VE (OR ALREADY REROUTED THRU WETLAND)
!            CHANNEL ROUTING OR WETLAND->CHANNEL ROUTING
!            ROUTE TRACER THROUGH CHANNEL - CONVERGENCE LOOP:

      
!              UPDATE THE TRACER MASSES IN CHANNEL
               isostore2GW(n,l)=isostore1GW(n,l)+(isoin1GW(n,l)+
     *           isoin2GW(n,l)-isoout1GW(n,l)-isoout2GW(n,l))/2.
     	         isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)

               isostore2SW(n,l)=isostore1SW(n,l)+(isoin1SW(n,l)+
     *           isoin2SW(n,l)-isoout1SW(n,l)-isoout2SW(n,l))/2.
	         isostore2SW(n,l)=amax1(isostore2SW(n,l),0.00001)

               isostore2IF(n,l)=isostore1IF(n,l)+(isoin1IF(n,l)+
     *          isoin2IF(n,l)-isoout1IF(n,l)-isoout2IF(n,l))/2.
	         isostore2IF(n,l)=amax1(isostore2IF(n,l),0.00001)

               isostore2GWfs(n,l)=isostore1GWfs(n,l)+(isoin1GWfs(n,l)+
     *           isoin2GWfs(n,l)-isoout1GWfs(n,l)-isoout2GWfs(n,l))/2.
	         isostore2GWfs(n,l)=amax1(isostore2GWfs(n,l),0.00001)

               isostore2SWfs(n,l)=isostore1SWfs(n,l)+(isoin1SWfs(n,l)+
     *          isoin2SWfs(n,l)-isoout1SWfs(n,l)-isoout2SWfs(n,l))/2.
	         isostore2SWfs(n,l)=amax1(isostore2SWfs(n,l),0.00001)

               isostore2IFfs(n,l)=isostore1IFfs(n,l)+(isoin1IFfs(n,l)+
     *          isoin2IFfs(n,l)-isoout1IFfs(n,l)-isoout2IFfs(n,l))/2.
	         isostore2IFfs(n,l)=amax1(isostore2IFfs(n,l),0.00001)


!              CONVERGENCE LOOP:
               do ijk=1,50

!                UPDATE THE CONCENTRATIONS IN THE CHANNEL:
                 isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
                 isoconcSW(n,l)=isostore2SW(n,l)/store2(n)
                 isoconcIF(n,l)=isostore2IF(n,l)/store2(n)
                 isoconcGWfs(n,l)=isostore2GWfs(n,l)/store2(n)
                 isoconcSWfs(n,l)=isostore2SWfs(n,l)/store2(n)
                 isoconcIFfs(n,l)=isostore2IFfs(n,l)/store2(n)

!                COMPUTE THE TRACER MASSES LEAVING THE GRID...
!                EVAP LOSS TO PRESERVE FLOW BALANCES.
!                THIS SHOULD BE BACK DATED ONE TIME STEP
                 isoout2GW(n,l)=isoconcGW(n,l)*qo2(n)*t*coeff(n)
     *                         -isoconcGW(n,l)*strloss(n)*t
     	           isoout2GW(n,l)=amax1(isoout2GW(n,l),0.00001)

                 isoout2SW(n,l)=isoconcSW(n,l)*qo2(n)*t*coeff(n)
     *                         -isoconcSW(n,l)*strloss(n)*t
     	           isoout2SW(n,l)=amax1(isoout2SW(n,l),0.00001)

                 isoout2IF(n,l)=isoconcIF(n,l)*qo2(n)*t*coeff(n)
     *                         -isoconcIF(n,l)*strloss(n)*t
     	           isoout2IF(n,l)=amax1(isoout2IF(n,l),0.00001)

                 isoout2GWfs(n,l)=isoconcGWfs(n,l)*qo2(n)*t*coeff(n)
     *                           -isoconcGWfs(n,l)*strloss(n)*t
     	           isoout2GWfs(n,l)=amax1(isoout2GWfs(n,l),0.00001)

                 isoout2SWfs(n,l)=isoconcSWfs(n,l)*qo2(n)*t*coeff(n)
     *                           -isoconcSWfs(n,l)*strloss(n)*t
     	           isoout2SWfs(n,l)=amax1(isoout2SWfs(n,l),0.00001)

                 isoout2IFfs(n,l)=isoconcIFfs(n,l)*qo2(n)*t*coeff(n)
     *                           -isoconcIFfs(n,l)*strloss(n)*t
     	           isoout2IFfs(n,l)=amax1(isoout2IFfs(n,l),0.00001)


!                TS: ADDED RELAXATION FOR ITERATING TO CODE TO HELP CONVERGENCE (03/11/05)
                 isowt=amax1(.5,real(ijk/51.))

                 isoout2GW(n,l)=(1.0-isowt)*isoout2GW(n,l)+isowt*oldiso1
	           oldiso1=isoout2GW(n,l)

                 isoout2SW(n,l)=(1.0-isowt)*isoout2SW(n,l)+isowt*oldiso2
	           oldiso2=isoout2SW(n,l)

                 isoout2IF(n,l)=(1.0-isowt)*isoout2IF(n,l)+isowt*oldiso3
	           oldiso3=isoout2IF(n,l)

                 isoout2GWfs(n,l)=(1.0-isowt)*isoout2GWfs(n,l)
     *                                                    +isowt*oldiso4
	           oldiso4=isoout2GWfs(n,l)

                 isoout2SWfs(n,l)=(1.0-isowt)*isoout2SWfs(n,l)
     *                                                    +isowt*oldiso5
	           oldiso5=isoout2SWfs(n,l)

                 isoout2IFfs(n,l)=(1.0-isowt)*isoout2IFfs(n,l)
     *                                                    +isowt*oldiso6
	           oldiso6=isoout2IFfs(n,l)


!                UPDATE THE TRACER MASSES IN CHANNEL - LAGGED BY 1 TIMESTEP
                 isostore2GW(n,l)=isostore1GW(n,l)+(isoin1GW(n,l)+
     *            isoin2GW(n,l)-isoout1GW(n,l)-isoout2GW(n,l))/2.
     	           isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)

                 isostore2SW(n,l)=isostore1SW(n,l)+(isoin1SW(n,l)+
     *            isoin2SW(n,l)-isoout1SW(n,l)-isoout2SW(n,l))/2.
	           isostore2SW(n,l)=amax1(isostore2SW(n,l),0.00001)

                 isostore2IF(n,l)=isostore1IF(n,l)+(isoin1IF(n,l)+
     *            isoin2IF(n,l)-isoout1IF(n,l)-isoout2IF(n,l))/2.
	           isostore2IF(n,l)=amax1(isostore2IF(n,l),0.00001)

                 isostore2GWfs(n,l)=isostore1GWfs(n,l)+(isoin1GWfs(n,l)+
     *            isoin2GWfs(n,l)-isoout1GWfs(n,l)-isoout2GWfs(n,l))/2.
	           isostore2GWfs(n,l)=amax1(isostore2GWfs(n,l),0.00001)

                 isostore2SWfs(n,l)=isostore1SWfs(n,l)+(isoin1SWfs(n,l)+
     *            isoin2SWfs(n,l)-isoout1SWfs(n,l)-isoout2SWfs(n,l))/2.
	           isostore2SWfs(n,l)=amax1(isostore2SWfs(n,l),0.00001)

                 isostore2IFfs(n,l)=isostore1IFfs(n,l)+(isoin1IFfs(n,l)+
     *            isoin2IFfs(n,l)-isoout1IFfs(n,l)-isoout2IFfs(n,l))/2.
	           isostore2IFfs(n,l)=amax1(isostore2IFfs(n,l),0.00001)

!      if(n.eq.67) pause 'routing Tracer 5 through channel'


!                CHECK FOR CONVERGENCE - WE NEED THIS TO ITERATE ON ISOOUT2()
                 GWchk=abs(isoout2GW(n,l)-isooutold1)
                 SWchk=abs(isoout2SW(n,l)-isooutold2)
                 IFchk=abs(isoout2IF(n,l)-isooutold3)
                 GWfschk=abs(isoout2GWfs(n,l)-isooutold4)
                 SWfschk=abs(isoout2SWfs(n,l)-isooutold5)
                 IFfschk=abs(isoout2IFfs(n,l)-isooutold6)
                 if(GWchk.lt.0.00001.and.
     *              SWchk.lt.0.00001.and.
     *              IFchk.lt.0.00001.and.
     *              GWfschk.lt.0.00001.and.
     *              SWfschk.lt.0.00001.and.
     *              IFfschk.lt.0.00001) GOTO 50
                 isooutold1=isoout2GW(n,l)
                 isooutold2=isoout2SW(n,l)
                 isooutold3=isoout2IF(n,l)
                 isooutold4=isoout2GWfs(n,l)
                 isooutold5=isoout2SWfs(n,l)
                 isooutold6=isoout2IFfs(n,l)
               end do
   50          CONTINUE

! ** ERROR CHECK: TAS Jan 11/06 -- make new s/r for this
!      if(isoconcSW(n,l).gt.1)then
!	  print*,'isoconcSW',n,l
!        print*,isostore2SW(n,l),isostore1SW(n,l),store2(n)
!        print*,isoin1SW(n,l),isoin2SW(n,l)
!        print*,isoout1SW(n,l),isoout2SW(n,l)
!	  print*,isoconcSW(n,l)
!	  pause
!      endif
!	if(isoconcSWfs(n,l).gt.1)then
!	  print*,'isoconcSWfs',n,l
!        print*,isostore2SWfs(n,l),isostore1SWfs(n,l),store2(n)
!        print*,isoin1SWfs(n,l),isoin2SWfs(n,l)
!        print*,isoout1SWfs(n,l),isoout2SWfs(n,l)
!	  print*,isoconcSWfs(n,l)
!	  pause
!      endif
!      if(isoconcIF(n,l).gt.1)then
!	  print*,'isoconcIF',n,l
!        print*,isostore2IF(n,l),isostore1IF(n,l),store2(n)
!        print*,isoin1IF(n,l),isoin2IF(n,l)
!        print*,isoout1IF(n,l),isoout2IF(n,l)
!	  print*,isoconcIF(n,l)
!	  pause
!      endif
!      if(isoconcIFfs(n,l).gt.1)then
!	  print*,'isoconcIFfs',n,l
!        print*,isostore2IFfs(n,l),isostore1IFfs(n,l),store2(n)
!        print*,isoin1IFfs(n,l),isoin2IFfs(n,l)
!        print*,isoout1IFfs(n,l),isoout2IFfs(n,l)
!	  print*,isoconcIFfs(n,l)
!	  pause
!      endif
!      if(isoconcGW(n,l).gt.1)then
!	  print*,'isoconcGW',n,l
!        print*,isostore2GW(n,l),isostore1GW(n,l),store2(n)
!        print*,isoin1GW(n,l),isoin2GW(n,l)
!        print*,isoout1GW(n,l),isoout2GW(n,l)
!	  print*,isoconcGW(n,l)
!	  pause
!      endif
!      if(isoconcGWfs(n,l).gt.1)then
!	  print*,'isoconcGWfs',n,l
!        print*,isostore2GWfs(n,l),isostore1GWfs(n,l),store2(n)
!        print*,isoin1GWfs(n,l),isoin2GWfs(n,l)
!        print*,isoout1GWfs(n,l),isoout2GWfs(n,l)
!	  print*,isoconcGWfs(n,l)
!	  pause
!	endif

            else
              isostore2SW(n,l)=0.0
              isoout2SW(n,l)=0.0
              isostore2SWfs(n,l)=0.0
              isoout2SWfs(n,l)=0.0
              isostore2IF(n,l)=0.0
              isoout2IF(n,l)=0.0
              isostore2IFfs(n,l)=0.0
              isoout2IFfs(n,l)=0.0
              isostore2GW(n,l)=0.0
              isoout2GW(n,l)=0.0
              isostore2GWfs(n,l)=0.0
              isoout2GWfs(n,l)=0.0

!      if(n.eq.67) pause 'skipped routing Tracer 5'

            end if


!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!           ISOTOPES ARE CONSERVATIVE!
!           NOTE: CAN USE THIS TO MODEL GW RETARDATION OF FLOW
            decay = 0.0
	      if(lnxt.ne.0)then
!             UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT
!             GRID IS NOT A "DUMMY GRID"
              isoin2GW(lll,lnxt)=(1-(decay/100))*(isoin2GW(lll,lnxt)+
     *                                        isoout2GW(n,l))
              isoin2SW(lll,lnxt)=(1-(decay/100))*(isoin2SW(lll,lnxt)+
     *                                       isoout2SW(n,l))
              isoin2IF(lll,lnxt)=(1-(decay/100))*(isoin2IF(lll,lnxt)+
     *                                        isoout2IF(n,l))
              isoin2GWfs(lll,lnxt)=(1-(decay/100))*(isoin2GWfs(lll,lnxt)
     *                                      +isoout2GWfs(n,l))
              isoin2SWfs(lll,lnxt)=(1-(decay/100))*(isoin2SWfs(lll,lnxt)
     *                                       +isoout2SWfs(n,l))
              isoin2IFfs(lll,lnxt)=(1-(decay/100))*(isoin2IFfs(lll,lnxt)
     *                                       +isoout2IFfs(n,l))

	      elseif(lnxt.ne.0 .and. res(n).gt.0) then
!             SET=0 AT LAKE OUTLETS B/C NO ROUTING THROUGH LAKES
              isostore2GW(n,l)=0.0
	        isoout2GW(n,l)=0.0
	        isoin2GW(lll,lnxt)=0.0
              isostore2GW(lll,lnxt)=0.0
              isostore2SW(n,l)=0.0
	        isoout2SW(n,l)=0.0
	        isoin2SW(lll,lnxt)=0.0
              isostore2SW(lll,lnxt)=0.0
              isostore2IF(n,l)=0.0
	        isoout2IF(n,l)=0.0
	        isoin2IF(lll,lnxt)=0.0
              isostore2IF(lll,lnxt)=0.0
              isostore2GWfs(n,l)=0.0
	        isoout2GWfs(n,l)=0.0
	        isoin2GWfs(lll,lnxt)=0.0
              isostore2GWfs(lll,lnxt)=0.0
              isostore2SWfs(n,l)=0.0
	        isoout2SWfs(n,l)=0.0
	        isoin2SWfs(lll,lnxt)=0.0
              isostore2SWfs(lll,lnxt)=0.0
              isostore2IFfs(n,l)=0.0
	        isoout2IFfs(n,l)=0.0
	        isoin2IFfs(lll,lnxt)=0.0
              isostore2IFfs(lll,lnxt)=0.0
            endif


!           ADD MASS OUTFLOW OF CURRENT GRID AS INFLOW TO LAKE (NEXT GRID) (cms)
!           BUT ONLY IF ON THE EDGE OF A LAKE (NOT IN A LAKE)
c            if(ireach(lll).gt.0.and. iz.ne.jz.and.dds_flag.ne.1) then
            if(ireach(lll).gt.0.and. iz.ne.jz) then

              isolakeGW(rbin)=isolakeGW(rbin)+isoout2GW(n,l)/t      


!	write(777,'(4i10,999(f12.3))')n,l,lll,rbin,isolakeGW(rbin,jjz),
!     *            isoout2GW(n,l)/t,isoin2GW(lll,lnxt)/t

	      endif


!            ERROR CHECK: ALL COMPONENTS MUST SUM TO TOTAL SIM'D Q
!            CAUSE SOME CONC'NS > 1.0 FROM ABOVE...
             isosumQ(n)=isoout2SW(n,l)+isoout2SWfs(n,l)+
     *                  isoout2IF(n,l)+isoout2IFfs(n,l)+
     *                  isoout2GW(n,l)+isoout2GWfs(n,l)
!	print*,isosumQ(n)


!           ACCUMULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
            massin(n)=(isoin1GW(n,l)+isoin2GW(n,l))/2.
     *               +(isoin1GWfs(n,l)+isoin2GWfs(n,l))/2.
     *               +(isoin1SW(n,l)+isoin2SW(n,l))/2.
     *               +(isoin1SWfs(n,l)+isoin2SWfs(n,l))/2.
     *               +(isoin1IF(n,l)+isoin2IF(n,l))/2.
     *               +(isoin1IFfs(n,l)+isoin2IFfs(n,l))/2.
            massout(n)=(isoout1GW(n,l)+isoout2GW(n,l))/2.
     *                +(isoout1GWfs(n,l)+isoout2GWfs(n,l))/2.
     *                +(isoout1SW(n,l)+isoout2SW(n,l))/2.
     *                +(isoout1SWfs(n,l)+isoout2SWfs(n,l))/2.
     *                +(isoout1IF(n,l)+isoout2IF(n,l))/2.
     *                +(isoout1IFfs(n,l)+isoout2IFfs(n,l))/2.
            masstore(n)=(isostore2GW(n,l)-isostore1GW(n,l))
     *                 +(isostore2GWfs(n,l)-isostore1GWfs(n,l))
     *                 +(isostore2SW(n,l)-isostore1SW(n,l))
     *                 +(isostore2SWfs(n,l)-isostore1SWfs(n,l))
     *                 +(isostore2IF(n,l)-isostore1IF(n,l))
     *                 +(isostore2IFfs(n,l)-isostore1IFfs(n,l))
            ISOdelta(n)=massin(n)-massout(n)

 !          CHECK OVERALL MASS BALANCE:
 !          MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
            if(iz.ne.jz.and.n.eq.nnprint)then
              sqerr=(ISOdelta(n)-masstore(n))**2.
              write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                      masstore(n),sqerr
	      endif

          endif  ! SLOPE>=0 AND L.NE.0

          else   ! IREACH(N).LE.0
!           IN A LAKE, DON'T RUN TRACER!
	      CONTINUE 
	    endif


        end do   ! GRID NO. LOOP

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

!       WRITE OUT DATA TO TRACER.CSV FILE
!        if(jan.eq.3)then    ! Prints every 0.25 hours
        if(iz.ne.jz)then     ! Prints every hour
          do l=1,no
!           STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
            nn(l)=s(iy(l),jx(l))
	    end do

!         WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!         GRID=NNPRINT. 
!         UNITS: isoout2IBN(n,ll)=[kg]/[s]=[kg/s]=[m^3/s]
!         NB: TRACER OUTFLOW BASED ON MASS TO ACCOUNT FOR EVAP. LOSS

c        if(no.gt.30.and.dds_flag.ne.1) then
        if(no.gt.30) then
          write(90,99887)time,(isoout2GW(nn(l),l)/t,l=1,no)

c        elseif(dds_flag.ne.1)then
          write(90,9005)time,
     *     (isoout2SW(nn(l),l)/t,!isoconcSW(nn(l),l),
     *      isoout2SWfs(nn(l),l)/t,!isoconcSWfs(nn(l),l),
     *      isoout2IF(nn(l),l)/t,!isoconcIF(nn(l),l),
     *      isoout2IFfs(nn(l),l)/t,!isoconcIFfs(nn(l),l),
     *      isoout2GW(nn(l),l)/t,!isoconcGW(nn(l),l),
     *      isoout2GWfs(nn(l),l)/t,l=1,no)!isoconcGWfs(nn(l),l),

	write(999,12345)time,(qo2(nn(l)),isosumQ(nn(l))/t,
     *                (qo2(nn(l))-isosumQ(nn(l))/t),l=1,no)

12345 FORMAT(f10.3,<no>(3(',',f15.5)))

        endif

c        if(wetflg.eq.'y'.and.dds_flag.ne.1) write(93,9101)time,
        if(wetland_flag(n)) write(93,9101)time,
     *    (l,nn(l),qlz(nn(l)),qswevp(nn(l)),isoout2wet(nn(l),l)/t,
     *     isoconcwet(nn(l),l),l=1,no)
        endif
!       filename(90)='..\simout\tracer.csv'
!       filename(91)='..\simout\tracerMB.csv'     ! added Oct.30/03 TS
!       filename(93)='..\simout\tracerWET.csv'    ! added Dec.01/03 TS
!       filename(94)='..\simout\tracerWETMB.csv'  ! added Dec.01/03 TS


	endif      ! SNOWMELT TRACER



! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
 9005 FORMAT(f10.3,<no>(12(',',f15.5)))
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
 9101 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
20400 FORMAT(f10.3,999(',',f15.5))
99887 FORMAT(f10.3,<no>((',',f15.5)))
99888 FORMAT(f10.3,<no>(2(',',f15.5)))


      RETURN
      END SUBROUTINE tracer5      SUBROUTINE tracerGW(iz,jz,time,t,jan,tdum,jjz,jjzold)

!***********************************************************************
!    Copyright (C) 2016 by Nicholas Kouwen, Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! GROUNDWATER TRACER
! This subroutine is designed to route isotope tracers through the
! WATFLOOD model to track the amount of runoff from groundwater.  
! It will do so based on a mixed cell model (continuity).
! Adapted from LFL's sediment transport subroutine.
!
! Created:  May 2003    - NK
! Modified: Summer 2003 - TS
!
!     REV. 9.1.42  May   31/03 - GW Tracer module added - first try
!     REV. 9.1.43  June  18/03 - Expanded tracer module
!     REV. 9.1.44  June  19/03 - TS: Added sub-basin tracer =0
!     REV. 9.1.45  July  29/03 - TS: Added landcover tracer =1
!     REV. 9.1.46  Aug.  18/03 - TS: Added rain tracer (qstream) =3
!     REV. 9.1.47  Aug.  19/03 - TS: Added sub-basin/landcover tracer =2
!     REV. 9.1.48  Aug.  26/03 - TS: Added flow-type & snowmelt tracers =4/5
!     REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
!     REV. 9.1.50  Jan.  27/04 - TS: Separated tracer codes
!     REV. 9.8.77  July  2013  - TH: Added lake routing, diversions & nudging
!     REV.         Feb.  4/16  - TH: Replaced convergence loop with direct solution
!
!*****************************************************************************

      use area_watflood
      implicit none	
	
!     FROM RUN-TO-RUN THOUGH, TRACER MASSES ARE CONSERVED.
!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      INTEGER :: n,m,lll,l,iz,jz,i,j,jan,inxt,jnxt,lnxt
	INTEGER :: rbin,resnum,jjz,jjzold
      REAL*4  :: t,isooutold,decay,time
     	REAL*4  :: tdum,roe

!     changed ro to roe to avoid conflict with wq  nk  May 22/07

      roe=1.0

!     AT VERY START OF WATFLOOD RUN, SET res(n) EQUAL TO l IF LAKE, 0 OTHERWISE
!     LOOP FROM FIRST GRID, n=1, TO LAST NON-OUTLET GRID, naa
      res_set: if(index==0)then
        do n=1,naa
          res(n)=0
        end do

        do n=1,naa
          lll=next(n)
          do l=1,noresv
            if(yyy(n)==ires(l).and.xxx(n)==jres(l)) res(n)=l
          end do
        end do
      end if res_set



! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!                                                               * *
!     TRACER 100 => GW TRACER (orig: nick kouwen)               * *
!                                                               * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     INITIALIZE AND RESET VALUES FOR EACH TIME STEP
      initialize: do n=1,naa
        i=yyy(n)          !integer holder for y-coord
        j=xxx(n)          !integer holder for x-coord
        l=nbasin(i,j)     !basin # of current grid
	  lll=next(n)       !n # of next grid in flow path
        resnum=ireach(n)  !lake # of current grid
	  rbin=ireach(lll)  !lake # of next grid in flow path

        if(rbin/=0) then
          isolakeGW(rbin)=0.0  !isolakeGW is the GW inflow to a lake
          isolakest(rbin)=0.0  !isolakest is the total open water 
!                                   evaporation from a lake
	  endif

!       SHIFT VALUES UP TIME STEP
        if(l/=0)then
          isoin1GW(n,l)=isoin2GW(n,l)
          isoin2GW(n,l)=0.0
          isoout1GW(n,l)=isoout2GW(n,l)
          isoout2GW(n,l)=0.0
          isostore1GW(n,l)=isostore2GW(n,l)
          isostore2GW(n,l)=0.0
	    if(wetflg=='y')then
            isoin1wet(n,l)=isoin2wet(n,l)
            isoin2wet(n,l)=0.0
            isoout1wet(n,l)=isoout2wet(n,l)
            isoout2wet(n,l)=0.0
            isowstore1(n,l)=isowstore2(n,l)
            isowstore2(n,l)=0.0
	    endif
	  endif
      end do initialize

!     IF THERE ARE DIVERSIONS, GIVE THE DIVERTED FLOW AN ASSUMED TRACER MASS      
      divert: do m=1,nodivert
        n=gridgive(m)  
!       gridgive holds the grid number the diversion flows into
        i=yyy(n)
        j=xxx(n)
        l=nbasin(i,j)
        isoin2GW(n,l)=isoin2GW(n,l)+0.75*qr(n)*t
!       qr(n) holds qdivert for this time step
      end do divert

!       ^^^^^^^^^^^  TRACER ROUTING  ^^^^^^^^^^^^^^^^^^^^^^^^^^
!       isoin    = isotope mass in kg
!       isoout   = isotope mass out in kg
!       isostore = isotope in storage in kg
!       isoconc  = isotope concentration in the unit in kg/m^3
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        
      route: do n=1,naa
        lll=next(n)
        i=yyy(n)
        j=xxx(n)
        l=nbasin(i,j)
        resnum=ireach(n)
	  rbin=ireach(lll)
        inxt=yyy(lll)          !y-coord of next grid
        jnxt=xxx(lll)          !x-coord of next grid
	  lnxt=nbasin(inxt,jnxt) !basin # of next grid in flow path
	  
	  
!	  WHEN IN LAKE, ADD OPEN WATER EVAPORATION FOR GRID 
!       TO TOTAL EVAPORATION FOR THE LAKE 
        if(resnum>0)
     *    isolakest(resnum)=isolakest(resnum)+strloss(n)

!       RUN FOR LAND AND LAKE OUTLET ONLY
        if(ireach(n)<=0.0 .OR.
     *     resnum>0.and.res(n)>0) then

!       WHEN THE SLOPE <= 0.0 THE ELEMENT IS NOT IN THE BASIN: SKIP ROUTE
!       IF L=0, THEN THE 1ST GAUGE IN THE BASIN IS NOT AT THE OUTLET, AND THERE
!       IS BASIN AREA BELOW.  B/C WE HAVE NO DATA FOR THIS AREA - IGNORE IT!
        in_basin: if(slope(n)>0.0.and.l/=0)then

          positive_storage: if(store2(n)>0.0)then
             
!       RESET HOLDERS FOR OLD ISOOUT             
             isooutold=1.0e+25
	       oldiso=isoout2GW(n,l)

!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!            ROUTE TRACER THROUGH WETLAND FIRST (IF THERE ARE WETLANDS):
             wetlands: if(wetland_flag(n)==.true.)then

!              SET INITIAL CONCENTRATION AS 1 kg/m^3]
!              UNITS:  = [KG]
!              TRACE MASS OF GW ENTERING WETLAND FROM QLZ
               isoin2wet(n,l)=isoin2wet(n,l)+1.0*qlz(n)*t

               

               wet_pos_outflow: if(qowet2(n)>=0.0)then
!                SPECIFY INITIAL MASS FOR CHANNEL FROM WETLAND:
                 call tracewet(iz,jz,time,n,l,t)
                 isoin2GW(n,l)=isoin2GW(n,l)+isooutwet

               else   ! qowet2(n) is -ve
!                SPECIFY INITIAL MASS IN WETLAND (+MASS FROM CHANNEL)
!                NOTE: -VE CAUSE QOWET2 IS -VE BUT MASS IS ADDED!

                 isoin2wet(n,l)=isoin2wet(n,l)
     *                       -isoconcGW(n,l)*qowet2(n)*t
                 isoin2GW(n,l)=isoin2GW(n,l)
     *                        +isoconcGW(n,l)*qowet2(n)*t
                 call tracewet(iz,jz,time,n,l,t)
     
	         endif wet_pos_outflow

	       else  !if wetland_flag(n)=='n' ->no wetland routing
!              SET INITIAL CONCENTRATION AS 1 kg/m^3
!              UNITS:  = [KG]
!              ADD THE MASS OF GW ENTERING CHANNEL FROM QLZ
	         isoin2GW(n,l)=isoin2GW(n,l)+1.0*qlz(n)*t
	         
!	      AT LAKE OUTLET, MAKE INFLOW EQUAL THE ACCUMULATED INFLOWS TO WHOLE LAKE
	      if(resnum>0.and.res(n)>0) isoin2GW(n,l)=isolakeGW(resnum)
	        
	       endif wetlands

!              UPDATE THE CONCENTRATION IN THE CHANNEL
 
               if(resnum>0.and.res(n)>0)then !if at lake outlet grid
                 isostore2GW(n,l)=(isostore1GW(n,l)+(isoin1GW(n,l)+
     *              isoin2GW(n,l)-isoout1GW(n,l))/2.)
     *              /(1.0+(qo2(n)*coeff(n)+isolakest(resnum))*t
     *              /2.0/store2(n))
	           isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)
	           isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
                 isoout2GW(n,l)=isoconcGW(n,l)*qo2(n)*t*coeff(n)
     *                       +isoconcGW(n,l)*isolakest(resnum)*t
     	           isoout2GW(n,l)=amax1(isoout2GW(n,l),0.00001)
     	           
               else
                 isostore2GW(n,l)=(isostore1GW(n,l)+(isoin1GW(n,l)+
     *            isoin2GW(n,l)-isoout1GW(n,l))/2.)
     *              /(1.0+(qo2(n)*coeff(n)+strloss(n))*t
     *              /2.0/store2(n))
	           isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)
	           isoconcGW(n,l)=isostore2GW(n,l)/store2(n)
                 isoout2GW(n,l)=isoconcGW(n,l)*qo2(n)*t*coeff(n)
     *                       +isoconcGW(n,l)*strloss(n)*t
     	           isoout2GW(n,l)=amax1(isoout2GW(n,l),0.00001)
     	         end if
             
          else   ! follow what's done in rerout
!           TS: added May 21/08 s.t tracer works when store2<0	
            if(isoin2GW(n,l)<0.0)then
              isoout2GW(n,l)=isoin2GW(n,l)/2.0
            else
              isoout2GW(n,l)=0.0
	      endif
            isostore2GW(n,l)=isostore1GW(n,l)+(isoin1GW(n,l)+
     *            isoin2GW(n,l)-isoout1GW(n,l)-isoout2GW(n,l))/2.
	      isostore2GW(n,l)=amax1(isostore2GW(n,l),0.00001)

          end if positive_storage
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   

!         UPDATE MASS BEING INPUT INTO NEXT GRID CELL IF THE NEXT GRID IS NOT A "DUMMY GRID"
!         SINCE ISOOUT INCLUDES EVAP LOSSES, REMOVE EVAP SO IT IS NOT PASSED TO NEXT GRID
          if(lnxt/=0) then !IF NO LAKES, CONTINUE TO PASS
            if(nopt(l)==2.and.n==iflowgrid(l))then
            !IF IT'S A NUDGED STATION, USE THE NUDGED FLOW
              isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *            +qhyd(l,iz+1)*t*isoconcGW(n,l)
            else
              if(resnum>0.and.res(n)>0)then
               isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *           +isoout2GW(n,l)-isoconcGW(n,l)*isolakest(resnum)*t
              else 
               isoin2GW(lll,lnxt)=isoin2GW(lll,lnxt)
     *           +isoout2GW(n,l)-isoconcGW(n,l)*strloss(n)*t
            end if
           endif
	    endif

!         ADD MASS OUTFLOW OF CURRENT GRID AS INFLOW TO LAKE (NEXT GRID) (cms)
!         BUT ONLY IF ON THE EDGE OF A LAKE (NOT IN A LAKE)
          if(rbin>0) then
           !IF IT'S A NUDGED STATION, USE THE NUDGED FLOW
           if(nopt(l)==2.and.n==iflowgrid(l))then
            isolakeGW(rbin)=isolakeGW(rbin)
     *            +qhyd(l,iz+1)*t*isoconcGW(n,l)
           else 
            isolakeGW(rbin)=isolakeGW(rbin)+isoout2GW(n,l)
           endif
	    endif
	    	    

!         CALCULATE MASSES FOR MASS BALANCE CHECK AT END OF RUN:
          massin(n)=(isoin1GW(n,l)+isoin2GW(n,l))/2.
          massout(n)=(isoout1GW(n,l)+isoout2GW(n,l))/2.
          masstore(n)=(isostore2GW(n,l)-isostore1GW(n,l))
          ISOdelta(n)=massin(n)-massout(n)

 !        CHECK OVERALL MASS BALANCE:
 !        MASS IN - MASS OUT = MASS STORED (IF EVERYTHING WORKS!) 
          MBcheck: if(iz/=jz.and.n==nnprint)then
            sqerr=(ISOdelta(n)-masstore(n))**2
            write(91,8000)time,massin(n),massout(n),ISOdelta(n),
     *                    masstore(n),sqerr

            wetMB: if(wetflg=='y')then  !MB check for wetlands 
              sqerr=(wISOdelta(n)-wmasstore(n))**2
              write(94,8000)time,wmassin(n),wmassout(n),wISOdelta(n),
     *                      wmasstore(n),sqerr
	      endif wetMB
	    endif MBcheck

         end if in_basin           ! SLOPE>=0 AND L.NE.0

	  endif
          
      end do route            ! GRID NO. LOOP
      
!     WRITE OUT DATA TO TRACER.CSV FILE, MAKE SURE WE ARE WITHIN
!     CALCULATION AREA OF BASIN (L NOT= 0)
!      if(jan.eq.3)then    ! Prints every 0.25 hours
      if(iz/=jz)then ! Prints every hour
        do l=1,no
!         STORES THE GRID NO. AS FXN OF THE GAUGE(BSN) NO.
          nn(l)=s(iy(l),jx(l))
	  end do

!       WRITE TO THE FILE ONLY WHEN YOU ARE AT THE FLAGGED OUTPUT
!       GRID=NNPRINT. 
!       UNITS: isoout2IBN(n,ll)=[kg]/[s]=[kg/s]=[m^3/s]
!       PRINTS OUT EVERY SUB-BASIN @ SUB-BASIN GAUGE LOCATION
        if(wetflg=='y') write(93,9101)time,
     *    (l,nn(l),qlz(nn(l)),qowet2(nn(l)),qswevp(nn(l)),
     *     isoout2wet(nn(l),l)/(roe*t),isoconcwet(nn(l),l),l=1,no)

!       added by NK Mar. 17/06
        if(mod(iz,kt)==0)then
          write(90,99887)
     *      totaltime,(qo2(nn(l))*isoconcGW(nn(l),l),l=1,no)
	  endif

!        i=yyy(nnprint)
!        j=xxx(nnprint)
!        l=nbasin(i,j)
!        if(wetflg.eq.'y'.and.dds_flag.ne.1) write(204,20400)time,
!     *    (isoin2GW(nnprint,l)-isoout2wet(nnprint,l))/(roe*t),
!     *    isoin2GW(nnprint,l)/qo2(nnprint)/(roe*t),
!     *    isoout2wet(nnprint,l)/(roe*t),isoconcwet(nnprint,l),
!     *    isowstore2(nnprint,l),
!     *    isoout2GW(nnprint,l)/(roe*t),isoconcGW(nnprint,l),
!     *    isostore2GW(nnprint,l)

      endif

!      filename(90)='..\simout\tracer.csv'
!      filename(91)='..\simout\tracerMB.csv'     ! added Oct.30/03 TS
!      filename(93)='..\simout\tracerWET.csv'    ! added Dec.01/03 TS
!      filename(94)='..\simout\tracerWETMB.csv'  ! added Dec.01/03 TS


! FORMATS:
 8000 FORMAT(f10.3,256(',',f15.5))
c 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',f15.5)))
c 9100 FORMAT(f10.3,<no>(2(',',I15),5(',',f15.5)))
c 9101 FORMAT(f10.3,<no>(2(',',I15),5(',',f15.5)))
!               fixed for general format  nk  Jan. 17/01
 9000 FORMAT(f10.3,<no>(2(',',I15),4(',',g15.5)))
 9100 FORMAT(f10.3,<no>(2(',',I15),5(',',g15.5)))
 9101 FORMAT(f10.3,<no>(2(',',I15),5(',',g15.5)))
10000 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,',
     *'        qlz    ,       qswevp ,        ISOoutQ,',
     *'        ISOconc,'))
11000 FORMAT('    time  ,        IN     ,       OUT     ,',
     *'        DELTA  ,       STORE   ,       SSE     ,')
20400 FORMAT(f10.3,999(',',f15.5))
99887 FORMAT(f10.3,<no>((',',f15.5)))
12345 FORMAT(f10.3,<no>(3(',',f15.5))) 



      RETURN
      END SUBROUTINE tracerGW      
      SUBROUTINE tracewet(iz,jz,time,n,l,t)

!***********************************************************************
!    Copyright (C) 2016 by Tricia Stadnyk and Tegan Holmes  
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!*****************************************************************************
! S/R TRACERWET
! This subroutine is designed to route isotope tracers through the WETLAND
! portion of the WATFLOOD model.  It will do so based on a mixed cell model
! (continuity), assuming instant mixing.
! Adapted from LFL's sediment transport subroutine.
!
! Created:  November 2003 - TS
!
! REV. 9.1.49  Nov.  23/03 - TS: Added wetlands to GW Tracer + Wetland Tracer
! REV.         Feb.  4/16  - TH: Replaced convergence loop with direct solution, matched evap back with route.f
!
!*****************************************************************************

   

      use area_watflood
      implicit none	
	
	REAL    :: t,time
	REAL*4  :: GWchk,GWfschk,SWchk,SWfschk,IFchk,IFfschk
	INTEGER :: iwet,n,l,lll,iz,jz


! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	if(itrace.eq.1)then      ! TRACER FOR GLACIERS
!       3D ARRAYS

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	elseif(itrace.eq.2)then      ! TRACER FOR LCOVER
!       3D ARRAYS



! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	elseif(itrace.eq.4)then      ! TRACER W/ FLOWTYPES

!       UPDATE THE TRACER MASS IN WETLAND
        isowstore2(n,l)=(isowstore1(n,l)+(isoin1wet(n,l)+
     *               isoin2wet(n,l)-isoout1wet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
	  isowstore2(n,l)=amax1(isowstore2(n,l),0.00001)

        isowstore2SW(n,l)=(isowstore1SW(n,l)+(isoin1SWwet(n,l)+
     *          isoin2SWwet(n,l)-isoout1SWwet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
	  isowstore2SW(n,l)=amax1(isowstore2SW(n,l),0.00001)

        isowstore2IF(n,l)=(isowstore1IF(n,l)+(isoin1IFwet(n,l)+
     *          isoin2IFwet(n,l)-isoout1IFwet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
	  isowstore2IF(n,l)=amax1(isowstore2IF(n,l),0.00001)

!         UPDATE THE CONCENTRATION IN THE WETLAND
        isoconcwet(n,l)=isowstore2(n,l)/wstore2(n)
        isoconcSWwet(n,l)=isowstore2SW(n,l)/wstore2(n)
        isoconcIFwet(n,l)=isowstore2IF(n,l)/wstore2(n)

!         COMPUTE THE TRACER MASS LEAVING THE GRID...
!         EVAP LOSS TO PRESERVE FLOW BALANCES.
!         THIS SHOULD BE BACK DATED ONE TIME STEP
        isoout2wet(n,l)=isoconcwet(n,l)*qowet2(n)*t
     *                   +isoconcwet(n,l)*qswevp(n)*t
     	  isoout2wet(n,l)=amax1(isoout2wet(n,l),0.00001)

        isoout2SWwet(n,l)=isoconcSWwet(n,l)*qowet2(n)*t
     *                   +isoconcSWwet(n,l)*qswevp(n)*t
        isoout2SWwet(n,l)=amax1(isoout2SWwet(n,l),0.00001)

        isoout2IFwet(n,l)=isoconcIFwet(n,l)*qowet2(n)*t
     *                   +isoconcIFwet(n,l)*qswevp(n)*t
        isoout2IFwet(n,l)=amax1(isoout2IFwet(n,l),0.00001)

        isooutwet1=isoconcwet(n,l)*qowet2(n)*t
        isooutwet2=isoconcSWwet(n,l)*qowet2(n)*t
        isooutwet3=isoconcIFwet(n,l)*qowet2(n)*t

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	elseif(itrace.eq.5)then      ! TRACER W/ FLOWTYPES+MELT
!       2D ARRAYS
        
!       UPDATE THE TRACER MASS IN WETLAND
        isowstore2(n,l)=(isowstore1(n,l)+(isoin1wet(n,l)+
     *               isoin2wet(n,l)-isoout1wet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2(n,l)=amax1(isowstore2(n,l),0.00001)

        isowstore2SW(n,l)=(isowstore1SW(n,l)+(isoin1SWwet(n,l)+
     *          isoin2SWwet(n,l)-isoout1SWwet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2SW(n,l)=amax1(isowstore2SW(n,l),0.00001)

        isowstore2IF(n,l)=(isowstore1IF(n,l)+(isoin1IFwet(n,l)+
     *          isoin2IFwet(n,l)-isoout1IFwet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2IF(n,l)=amax1(isowstore2IF(n,l),0.00001)

        isowstore2fs(n,l)=(isowstore1fs(n,l)+(isoin1fswet(n,l)+
     *          isoin2fswet(n,l)-isoout1fswet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2fs(n,l)=amax1(isowstore2fs(n,l),0.00001)

        isowstore2SWfs(n,l)=(isowstore1SWfs(n,l)+(isoin1SWfswet(n,l)+
     *    isoin2SWfswet(n,l)-isoout1SWfswet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2SWfs(n,l)=amax1(isowstore2SWfs(n,l),0.00001)

        isowstore2IFfs(n,l)=(isowstore1IFfs(n,l)+(isoin1IFfswet(n,l)+
     *    isoin2IFfswet(n,l)-isoout1IFfswet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
!	  isowstore2IFfs(n,l)=amax1(isowstore2IFfs(n,l),0.00001)


!         UPDATE THE CONCENTRATION IN THE WETLAND
          isoconcwet(n,l)=isowstore2(n,l)/wstore2(n)
          isoconcSWwet(n,l)=isowstore2SW(n,l)/wstore2(n)
          isoconcIFwet(n,l)=isowstore2IF(n,l)/wstore2(n)
          isoconcfswet(n,l)=isowstore2fs(n,l)/wstore2(n)
          isoconcSWfswet(n,l)=isowstore2SWfs(n,l)/wstore2(n)
          isoconcIFfswet(n,l)=isowstore2IFfs(n,l)/wstore2(n)

!         COMPUTE THE TRACER MASS LEAVING THE GRID...
!         EVAP LOSS TO PRESERVE FLOW BALANCES.
!         THIS SHOULD BE BACK DATED ONE TIME STEP
          isoout2wet(n,l)=isoconcwet(n,l)*qowet2(n)*t
     *                   +isoconcwet(n,l)*qswevp(n)*t
!          isoout2wet(n,l)=amax1(isoout2wet(n,l),0.00001)

          isoout2SWwet(n,l)=isoconcSWwet(n,l)*qowet2(n)*t
     *                   +isoconcSWwet(n,l)*qswevp(n)*t
!     	    isoout2SWwet(n,l)=amax1(isoout2SWwet(n,l),0.00001)

          isoout2IFwet(n,l)=isoconcIFwet(n,l)*qowet2(n)*t
     *                   +isoconcIFwet(n,l)*qswevp(n)*t
!     	    isoout2IFwet(n,l)=amax1(isoout2IFwet(n,l),0.00001)

          isoout2fswet(n,l)=isoconcfswet(n,l)*qowet2(n)*t
     *                   +isoconcfswet(n,l)*qswevp(n)*t
!          isoout2fswet(n,l)=amax1(isoout2fswet(n,l),0.00001)

          isoout2SWfswet(n,l)=isoconcSWfswet(n,l)*qowet2(n)*t
     *                   +isoconcSWfswet(n,l)*qswevp(n)*t
!     	    isoout2SWfswet(n,l)=amax1(isoout2SWfswet(n,l),0.00001)

          isoout2IFfswet(n,l)=isoconcIFfswet(n,l)*qowet2(n)*t
     *                   +isoconcIFfswet(n,l)*qswevp(n)*t
!     	    isoout2IFfswet(n,l)=amax1(isoout2IFfswet(n,l),0.00001)

      
        isooutwet1=isoconcwet(n,l)*qowet2(n)*t
        isooutwet2=isoconcSWwet(n,l)*qowet2(n)*t
        isooutwet3=isoconcIFwet(n,l)*qowet2(n)*t
        isooutwet4=isoconcfswet(n,l)*qowet2(n)*t
        isooutwet5=isoconcSWfswet(n,l)*qowet2(n)*t
        isooutwet6=isoconcIFfswet(n,l)*qowet2(n)*t

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	elseif(itrace.eq.0. OR. itrace.eq.3 .OR. itrace.eq.100)then    
                                   ! TRACER FOR GW, RAIN, AND SUB-BASINS

!       UPDATE THE TRACER MASS IN WETLAND
        isowstore2(n,l)=(isowstore1(n,l)+(isoin1wet(n,l)+
     *              isoin2wet(n,l)-isoout1wet(n,l))/2.)
     *             /(1.0+(qowet2(n)+qswevp(n))*t
     *              /2.0/wstore2(n))
	  isowstore2(n,l)=amax1(isowstore2(n,l),0.00001)

!         UPDATE THE CONCENTRATION IN THE WETLAND
        isoconcwet(n,l)=isowstore2(n,l)/wstore2(n)

!         COMPUTE THE TRACER MASS LEAVING THE GRID...
!         EVAP LOSS TO PRESERVE FLOW BALANCES.
!         THIS SHOULD BE BACK DATED ONE TIME STEP
        isoout2wet(n,l)=isoconcwet(n,l)*qowet2(n)*t
     *                   -isoconcwet(n,l)*qswevp(n)*t
        isoout2wet(n,l)=amax1(isoout2wet(n,l),0.00001)

        isooutwet=isoconcwet(n,l)*qowet2(n)*t

      endif           ! GW TRACER
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *



! FORMATS:
 8000 FORMAT(g10.3,256(',',g15.5))    ! nk  changed Jan 5/11
c 8000 FORMAT(f10.3,256(',',f15.5))
10000 FORMAT('   time   ,',
     *<no>('         basin#,          grid#,',
     *'        qlz    ,       qswevp ,        ISOoutQ,',
     *'        ISOconc,'))
11000 FORMAT('    time  ,        IN     ,       OUT     ,',
     *'        DELTA  ,       STORE   ,       SSE     ,')



      RETURN
	END SUBROUTINE tracewet      SUBROUTINE watbal(jan)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************

!     REV. 9.00  - Mar.   2000 -  TS: CONVERTED TO FORTRAN 90
!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance

!***********************************************************************

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer(4)  ::  io_err,sys_err,stat,unit,cond,n,jan,l,j,i,ii,ios
      integer(4)  ::  m
      real(4)     ::  freewat(17500),balance(17500)
      integer     ::  iallocate
      real*4, dimension(:),   allocatable :: lz_frac


!     rev. 9.8.45  Jan.  31/13  - NK: disabled some writes for iopt = 99
      if(iopt.eq.99)return
      if(.not.allocated(lz_frac))then
        allocate(lz_frac(na),stat=iAllocate)
        if(iAllocate.ne.0)STOP 
     *    'Warning: error with allocation of lz_area arrays in watbal' 
      endif
!     START OF WATER BALANCE CHECK
!     ALL AMOUNTS HERE ARE FOR a whole grid

      do n=1,naa
	   totint(n)=0.0
         totd1(n)=0.0
         totuzs(n)=0.0
         totsnw(n)=0.0
         totchnl(n)=0.0
         freewat(n)=0.0
      end do

d	if(iopt.eq.2)print*,' checkpoint 1 in watbal. JAN=',jan

      if(jan.eq.1)then   !firstpass
         do n=1,naa
            storinit(n)=0.0
            sump(n)=0.0
            sumrff(n)=0.0
            do ii=1,classcount
               ssumr(n,ii)=0.0
               sumf(n,ii)=0.0
               sumffs(n,ii)=0.0	   
            end do
            eloss(n)=0.0
	     netinflow(n)=0.0
	     netoutflow(n)=0.0
         end do
         do ii=1,classcount
            sr(ii)=0.0
            sqint(ii)=0.0
            sqintfs(ii)=0.0
            sdrng(ii)=0.0
            sdrngfs(ii)=0.0
            sq1(ii)=0.0
            sq1fs(ii)=0.0           
            sexcess(ii)=0.0
         end do
         sqlz=0.0
         slzinflw=0.0    ! not used

c!     rev. 9.9.15  Jun.  02/14  - NK: Add lz to the water balance - it was missing
c!        calculate the fraction of the grid occupied by LZS
c         allocate(lz_frac(na),stat=iAllocate)
c         if(iAllocate.ne.0)STOP 
c     *    'Warning: error with allocation of lz_area arrays in watbal' 
c         do n=1,naa
c           lz_frac(n)=0.0
c           if(wetflg.eq.'y')then
c             do ii=1,classcount-3
c               lz_frac(n)=lz_frac(n)+aclass(n,ii)
c               write(813,81302)n,ii,aclass(n,ii),lz_frac(n)
c             end do
c           else
c             do ii=1,classcount-2
c               lz_frac(n)=lz_frac(n)+aclass(n,ii)
c               write(813,81302)n,ii,aclass(n,ii),lz_frac(n)
c             end do
c           endif
c           lz_frac(n)=lz_frac(n)+aclass(n,classcount)
c           write(813,81302)n,classcount,aclass(n,classcount),lz_frac(n)
c81302      format(2i5,2f15.3)
c           write(813,*)
c         end do
      endif     !  jan = 1  =  firstpass

      do n=1,na
        lz_frac(n)=1.0    ! lzs is spread over the whole grid, including water & wetlands
      end do


d	if(iopt.eq.2)print*,' checkpoint 2 in watbal. JAN=',jan

      if(wetflg.eq.'y')then
        m=classcount-2
      else
        m=classcount-1
      endif

      do n=1,naa
        do ii=1,classcount
           if(aclass(n,ii).gt.0.0)then
!              for all classes:           
               totsnw(n)=totsnw(n)
     *                  +snowc(n,ii)*aclass(n,ii)*sca(n,ii)
               if(abs(wcl(n,ii)).lt.0.0001)wcl(n,ii)=0.0  
!                     prevent underflow - 22/04/02 nk
               freewat(n)=freewat(n)+wcl(n,ii)*aclass(n,ii)*sca(n,ii)
c              freewat(n)=freewat(n)+water(n,ii)*aclass(n,ii)*sca(n,ii)
             if(ii.eq.classcount-1)then   !water
!              water water water water water water water water water             
               if(ireach(n).eq.0)then
!                not in a lake or reservoir              
c                totchnl(n)=(store2(n))/grid_area(n)*1000.*aclass(n,ii)  
c                 totchnl(n)=store2(n)/grid_area(n)*1000.    !*aclass(n,ii) 
c                 totchnl(n)=store2(n)/(grid_area(n)/frac(n))*1000.    !*aclass(n,ii) 
                 totchnl(n)=store2(n)/al/al*1000.     
               else
                 if(res(n).gt.0)then   ! outlet grid
c                   totchnl(n)=(store2(n))/grid_area(n)*1000.    !*aclass(n,ii)   
c                   totchnl(n)=(store2(n))/(grid_area(n)/frac(n))*1000.    !*aclass(n,ii)   
                   totchnl(n)=(store2(n))/al/al*1000.    !*aclass(n,ii)   
                 else
                   totchnl(n)=0.0   
                 endif
               endif
             elseif(ii.eq.classcount-2.and.wetflg.eq.'y')then 
!              coupled wetland   coupled wetland   coupled wetland 
!              convert wetland storage into depth in mm on the nominal grid
               totwetl(n)=wstore2(n)/(grid_area(n)/frac(n))*1000.   
               totint(n)=totint(n)+v(n,ii)*aclass(n,ii)
             else
!              for all classes except water and coupled wetland:  
!     rev. 10.2.52 Apr.  15/19  - NK: Added total UZS for reporting in FEWS
!              this stuff added to sub for reporting in FEWS
               totint(n)=totint(n)+v(n,ii)*aclass(n,ii)
               totd1(n)=totd1(n)
     *                 +d1(n,ii)*aclass(n,ii)*(1.0-sca(n,ii))
     *                 +d1fs(n,ii)*aclass(n,ii)*sca(n,ii)
               totuzs(n)=totuzs(n)
     *                  +uzs(n,ii)*aclass(n,ii)*(1.0-sca(n,ii))
     *                  +uzsfs(n,ii)*aclass(n,ii)*sca(n,ii)
               totwetl(n)=0.0
             endif
           endif         !  class.gt.0.0
        end do          !  ii=1,classcount
         
!       add all the storages in mm
        totgrid(n)=totd1(n)
     *              +totint(n)
     *              +totuzs(n)
     *              +totsnw(n)
     *              +freewat(n)
     *              +lzs(n)*lz_frac(n)
     *              +totwetl(n)
     *              +totchnl(n)
!       need to scale the netoutflow to nominal grid frac = 1

        netoutflow(n)=netoutflow(n)/frac(n)

c        if(n.eq.nnprint)then
c           write(812,81102)totd1(n),totint(n),totuzs(n),totsnw(n)
c     *              ,freewat(n),lzs(n)*lz_frac(n),totwetl(n),totchnl(n),
c     *               lz_frac(n)  
c81102      format(9f15.3)
c        endif   
         
      end do

d	if(iopt.eq.2)print*,' checkpoint 3 in watbal. JAN=',jan

      if(jan.eq.1)then
         do n=1,naa
            storinit(n)=totgrid(n)
            balance(n)=0.0
         end do
      else
         do n=1,naa
!          need to adjust sump because water area is NOT included in 
!          the water balance. All amounts are for a whole grid
!          but water is added only to the non-water area
!          & spread over the whole grid for this accounting.
           if(ireach(n).eq.0)then
!     rev. 9.9.13  Apr.  04/16  - NK: Fix water balance
             balance(n)=storinit(n)
     *          	    +sump(n)               ! *(1.0-aclass(n,classcount))
     *                  -eloss(n)
     *                  -netoutflow(n)
     *                  -totgrid(n)
           else
             balance(n)=storinit(n)
     *                  -totgrid(n)
     *                  -netoutflow(n)
           endif
         end do
      endif

d	if(iopt.eq.2)print*,' checkpoint 4 in watbal. JAN=',jan

      if(jan.eq.1)then
        open(unit=97,file=filename(96),status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',filename(96)(1:40)
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in watbal.f @ 211'
        endif
      else
        open(unit=97,file=filename(97),status='unknown',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',filename(97)(1:40)
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in watbal.f @ 221'
        endif
      endif

      write(97,6200)
 6200 format
     *(' n, basin, row, col, reach, fracn,  elev,   stinit, interc,
     *  surf,   swe,       uzs,   lzs,  chlstore,  wetstore,  totstore,
     *  precip,  eloss ,netoutflow, balance, class_1_to_classcount')

      do n=1,naa
        if(ireach(n).eq.0)then
          i=yyy(n)
          j=xxx(n)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
            write(97,6201,iostat=ios)
     *        n,nhyd(i,j),i,j,ireach(n),frac(n),elev(n),
     *        storinit(n),totint(n),totd1(n),totsnw(n),totuzs(n),
     *        lzs(n)*lz_frac(n),totchnl(n),totwetl(n),totgrid(n),
     *        sump(n),eloss(n),netoutflow(n),balance(n),
     *        (aclass(n,ii),ii=1,classcount)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
        endif    
      end do
      
      write(97,*)
      write(97,*)'Water balance for reservoirs & lakes'
      write(97,6200)
      do n=1,naa
        if(ireach(n).gt.0.and.res(n).eq.0)then
          i=yyy(n)
          j=xxx(n)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
            write(97,6201,iostat=ios)
     *        n,nhyd(i,j),i,j,ireach(n),frac(n),elev(n),
     *        storinit(n),totint(n),totd1(n),totsnw(n),totuzs(n),
     *        lzs(n)*lz_frac(n),totchnl(n),totwetl(n),totgrid(n),
     *        sump(n),eloss(n),netoutflow(n),balance(n),
     *        (aclass(n,ii),ii=1,classcount)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
        endif
      end do
      
      write(97,*)
      write(97,*)'Water balance for reservoir & lake outlets'
      write(97,6200)
      do n=1,naa
        if(ireach(n).gt.0.and.res(n).gt.0)then
          i=yyy(n)
          j=xxx(n)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
            write(97,6201,iostat=ios)
     *        n,nhyd(i,j),i,j,ireach(n),frac(n),elev(n),
     *        storinit(n),totint(n),totd1(n),totsnw(n),totuzs(n),
     *        lzs(n)*lz_frac(n),totchnl(n),totwetl(n),totgrid(n),
     *        sump(n),eloss(n),netoutflow(n),balance(n),
     *        (aclass(n,ii),ii=1,classcount)
            if(n.eq.nnprint)write(97,6201,iostat=ios)
        endif
      end do
 6201 format(i4,4(',',i4),',',f7.3,',',f7.1,',',f10.0,3(',',f6.1),
     *           ',',f10.3,',',f6.1,
     *           3(',',f10.1),4(',',f8.0),'  ',99(',',f6.3))



d	if(iopt.eq.2)print*,' checkpoint 5 in watbal. JAN=',jan

      close (unit=97,status='keep')


d	if(iopt.eq.2)print*,' checkpoint 5 in watbal. JAN=',jan

!      CALL ERRSNS(io_err,SYS_ERR,STAT,UNIT,cond)

d	if(iopt.eq.2)print*,' checkpoint 6 in watbal - before return'


!     * * * *  END OF WATER BALANCE CHECK  * * * * 

! FORMATS:



      RETURN

      END SUBROUTINE watbal
       SUBROUTINE write_both_headers(coordsys,jan)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!     REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90
!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!     rev. 9.9.02  Dec.  12/13  - NK: Changed format for origin in wfo code

!***********************************************************************


      use area_watflood
	implicit none


!  INPUT PARAMETERS: FILENAME FOR WFO FILE, UNIT NUMBER, NUMER OF 
!                    COLUMNS, NUMBER OF ROWS, GRID SIZE, GRID ORIGINS
!                    (X,Y), NUMBER OF LANDCOVER TYPES


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        CHARACTER(64):: appname
        CHARACTER(2) :: num_to_char(16)
        CHARACTER(*) :: coordsys
!        INTEGER      :: xcount,ycount,classcount,i,j,attcount,seq,step,
!     *          nsteps,attnum,iAllocate,iDeallocate,jan,nrvr,nj,npick
        INTEGER      :: i,j,attcount,seq,step,
     *          nsteps,attnum,iAllocate,iDeallocate,jan,nj,npick
!        REAL         :: xdelta,ydelta,xorigin,yorigin

!        CHARACTER(64), DIMENSION(:), ALLOCATABLE :: attname
!        CHARACTER(32), DIMENSION(:), ALLOCATABLE :: attunits

      DATA num_to_char/'01','02','03','04','05','06','07','08',
     *                 '09','10','11','12','13','14','15','16'/
      
!       WFO IO FUNCTIONS
        INTEGER wfo_open_file,wfo_write_header
        INTEGER wfo_write_attribute_header
        INTEGER wfo_close_header

      appname = 'Watflood'
!     coordsys='UTM'       !UTM or LATLONG

!     SAMPLE ATTRIBUTES
!     SET UP ATTRIBUTE INFORMATION (NAMES AND UNITS)

!     Note:  These are also read from the wfo_spec.txt file
!     where the names are just for information. They are hard wired
!     here so they can not be changed accidentally by the user.

      j=0
      if(wfo_pick(1).eq.1)then
        j=j+1
        attname(j)='Temperature'
        attunits(j)='degrees Celsius'
      endif

      if(wfo_pick(2).eq.1)then
        j=j+1
        attname(j)='Precipitation'
        attunits(j)='mm'
      endif

      if(wfo_pick(3).eq.1)then
        j=j+1
        attname(j)='Cumulative Precipitation'
        attunits(j)='mm'
      endif

      if(wfo_pick(4).eq.1)then
        j=j+1
        attname(j)='Lower Zone Storage'
        attunits(j)='mm'
      endif

      if(wfo_pick(5).eq.1)then
        j=j+1
        attname(j)='Lower Zone Discharge'
        attunits(j)='m^3/s'
      endif

      if(wfo_pick(6).eq.1)then
        j=j+1
        attname(j)='Grid Runoff'
        attunits(j)='Cms'
      endif

!     REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
      if(wfo_pick(7).eq.1)then
        j=j+1
        attname(j)='Observed Grid Outflow'
        attunits(j)='Cms'
      endif

      if(wfo_pick(8).eq.1)then
        j=j+1
        attname(j)='Computed Grid Outflow'
        attunits(j)='Cms'
      endif

      if(wfo_pick(9).eq.1)then
        j=j+1
        attname(j)='Weighted SWE'
        attunits(j)='mm'
      endif

!     rev. 9.1.35  Dec. 26/02  - Added wetland & channel height to the wfo file
      if(wfo_pick(10).eq.1)then
        j=j+1
        attname(j)='Wetland Internal Depth'
        attunits(j)='meters'
      endif

      if(wfo_pick(11).eq.1)then
        j=j+1
        attname(j)='Channel Depth'
        attunits(j)='metres'
      endif

!     rev. 9.1.21  Jun.  28/02  - Added wetland storage & outflow to the wfo file
      if(wfo_pick(12).eq.1)then
        j=j+1
        attname(j)='Wetland Storage'
        attunits(j)='cubic meters'
      endif

      if(wfo_pick(13).eq.1)then
        j=j+1
        attname(j)='Wetland Outflow'
        attunits(j)='Cms'
      endif

      if(wfo_pick(14).eq.1)then
        j=j+1
        attname(j)='Weighted Cumm ET'
        attunits(j)='mm'
      endif
      
!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
      if(wfo_pick(15).eq.1)then
        j=j+1
        attname(j)='Bankfull'
        attunits(j)='Percent'
      endif
      
!     rev. 9.9.70  Jun.  12/15  - NK: Add del_rain, and dSTRconc2  to the wfo file
!     rev. 9.9.70  Jun.  12/15  - NK: Add del_rain, and dSTRconc2  to the wfo file
      if(frcflg.eq.'y')then
c      if(wfo_pick(12).eq.1)then
        j=j+1
        attname(j)='del_rain'
        attunits(j)=''
c      endif
c      if(wfo_pick(13).eq.1)then
        j=j+1
        attname(j)='dSTRconc2'
        attunits(j)=''
c      endif
      endif
      

      npick=15         ! change this if items are added above
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` 

      do i=1,classcount
        if(wfo_pick(npick+i).eq.1)then
          j=j+1
          attname(j)='Depression Storage Class '//num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Depression Storage (Snow) Class '//
     *                       num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+2*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Snow Water Equivalent Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+3*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Snow Covered Area Class '//
     *                         num_to_char(i)
          attunits(j)='fraction'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+4*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Upper Zone Storage Class '//
     *                          num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+5*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Upper Zone Storage (Snow) Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do

!     rev. 9.1.30  Nov.  08/02  - added q1, qint, drng & qlz to the wfo file
      do i=1,classcount
        if(wfo_pick(npick+6*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Surface Flow (bare) Class '//
     *                         num_to_char(i)
          attunits(j)='m^3/s'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+7*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Surface Flow (snow) Class '//
     *                         num_to_char(i)
          attunits(j)='m^3/s'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+8*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Interflow (bare) Class '//
     *                         num_to_char(i)
          attunits(j)='m^3/s'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+9*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Interflow (snow) Class '//
     *                         num_to_char(i)
          attunits(j)='m^3/s'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+10*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Recharge Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+11*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Recharge (snow) Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do

      do i=1,classcount
        if(wfo_pick(npick+12*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Pot. Evapotranspiration Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do
      do i=1,classcount
        if(wfo_pick(npick+13*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Evapotranspiration Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do
      do i=1,classcount
        if(wfo_pick(npick+14*(classcount)+i).eq.1)then
          j=j+1
          attname(j)='Sublimation Class '//
     *                         num_to_char(i)
          attunits(j)='mm'
        endif
      end do

!     attcount redefined here
      attcount=j

!        OPEN THE FILE FOR WRITING
      if(wfo_open_file().ne.1)then
        write(*,'(A)') ' '
        write(*,'(A)') '  *** FATAL ERROR ***     '
        write(*,'(A)') ' Unable to Open File for Writing'

        write(*,'(9X,(A))') filename(65)
        STOP 'Program terminated in write_both_headers @89'
      endif

!     WRITE THE MAIN FILE HEADER


      if(wfo_write_header(appname,
     *               coordsys) .ne. 1)then

         write(*,'(A)') ' '
         write(*,'(A)') '  *** FATAL ERROR ***     '
         write(*,'(A)') ' Unable to Write Main Header'
         STOP 'Program terminated in write_both_headers @98'
      endif

!     WRITE THE ATTRIBUTE HEADER
      if(wfo_write_attribute_header(attcount,attname,attunits) 
     *                       .ne. 1)then
         write(*,'(A)') ' '
         write(*,'(A)') '  *** FATAL ERROR ***     '
         write(*,'(A)') ' Unable to Write Attribute Header'
         STOP 'Program terminated in write_both_headers @107'
      endif	

!     CLOSE THE HEADER
      if(wfo_close_header().ne. 1)then
         write(*,'(A)') ' '
         write(*,'(A)') '  *** FATAL ERROR ***     '
         write(*,'(A)') ' Unable to Close Header'
         STOP 'Program terminated in write_both_headers @115'
      endif

! DEALLOCATIONS OF ARRAYS:
      deallocate(attname,attunits,stat=iDeallocate)
      if (iDeallocate.ne.0) STOP   
     *    'Error with deallocation of ensim arrays in wfocodea'

      RETURN

      END SUBROUTINE write_both_headers

! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

!***********************************************************************
      INTEGER FUNCTION wfo_open_file()
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION OPENS A FILE AS BINARY

! RETURN:        = 1 SUCCESS
!                = 0 ERROR
!
!***********************************************************************

      use area_watflood
	implicit none

!     PARAMETER TYPE DEFINITIONS
!        CHARACTER(*) :: fln
!        INTEGER      :: lun
      integer*4     ::  ios
      logical       :: exists

      wfo_open_file = 0


!       OPEN THE FILE
        open(unit=65,file=filename(65),status='unknown',
     *                form='binary',iostat=ios)
	  if(ios.ne.0)then
	    print*,' Problems opening unit 65'
	    print*,' Problem ignored. Look for file name for65'
	    print*
	  else
          print*,' Opened the wfo file for ENSIM'
          wfo_open_file = 1
	  endif

      RETURN

      END FUNCTION wfo_open_file 


!***********************************************************************
!      INTEGER FUNCTION wfo_write_header(appname, xorigin, yorigin,
!     *	               xcount, ycount, xdelta, ydelta, coordsys)
      INTEGER FUNCTION wfo_write_header(appname,coordsys) 
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION WRITES A PROPER WFO FILE HEADER

! RETURN:       = 1 SUCCESS
!               = 0 ERROR
!ed basin\
!***********************************************************************

!        USE DFLIB

      use area_watflood
	implicit none

!     PARAMETER TYPE DEFINITIONS
        CHARACTER(*) :: appname,coordsys
!        INTEGER      :: xcount,ycount
!        REAL         :: xorigin,yorigin,xdelta,ydelta

!     LOCAL VARIABLES
        CHARACTER(128) :: line
        CHARACTER(64)  :: username
        CHARACTER(10)  :: ctime
        CHARACTER(8)   :: fmt_string,cday
        CHARACTER(5)   :: czone
        CHARACTER(4)   :: data_type
        INTEGER        :: mi,ss,ms,ivalues(8)

      print*,'Writing the wfo header for ENSIM' 
      wfo_write_header = 1

      fmt_string = 'BINARY'
      data_type = 'wfo'

!     WRITE DATA
      call wfo_write_header_record(
     *'###########################################################')

      write(line,101) data_type, fmt_string
  101 format(':FileType ',(A),' ',(A),' EnSim 1.0')

      call wfo_write_header_record(line)
      call wfo_write_header_record('#')
      call wfo_write_header_record(
     *	'# DataType       Binary Watflood Output')
      call wfo_write_header_record('#')

      write(line,102) appname
  102 format(':Application       ', (A))

      call wfo_write_header_record(line)

!      call getlog(username)
!      write(line,103) username
! 103 format(':WrittenBy         ', (A))
!      call wfo_write_header_record(line)

!     GETDAT AND GETTIM REPLACED BY DATE_AND_TIME INTRINSIC
!      call getdat(yy,mm,dd)
!      call gettim(hh,mi,ss,ms)
      call date_and_time(cday,ctime,czone,ivalues)
      yy=ivalues(1)
      mm=ivalues(2)
      dd=ivalues(3)
      hh=ivalues(5)
      mi=ivalues(6)
      ss=ivalues(7)
      ms=ivalues(8)

      write(line,104) yy,mm,dd,hh,mi,ss
  104 format(':CreationDate        ',I4.4,"/",I2.2,"/",I2.2,2x,
     *  I2.2,":",I2.2,":",I2.2)
      call wfo_write_header_record(line)
      
      write(line,114) year_start,mo_start,day_start,hour_start,0,0
  114 format(':StartTime ',I4.4,"/",I2.2,"/",I2.2,2x,
     *  I2.2,":",I2.2,":",I2.2)
      call wfo_write_header_record(line)
     
      call wfo_write_header_record(          
     *'#-----------------------------------------------------------')
      call wfo_write_header_record('#')

!     REV. 10.1.38 Jul   28/16  - NK: Added noDataValue to WFO & tb0 files
      write(line,1005) -999.0                !noDataValue
 1005 format(':NoDataValue ', (f))
      call wfo_write_header_record(line)

      write(line,105) coordsys1
  105 format(':Projection ', (A))
      call wfo_write_header_record(line)

!     REV. 10.1.37 Jul   28/16  - NK: Added "Ellipsoid to the WFO header
      write(line,1006) datum1
 1006 format(':Ellipsoid ', (A))
      call wfo_write_header_record(line)

      write(line,106) xorigin
!     rev. 9.9.02  Dec.  12/13  - NK: Changed format for origin in wfo code
c  106 format(':xorigin ',(f))
  106 format(':xorigin ',(e))
      call wfo_write_header_record(line)

      write(line,107) yorigin
!     rev. 9.9.02  Dec.  12/13  - NK: Changed format for origin in wfo code
c  107 format(':yorigin ',(f))
  107 format(':yorigin ',(e))
      call wfo_write_header_record(line)

      write(line,108) xcount
  108 format(':xcount ',(i))
      call wfo_write_header_record(line)

      write(line,109) ycount
  109 format(':ycount ',(i))
      call wfo_write_header_record(line)

      write(line,110) xdelta
  110 format(':xdelta ',(f))
      call wfo_write_header_record(line)

      write(line,111) ydelta
  111 format(':ydelta ',(f))
      call wfo_write_header_record(line)

      RETURN

      END FUNCTION wfo_write_header


!***********************************************************************
      SUBROUTINE wfo_write_header_record(line)
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS SUBROUTINE WRITES A HEADER RECORD TO THE OPEN LUN
! APPEND A NEWLINE CHAR SINCE THE FILE IS BINARY
!
!***********************************************************************

		
!     PARAMETER TYPE DEFINITIONS
        CHARACTER(*) :: line   	
!       can't use (*) cause we are adding something to the end
!        INTEGER :: lun
      integer*4    :: ios

!     LOCAL VARIABLES
        CHARACTER(256) :: lline
        INTEGER :: llen

      llen = LEN_TRIM(line)
      lline = line(1:llen)// ' '               ! Append a space

      llen = LEN_TRIM(lline)
      if(llen .GT. 255)then
         llen = 255
      end if

      llen = llen+1
      lline(llen:llen) = CHAR(10)               ! Append a line feed

      write(65,iostat=ios) lline(1:llen)
	if(ios.ne.0)then
	  print*,' Error writing to unit 65 at approx line 310 in wfocode'
	  print*
	  stop 'in wfocode'
	endif


      RETURN

      END SUBROUTINE wfo_write_header_record


!***********************************************************************
      INTEGER FUNCTION wfo_write_attribute_header(attcount,
     *                 attname,attunits)
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION WRITE THE ATTRIBUTE NAMES AND UNITS INTO THE HEADER  

! RETURN:       = 1 SUCCESS
!               = 0 ERROR
!
!***********************************************************************

!        USE DFLIB

!     PARAMETER TYPE DEFINITIONS
        INTEGER       :: attcount
        CHARACTER(64) :: attname(attcount)
        CHARACTER(32) :: attunits(attcount)


!     LOCAL VARIABLES
        CHARACTER(128) :: line
        INTEGER        :: attnum

      wfo_write_attribute_header = 1
      call wfo_write_header_record('#')

      write(line,121) attcount
  121 format(':AttributeCount ',(i))
      call wfo_write_header_record(line)

      do attnum=1, attcount
         write(line,122) attnum, attname(attnum)
         call wfo_write_header_record(line)
         write(line,123) attnum, attunits(attnum)
         call wfo_write_header_record(line)
      end do
  122 format(':AttributeName ',(i),' ',(A))
  123 format(':AttributeUnits ',(i),' ',(A))

      call wfo_write_header_record('#')

      RETURN

      END FUNCTION wfo_write_attribute_header


!***********************************************************************
      INTEGER FUNCTION wfo_write_timestamp(seq,step,yy,mm,dd,
     *                 hh,mi,ss,ms)
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION WRITES A BINARY TIMESTAMP FOR THIS STEP
! YR, MONTH, DAY, HR, MiN, SEC, MiLLISEC FOR THIS STEP
 
! RETURN:       = 1 SUCCESS
!               = 0 ERROR
!
!***********************************************************************


!     PARAMETER TYPE DEFINITIONS
        INTEGER :: seq,step
        INTEGER :: yy,mm,dd,hh,mi,ss,ms,ios

      wfo_write_timestamp = 1

!     WRITE THE RECORD

      write(65,iostat=ios) seq,step,yy,mm,dd,hh,mi,ss,ms
	if(ios.ne.0)then
	  print*,' Error writing to unit 65 at approx line 391 in wfocode'
	  print*,' Disk full maybe?'
	  print*
	  stop 'in wfocode'
	endif

      RETURN

      END FUNCTION wfo_write_timestamp


!***********************************************************************
      INTEGER FUNCTION wfo_close_header()
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION CLOSES THE HEADER

! RETURN:       = 1
!
!***********************************************************************


!     PARAMETER TYPE DEFINITIONS
!        INTEGER :: lun

      wfo_close_header=1

      call wfo_write_header_record('#')

      call wfo_write_header_record(':EndHeader')

      RETURN

      END FUNCTION wfo_close_header


!***********************************************************************
!      INTEGER FUNCTION wfo_write_attribute_data(nx,ny,arr,ensimflg)
      INTEGER FUNCTION wfo_write_attribute_data(nx,ny)
!***********************************************************************
!    REV. 9.00   Mar.  2000  -  TS: CONVERTED TO FORTRAN 90

! THIS FUNCTION WRITES A BINARY WFO DATA RECORD
! WRITES GRID DATA FROM LEFT TO RIGHT STARTING FROM BOTTOM ROW
 
! RETURN:       = 1 SUCCESS
!               = 0 ERROR
!
!***********************************************************************

      use area_watflood
	implicit none

!     PARAMETER TYPE DEFINITIONS
      
      INTEGER :: nx,ny,i,j,ios

!      integer :: nx,ny,i,j
!      REAL*4    :: arr(nx,ny)

c      character*1  :: ensimflg

!       temp fix until allocated properly


      wfo_write_attribute_data = 1

!     WRITE THE RECORD
!	write(65,iostat=ios) ((arr(I,J),I=1,nx),J=1,ny)
      write(65,iostat=ios) ((outwfo(i,j),i=1,nx),j=1,ny)
	if(ios.ne.0)then
	  print*,' Error writing to unit 65 at approx line 458 in wfocode'
	  print*
        ensimflg='n'
	  
	  write(51,5101)
        write(98,5101)
5101  format(' Error writing to unit 65 at approx line=458 in wfcode'/
     * ' File closed and progarm continues without writing the rest'/
     * ' of the watflood.wfo file')
	endif

      RETURN

      END FUNCTION wfo_write_attribute_data

      SUBROUTINE withdraw()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     


!***********************************************************************
!
!   THIS S/R  takes water from storage for municipal or irrigation use
!
!***********************************************************************
!     rev. 9.8.49  Feb.  20/13  - NK: Added n=municipal & irrigation withdrawals

!     This s/r is called only once a year even if events are shorter
!     in the case of shorter events, 
!     the file is read in the first event: id=1      


      use area_watflood
	implicit none

      logical        :: exists,firstpass
      character(32)  :: tempname(3),use0
      character(256) :: line
      integer        :: no_frames
      integer        :: ios,i,j,k,l,m,n,ntake,iallocate
      real*4         :: lat0,long0,value0
      real*4         :: latS(6),longS(6),valueS(12)
	real*4         :: crop0(12),urban(12),other(12),
     *              	winter(12),summer(12)
	real*4         :: mohours(12),mosecs(12)


	data firstpass/.true./
	data crop0/0.0,0.0,0.0,0.05,0.05,0.14,0.39,0.29,0.04,0.04,0.0,0.0/
	data urban/0.06,0.06,0.06,0.06,0.06,0.13,
     *           0.13,0.13,0.13,0.06,0.06,0.06/
	data other/0.08333,0.08333,0.08333,0.08333,0.08333,0.08333,
     *           0.08333,0.08333,0.08333,0.08333,0.08333,0.08333/
	data summer/0.00,0.00,0.00,0.125,0.125,0.125,
     *           0.125,0.125,0.125,0.125,0.125,0.00/
	data winter/0.20,0.20,0.20,0.0,0.0,0.0,
     *           0.0,0.0,0.0,0.0,0.20,0.20/
      DATA mohours
     *     /744.,672.,744.,720.,744.,720.,744.,744.,720.,744.,720.,744./

      write(line,10001)year1
10001 format('diver\ab',i4,'.xyz')
      read(line,10002)tempname(1)
10002 format(a16)
      write(line,10003)year1
10003 format('diver\mb',i4,'.xyz')
      read(line,10002)tempname(2)
      tempname(3)='diver\SR12011.txt' ! SK withdrawal file name.
!     withdrawals can be made one year and not the next
      withdrawflg=.false.
      if(firstpass)then
        allocate(qwdr(na,12),stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *  'Error with allocation of withdraw(,) in withdraw.f'  
      endif
!     number of seconds in each month        
      do l=1,12
        mosecs(l)=mohours(l)*3600.0
      end do
!     for leap years extra day        
      if(mod(year1,4).eq.0)then
        mosecs(2)=mosecs(2)+86400.0
      endif

!     initialize withdrawals every year      
      do n=1,na
	  do l=1,12
          qwdr(n,l)=0.0
	  end do
      end do
      
!     Alberta & Manitoba Alberta & Manitoba Alberta & Manitoba Alberta & Manitoba        
c      if(iopt.ge.1.and.id.eq.1)then
c        open(unit=51,file='withdrawal_debug.csv',
c     *                              status='unknown',iostat=ios)
c      endif
        
      do k=1,2  ! alberta & manitoba (so far)
!       Look for the data file and read if present
!       and accumulate withdrawals in each grid
        INQUIRE(FILE=tempname(k),EXIST=exists)
        IF(exists)THEN
	    if(iopt.ge.1)
     *	    print*,'withdrawal file found file name =',tempname(k)(1:32)
          if(iopt.ge.1)then
            write(51,*)'Province #',k,tempname(k)
            write(51,*)
     *          '    i    j    k    m    n  monthly wthdrwls m**3 ---->'
          endif
          withdrawflg=.true.
          open(unit=99,file=tempname(k),status='old',iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',tempname(k)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in withdraw.f @ 104'
          else 
            if(iopt.ge.1)print*,'opened ',tempname(k)(1:32)
          endif
          ios=0
          i=0
!         count the number of lines in the file & find # locations        
          do while(ios.eq.0)  
            read(99,*,iostat=ios)line
            i=i+1
          end do
          ntake=i-2
          if(iopt.ge.1)then
            print*,'No of withdrawal locations =',ntake
          endif
          rewind 99
          read(99,*)line
!         accumulate the withdrawals in m**3 in each grid        
          do m=1,ntake
!           read the withdrawal amount          
            read(99,*)long0,lat0,value0,use0,source
            if(iopt.ge.0)then
              write(51,*)long0,lat0,value0,use0,source
            endif
            i=int((lat0-yorigin)/ydelta)+1
            j=int((long0-xorigin)/xdelta)+1
            if(i.ge.1.and.i.le.ycount.and.j.ge.1.and.j.le.xcount)then
            n=s(i,j)     !  grid number
            if(n.ge.1.and.n.le.naa)then
!             populate the array with monthly withdrawals in cubic metres
!             accumulate the amounts in each grid
              if(use0(1:14).eq.'growing_season')then
	          do l=1,12
	            qwdr(n,l)=qwdr(n,l)+value0*crop0(l)
	          end do
	        elseif(use0(1:11).eq.'open_season')then
 	          do l=1,12
	            qwdr(n,l)=qwdr(n,l)+value0*summer(l)
	          end do
	        elseif(use0(1:5).eq.'urban')then
 	          do l=1,12
	            qwdr(n,l)=qwdr(n,l)+value0*urban(l)
	          end do
	        elseif(use0(1:5).eq.'winter')then
 	          do l=1,12
	            qwdr(n,l)=qwdr(n,l)+value0*urban(l)
	          end do
              else      ! default - equal monthly withdrawals
!               this includes the annual class in the files          
 	          do l=1,12
	            qwdr(n,l)=qwdr(n,l)+value0*other(l)
	          end do
	        endif
	        if(iopt.ge.1)then
	          write(51,69900)i,j,k,m,n,(qwdr(n,l),l=1,12)
69900           format(5i5,12f12.0)	 
              endif  
            endif 
	      endif  ! in the watershed bounds
          end do
	    close(unit=99,status='keep')
        
	    withdrawflg=.true.
        endif  ! if data files exists
      end do ! m=1,2 provinces 

!     convert to withdrawal flows in m**3/s
!     qwdr(n,l) is used in route where it is subtracted from 
!     channel or lake inflow along with other outflows (e.g. streamloss)
!This conversion applies only to Alberta and Manitoba, Not Sask.
!---------------------------------------------------------------
	do l=1,12
        do n=1,na
          qwdr(n,l)=qwdr(n,l)/mosecs(l)
        end do
      end do

!     Saskatchewan Saskatchewan Saskatchewan Saskatchewan Saskatchewan Saskatchewan 
      if(iopt.ge.1)then
c        write(*,*)'sask'
c        print*,tempname(3)
        write(51,*)'sask withdraw'
      endif
      INQUIRE(FILE=tempname(3),EXIST=exists)
      IF(exists)THEN
        if(iopt.ge.1)
     *    print*,'withdrawal file found file name =',tempname(3)(1:32)
        if(iopt.ge.1)then
          write(51,*)'Saskatchewan file=',tempname(3)
          write(51,*)
     *          '    i    j    k    m    n  monthly wthdrwls m**3 ---->'
        endif
        withdrawflg=.true.
        open(unit=99,file=tempname(3),status='old',iostat=ios)
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file',tempname(3)
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          print*,'or target directory does not exist'
          stop 'Program aborted in withdraw.f @ 205'
        else 
          if(iopt.ge.1)print*,'opened ',tempname(3)(1:32)
        endif
!       read the coordinates  
        if(iopt.ge.1)write(51,*)'Saskatchewan withdrawals:'      
        do i=1,5
          read(99,*)line,latS(i),longS(i)
          if(iopt.ge.0)then
            write(51,*)line,latS(i),longS(i)
          endif
        end do
!       scan the file for the year we want
        do while(.not.eof(99))
          read(99,*,iostat=ios)i
          if(i.eq.year1)then
            read(99,99000)line   !read the blank line
99000       format(a1)            
            do k=1,5
              read(99,99001,iostat=ios)line,(valueS(l),l=1,12)
	        if(ios.ne.0)then
	          print*,'problems reading sask withdrawals'
	          print*
	          stop 'program aborted in withdraw @ 207'
	        endif
99001         format(a25,12f9.3)
              write(51,*)line,(valueS(l),l=1,12)
              i=int((latS(k)-yorigin)/ydelta)+1
              j=int((longS(k)-xorigin)/xdelta)+1
              n=s(i,j)
	        do l=1,12
	          qwdr(n,l)=qwdr(n,l)+valueS(l)
	        end do
            end do
          endif
        end do
        close(unit=99)
      endif  
      
      
            
!     write the withdrawals to       
      if(withdrawflg)then
      if(iopt.ge.1)then
        do l=1,12
          write(line,10005)l
10005     format(i2,'.xyz')
          read(line,10006)tempname(1)
10006     format(a6)
          open(unit=700+l,file=tempname(1),iostat=ios)
          if(ios.ne.0)then    ! added Nov. 10/14  nk
            print*
            print*,'Unable to open file',tempname(1)
            print*,'Possible cause(s):'
            print*,'file in use by another application'
            print*,'or target directory does not exist'
            stop 'Program aborted in withdraw.f @ 259'
          endif
          write(700+l,*)'month=',l,' unit =',700+l,' ID=',id
	    do i=1,ycount
	      do j=1,xcount
              n=s(i,j)
	        if(n.gt.0)then
                if(qwdr(n,l).gt.0.0)then
	          write(700+l,70000)
     *	                    xorigin+xdelta*float(j)-xdelta/2.0,',',
     *                      yorigin+ydelta*float(i)-ydelta/2.0,',',
     *                      qwdr(n,l),n,i,j
70000           format(2(f10.3,a1),f10.3,3(',',i10))     
                endif
              endif
	      end do
	    end do
	    if(id.eq.ni)close(unit=700+l,status='keep')
	  end do
	endif
	endif

      
      
      
      
      firstpass=.false.

      return

      end subroutine withdraw!************************************* 
      subroutine wqnut
! ************************************************************************ 

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Luis Leon
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     called every hour

! created Jul/98 - Luis Leon
!          this subroutine calculates the nutrient concentrations 
!          for each element of the watershed: cron(n,ii), crop(n,ii)

      use area_watflood
	implicit none

      integer :: n,ii,i,j
      real :: fpor,soln,pavr,peff,pavs,term1n,termexp1n,
     *        termexp2n,term2n,term3n,term1p,termexp1p,
     *        termexp2p,term2p,term3p,solp
       
! ***** Equations, References And Units From The Creams Model:
!      Frere Et.Al. (1980) The Nutrient Submodel. In: Knisel, W.G.
!           Creams: A Field Scale Model For Chemicals, Runoff, And Erosion
!           From Agricultural Management Systems, Usda, Rep No. 26
!      Young E.Al. (1986) Agricultural Nonpoint Source Pollution Model:
!           A Watershed Analysis Tool, Model Documentation, Usda.
!
! [general]
!      naa = number of "n" elements
!      classcount = total number of "ii" land classes
!      ieff = effective infiltration for storm [mm] - watflood value fake(ii)??
!      roff = total runoff for the storm [mm] - watflood value hsed(n,ii) = (d1-ds)
!      fpor = porosity factor [-]
!      peff = effective precipitation [mm]
!      por =  soil porosity [-]
!      spg(n) =  soil specific weight [-]
!      p(i,j) = storm precipitation for the time step [mm] - watflood value
!      er = nuetrient enrichment ratio
!      ysed = total sediment yield [kg/ha]
!      nofer = number of cells with fertilizer application
! [nitrogen]
!      cron(n,ii) = soluble nitrogen concentration in the runoff [kg/ha]
!      cronrot(n) = nitrogen concentration all classes for routing [kg/ha]
!      navs = available nitrogen in the surface [kg/ha]
!      navr = available nitrogen due to rainfall [kg/ha]
!      ndmv = rate for downward movement of nitrogen into the soil [1/mm]
!      nrmv = rate for nitrogen movement into the runoff [1/mm]
!      nrnc = nitrogen contribution due to rain [kg/ha]
!      soln = soluble nitrogen in the surface cm of the soil [kg/ha]
!      nfer(n) = nitrogen fertilizer application [kg/ha] - input data
!      nfa(n)  = fraction of nitrogen availability [%/100] - input data
!      ncpw = nitrogen concentration in pore water [ppm] - input data
!      ncrn = nitrogen concentration in rainfall [ppm] - input data
!      nlec = nitrogen leaching extraction coefficient - input data
!      nrec = nitrogen runoff extraction coefficient - input data
!      ndec = nitrogen decay fraction [%]
!      nsed = overland nitrogen transported by sediment [kg/ha]
!      nscn = soil nitrogen concentration [g n/g soil] - input data
! [phosphorus]
!      crop(n,ii) = soluble phosphorus concentration in the runoff [kg/ha]
!      croprot(n) = phosphorus concentration all classes for routing [kg/ha]
!      pavs = available phosphorus in the surface [kg/ha]
!      pavr = available phosphorus due to residual in soil [kg/ha]
!      pdmv = rate for downward movement of phosphorus into the soil [1/mm]
!      prmv = rate for phosphorus movement into the runoff [1/mm]
!      solp = soluble phosphorus in the surface cm of the soil [kg/ha]
!      pfer(n) = phosphorus fertilizer application [kg/ha] - input data
!      pfa(n)  = fraction of phosphorus availability [%/100] - input data
!      pcpw = phosphorus concentration in pore water [ppm] - input data
!      plec = phosphorus leaching extraction coefficient - input data
!      prec = phosphorus runoff extraction coefficient - input data
!      pdec = phosphorus decay fraction [%]      
!      psed = overland phosphorus transported by sediment [kg/ha]
!      pscn = soil phosphorus concentration [g p/g soil] - input data

!      ** initialize values      ****************

       do 10 n=1,naa
         cronrot(n)=0.0
         croprot(n)=0.0
         do 10 ii=1,classcount
              cron(n,ii)=0.0
              crop(n,ii)=0.0
   10  continue
 
   
!     ** calculate constants first **************

!      calculate the available nitrogen due to rainfall
      navr=ncrn*0.000001  
    
      do 20 n=1,naa
       i=yyy(n)
       j=xxx(n)
         if (p(i,j).gt.0.0) then
!         calculate soil porosity and porosity factor:
                por=1.0-(spg(n)/2.65)
                fpor=0.00001/por
!         calculate nutrients movement rates:
                ndmv=nlec/(10.*por)
                nrmv=nrec/(10.*por)
                pdmv=plec/(10.*por)
                prmv=prec/(10.*por)
!         calculate soluble nutrients in top cm of soil:
                soln=0.10*ncpw*por
                solp=0.10*pcpw*por
!         calculate available phosphorus due to soil residual:
                pavr=solp*fpor
!         calculate nitrogen contribution due to rainfall:
                nrnc=ncrn*p(i,j)
!         calculate the effective precipitation in the top cm:
                peff=p(i,j)-(10.*fpor)                
!         calculate the available nutrients in the surface:
                nfa(n)=nfa(n)/100.
                navs=(soln+(nfer(n)*nfa(n)))*fpor
                pfa(n)=pfa(n)/100.
                pavs=(solp+(pfer(n)*pfa(n)))*fpor

!     ** for each land class type ***************

      do 30 ii=1,classcount
           if ((hsed(n,ii).gt.0.0))then
!         calculate the nitrogen concentration in runoff
                term1n=(navs-navr)/fpor
                termexp1n=exp(-ndmv*fake(ii))
                termexp2n=exp(-ndmv*fake(ii)-nrmv*hsed(n,ii))
                term2n=termexp1n-termexp2n
                term3n=nrnc*hsed(n,ii)/peff
!         divide by 10 for effective precipitation in top centimeter                
                cron(n,ii)=((term1n*term2n)+term3n)/10.
!         calculate the phosphorus concentration in runoff
                term1p=(pavs-pavr)/fpor
                termexp1p=exp(-pdmv*fake(ii))
                termexp2p=exp(-pdmv*fake(ii)-prmv*hsed(n,ii))
                term2p=termexp1p-termexp2p
                term3p=pavr*prmv*hsed(n,ii)/fpor
!         multiply by 10 for porosity factor in top centimeter                    
                crop(n,ii)=((term1p*term2p)+term3p)*10.
!         class weighted by fractions of landclass (kg/ha)
                cron(n,ii)=cron(n,ii)*frac(n)*aclass(n,ii)
                crop(n,ii)=crop(n,ii)*frac(n)*aclass(n,ii)
!         conversion to kg/m3 (div/10,000) and then by hsed in m (/1000)
                cron(n,ii)=(cron(n,ii)/10000.)/(hsed(n,ii)/1000.)
                crop(n,ii)=(crop(n,ii)/10000.)/(hsed(n,ii)/1000.)
!         add for all classes to nutrient concentration per cell                
                cronrot(n)=cronrot(n)+cron(n,ii)           
                croprot(n)=croprot(n)+crop(n,ii)
           endif
30    continue


           endif
20    continue


! ****** for each element ***********************
!                  ***end of main loop** *
!  cronrot(n) and croprot(n)=total nutrients from element (n) in [kg/m3]
!           and ready to be routed into the downstream element.

      return
      
      end
!***********************************************************************
      subroutine wqread
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!
! this subroutine reads in the water quality data file
! lflv - oct/98
      
      use area_watflood
	implicit none

      integer :: lpos,ios,i,j,n,l

! open and read *.wqd file (*=file name from fln(1), .wqd=water quality data)
!      lpos=index(fln(1),'.')
!      fln(99)=fln(1)(1:lpos)//'wqd'
!      fln(1)='basin\duff.wqd'
!      open(unit=99,file=fln(1),status='old',iostat=ios)
!      if(ios.ne.0)then
!        print*,' Error opening file name ',fln(1)
!        print* 
!        stop 'Program aborted in WQread.for @ 22'
!      endif


      Print*,' Reading the water quality file  ',fln(26)


! sediment data...
      read(256,*)
      read(256,*)gamma,ro,viskin,grav,a_wq,b_wq
!       changed a & b to a_wq & b_wq

      read(256,*)(gc(i),i=1,classcount)
      read(256,*)(cf(i),i=1,classcount)

!     particle size - d50
      read(256,*)
      do 10 i=ycount,1,-1
         read(256,*)(diam(i,j),j=1,xcount)
   10 continue
   
!     specific weight - spg
      read(256,*)
      do 20 i=ycount,1,-1
         read(256,*)(spew(i,j),j=1,xcount)
   20 continue
   
!     erodibility - erod
      read(256,*)
      do 30 i=ycount,1,-1
         read(256,*)(erodi(i,j),j=1,xcount)
   30 continue
      
!     put into vector format
      do 50 n=1,naa
         i=yyy(n)
         j=xxx(n)
         d50(n)=diam(i,j)
         spg(n)=spew(i,j)
         erod(n)=erodi(i,j)
   50 continue

! nutrient data...
      read(256,*)
      read(256,*)ncrn,ndec,pdec,sdep   
      read(256,*)nscn,ncpw,nrec,nlec
      read(256,*)pscn,pcpw,prec,plec
   
!     fertilizer application

!     initialize values to zero
      do i=1,ycount
        do j=1,xcount
          mnfer(i,j)=0.0
          mpfer(i,j)=0.0
          mnfa(i,j)=0.0
          mpfa(i,j)=0.0
        end do
      end do

      read(256,*)
      read(256,*)nofer
      do 60 l=1,nofer
         read(256,*)i,j,mnfer(i,j),mpfer(i,j),mnfa(i,j),mpfa(i,j)
   60 continue

      print*,' Done reading '

!     put into vector format
      do 70 n=1,naa
         i=yyy(n)
         j=xxx(n)
         nfer(n)=mnfer(i,j)
         pfer(n)=mpfer(i,j)
         nfa(n)=mnfa(i,j)
         pfa(n)=mpfa(i,j)
   70 continue
      
      return

!     water quality data file not found:
99000 write(*,*)' error opening or reading wqd file - file not found'
      pause 'abnormal ending in spl #1 - hit any key to continue'
      stop  'program aborted in wqread - file not found'    

      end
!***********************************************************************
      subroutine wqroute(t)
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!***********************************************************************
!
! This subroutine routes the water quality variables: sediments and
! nutrients.  It will do so based on a mixed cell model (continuity)
! Modified: Nov/98 - LFL

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      integer :: n,lll,l,nnnext
      real*4  ::    wi,wold,t,woldn,woldp,wi2keep,weight

! initialize and reset values for each time step
      do 10 n=1,naa
! sediment        
        wi1(n)=wi2(n)
        wi2(n)=0.0
        wo1(n)=wo2(n)
!        wo2(n)=0.0  ! (try without this line nk)
        ss1(n)=ss2(n)
        ss2(n)=0.0
! nutrients (n-nitrogen ; p-phosphorus)
        wi1n(n)=wi2n(n)
        wi2n(n)=0.0
        wo1n(n)=wo2n(n)
        wo2n(n)=0.0
        ss1n(n)=ss2n(n)
        ss2n(n)=0.0
        wi1p(n)=wi2p(n)
        wi2p(n)=0.0
        wo1p(n)=wo2p(n)
        wo2p(n)=0.0
        ss1p(n)=ss2p(n)
        ss2p(n)=0.0
   10 continue    

	
      if(index.eq.0)then
        do 20 n=1,naa

   20   res(n)=0
        do 30 n=1,naa
          lll=next(n)
          do 30 l=1,noresv
            if(yyy(n).eq.ires(l).and.xxx(n).eq.jres(l)) res(n)=l
   30  continue
      endif


!*****   route the sediment   ****************

      do 40 n=1,naa
        lll=next(n)
!       when the slope <= 0.0 the element is not in the basin: skip route

        if(slope(n).gt.0.0)then
          if (store2(n).ne.0.0)then
!            wold=1.0e+25

            wold=wo2(n)

!           yrot is the ss conc. in kg/m^3  9nk0
!           wi is the sediment mass inflow in kg this dt  (nk)      


!            Mar. 23. 2004- Ek changed these lines

!            wi2(n)=wi2(n)+yrot(n)*qr(n)*t

            wi2(n)=wi1(n)+yrot(n)*(q1(n,3)+qint(n,3))*t

!      if(n.eq.130)then
!      print*,n,yrot(n),wi2(n),q1(n,3),qint(n,3)
!      endif  
  
	      do 50 ijk=1,50
              weight=amax1(0.5,real(ijk)/50.0)
!             ss2 is the suspended solids in kg   (nk 21/03/04   )
              ss2(n)=ss1(n)+(wi1(n)+wi2(n)-wo1(n)-wo2(n))/2

!             yfinal is the sediment concentration in kg/m^3  (nk)
              yfinal(n)=ss2(n)/store2(n)

!             wo2=sediment mass leaving during dt
              wo2(n)=weight*qo2(n)*yfinal(n)*t+(1.0-weight)*wo2(n)
              if(abs(wo2(n)-wold).lt.0.03*wold)goto 60
              wold=wo2(n)
  50        continue
  
!      if(n.eq.218.and.wi2(n).gt.0.0)then
!      print*,n,wi2(n),wi1(n),wi2(lll)
!      print*,wold,q1(n,3),qint(n,3)
!      endif  
  
    
  60        continue
          else
            ss2(n)=0.0
            wo2(n)=0.0
          end if
! decreased by the amount of deposition:            


!      REMOVED WITH IMPLEMENTATION OF WETLAND DECAY ROUTINE!!!!!!!

!          wi2(lll)=(1.0-(sdep/100.))*(wi1(lll)+wo2(n))
          wi2(lll)=(wi1(lll)+wo2(n))

      if(wi1(lll).lt.0.0.or.wi2(lll).lt.0.0.or.
     *                       wo2(n).lt.0.0.or.wo2(n).lt.0.0)
     *      write(98,*)n,next(n),wi1(lll),wi2(lll),wo1(n),wo2(n)
      if(next(n).eq.nnprint)
     *         write(98,*)n,next(n),wi1(lll),wi2(lll),wo1(n),wo2(n)
        endif
   40 continue


!*****   route the nutrients   ****************

      do 70 n=1,naa
        lll=next(n)
!       when the slope <= 0.0 the element is not in the basin: skip route
        if(slope(n).gt.0.0)then
          if (store2(n) .ne. 0.0) then

!            woldn=1.0e+25




!            Mar. 23. 2004- Ek changed these lines
            woldn=wo2n(n)
!            wi2n(n)=wi2n(n)+cronrot(n)*qr(n)*t
                     
            
!*****************************            
            wi2n(n)=wi1n(n)+cronrot(n)*(q1(n,3)+qint(n,3))*t
!*************************************


            do 80 ijk=1,50
              weight=amax1(0.5,real(ijk)/50.0)
              ss2n(n)=ss1n(n)+(wi1n(n)+wi2n(n)-wo1n(n)-wo2n(n))/2
              nfinal(n)=ss2n(n)/store2(n)
              wo2n(n)=weight*qo2(n)*nfinal(n)*t+(1.0-weight)*wo2n(n)
              if(abs(wo2n(n)-woldn).lt.0.03*woldn)goto 100
              woldn=wo2n(n)
  80        continue
 100  continue
          else
            ss2n(n)=0.0
            wo2n(n)=0.0
          end if

!      REMOVED WITH IMPLEMENTATION OF WETLAND DECAY ROUTINE!!!!!!!
!         decreased by the amount of decay:            
!          wi2n(lll)=(1-(ndec/100.))*(wi2n(lll)+wo2n(n))

          wi2n(lll)=(wi2n(lll)+wo2n(n))

        endif
   70 continue

      do 170 n=1,naa
        lll=next(n)
!       when the slope <= 0.0 the element is not in the basin: skip route
        if(slope(n).gt.0.0)then
          if (store2(n) .ne. 0.0) then

!            Mar. 23. 2004- Ek changed these lines

            woldp=wo2p(n)
!            wi2p(n)=wi2p(n)+croprot(n)*qr(n)*t

            wi2p(n)=wi1p(n)+croprot(n)*(q1(n,3)+qint(n,3))*t

            do 180 ijk=1,50
              weight=amax1(0.5,real(ijk)/50.0)
              ss2p(n)=ss1p(n)+(wi1p(n)+wi2p(n)-wo1p(n)-wo2p(n))/2.
              pfinal(n)=ss2p(n)/store2(n)
              wo2p(n)=weight*qo2(n)*pfinal(n)*t+(1.0-weight)*woldp
              if(abs(wo2p(n)-woldp).lt.0.03*woldp)goto 200
              woldp=wo2p(n)
 180        continue
 200  continue
          else
            ss2p(n)=0.0
            wo2p(n)=0.0
          end if

!      REMOVED WITH IMPLEMENTATION OF WETLAND DECAY ROUTINE!!!!!!!
!         decreased by the amount of decay:            
!          wi2p(lll)=(1-(pdec/100.))*(wi2p(lll)+wo2p(n))
          wi2p(lll)=(wi2p(lll)+wo2p(n))

        endif
  170 continue
 
      return
      end
!* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
      subroutine wqsed(jan,aintvl) 
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Luis Leon
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
! ************************************************************************ 
! modified: May/97 - Luis Leon
!          This subroutine calculates the sediment concentration 
!          for each element of the watershed yrot(n)
    
      use area_watflood
	implicit none

      integer :: jan,ii,n,i,j,i3,ii1,ii2
      real ::    aintvl,amin1,log10,psi  !<< replaced phi



! ****** Equations References And Units From:
!       Hartley, D.M.  1987.  "Simplified Process Model For Water
!            Sediment Yield From Single Storms.  Part I - Model
!            Formulation"  In Transactions Of The Asae 30(3):710-717.
!
!       naa = number of "n" elements
!       classcount = total number of "ii" land classes
!       gamma = specific weight of water [kg/m2/s2]
!       ro = density of the fluid [kg/m3]
!       viskin = kinemative viscosity [m2/s]
!       grav = standard acceleration [m/s2]
!       a,b = empirical constants used in transport capacity formula
!       kf(ii) = overland flow resistance [-]
!       gc(ii) = ground cover in percent
!       cf(ii) = cover factor in percent - determined by fig. 5.(hartley)
!       erod(n) = soil erodibility d [g/j]
!       d50(n) = average d50 of the detached sediment [mm] (lookup table)
!       spg(n) = specific gravity of detached sediment [-] (lookup table)
!       rey = shield's criterion reynold's number [-]
!       psi = shield's parmeter [-]
!       slope(n) = sqrt of channel slope
!       sl1(n) = sqrt of overland slope
!       al = length of element [m]
!       frac(n) = fraction of element within the basin
!       aclass(n,ii) = fraction of class ii in n
!       d1 = depth of water [mm]
!      ds = depression storage [mm]
! *note: hsed(n,ii) = d1-ds, average end depth [mm] {calc in runof5}
! *note: qs(n,ii) = overland flow [m3/s] = q1(ii) {calc in runof5}
!      ql(n,ii) = unit overland flow [m2/hr]
!      flow_shear = flow shear stress [units of gamma * mm]
!      crit_shear = critical shear [units of gamma * mm]
!      c_val = volumetric sediment concentration [-]
! *note: rf = runoff [mm] : rf(n,ii) = q1(ii)/tdum {calc in runof5}
!      y_crit = sediment transport capacity [kg/m2]
!      coef_cover = coefficient group for eq.44
!      ernfl = rate of rainfall energy [J/m2/hr]
!      ero = rate of runoff energy [J/m2/hr]
!      grf = rainfall soil detachment [kg/m2/hr]
!      gro = runoff soil detachment [kg/m2/hr]
!      y_pot = potential sediment supply/yield [kg/m2]
!      y(n,ii) = mininum of y_pot and y_crit [kg/m2]
!      yrot(n) = total yield from all classes for routing [kg/m3]
! 
!  ****** initialize values  ********************

       if(jan.eq.1)then

          do 40 ii=1,classcount
!            equation 16 (for each landclass)
             kf(ii)=60.0+3140.*gc(ii)**1.65
   40     continue
       endif

      do 50 n=1,naa
          yrot(n)=0.0
          do 50 ii=1,classcount
              y(n,ii) =0.0
              if(hsed(n,ii).le.0.0)then
                 hsed(n,ii)=0.0
              endif
!      convert to unit flow discharge (aintvl in hrs)
              ql(n,ii)=(qs(n,ii)/al)*(aintvl*3600.)
   50  continue
              
! ****** calculate rainffall energy *************

       do 60 n=1,naa
         i=yyy(n)
         j=xxx(n)
          if(p(i,j).le.0.0)then
             ernfl(n)=0.0
           else
!            eq43 [J/m2/hr] (for time step=1hr, p=rain intensity
!                 if not then divide p by time step)
             ernfl(n)=p(i,j)*(11.9+8.7*log10(p(i,j)))
           endif
   60  continue    

! ****** for each element ***********************

      do 120 n=1,naa
      if(slope(n).gt.0.0) then
          i=yyy(n)
          j=xxx(n)
          i3=ibn(n) 
          if(classcount.le.0) then
!           if classcount =0 then program runs in the lumped mode
            ii1=ibn(n)
            ii2=ibn(n)
          else
!           parameters grouped by land cover/use
            ii1=1
            ii2=classcount
          endif

! ****** for each land class type ***************
    
         do 110 ii=1,classcount
! *note: already change of qs [m3/s] to ql [m2/hr]
           if ((qs(n,ii).gt.0.0).and.(hsed(n,ii).gt.0.0))then
         
! * * * *  calculate the sediment tranport capacity
!             eq27 [gamma*mm] gamma cancels in eq21 : 5/8 is beta/beta+1
                flow_shear=(5.*60./8.*kf(ii))*hsed(n,ii)*sl1(n)
!             eq29 [-] including grav because shear has no gamma
                rey=((flow_shear*grav/1000.)**0.5)*d50(n)/viskin
!             from equation of shields diagram
                psi=(0.11/rey)+0.021*log10(rey)
!             eq20 [gamma*mm] gamma cancels in eq21
                crit_shear=(spg(n)-1.0)*psi*d50(n)
!             eq21 [-] for volumetric concentration
                c_val=a_wq*(flow_shear/crit_shear)**b_wq
!             eq42 [kg/m2] to compare with potential yield
                y_crit=2.65*ro*c_val*rf(n,ii)/1000.
                
!     changed a & b to a_wq and b_wq

! * * * *  calculate the sediment supply
!             eq44 [kg/m2/hr] divide by 1000 to convert g to kg
                coef_cover=(1-gc(ii))*cf(ii)
                grf=(ernfl(n)*coef_cover*erod(n))/1000.
!             eq45 [j/m2/hr] warning! the constant 60 has units
                ero=(60/kf(ii))*gamma*(ql(n,ii)/2.0)*sl1(n)
!             eq46 [kg/m2/hr] divide by 1000 to convert g to kg
                gro=(ero*erod(n))/1000.
!             eq47 [kg/m2]
                y_pot=(grf+gro)
                
! * * * *  calculate the sediment yield
!             compare capacity with supply and choose minimum
                y(n,ii)=amin1(y_crit,y_pot)
!             class weighted and converted to [kg/m3] /hsed in m (div/1000)
                y(n,ii)=y(n,ii)*frac(n)*aclass(n,ii)/(hsed(n,ii)/1000.) 
!             add for all classes to sediment supply per cell                
                yrot(n)=yrot(n)+y(n,ii)           

         endif

!      if(yrot(n).ne.0.0)then
!      print*,n,ii,yrot(n)
!      endif
  


110      continue
       endif
120    continue

!                   * * * end of main loop * * *
!  yrot(n)=total sediment inflow from element (n) in [kg/m3]
!  and ready to be routed into the downstream element ==> route

      return

      end
      SUBROUTINE write_flow1d_tb0(un,fn,nfg,ng,no_signf)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.1.64  Jul. 11/08  - NK: Coded up for tb0

!***********************************************************************
! - THIS SUBROUTINE OUTPUTS and r2c file.

! - List of arguments:

!   I - un      int        unit number
!   I - fn      int        file number
!   I - itogo   int        no. of hours until next rainfall
!   R - unit_conversion    REAL*4     conversion factor (area2)
!   I - FLN     CHAR*12    file names
!   I - DIR     CHAR*12    directory name
!   I - ocflg   int        open_close flag 1 open file -1 close file
!   I - frmflg  int        frame flag  1 new frame -1 end frame  
!                          0 each call = 1 frame with frame marks
!***********************************************************************

      use area_watflood
	implicit none

      INTEGER       :: un,fn,ii,no_signf,ng,nfg,i,j,l,ios
	character(20) :: junk
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday

!     FIRST TIME THROUGH THIS SUBROUTINE ONLY
!     OPEN OUTPUT FILE AND WRITE HEADER

      if(no_signf.lt.0)then

!     write the header

!     FILE NAMES AND UNIT NUMBERS DIFFER BY 30
!      write(*,1400)fn,fln(fn)
! 1400 format(' opening fln(',i3,'):',a30,'---')
!      write(*,*)

      open(unit=un,file=filename(fn),status='unknown',iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file',filename(fn)(1:40)
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        print*,'or target directory does not exist'
        stop 'Program aborted in write_flow_1d.f @ 48'
      endif
      PRINT*
	print*,'Opened unit=',un,' filename=',fln(fn)(1:40)
      write(un,3005)'########################################'
      write(un,3005)':FileType tb0  ASCII  EnSim 1.0         '
	write(un,3005)'# DataType               Time Series    '
      write(un,3005)'#                                       '
      write(un,3005)':Application             WATFLOOD       '
	write(un,3005)':Version                 2.1.23         '
	write(un,3020)':WrittenBy          ',author
      call date_and_time(cday,time)
	write(un,3010)':CreationDate       ',
     *     cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
3010  format(a20,a4,'-',a2,'-',a2,2x,a2,':',a2)
      write(un,3005)'#                                       '
	write(un,3005)'#---------------------------------------'
      write(un,3005)'#                                       '
      write(un,3020)'#SourceFile         ',source_file_name
	write(un,3020)':Name               ',name
      write(un,3005)'#                                       '
!     rev. 9.9.62  Mar.  21/15  - NK: Change zone from character to integer
c	write(un,3004)':Projection         ',coordsys_temp
c	if(coordsys_temp.eq.'LATLONG   ')then
c	  write(un,3004)':Ellipsoid          ',datum_temp
c	endif
c	if(coordsys_temp.eq.'UTM       ')then
c	  write(un,3004)':Ellipsoid          ',datum_temp
c        write(un,3001)':Zone               ',zone_temp
c	endif
      write(un,3004)':StartTime          ',startdate,starttime
	write(un,3005)':DeltaT  24:00:00.000   //1 day          '
c      write(un,3005)'#                                       '
c      write(un,3003)':UnitConverson      ',unit_conversion
      write(un,3005)'#                                       '
	write(un,3005)':ColumnMetaData                         '
c      write(un,3021)'   :ColumnUnits     ',column_units
	write(un,3021)'   :ColumnType      ',(column_type(l),l=1,ng)
	write(un,3021)'   :ColumnName      ',(resname(l),l=1,ng)
c	if(coordsys_temp.eq.'LATLONG   ')then
c	  write(un,3022)'   :ColumnLocationX ',(xres(l),l=1,ng)
c	  write(un,3022)'   :ColumnLocationY ',(yres(l),l=1,ng)
c	else
c	  write(un,3023)'   :ColumnLocationX ',(xres(l),l=1,ng)
c	  write(un,3023)'   :ColumnLocationY ',(yres(l),l=1,ng)
c	endif
      write(un,3005)':EndColumnMetaData                      '
      write(un,3005)'#                                       '
     	write(un,3005)':endHeader                              '

      return

      endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! fix fix

!       this is just to read in the new format
!       still needs to be programmed for multiple classes

!     the header is written only the first time through
!     this part is called with each class

!     :Frame and :EndFrame lines are written only for time series




!       NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
!       The r2c grids are written upside down: 
!                 south on top, north on bottom    !!!!!!!!!!
        if(no_signf.eq.0)then
          do i=1,ycount_temp
            write(un,1300)(outarray(i,j),j=1,xcount_temp)
1300        format(9999(1x,f5.0))
          end do          
        elseif(no_signf.eq.1)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1301)(outarray(i,j),j=1,xcount_temp)
1301        format(9999(1x,f5.1))
          end do          
        elseif(no_signf.eq.2)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1302)(outarray(i,j),j=1,xcount_temp)
1302        format(9999(1x,f5.2))
          end do          
        elseif(no_signf.eq.3)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1303)(outarray(i,j),j=1,xcount_temp)
1303        format(9999(1x,f6.3))
          end do          
        elseif(no_signf.eq.4)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1304)(outarray(i,j),j=1,xcount_temp)
1304        format(9999(1x,f7.4))
          end do          
        elseif(no_signf.eq.5)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1305)(outarray(i,j),j=1,xcount_temp)
1305        format(9999(1x,f8.5))
          end do          
        elseif(no_signf.eq.6)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1306)(outarray(i,j),j=1,xcount_temp)
1306        format(9999(1x,f9.6))
          end do          
        elseif(no_signf.eq.8)then   ! flow
          do i=1,ycount_temp
            write(un,1308)(outarray(i,j),j=1,xcount_temp)
1308        format(9999(1x,e10.3))
          end do          
        elseif(no_signf.eq.9)then   ! drain, dsnow
          do i=1,ycount_temp
            write(un,1309)(outarray(i,j),j=1,xcount_temp)
1309        format(9999(1x,f6.2))
          end do          
        else                        ! init soil moisture
          do i=1,ycount_temp
            write(un,1307)(outarray(i,j),j=1,xcount_temp)
1307        format(9999(1x,e12.6))
          end do          
        endif


        close(unit=un,status='keep')
        write(51,*)'Closed unit ',un,' Filename=  ',fln(fn)
        write(*,*)'Closed unit ',un,' Filename=  ',fln(fn)

      return

! FORMATS
 3000 format(a10,i5)
 3001 format(a20,i16)
 3002 format(2a20)
 3003 format(a20,f16.7)
 3004 format(a20,a10,2x,2a10)
 3005 format(a40)
 3006 format(a3,a10)
 3007 format(a14,i5,a6,i5)
 3012 format(a9)
 3020 format(a20,a40)
 3021 format(a20,999(1x,a11))
 3022 format(a20,999f10.0)
 3023 format(a20,999f10.4)
     
       END SUBROUTINE write_flow1d_tb0









      subroutine write_modflow(ju,juold,jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      use area_watflood
	implicit none


!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        DIMENSION     :: smc5(16)
        CHARACTER(14) :: date
        CHARACTER(3)  :: eofmark
        CHARACTER(1)  :: lineflg,smok,openflg
        character(20) :: junk
        REAL(4)		:: optlow,time,tot1,qwert,conv,scale,
     *               smc5,tj1,clock,t,thr,dtmin,dtmax,div,aintvl,sintvl,
     *               tot2,e1,tdum,qtemp,diff2,sdlz,
     *               wfo_spec_version_number
        INTEGER       :: rbin,inta,block,no1,classcount1,na1,ycount1,xcount1,
     *                   iallcnt1,n1,ii1,jan,m,ios,iallocate,
     *                   l,ii,juold,jj,lun,nhr,nhf,
     *                   icase,iz,jz,nchr,mz,ju,mon,i,j,n,
     *                   iwest,ieast,isouth,inorth,nocolumns,nno,k,
     *                   nu,igrdshft,minsnwflg,oldjan,flgevp22,
     *                   noresv1,nj,npick            
        CHARACTER(128):: qstr

        INTEGER(kind=2) :: result1,ntest

        CHARACTER(10) :: coordsys
!        INTEGER      :: xcount,ycount
!        REAL         :: xorigin,yorigin,xdelta,ydelta,
        real         :: a66

      real :: ha,fpw,kdn,nratio

!     write output for MODFLOW:  added May, 2000 NK
!     recharge is accumulated over 24 hour in this case
      do n=1,naa
        i=yyy(n)
        j=xxx(n)
        qrgrid(i,j)=rechrg(n)/24.
      end do
      if(ju.ne.juold.and.ju.ge.1)then
!       The grid for modflow might be different so the grid can be extended 
!       by iwest, ieast,isouth and inorth
!       Eventually these can be put into an input file
!       At this point, signs are wrong.
!        iwest=2
!        ieast=3
!        isouth=1
!        inorth=0

        iwest=0
        ieast=0
        isouth=0
        inorth=0
        
        nocolumns=xcount-iwest-ieast
        write(262,4701)ju,-1-isouth+ycount-inorth,nocolumns
!       write(*,4701)ju,-1-isouth+ycount-inorth,nocolumns
        if(nocolumns.le.10)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4710)
     *        (qrgrid(i,j),j=1+iwest,10+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.20)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4720)
     *        (qrgrid(i,j),j=1+iwest,20+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.30)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4730)
     *        (qrgrid(i,j),j=1+iwest,30+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.40)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4740)
     *        (qrgrid(i,j),j=1+iwest,40+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.50)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4750)
     *        (qrgrid(i,j),j=1+iwest,50+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.60)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4760)
     *        (qrgrid(i,j),j=1+iwest,60+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.70)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4770)
     *        (qrgrid(i,j),j=1+iwest,70+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.80)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4780)
     *        (qrgrid(i,j),j=1+iwest,80+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.90)then
          do i=ycount-inorth,1+isouth,-1
            write(262,4790)
     *        (qrgrid(i,j),j=1+iwest,90+iwest),jz,ju-1
          end do
        elseif(nocolumns.le.100)then
          do i=ycount-inorth,1+isouth,-1
            write(262,7900)
     *       (qrgrid(i,j),j=1+iwest,100+iwest),jz,ju-1
          end do
        endif

!       rechrg is a 24 hr value. It is accumulated in runof6 and 
!       then reset here as soon as it is written to the file
        do n=1,naa
          rechrg(n)=0.0
        end do

      endif  !(ju.ne.juold.and.ju.ge.1)

      return

4701  format(' Recharge in mm: ju=',i5,' rows=',i5,' columns=',i5)
4710          format(10f5.1,i5,i5,'  /jz,ju-1')
4720          format(20f5.1,i5,i5,'  /jz,ju-1')
4730          format(30f5.1,i5,i5,'  /jz,ju-1')
4740          format(40f5.1,i5,i5,'  /jz,ju-1')
4750          format(50f5.1,i5,i5,'  /jz,ju-1')
4760          format(60f5.1,i5,i5,'  /jz,ju-1')
4770          format(70f5.1,i5,i5,'  /jz,ju-1')
4780          format(80f5.1,i5,i5,'  /jz,ju-1')
4790          format(90f5.1,i5,i5,'  /jz,ju-1')
7900          format(100f5.1,i5,i5,'  /jz,ju-1')

 7500 format(i5,f10.3,i5,'  /jz,dtmin,ju  runoff in cms')
 7501 format(199f9.5)
 7502 format(i5,f10.3,i5,'  /jz,dtmin,ju  recharge in mm')
 7503 format(i5,f10.3,i5,'  /jz,dtmin,ju  baseflow in cms')




      end subroutine write_modflow      subroutine write_resume(jz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*

      use area_watflood
      use area_debug
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      DIMENSION     :: smc5(16)
      CHARACTER(14) :: date
      CHARACTER(3)  :: eofmark
      CHARACTER(1)  :: lineflg,smok
      character(20) :: junk
      REAL(4)		:: optlow,time,tot1,qwert,conv,scale,
     *               smc5,tj1,clock,t,thr,dtmin,dtmax,div,aintvl,sintvl,
     *               tot2,e1,tdum,qtemp,diff2,sdlz,
     *               wfo_spec_version_number
      INTEGER       :: rbin,inta,block,no1,classcount1,na1,
     *                   iallcnt1,n1,ii1,jan,m,ios,n,iallocate,
     *                   l,ii,juold,jj,lun,nhr,nhf,
     *                   i,j,icase,iz,jz,nchr,mz,ju,mon,
     *                   iwest,ieast,isouth,inorth,nocolumns,nno,k,
     *                   nu,igrdshft,minsnwflg,oldjan,flgevp22,
     *                   ycount1,xcount1,noresv1,nj,npick
      CHARACTER(128):: qstr,line,tmpLine

      INTEGER(kind=2) :: result1,ntest

      CHARACTER(10) :: coordsys
      real         :: a66
      real :: ha,fpw,kdn,nratio
      logical :: exists

      print*,'The to_be_continued flag tbcflg= ',tbcflg
      print*,' Writing a new resume.txt file - in write_resume'

      
!       THIS SECTION IS USED TO WRITE ALL STATE VARIABLES
!       SO PRGRAM CAN BE CONTINUED WHERE IT LEFT OFF
!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*
        open(unit=99,file='resume\resume.txt',status='unknown',
     *                              iostat=ios)
        if(ios.ne.0)then
          print*
          print*,'Unable to open file  resume.txt'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          stop 'Program aborted in write_resume.f @ 46'
        endif
!         we're assuming that noresv>noresvi
        write(99,*)'resume_version= 7'
	  write(99,*)'start y/m/d/h:',
     *              year_start,mo_start,day_start,hour_start
	  write(99,*)'end   y/m/d/h:',
     *              year_now,month_now,day_now,hour_now
        write(99,*,iostat=ios)classcount,na,ycount,xcount,no,noresv,
     *        (inbsnflg(n),n=1,no+noresv)
        block=1
        write(99,*)block,' block'   
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
        do n=1,na
          write(99,*)n,sump(n),qmax(n),sumrff(n)
	  end do
!       took qsn(n) out  Nov. 5/01  NK

        do n=1,na
          write(99,*)n,(effpor(n,ii),ii=1,classcount)
	  end do

        block=2
        write(99,*)block,' block'   
!     rev. 9.2.40  Jun.  09/06  - NK: added tto(),ttomin(),ttomax() to resume
        do n=1,na-1
          write(99,*)tto(n),ttomin(n),ttomax(n)
        end do


        block=3           !  sums
        write(99,*)block,' block'   
        write(99,*)(sr(ii),x4(ii),sexcess(ii),
     *     sq1(ii),sq1fs(ii),sqint(ii),sqintfs(ii),
     *     sdrng(ii),sdrngfs(ii),ii=1,classcount)

        block=4           !  sums
        write(99,*)block,' block' 
        do n=1,na
          do ii=1,classcount  
            write(99,*)n,ii,ssumr(n,ii),sumf(n,ii),sumffs(n,ii)
          end do
        end do

        block=5
!       write(*,*)block,' block' 
        write(99,*)block,' block' 
        do n=1,na
          i=yyy(n)
          j=xxx(n)
!          write(*,*)sn1(i,j),basinerr(i,j),ssmc(i,j),nhyd(i,j),
!     *                 nbasin(i,j)
          write(99,*)sn1(i,j),basinerr(i,j),nhyd(i,j),
     *               nbasin(i,j)
        end do

        block=6

        do i=1,no
          aa(i)=max(-1.0e+32,aa(i))
          bb(i)=max(-1.0e+32,bb(i))
          cc(i)=max(-1.0e+32,cc(i))
          ashnum(i)=max(-1.0e+32,ashnum(i))
          ashden(i)=max(-1.0e+32,ashden(i))
          qpeakh(i)=max(-1.0e+32,qpeakh(i))
          qpeaks(i)=max(-1.0e+32,qpeaks(i))
          nq(i)=max(-99999,nq(i))
          nqc(i)=max(-1.0e+32,aa(i))
          nxtbasin(i)=max(-99999,nxtbasin(i))
          area(i)=max(-1.0e+32,area(i))
          aa(i)=min(1.0e+32,aa(i))
          bb(i)=min(1.0e+32,bb(i))
          cc(i)=min(1.0e+32,cc(i))
          ashnum(i)=min(1.0e+32,ashnum(i))
          ashden(i)=min(1.0e+32,ashden(i))
          qpeakh(i)=min(1.0e+32,qpeakh(i))
          qpeaks(i)=min(1.0e+32,qpeaks(i))
          nq(i)=min(99999,nq(i))
          nqc(i)=min(1.0e+32,aa(i))
          nxtbasin(i)=min(99999,nxtbasin(i))
          area(i)=min(1.0e+32,area(i))
        end do

!     rev. 9.8.34  Oct.  23/12  - NK: Added sums to the resume.txt file
        block=7      ! additional sums
        write(99,*)block,' block   SV sums'   
        write(99,*)intevt
        write(99,*)evt
        write(99,*)sump
        write(99,*)ssumr
        write(99,*)sumf
        write(99,*)sumffs
        write(99,*)sumrff
        write(99,*)slzinflw
        write(99,*)sdlz
        write(99,*)sum_sublim
        write(99,*)sum_pet
        write(99,*)sum_et

        block=8      ! carry statistics
        write(99,*)block,' block    stats'   
        write(99,*)(aa(i),bb(i),cc(i),ashnum(i),ashden(i),
     *    qpeakh(i),qpeaks(i),nq(i),nqc(i),nxtbasin(i),area(i),i=1,no)
        
!     rev. 10.3.03 Jan.  21/20  = NK added dd_ice & dd_thaw to the resume.txt file      
        block=9      ! dd_ice
        write(99,*)block,' block    dd_ice'   
        write(99,*)(dd_ice(n),n=1,na)
            
        block=10      ! dd_thaw
        write(99,*)block,' block    dd_thaw'   
        write(99,*)(dd_thaw(n),n=1,na)

        eofmark='eof'
        write(99,9701)eofmark
        close(unit=99,status='keep')

        author='write_resume      '

!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        call write_flowinit()
        call write_soilinit()
!     rev. 9.8.91  Oct.  30/13  - NK: Got rid of lzs_init.r2c - data is in flow_init.r2c already
!       this data is in flow_init.r2c so this is redundant.
c        call write_lzsinit()
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



!     rev. 9.9.11  Mar.  20/14  - NK: Added lake_level_init.pt2 file for a resume
!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*

        open(unit=99,file='resume\lake_level_init.pt2',status='unknown')
        if(ios.ne.0)then    ! added Nov. 10/14  nk
          print*
          print*,'Unable to open file  lake_level_init.pt2'
          print*,'Possible cause(s):'
          print*,'file in use by another application'
          stop 'Program aborted in sub.f @ 4451'
        endif

        write(99,99011)'########################################   '
        write(99,99011)':FileType pt2  ASCII  EnSim 1.0            '
        write(99,99011)'#                                          '
        write(99,99011)'# DataType               EnSim PT2 Set     '  
        write(99,99011)'#                                          '
        write(99,99011)':Application             WATFLOOD          '
        write(99,99011)':Version                 2.1.23            '   
        write(99,99011)':WrittenBy          spl                    ' 
        write(99,99011)':CreationDate       2014-03-25  07:27      '
        write(99,99011)'#                                          '
        write(99,99011)'#--------------------------------------    '
        write(99,99011)':SourceFile                   flow_data    '
        write(99,99011)'#                                          '
        write(99,99011)':Name                 InitLakeLevels       '
        write(99,99011)'#                                          '
	  write(99,3004)':Projection         ',coordsys1
	  if(coordsys1.eq.'UTM       ')then
          write(99,3004)':Zone               ',zone1
	    write(99,3004)':Ellipsoid          ',datum1
	  elseif(coordsys1(1:7).eq.'LatLong')then
	    write(99,3004)':Ellipsoid          ',datum1
        endif
        write(99,99011)'#                                          '
        write(99,99011)':SampleTime        0000/00/00  00:00:00.0  '
        write(99,99011)'#                                          '    
        write(99,99011)':AttributeName 1     StationName           '  
        write(99,99011)':AttributeType 1     text                  '    
        write(99,99011)':AttributeName 2     InitialElevation      '   
        write(99,99011)':AttributeType 2     float                 '    
        write(99,99011)':AttributeName 3     Datum                 '   
        write(99,99011)':AttributeType 3     float                 '   
        write(99,99011)':AttributeName 4     Depth                 '   
        write(99,99011)':AttributeType 4     float                 '   
        write(99,99011)':AttributeName 5     SafeMax               '   
        write(99,99011)':AttributeType 5     float                 '   
        write(99,99011)':AttributeName 6     Qmin                  '   
        write(99,99011)':AttributeType 6     float                 '   
        write(99,99011)':AttributeName 6     DecayT                  '   
        write(99,99011)':AttributeType 6     float                 '   
        write(99,99011)':endHeader                                 '    
99011   format(a43)                               
        do l=1,noresv    
          write(99,99010)xres(l),yres(l),resname(l)(1:7),
     *      lake_elv(l,jz),b7(l),b7(l)-LKinvert(l),safe_max(l),qmin(l),
     *      DecayT(l)
99010     format(2f20.6,5x,a7,6f12.3)        
        end do     
      
        close(unit=99,status='keep')
 
      go to 77777
        
!     rev. 10.2.42 Jan.  16/19  - NK: Added resume\yyyy-mm-dd folder with resume files
!       Create the resume file directory and file name 
        line='mkdir resume'
        CALL execute_command_line(line(1:12))
!       Create the sub dir for this date      
        if(month_now.le.9.and.day_now.le.9)then
          write(tmpLine,10001)year_now,month_now,day_now
10001     format('mkdir resume\',i4,'-0',i1,'-0',i1)   
        elseif(month_now.le.9.and.day_now.gt.9)then
          write(tmpLine,10002)year_now,month_now,day_now
10002     format('mkdir resume\',i4,'-0',i1,'-',i2)   
        elseif(month_now.gt.9.and.day_now.le.9)then
          write(tmpLine,10003)year_now,month_now,day_now
10003     format('mkdir resume\',i4,'-',i2,'-0',i1)   
        else
          write(tmpLine,10004)year_now,month_now,day_now
10004     format('mkdir resume\',i4,'-',i2,'-',i2) 
        endif
        CALL execute_command_line(tmpLine(1:23))
      
!       make the copy commands 
        write(line,10005)tmpLine(7:23)
10005   format('copy resume.txt  ',a23,'\resume.txt')
        if(debug_output)write(63,*)line(1:51)
        CALL execute_command_line(line(1:51))
        
        write(line,10006)tmpLine(7:23)
10006   format('copy lake_level_init.pt2  ',a23,'\lake_level_init.pt2')
        if(debug_output)write(63,*)line(1:90)
        CALL execute_command_line(line(1:90))
        
        write(line,10007)tmpLine(7:23)
10007   format('copy flow_init.r2c  ',a23,'\flow_init.r2c')
        if(debug_output)write(63,*)line(1:72)
        CALL execute_command_line(line(1:72))
        
        write(line,10008)tmpLine(7:23)
10008   format('copy soil_init.r2c  ',a23,'\soil_init.r2c')
        if(debug_output)write(63,*)line(1:72)
        CALL execute_command_line(line(1:72))
        
77777   continue   
        
        write(98,*)
     *   'Info: A new  resume\resume.txt          file has been written'
        write(98,*)
     *   'Info: A new  resume\flow_init.r2c       file has been written'
        write(98,*)
     *   'Info: A new  resume\soil_init.r2c       file has been written'
        write(98,*)
     *   'Info: A new  resume\lake_level_init.pt2 file has been written'
        write(98,*)
     *   'Info: in the resume directory overwriting the old file'
        write(98,*)'Info: To NOT overwrite, set the' 
        write(98,*)'Info: tbcflg = n in the LAST(!) event file.'
        
      RETURN

3004  format(a20,a10,2x,a10)
9701  format(a3)
 9702 format(' resume.txt file length does not match current'/
     *       ' memory array spec. Regenerate the file'/)

99000 format(f5.1)
99001 format(f25.0)
99003 format(i1,5x,a50)
99004 format(i5)
98001 format(' Warning: Error reading resume.txt'/
     *' Probable cause: wrong format or end of file reached'/
     *' This could be due to a change in grid characteristics'/
     *' since creating the resume file'/
     *' Solution: create a new resume file with current executable'/
     *' block= ',i5)
      end subroutine write_resume

      SUBROUTINE write_flow1d_tb0(un,fn,nfg,ng,no_signf)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.1.64  Jul. 11/08  - NK: Coded up for tb0

!***********************************************************************
! - THIS SUBROUTINE OUTPUTS and r2c file.

! - List of arguments:

!   I - un      int        unit number
!   I - fn      int        file number
!   I - itogo   int        no. of hours until next rainfall
!   R - unit_conversion    REAL*4     conversion factor (area2)
!   I - FLN     CHAR*12    file names
!   I - DIR     CHAR*12    directory name
!   I - ocflg   int        open_close flag 1 open file -1 close file
!   I - frmflg  int        frame flag  1 new frame -1 end frame  
!                          0 each call = 1 frame with frame marks
!***********************************************************************

      use area_watflood
	implicit none

      INTEGER       :: un,fn,ii,no_signf,ng,nfg,i,j,l,ios
	character(20) :: junk
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday

!     FIRST TIME THROUGH THIS SUBROUTINE ONLY
!     OPEN OUTPUT FILE AND WRITE HEADER

      if(no_signf.lt.0)then

!     write the header

!     FILE NAMES AND UNIT NUMBERS DIFFER BY 30
!      write(*,1400)fn,fln(fn)
! 1400 format(' opening fln(',i3,'):',a30,'---')
!      write(*,*)

      open(unit=un,file=filename(fn),status='unknown',iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file',filename(fn)(1:40)
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        print*,'or target directory does not exist'
        stop 'Program aborted in write_flow_1d.f @ 48'
      endif
      PRINT*
	print*,'Opened unit=',un,' filename=',fln(fn)(1:40)
      write(un,3005)'########################################'
      write(un,3005)':FileType tb0  ASCII  EnSim 1.0         '
	write(un,3005)'# DataType               Time Series    '
      write(un,3005)'#                                       '
      write(un,3005)':Application             WATFLOOD       '
	write(un,3005)':Version                 2.1.23         '
	write(un,3020)':WrittenBy          ',author
      call date_and_time(cday,time)
	write(un,3010)':CreationDate       ',
     *     cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
3010  format(a20,a4,'-',a2,'-',a2,2x,a2,':',a2)
      write(un,3005)'#                                       '
	write(un,3005)'#---------------------------------------'
      write(un,3005)'#                                       '
      write(un,3020)'#SourceFile         ',source_file_name
	write(un,3020)':Name               ',name
      write(un,3005)'#                                       '
!     rev. 9.9.62  Mar.  21/15  - NK: Change zone from character to integer
c	write(un,3004)':Projection         ',coordsys_temp
c	if(coordsys_temp.eq.'LATLONG   ')then
c	  write(un,3004)':Ellipsoid          ',datum_temp
c	endif
c	if(coordsys_temp.eq.'UTM       ')then
c	  write(un,3004)':Ellipsoid          ',datum_temp
c        write(un,3001)':Zone               ',zone_temp
c	endif
      write(un,3004)':StartTime          ',startdate,starttime
	write(un,3005)':DeltaT  24:00:00.000   //1 day          '
c      write(un,3005)'#                                       '
c      write(un,3003)':UnitConverson      ',unit_conversion
      write(un,3005)'#                                       '
	write(un,3005)':ColumnMetaData                         '
c      write(un,3021)'   :ColumnUnits     ',column_units
	write(un,3021)'   :ColumnType      ',(column_type(l),l=1,ng)
	write(un,3021)'   :ColumnName      ',(resname(l),l=1,ng)
c	if(coordsys_temp.eq.'LATLONG   ')then
c	  write(un,3022)'   :ColumnLocationX ',(xres(l),l=1,ng)
c	  write(un,3022)'   :ColumnLocationY ',(yres(l),l=1,ng)
c	else
c	  write(un,3023)'   :ColumnLocationX ',(xres(l),l=1,ng)
c	  write(un,3023)'   :ColumnLocationY ',(yres(l),l=1,ng)
c	endif
      write(un,3005)':EndColumnMetaData                      '
      write(un,3005)'#                                       '
     	write(un,3005)':endHeader                              '

      return

      endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! fix fix

!       this is just to read in the new format
!       still needs to be programmed for multiple classes

!     the header is written only the first time through
!     this part is called with each class

!     :Frame and :EndFrame lines are written only for time series




!       NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
!       The r2c grids are written upside down: 
!                 south on top, north on bottom    !!!!!!!!!!
        if(no_signf.eq.0)then
          do i=1,ycount_temp
            write(un,1300)(outarray(i,j),j=1,xcount_temp)
1300        format(9999(1x,f5.0))
          end do          
        elseif(no_signf.eq.1)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1301)(outarray(i,j),j=1,xcount_temp)
1301        format(9999(1x,f5.1))
          end do          
        elseif(no_signf.eq.2)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1302)(outarray(i,j),j=1,xcount_temp)
1302        format(9999(1x,f5.2))
          end do          
        elseif(no_signf.eq.3)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1303)(outarray(i,j),j=1,xcount_temp)
1303        format(9999(1x,f6.3))
          end do          
        elseif(no_signf.eq.4)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1304)(outarray(i,j),j=1,xcount_temp)
1304        format(9999(1x,f7.4))
          end do          
        elseif(no_signf.eq.5)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1305)(outarray(i,j),j=1,xcount_temp)
1305        format(9999(1x,f8.5))
          end do          
        elseif(no_signf.eq.6)then   ! swe, precip and temp
          do i=1,ycount_temp
            write(un,1306)(outarray(i,j),j=1,xcount_temp)
1306        format(9999(1x,f9.6))
          end do          
        elseif(no_signf.eq.8)then   ! flow
          do i=1,ycount_temp
            write(un,1308)(outarray(i,j),j=1,xcount_temp)
1308        format(9999(1x,e10.3))
          end do          
        elseif(no_signf.eq.9)then   ! drain, dsnow
          do i=1,ycount_temp
            write(un,1309)(outarray(i,j),j=1,xcount_temp)
1309        format(9999(1x,f6.2))
          end do          
        else                        ! init soil moisture
          do i=1,ycount_temp
            write(un,1307)(outarray(i,j),j=1,xcount_temp)
1307        format(9999(1x,e12.6))
          end do          
        endif


        close(unit=un,status='keep')
        write(51,*)'Closed unit ',un,' Filename=  ',fln(fn)
        write(*,*)'Closed unit ',un,' Filename=  ',fln(fn)

      return

! FORMATS
 3000 format(a10,i5)
 3001 format(a20,i16)
 3002 format(2a20)
 3003 format(a20,f16.7)
 3004 format(a20,a10,2x,2a10)
 3005 format(a40)
 3006 format(a3,a10)
 3007 format(a14,i5,a6,i5)
 3012 format(a9)
 3020 format(a20,a40)
 3021 format(a20,999(1x,a11))
 3022 format(a20,999f10.0)
 3023 format(a20,999f10.4)
     
       END SUBROUTINE write_flow1d_tb0









      subroutine write_sens_result(rvrname,classname,delta_factor)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
      use area_watflood
      USE EF_module
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      character(20) :: rvrname(12),classname(24)
      integer   :: ii,j,ios
      real*4    :: delta_factor


      open(unit=99,file='sensitivity.txt',status='unknown',
     *             iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file  sensitivity.txt'
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        stop 'Program aborted in write_sensitivity.f @ 23'
      endif

      write(99,*)'Routing parameters:'
      write(99,10000)'param ',(rivtype(ii),ii=1,nrvr)
      do j=1,12,2
        write(99,10000)rvrname(j)
        write(99,10001)int(delta_factor),(nrvr_array(ii,j),ii=1,nrvr)
        write(99,10002)int(delta_factor),(nrvr_array(ii,j+1),ii=1,nrvr)
      end do
      write(99,*)'Hydrological parameters:'
      write(99,10010)'param ',(nclass(ii),ii=1,classcount)
      do j=1,24,2
        if(j.ne.17)then
          write(99,*)classname(j)
          write(99,10003)int(delta_factor),
     *       (class_array(ii,j),ii=1,classcount)
          write(99,10004)int(delta_factor),
     *       (class_array(ii,j+1),ii=1,classcount)
        else
          write(99,*)classname(j)
          write(99,10005)(class_array(ii,j),ii=1,classcount)
          write(99,10006)(class_array(ii,j+1),ii=1,classcount)
        endif
      end do

      close(unit=99,status='keep')

	print*
	print*,'Please see `sensitivities.txt` in working directory' 
	print*,'for a summary of the sensitivities'
	print*

10000 format(a6,<nrvr>a10)
10001 format('-',i3,'%',<nrvr>f10.3)
10002 format('+',i3,'%',<nrvr>f10.3)
10010 format(a6,<classcount>a10)
10003 format('-',i3,'%',<classcount>f10.3)
10004 format('+',i3,'%',<classcount>f10.3)
10005 format('- 1dC',<classcount>f10.3)
10006 format('+ 1dC',<classcount>f10.3)


      return

      end subroutine write_sens_result      SUBROUTINE write_soilinit()

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.3.05  Nov.  13/06  - NK: adder write_flowinit.for to flowinit.for

!     "author" must be specifief before calling this s/r

      use area_watflood
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      logical    :: exists
c	integer(4)    :: i,j,n,ii,ios,mm
	integer(4)    :: i,j,n,ii,ios,k
      CHARACTER(30) :: sys_command
      CHARACTER(10) :: time
      CHARACTER(8)  :: cday
!     write the init file for watroute in r2c format

!     rev. 10.2.50 Mar.  22/19  - NK: New resume files written to \resume\*.*
	fln(99)='resume\soil_init.r2c'
      inquire(FILE=fln(99),EXIST=exists)
      open(99,file=fln(99),status='unknown',iostat=ios)
      if(ios.ne.0)then    ! added Nov. 10/14  nk
        print*
        print*,'Unable to open file  soil_init.r2c'
        print*,'Possible cause(s):'
        print*,'file in use by another application'
        stop 'Program aborted in write_soilinit.f @ 33'
      endif


!     writing a new initial conditions r2c file for watroute      

!     write the init file for runoff in r2c format
!     write the init file for runoff in r2c format
!     write the init file for runoff in r2c format
!     write the init file for runoff in r2c format
!     write the init file for runoff in r2c format

!     Jan 22/07  nk

      write(99,3005)'########################################'
      write(99,3005)':FileType r2c  ASCII  EnSim 1.0         '
      write(99,3005)'#                                       '
	write(99,3005)'# DataType               2D Rect Cell   '
      write(99,3005)'#                                       '
      write(99,3005)':Application             EnSimHydrologic'
	write(99,3005)':Version                 2.1.23         '
	write(99,3005)':WrittenBy               soilinit       '
      call date_and_time(cday,time)
	write(99,3010)':CreationDate       ',
     *       cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
3010  format(a20,a4,'/',a2,'/',a2,2x,a2,':',a2)
      write(99,3005)'#                                       '
        if(tbcflg.eq.'y')then
	    write(99,3011)'#start y/m/d/h:',
     *                   year_start,mo_start,day_start,hour_start
!     REV. 10.1.26 Mar.  23/16  - NK: Fixed comment for spinup period 
	    write(99,3011)'#end   y/m/d/h:',
     *                   year_now,month_now,day_now,hour_now
 3011 format(a15,4i10)
        endif
	write(99,3005)'#---------------------------------------'
      write(99,3020)':SourceFileName     ',fln(6)
      write(99,3005)'#                                       '
	write(99,3004)':Projection         ',coordsys1
!     rev. 9.9.62  Mar.  21/15  - NK: Change zone from character to integer
	if(coordsys1.eq.'UTM       ')then
          write(99,3001)':Zone               ',zone1
	    write(99,3004)':Ellipsoid          ',datum1
	endif
	if(coordsys1.eq.'LATLONG   ')then
	    write(99,3004)':Ellipsoid          ',datum1
      endif
      write(99,3005)'#                                       '
      write(99,3003)':xOrigin            ',xorigin
      write(99,3003)':yOrigin            ',yorigin
      write(99,3005)'#                                       '
      n=0
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'v         ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'d1        ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'d1fs      ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'uzs       ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'uzsfs     ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'snowc     ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'sca       ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'wcl       ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'def       ' 
      end do
	do ii=1,classcount
	  n=n+1
        write(99,3008)':AttributeName ',n,ii,'api       ' 
      end do
	  n=n+1
        write(99,3009)':AttributeName ',n,'tto       ' 
	  n=n+1
        write(99,3009)':AttributeName ',n,'ttomin    ' 
	  n=n+1
        write(99,3009)':AttributeName ',n,'ttomax    ' 

      write(99,3005)'#                                       '
      write(99,3001)':xCount             ',xcount
      write(99,3001)':yCount             ',ycount
      write(99,3003)':xDelta             ',xdelta
      write(99,3003)':yDelta             ',ydelta
      write(99,3005)'#                                       '
      write(99,3005)':EndHeader                              '

 3000 format(a10,i5)
 3001 format(a20,i16)
 3002 format(2a20)
 3003 format(a20,f16.7)
 3004 format(a20,a10,2x,a10)
 3005 format(a40)
 3006 format(a3,a10)
 3007 format(a14,i5,a6,i5)
 3008 format(a15,2i5,a10)
 3009 format(a15,i5,5x,a10)
 3012 format(a9)
 3020 format(a20,a40)
 	if(iopt.eq.2)print*, 'in flowinit at 1302'

!     initialize p() to male sure there is no junk in the unused grids
      do i=1,ycount
	  do j=1,xcount
	    p(i,j)=0.0
	  end do
	end do
!     p(1,1) is used to show the top left corner of each frame in the file. 
!     If there is a value, it's over written.
      k=0
!     Initial interception mm storage
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=v(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial surface storage mm bare
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=d1(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial surface storage mm snow
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=d1fs(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial upper zone storage mm bare
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=uzs(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial upper zone storage mm snow
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=uzsfs(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial snow water equivalent in mm swe 
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=snowc(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial snow covered area fraction sca
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=sca(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial free water content in snow mm
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=wcl(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial heat deficit mm
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=def(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial api mm
      do ii=1,classcount
        k=k+1
        p(1,1)=float(k)
        do n=1,naa
          i=yyy(n)
          j=xxx(n)
          p(i,j)=api(n,ii)
        end do
        do i=1,ycount
          write(99,4009)(p(i,j),j=1,xcount)
        end do
	end do

!     Initial tto  
      k=k+1
      p(1,1)=float(k)
      do n=1,naa
        i=yyy(n)
        j=xxx(n)
        p(i,j)=tto(n)
      end do
	do i=1,ycount
        write(99,4009)(p(i,j),j=1,xcount)
      end do

!     Initial ttomin  
      k=k+1
      p(1,1)=float(k)
      do n=1,naa
        i=yyy(n)
        j=xxx(n)
        p(i,j)=ttomin(n)
      end do
	do i=1,ycount
        write(99,4009)(p(i,j),j=1,xcount)
      end do

!     Initial ttomax 
      k=k+1
      p(1,1)=float(k)
      do n=1,naa
        i=yyy(n)
        j=xxx(n)
        p(i,j)=ttomax(n)
      end do
	do i=1,ycount
        write(99,4009)(p(i,j),j=1,xcount)
      end do

      close(unit=99,status='keep')

 4001 format(999(' ',f5.0))
 4002 format(999(' ',f10.3))
 4003 format(999(' ',i5))
 4004 format(999(' ',f10.5))
 4005 format(999(' ',f10.7))
 4006 format(999(' ',f8.1))
 4007 format(999(' ',f8.0))
 4008 format(999(' ',f8.3))
 4009 format(999(' ',e10.3))
 4010 format(999(' ',f5.3))
 4011 format(999(' ',f5.1))

 4050 format(999(i4))
 4052 format(999(' ',i3))

      close(unit=99,status='keep')

      return

      end SUBROUTINE write_soilinit

      subroutine write_wfo(t,jz,iz)

!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen and Dave Watson (NRC)
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!     rev. 9.8.22  Jul.  17/12  - NK: Added resetflg to reset cumm. precip Sept.1

      use area_watflood
      use areacg
      
	implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

        REAL(4)		::     wfo_spec_version_number,tot1,t
        INTEGER       :: nratio,nj,jan,iallcnt1,i,j,ios,n,ii,jj,inta,
     *                  iallocate,l,npick,jz,iz
      INTEGER :: wfo_write_timestamp
      INTEGER :: wfo_write_attribute_data

	DATA iallcnt1/0/


!     NOTE: FOR MONTHLY RUNS, DIMENSIONS CAN BE CHANGED FROM 
!           3,8784,500  TO  12,366,3000

!>>>>>>>>>>>>>  AB: STUFF FOR ENSIM
      INTEGER(4) :: wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss,
     *                   wfo_ms
      INTEGER(4) :: wfo_seq


!       WRITE STUFF FOR ENSIM:
!       WRITE STUFF FOR ENSIM:
!       WRITE STUFF FOR ENSIM:
!       WRITE STUFF FOR ENSIM:
!       WRITE STUFF FOR ENSIM:
!       but not if we're optimizing 

!     rev. 9.1.51  Jan.  28/04  - NK: added iz.ne.jz conditional to ENSIM output  
!     Before this revision stuff was written to the WFO file at intervals < 1 hr
!     i.e. at the routing time steps and not hourly or greater.
!     Now stuff can not be reported at smaller than 1 hr dt's
!     rev. 9.2.20  Oct.  28/05  - NK: WFO_SPEC - reporting start & finish times 


!     Accumulate the precip during the current reporting time step
!           (not the modelling time step)
      if(wfo_pick(2).eq.1)then
        do n=1,naa
          ii=yyy(n)
          jj=xxx(n)
          wfo_sum_p(n)=wfo_sum_p(n)+p(ii,jj)
        end do
      endif

!     rev. 9.1.50  Jan.  14/04  - NK: version number added to the wfo_spec.txt file
!     Total precip accumulation since the run began
!     This is modified to be able to accumulate for a period
!     shorter than the model run so the total precip for one event
      if(wfo_pick(3).eq.1)then
!     can be shown in ENSIM
        do n=1,naa
          ii=yyy(n)
          jj=xxx(n)
          wfo_cum_p(n)=wfo_cum_p(n)+p(ii,jj)
        end do
      endif
      
!     REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
      if(wfo_pick(8).eq.1)then
!     can be shown in ENSIM
        do n=1,naa
          wfo_sum_qsyn(n)=wfo_sum_qsyn(n)+qo2(n)
        end do
      endif
!     write wfo file only at chosen interval

      if(mod(jz,min(ireport,mhtot)).eq.0.and.iz.ne.jz)then
!       need the min(ireport,mhtot) for the case where the user
!       specifies ireport to be greated than the event length
!       which happens often because months are different lengths

        wfo_seq=wfo_seq+1
!       SET TIME YR,MONTH,DAY,HR,MIN,SEC,MILLISEC FOR THIS STEP
c        wfo_yy=0
c        wfo_mm=0
c        wfo_dd=0
c        wfo_hh=int(totaltime)
c!       wfo_hh=int(time)
c        inta=wfo_hh
c        wfo_mi=int((totaltime-float(inta))*60.0)
c        wfo_ss=0
c        wfo_ms=0
        
!     REV. 10.1.33 Jun   20/16  - NK: Change the time stamp in the watflood.wfo file
!     year_now,month_now,day_now,hour_now
      wfo_yy=year_now
      wfo_mm=month_now 
      wfo_dd=day_now   
      wfo_hh=hour_now
      
!     rev. 10.1.68 Feb.  18/17  - NK: Made midnight 00 instead of 24 
      if(wfo_hh.eq.24)wfo_hh=0
      wfo_mi=0
      wfo_ss=0
      wfo_ms=0
      
c      WRITE(123,*)wfo_yy,wfo_mm,wfo_dd,wfo_hh       ! <<<<<<<<<<<<<<<<<<<<<<<<<<< take out
      
!       WRITE THE TIMESTAMP
        if(wfo_write_timestamp(wfo_seq,wfo_seq,wfo_yy,wfo_mm,
     *    wfo_dd,wfo_hh,wfo_mi,wfo_ss,wfo_ms).ne.1) then
          write (*,'(A)') ' '
          write (*,'(A)') '  *** FATAL ERROR ***     '
          write (*,'(A)') ' Unable to Write Timestamp'
          STOP 'Program terminated in sub @780'
        end if


!               ATTRIBUTE 1 - TEMP
!               I'M DOING THIS B/C TEMP IS NOT DYNAMICALLY ALLOCATED SO
!               IT IS TOO LARGE AND SO WE NEED TO USE OUTWFO
                if(wfo_pick(1).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=ttemp(ii,jj)
                  end do
                  if(wfo_write_attribute_data
     *                    (xcount,ycount).ne.1)then
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               ATTRIBUTE 2 - PRECIP
!               I'M DOING THIS B/C P IS NOT DYNAMICALLY ALLOCATED SO IT
!               IS TOO LARGE AND SO WE NEED TO USE OUTWFO
                if(wfo_pick(2).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
!                   summed for reporting time step only
                    outwfo(jj,ii)=wfo_sum_p(n)
!                   reset the accumulator to 0.0 each time is is reported
                    wfo_sum_p(n)=0.0
                  end do
                  if(wfo_write_attribute_data
     *                  (xcount,ycount).ne.1)then
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!     rev. 9.1.44  Jun.  11/03  - Added Cumulative precip to the wfo file
!               ATTRIBUTE 3 - Cum. PRECIP
!               I'M DOING THIS B/C P IS NOT DYNAMICALLY ALLOCATED SO IT
!               IS TOO LARGE AND SO WE NEED TO USE OUTWFO
                if(wfo_pick(3).eq.1)then
                  do n=1,naa
                   ii=yyy(n)
                   jj=xxx(n)
!                  summed for reporting time step only
                   outwfo(jj,ii)=wfo_cum_p(n)
                  end do
                  if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif
                
!               ATTRIBUTE 4 - LOWER ZONE STORAGE
                if(wfo_pick(4).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=lzs(n)
                  end do
                  if(wfo_write_attribute_data
     *             (xcount,ycount).ne.1)then 
!                    WRITE ERROR
                     GO TO 98010
                  end if
                endif
c!               ATTRIBUTE 5 - groundwater outflow
c!               trcflg must be 'y' for this
c!               checked in rd_wfo_spec.for
c                if(wfo_pick(5).eq.1)then
c!     rev. 9.9.25  Sep.  02/14  - NK: Finally fixed the error when nbasin=0
c                  if(trcflg.eq.'y')then
c                    do n=1,naa
c                      ii=yyy(n)
c                      jj=xxx(n)
c                      l=nbasin(ii,jj)
c                      if(l.ne.0)then
c                        outwfo(jj,ii)=isoout2gw(n,l)/t
c                      else
c!                       this can happen if a watershed does not have a gauge.                      
c                        outwfo(jj,ii)=-1.0
c                      endif
cc                      outwfo(jj,ii)=isoout2gw(n,l)/t
c                    end do
cc                  else
cc                    do n=1,naa
cc                      ii=yyy(n)
cc                      jj=xxx(n)
cc                      l=nbasin(ii,jj)
cc                      if(l.ne.0)outwfo(jj,ii)=-999.0
cc                      outwfo(jj,ii)=isoout2gw(n,l)/t
cc                    end do
c                    
cc                  endif    !trcflg
c                 if(wfo_write_attribute_data
c     *             (xcount,ycount).ne.1)then 
c!                    WRITE ERROR
c                     GO TO 98010
c                  end if
c                endif

!               ATTRIBUTE 5 - groundwater outflow
                if(wfo_pick(5).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=qlz(n)
                  end do
                  if(wfo_write_attribute_data
     *                      (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif
                
!               ATTRIBUTE 6 - GRID RUNOFF
                if(wfo_pick(6).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=qr(n)
                  end do
                  if(wfo_write_attribute_data
     *                      (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
!               ATTRIBUTE 7 - OBSERVED GRID OUTFLOW
                if(wfo_pick(7).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=wfo_qhyd(n,jz)
                  end do
                  if(wfo_write_attribute_data
     *              (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               ATTRIBUTE 8 - COMPUTED GRID OUTFLOW
                if(wfo_pick(8).eq.1)then
!                 REV. 10.1.34 Jul   05/16  - NK: Added Obs. & Model mean flows to wfo file
!                 calculate the mean flow for this time step
                  do n=1,naa
                    wfo_qsyn(n)=wfo_sum_qsyn(n)/float(ireport)
!                   reset to zero for next time step                    
                    wfo_sum_qsyn(n)=0.0
                  end do

                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=wfo_qsyn(n)
                  end do
                  if(wfo_write_attribute_data
     *              (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               ATTRIBUTE 9 - WEIGHTED SWE
                if(wfo_pick(9).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=totsnw(n)
                  end do
                  if(wfo_write_attribute_data
     *             (xcount,ycount).ne.1)then 
!                    WRITE ERROR
                     GO TO 98010
                  end if
                endif

!     rev. 9.1.35  Dec. 26/02  - Added wetland & channel heights to the wfo file
!               ATTRIBUTE 10 - wetland internal water depth 
                if(wfo_pick(10).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=hwet2(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               ATTRIBUTE 11 - channel depth
                if(wfo_pick(11).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=hcha2(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               rev. 9.1.21  Jun.  28/02  - Added wetland storage & outflow to the wfo file
!               ATTRIBUTE 12 - wetland storage
                if(wfo_pick(12).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
c                    outwfo(jj,ii)=wstore2(n)
                    outwfo(jj,ii)=bankfull(ii,jj)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                    end if
                endif

!               ATTRIBUTE 13 - wetland OUTFLOW
                if(wfo_pick(13).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=qowet2(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!               ATTRIBUTE 14 - weighted evapotranspiration
                if(wfo_pick(14).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=eloss(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

!     rev. 10.2.16 Feb.  14/18  - NK: Added bankfull flow calculation
!               ATTRIBUTE 15 - bankfull
                if(wfo_pick(15).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
c                    outwfo(jj,ii)=bankfull(ii,jj)
                    outwfo(jj,ii)=totuzs(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
                endif

     
                    
                    
c            write(56,*)'time= ',totaltime
c            do i=ycount,1,-1
c              write(56,56000)(bankfull(i,j),j=1,xcount)
c56000         format(<xcount>f8.0)              
c            end do
     
                    
                    
                    

!     rev. 9.9.70  Jun.  12/15  - NK: Add del_rain, and dSTRconc2  to the wfo file
                if(frcflg.eq.'y')then
!               ATTRIBUTE 12 - dlt_rain
c                if(wfo_pick(12).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=dlt_rain(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
c                endif

!               ATTRIBUTE 13 - dSTRconc
c                if(wfo_pick(13).eq.1)then
                  do n=1,naa
                    ii=yyy(n)
                    jj=xxx(n)
                    outwfo(jj,ii)=dSTRconc2(n)
                  end do
                  if(wfo_write_attribute_data
     *            (xcount,ycount).ne.1)then 
!                   WRITE ERROR
                    GO TO 98010
                  end if
c                endif
                endif



                npick=15      ! change this if items are added above
!               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` 

!               ATTRIBUTE 13 - DEPRESSION STORAGE
                do i=1,classcount
                  if(wfo_pick(npick+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=d1(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR!
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 14 - DEPRESSION STORAGE (SNOW)
                do i=1,classcount
                  if(wfo_pick(npick+(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=d1fs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 15 - SNOW WATER EQUIVALENT
                do i=1,classcount
                  if(wfo_pick(npick+2*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=snowc(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 16 - SNOW COVERED AREA
                do i=1,classcount
                  if(wfo_pick(npick+3*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=sca(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 17 - UPPER ZONE STORAGE
                do i=1,classcount
                  if(wfo_pick(npick+4*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=uzs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 18 - UPPER ZONE STORAGE (SNOW)
                do i=1,classcount
                  if(wfo_pick(npick+5*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=uzsfs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               rev  9.1.29  Oct.  24/02  - Added q1, qint & drng to wfo file
!               ATTRIBUTE 19 - surface flow q1
                do i=1,classcount
                  if(wfo_pick(npick+6*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=q1(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 20 - surface flow q1fs (SNOW)
                do i=1,classcount
                  if(wfo_pick(npick+7*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=q1fs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 21 - interflow qint 
                do i=1,classcount
                  if(wfo_pick(npick+8*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=qint(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 22 - interflow qintfs (SNOW)
                do i=1,classcount
                  if(wfo_pick(npick+9*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=qintfs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 23 - recharge drng
                do i=1,classcount
                  if(wfo_pick(npick+10*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=drng(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!               ATTRIBUTE 24 - recharge drngfs (SNOW)
                do i=1,classcount
                  if(wfo_pick(npick+11*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=drngfs(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do

!     rev. 9.1.81  Apr.  04/05  - NK: added sublimation,et and etfs to wfo file
!               ATTRIBUTE 25 - evapotranspiration
!               refer to section below "reset et sums"
                do i=1,classcount
                  if(wfo_pick(npick+12*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=sum_pet(n,i)
!     *		                   /float(min(ireport,mhtot))
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do
!               ATTRIBUTE 26 - evapotranspiration (SNOW)
!               refer to section below "reset et sums"
                do i=1,classcount
                  if(wfo_pick(npick+13*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=sum_et(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do
!               ATTRIBUTE 27 - sublimation (SNOW)
!               refer to section below "reset et sums"
                do i=1,classcount
                  if(wfo_pick(npick+14*(classcount)+i).eq.1)then
                    do n=1,naa
                      ii=yyy(n)
                      jj=xxx(n)
                      outwfo(jj,ii)=sum_sublim(n,i)
                    end do
                    if(wfo_write_attribute_data
     *                (xcount,ycount).ne.1)then 
!                     WRITE ERROR
                      GO TO 98010
                    end if
                  endif
                end do
      endif

c!     "reset et sums"
c      if(mod(jz,min(ireport,mhtot)).eq.0)then
c        do ii=1,classcount
c          do n=1,naa  
c            sum_pet(n,ii)=0.0
c            sum_et(n,ii)=0.0   taken out Mar. 07/08 -nk- we want sum!!!
c            sum_sublim(n,ii)=0.0   taken out Jan. 17/11 -nk- we want sum!!!
c          end do
c        end do
c      endif


      return


!         fix fix  cound be a function
!     this should be fixed the proper way in wfo_write ...nk
!     THIS IS THE WFO ATTRIBUTE WRITING ERROR
98010 write (*,'(A)') ' '
      write (*,'(A)') '  *** FATAL ERROR ***     '
      write (*,'(A)') ' Unable to Write Attribute Data'
      STOP ' Program aborted in sub @1185'



      end subroutine write_wfo
      subroutine write_xml
      
!***********************************************************************
!    Copyright (C) 1987 by Nicholas Kouwen 
        
!    This file is part of WATFLOOD (R)      
        
!    WATFLOOD(R) is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    any later version.

!    WATFLOOD is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.

!    You should have received a copy of the GNU Lesser General Public License
!    along with WATFLOOD.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
     
!     rev. 10.1.64 Jan.  26/17  - NK: Added XML output file 
      
      use area_watflood
      use areacg
      implicit none

!     SAVES THE LOCAL VARIABLES FROM ONE CALL TO NEXT
      SAVE

      integer        :: i,j,k,l,n,jul_day1_id1,ios,jd,strLength
      logical        :: firstpass
      character(80)  :: line,tempname
      character(14)  :: str
      
      data firstpass/.true./

      if(firstpass)then
          
c        jul_day1_id1=jul_day1  
        jul_day1_id1=jul_day_now 
        
        do l=1,no
          if(l.le.9)then
            write(line,10013)l
10013       format('sta_00',i1,'.xml')
          elseif(l.le.99)then
            write(line,10014)l
10014       format('sta_0',i2,'.xml')
          elseif(l.le.999)then
            write(line,10015)l
10015       format('sta_',i3,'.xml')
          endif
          open(unit=1000+l,file=line(1:11),iostat=ios)
        end do  
        do l=1,no
          if(l.le.9)then
            write(line,10033)l
10033       format('header_sta_00',i1,'.xml')
          elseif(l.le.99)then
            write(line,10034)l
10034       format('header_sta_0',i2,'.xml')
          elseif(l.le.999)then
            write(line,10035)l
10035       format('header_sta_',i3,'.xml')
          endif
          open(unit=2000+l,file=line(1:18),iostat=ios)
        end do  
      endif     ! firstpass
      
      do l=1,no
!       jul_day1 is the first jul day this event
        jd=jul_day1
c         do k=24,nl,24
         do k=deltat_report,nl,deltat_report
           hh=mod(k-1,24)  
           if(hh.le.9)then             
           if(qsyn(l,k).lt.0.00000)then
!            missing values               
             write(1000+l,10020)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="',-999.000,'" flag="0"/>'
10020        format(8x,a13,a10,a9,i1,a15,f8.3,a12)       
           elseif(qsyn(l,k).lt.10.00000)then
             write(1000+l,10021)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
10021        format(8x,a13,a10,a9,i1,a15,f5.3,a12)       
           elseif(qsyn(l,k).lt.100.00000)then
             write(1000+l,10022)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
10022        format(8x,a13,a10,a9,i1,a15,f6.3,a12)       
           elseif(qsyn(l,k).lt.1000.00000)then
             write(1000+l,10023)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
10023        format(8x,a13,a10,a9,i1,a15,f7.3,a12)       
           elseif(qsyn(l,k).lt.10000.00000)then
             write(1000+l,10024)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
10024        format(8x,a13,a10,a9,i1,a15,f8.3,a12)       
           elseif(qsyn(l,k).lt.100000.00000)then
             write(1000+l,10025)'<event date="',yyyymmdd12(jd),
     *        '" time="0',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
10025        format(8x,a13,a10,a9,i1,a15,f9.3,a12)       
           endif
           else   ! HH > 9
           if(qsyn(l,k).lt.0.000)then
!            missing values               
             write(1000+l,20020)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="',-999.000,'" flag="0"/>'
20020        format(8x,a13,a10,a8,i2,a15,f8.3,a12)       
           elseif(qsyn(l,k).lt.10.00000)then
             write(1000+l,20021)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
20021        format(8x,a13,a10,a8,i2,a15,f5.3,a12)       
           elseif(qsyn(l,k).lt.100.00000)then
             write(1000+l,20022)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
20022        format(8x,a13,a10,a8,i2,a15,f6.3,a12)       
           elseif(qsyn(l,k).lt.1000.00000)then
             write(1000+l,20023)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
20023        format(8x,a13,a10,a8,i2,a15,f7.3,a12)       
           elseif(qsyn(l,k).lt.10000.00000)then
             write(1000+l,20024)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
20024        format(8x,a13,a10,a8,i2,a15,f8.3,a12)       
           elseif(qsyn(l,k).lt.100000.00000)then
             write(1000+l,20025)'<event date="',yyyymmdd12(jd),
     *         '" time="',hh,':00:00" value="', qsyn(l,k),'" flag="0"/>'
20025        format(8x,a13,a10,a8,i2,a15,f9.3,a12)       
           endif
           endif   ! hh
           
           if(mod(k,24).eq.0)jd=jd+1
         end do
        if(id.eq.ni)then
          write(1000+l,10016)'</series>'
10016     format(4x,a9)
c          if(l.eq.no)then
c              write(1000+l,10018)'</TimeSeries>'
c10018         format((a),$)                   !  $ for no carriage return
c          endif
          close(unit=1000+l,status='keep')
        endif           
      end do

!     Last event     
!     Now that we know the end date we can write the header           
      if(id.eq.ni)then    !  needs to be writte at the end as the end date is needed in the header
!       write the charm.xml file
!       check to see that flows are averaged for the by having dt = reporting time step      
        if(kt.ne.deltat_report)then
          print*
          print*,'WARNING'
          print*,'The reporting time step must be 24 hours to write'
          print*,'the xml file. Please change this in the event file'
          print*,kt,deltat_report
          print*
          print*
        endif
          
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
!       write the header
!       can't do this until we're done
        do l=1,no
c          write(2000+l,10001)'<?xml version="1.0" encoding="UTF-8"?>'

c10001     format(a38)          
c          write(2000+l,10001)'<TimeSeries xmlns:xsi="http://www.w3.org',
c     *                       '/2001/XMLSchema-instance" xmlns:xsd="htt',
c     *                       'p://www.w3.org/2001/XMLSchema" xmlns="ht',
c     *                       'tp://www.wldelft.nl/fews/PI">'
          if(l.eq.1)then
              write(2000+l,10101)'<TimeSeries' 
10101         format(a11)        
              write(2000+l,10102)
     *           'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' 
10102         format(4x,a53)        
              write(2000+l,10103)
     *             'xmlns:xsd="http://www.w3.org/2001/XMLSchema"' 
10103         format(4x,a44)        
              write(2000+l,10104)
     *             'xmlns="http://www.wldelft.nl/fews/PI">'
10104         format(4x,a38)
              write(2000+l,10107)'<timeZone>0.0</timeZone>'
          endif
10107     format(4x,a24)     
          write(2000+l,10105)'<series>'
10105     format(4x,a8)        
          write(2000+l,10106)'<header>'
10106     format(8x,a8)        
          write(2000+l,10004)'<type>instantaneous</type>'
10004     format(12x,a26)
          strLength = LEN_TRIM(gage(l))
          write(2000+l,10005)
     *             '<locationId>',gage(l),'</locationId>'
10005     format(12x,a12,a<strLength>,12a)        
          write(2000+l,10006)'<parameterId>SQIN</parameterId>'    !<<<<fix flow
10006     format(12x,a31)        
          write(2000+l,10007)
     *             '<timeStep unit="second" multiplier="3600"/>'
10007     format(12x,a43)        
          write(2000+l,10008)'<startDate date="',startdateXML,
     *             '" time="00:00:00"/>'
10008     format(12x,a17,a10,a19)        
          write(2000+l,10009)'<endDate date="',date_now,
     *             '" time="00:00:00"/>'        
10009     format(12x,a15,a10,a19)        
          write(2000+l,10010)'<missVal>-999</missVal>'
10010     format(12x,a23)        
          strLength = LEN_TRIM(gage(l))
          write(2000+l,10011)
     *             '<stationName>',gage(l),'</stationName>'
10011     format(12x,a13,a<strLength>,a14)     
          write(2000+l,10012)'<units>CMS</units>'
10012     format(12x,a18)        
          write(2000+l,10044)'</header>'
10044     format(8x,a9)        
          close(unit=2000+l,status='keep')
        end do
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        
!     rev. 10.2.10 Nov.  04/17  - NK: Fixed XML file    
        open(unit=99,file='toFews\watflood.xml',status='unknown',
     *                      iostat=ios)
        print*,'Opened  toFews\watflood.xml'
        
        do l=1,no
          if(l.le.9)then  
              
            write(tempname,10200)'header_sta_00',l,'.xml'
10200       format(a13,i1,a4) 
c            print*,tempname(1:18)
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! header
10201           format(a80)                
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
10202           format(a<strLength>)     
            end do
            close(unit=100,status='keep',iostat=ios)
            strLength = LEN_TRIM(gage(l))
            write(tempname,10203)'sta_00',l,'.xml'
10203       format(a6,i1,a4) 
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! data
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
            end do
            close(unit=100,status='keep',iostat=ios)
            print*,'Closed ',tempname(1:18)
            
          elseif(l.le.99)then  

            write(tempname,10204)'header_sta_0',l,'.xml'
10204       format(a12,i2,a4) 
c            print*,tempname(1:18)
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! header
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
            end do
            close(unit=100,status='keep',iostat=ios)
            strLength = LEN_TRIM(gage(l))
            write(tempname,10206)'sta_0',l,'.xml'
10206       format(a5,i2,a4) 
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! data
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
            end do
            close(unit=100,status='keep',iostat=ios)
            print*,'Closed ',tempname(1:18)
              
          elseif(l.le.999)then  

            write(tempname,10208)'header_sta_',l,'.xml'
10208       format(a11,i3,a4) 
c            print*,tempname(1:18)
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! header
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
            end do
            close(unit=100,status='keep',iostat=ios)
            strLength = LEN_TRIM(gage(l))
            write(tempname,10210)'sta_',l,'.xml'
10210       format(a4,i3,a4) 
            open(unit=100,file=tempname,status='unknown',iostat=ios)
            do while(.not.eof(100))
                read(100,10201,iostat=ios)line      ! data
                strLength = LEN_trim(line)
                if(ios.eq.0)write(99,10202)line
            end do
            close(unit=100,status='keep',iostat=ios)
            print*,'Closed ',tempname(1:18)
              
          endif   
        end do
        write(99,10018)'</TimeSeries>'
10018   format((a),$)                   !  $ for no carriage return
        close(unit=99,status='keep')
        print*,'Closed    toFews\watflood.xml'
        call execute_command_line("del *.xml")   !, wait=.false.)        
      endif     ! last event
        
      firstpass=.false.
        
      return
      
      end subroutine write_xml     
